{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\nconst oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\nclass AuthorizationCodeWithPkceOidcHandler {\n  constructor(storageUtility, redirector) {\n    this.storageUtility = storageUtility;\n    this.redirector = redirector;\n  }\n  async canHandle(oidcLoginOptions) {\n    return !!(oidcLoginOptions.issuerConfiguration.grantTypesSupported && oidcLoginOptions.issuerConfiguration.grantTypesSupported.indexOf(\"authorization_code\") > -1);\n  }\n  async handle(oidcLoginOptions) {\n    var _a;\n    const oidcOptions = {\n      authority: oidcLoginOptions.issuer.toString(),\n      client_id: oidcLoginOptions.client.clientId,\n      client_secret: oidcLoginOptions.client.clientSecret,\n      redirect_uri: oidcLoginOptions.redirectUrl.toString(),\n      post_logout_redirect_uri: oidcLoginOptions.redirectUrl.toString(),\n      response_type: \"code\",\n      scope: solid_client_authn_core_1.DEFAULT_SCOPES,\n      filterProtocolClaims: true,\n      loadUserInfo: false,\n      code_verifier: true,\n      prompt: (_a = oidcLoginOptions.prompt) !== null && _a !== void 0 ? _a : \"consent\"\n    };\n    const oidcClientLibrary = new oidc_client_ext_1.OidcClient(oidcOptions);\n    const {\n      redirector\n    } = this;\n    const storage = this.storageUtility;\n    try {\n      const signingRequest = await oidcClientLibrary.createSigninRequest();\n      await Promise.all([storage.setForUser(signingRequest.state._id, {\n        sessionId: oidcLoginOptions.sessionId\n      }), storage.setForUser(oidcLoginOptions.sessionId, {\n        codeVerifier: signingRequest.state._code_verifier,\n        issuer: oidcLoginOptions.issuer.toString(),\n        redirectUrl: oidcLoginOptions.redirectUrl,\n        dpop: oidcLoginOptions.dpop ? \"true\" : \"false\"\n      })]);\n      redirector.redirect(signingRequest.url.toString(), {\n        handleRedirect: oidcLoginOptions.handleRedirect\n      });\n    } catch (err) {\n      console.error(err);\n    }\n    return undefined;\n  }\n}\nexports.default = AuthorizationCodeWithPkceOidcHandler;","map":{"version":3,"mappings":";;;;;AA6BA;AAQA;AAOA,MAAqBA,oCAAoC;EAGvDC,YACUC,cAA+B,EAC/BC,UAAuB;IADvB,mBAAc,GAAdD,cAAc;IACd,eAAU,GAAVC,UAAU;EACjB;EAEH,MAAMC,SAAS,CAACC,gBAA8B;IAC5C,OAAO,CAAC,EACNA,gBAAgB,CAACC,mBAAmB,CAACC,mBAAmB,IACxDF,gBAAgB,CAACC,mBAAmB,CAACC,mBAAmB,CAACC,OAAO,CAC9D,oBAAoB,CACrB,GAAG,CAAC,CAAC,CACP;EACH;EAEA,MAAMC,MAAM,CAACJ,gBAA8B;;IAEzC,MAAMK,WAAW,GAAG;MAClBC,SAAS,EAAEN,gBAAgB,CAACO,MAAM,CAACC,QAAQ,EAAE;MAC7CC,SAAS,EAAET,gBAAgB,CAACU,MAAM,CAACC,QAAQ;MAC3CC,aAAa,EAAEZ,gBAAgB,CAACU,MAAM,CAACG,YAAY;MACnDC,YAAY,EAAEd,gBAAgB,CAACe,WAAW,CAACP,QAAQ,EAAE;MACrDQ,wBAAwB,EAAEhB,gBAAgB,CAACe,WAAW,CAACP,QAAQ,EAAE;MACjES,aAAa,EAAE,MAAM;MACrBC,KAAK,EAAEC,wCAAc;MACrBC,oBAAoB,EAAE,IAAI;MAI1BC,YAAY,EAAE,KAAK;MACnBC,aAAa,EAAE,IAAI;MACnBC,MAAM,EAAE,sBAAgB,CAACA,MAAM,mCAAI;KACpC;IAGD,MAAMC,iBAAiB,GAAG,IAAIC,4BAAU,CAACpB,WAAW,CAAC;IAErD,MAAM;MAAEP;IAAU,CAAE,GAAG,IAAI;IAC3B,MAAM4B,OAAO,GAAG,IAAI,CAAC7B,cAAc;IAEnC,IAAI;MACF,MAAM8B,cAAc,GAAG,MAAMH,iBAAiB,CAACI,mBAAmB,EAAE;MACpE,MAAMC,OAAO,CAACC,GAAG,CAAC,CAWhBJ,OAAO,CAACK,UAAU,CAACJ,cAAc,CAACK,KAAK,CAACC,GAAG,EAAE;QAC3CC,SAAS,EAAElC,gBAAgB,CAACkC;OAC7B,CAAC,EAMFR,OAAO,CAACK,UAAU,CAAC/B,gBAAgB,CAACkC,SAAS,EAAE;QAE7CC,YAAY,EAAER,cAAc,CAACK,KAAK,CAACI,cAAc;QACjD7B,MAAM,EAAEP,gBAAgB,CAACO,MAAM,CAACC,QAAQ,EAAE;QAE1CO,WAAW,EAAEf,gBAAgB,CAACe,WAAW;QACzCsB,IAAI,EAAErC,gBAAgB,CAACqC,IAAI,GAAG,MAAM,GAAG;OACxC,CAAC,CACH,CAAC;MAEFvC,UAAU,CAACwC,QAAQ,CAACX,cAAc,CAACY,GAAG,CAAC/B,QAAQ,EAAE,EAAE;QACjDgC,cAAc,EAAExC,gBAAgB,CAACwC;OAClC,CAAC;KACH,CAAC,OAAOC,GAAY,EAAE;MAErBC,OAAO,CAACC,KAAK,CAACF,GAAG,CAAC;;IAIpB,OAAOG,SAAS;EAClB;;AAnFFC","names":["AuthorizationCodeWithPkceOidcHandler","constructor","storageUtility","redirector","canHandle","oidcLoginOptions","issuerConfiguration","grantTypesSupported","indexOf","handle","oidcOptions","authority","issuer","toString","client_id","client","clientId","client_secret","clientSecret","redirect_uri","redirectUrl","post_logout_redirect_uri","response_type","scope","solid_client_authn_core_1","filterProtocolClaims","loadUserInfo","code_verifier","prompt","oidcClientLibrary","oidc_client_ext_1","storage","signingRequest","createSigninRequest","Promise","all","setForUser","state","_id","sessionId","codeVerifier","_code_verifier","dpop","redirect","url","handleRedirect","err","console","error","undefined","exports"],"sources":["E:\\react-todo-app\\node_modules\\@inrupt\\solid-client-authn-browser\\src\\login\\oidc\\oidcHandlers\\AuthorizationCodeWithPkceOidcHandler.ts"],"sourcesContent":["//\n// Copyright 2022 Inrupt Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n// Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n/**\n * @hidden\n * @packageDocumentation\n */\n\n/**\n * Handler for the Authorization Code with PKCE Flow\n */\nimport {\n  IOidcHandler,\n  IOidcOptions,\n  IRedirector,\n  IStorageUtility,\n  LoginResult,\n  DEFAULT_SCOPES,\n} from \"@inrupt/solid-client-authn-core\";\nimport { OidcClient } from \"@inrupt/oidc-client-ext\";\n\n/**\n * @hidden\n * Authorization code flow spec: https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth\n * PKCE: https://tools.ietf.org/html/rfc7636\n */\nexport default class AuthorizationCodeWithPkceOidcHandler\n  implements IOidcHandler\n{\n  constructor(\n    private storageUtility: IStorageUtility,\n    private redirector: IRedirector\n  ) {}\n\n  async canHandle(oidcLoginOptions: IOidcOptions): Promise<boolean> {\n    return !!(\n      oidcLoginOptions.issuerConfiguration.grantTypesSupported &&\n      oidcLoginOptions.issuerConfiguration.grantTypesSupported.indexOf(\n        \"authorization_code\"\n      ) > -1\n    );\n  }\n\n  async handle(oidcLoginOptions: IOidcOptions): Promise<LoginResult> {\n    /* eslint-disable camelcase */\n    const oidcOptions = {\n      authority: oidcLoginOptions.issuer.toString(),\n      client_id: oidcLoginOptions.client.clientId,\n      client_secret: oidcLoginOptions.client.clientSecret,\n      redirect_uri: oidcLoginOptions.redirectUrl.toString(),\n      post_logout_redirect_uri: oidcLoginOptions.redirectUrl.toString(),\n      response_type: \"code\",\n      scope: DEFAULT_SCOPES,\n      filterProtocolClaims: true,\n      // The userinfo endpoint on NSS fails, so disable this for now\n      // Note that in Solid, information should be retrieved from the\n      // profile referenced by the WebId.\n      loadUserInfo: false,\n      code_verifier: true,\n      prompt: oidcLoginOptions.prompt ?? \"consent\",\n    };\n    /* eslint-enable camelcase */\n\n    const oidcClientLibrary = new OidcClient(oidcOptions);\n\n    const { redirector } = this;\n    const storage = this.storageUtility;\n\n    try {\n      const signingRequest = await oidcClientLibrary.createSigninRequest();\n      await Promise.all([\n        // We use the OAuth 'state' value (which should be crypto-random) as\n        // the key in our storage to store our actual SessionID. We do this\n        // 'cos we'll need to lookup our session information again when the\n        // browser is redirected back to us (i.e. the OAuth client\n        // application) from the Authorization Server.\n        // We don't want to use our session ID as the OAuth 'state' value, as\n        // that session ID can be any developer-specified value, and therefore\n        // may not be appropriate (since the OAuth 'state' value should really\n        // be an unguessable crypto-random value).\n        // eslint-disable-next-line no-underscore-dangle\n        storage.setForUser(signingRequest.state._id, {\n          sessionId: oidcLoginOptions.sessionId,\n        }),\n\n        // Store our login-process state using the session ID as the key.\n        // Strictly speaking, this indirection from our OAuth state value to\n        // our session ID is unnecessary, but it provides a slightly cleaner\n        // separation of concerns.\n        storage.setForUser(oidcLoginOptions.sessionId, {\n          // eslint-disable-next-line no-underscore-dangle\n          codeVerifier: signingRequest.state._code_verifier,\n          issuer: oidcLoginOptions.issuer.toString(),\n          // The redirect URL is read after redirect, so it must be stored now.\n          redirectUrl: oidcLoginOptions.redirectUrl,\n          dpop: oidcLoginOptions.dpop ? \"true\" : \"false\",\n        }),\n      ]);\n\n      redirector.redirect(signingRequest.url.toString(), {\n        handleRedirect: oidcLoginOptions.handleRedirect,\n      });\n    } catch (err: unknown) {\n      // eslint-disable-next-line no-console\n      console.error(err);\n    }\n\n    // The login is only completed AFTER redirect, so nothing to return here.\n    return undefined;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}