{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _classCallCheck = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _asyncToGenerator = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SessionInfoManager = exports.clear = exports.getUnauthenticatedSession = void 0;\nvar solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\nvar uuid_1 = require(\"uuid\");\nvar oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\nfunction getUnauthenticatedSession() {\n  return {\n    isLoggedIn: false,\n    sessionId: (0, uuid_1.v4)(),\n    fetch: fetch\n  };\n}\nexports.getUnauthenticatedSession = getUnauthenticatedSession;\nfunction _clear2(_x, _x2) {\n  return _clear.apply(this, arguments);\n}\nfunction _clear() {\n  _clear = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(sessionId, storage) {\n    return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n      while (1) switch (_context7.prev = _context7.next) {\n        case 0:\n          _context7.next = 2;\n          return Promise.all([storage.deleteAllUserData(sessionId, {\n            secure: false\n          }), storage.deleteAllUserData(sessionId, {\n            secure: true\n          }), storage.delete(\"clientKey\", {\n            secure: false\n          })]);\n        case 2:\n          _context7.next = 4;\n          return (0, oidc_client_ext_1.clearOidcPersistentStorage)();\n        case 4:\n        case \"end\":\n          return _context7.stop();\n      }\n    }, _callee7);\n  }));\n  return _clear.apply(this, arguments);\n}\nexports.clear = _clear2;\nvar SessionInfoManager = /*#__PURE__*/function () {\n  function SessionInfoManager(storageUtility) {\n    _classCallCheck(this, SessionInfoManager);\n    this.storageUtility = storageUtility;\n  }\n  _createClass(SessionInfoManager, [{\n    key: \"update\",\n    value: function update(_sessionId, _options) {\n      throw new Error(\"Not Implemented\");\n    }\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(sessionId) {\n        var _a, isLoggedIn, webId, clientId, clientSecret, redirectUrl, refreshToken, issuer, tokenType;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return this.storageUtility.getForUser(sessionId, \"isLoggedIn\", {\n                secure: true\n              });\n            case 2:\n              isLoggedIn = _context.sent;\n              _context.next = 5;\n              return this.storageUtility.getForUser(sessionId, \"webId\", {\n                secure: true\n              });\n            case 5:\n              webId = _context.sent;\n              _context.next = 8;\n              return this.storageUtility.getForUser(sessionId, \"clientId\", {\n                secure: false\n              });\n            case 8:\n              clientId = _context.sent;\n              _context.next = 11;\n              return this.storageUtility.getForUser(sessionId, \"clientSecret\", {\n                secure: false\n              });\n            case 11:\n              clientSecret = _context.sent;\n              _context.next = 14;\n              return this.storageUtility.getForUser(sessionId, \"redirectUrl\", {\n                secure: false\n              });\n            case 14:\n              redirectUrl = _context.sent;\n              _context.next = 17;\n              return this.storageUtility.getForUser(sessionId, \"refreshToken\", {\n                secure: true\n              });\n            case 17:\n              refreshToken = _context.sent;\n              _context.next = 20;\n              return this.storageUtility.getForUser(sessionId, \"issuer\", {\n                secure: false\n              });\n            case 20:\n              issuer = _context.sent;\n              _context.next = 23;\n              return this.storageUtility.getForUser(sessionId, \"tokenType\", {\n                secure: false\n              });\n            case 23:\n              _context.t1 = _a = _context.sent;\n              _context.t0 = _context.t1 !== null;\n              if (!_context.t0) {\n                _context.next = 27;\n                break;\n              }\n              _context.t0 = _a !== void 0;\n            case 27:\n              if (!_context.t0) {\n                _context.next = 31;\n                break;\n              }\n              _context.t2 = _a;\n              _context.next = 32;\n              break;\n            case 31:\n              _context.t2 = \"DPoP\";\n            case 32:\n              tokenType = _context.t2;\n              if ((0, solid_client_authn_core_1.isSupportedTokenType)(tokenType)) {\n                _context.next = 35;\n                break;\n              }\n              throw new Error(\"Tokens of type [\".concat(tokenType, \"] are not supported.\"));\n            case 35:\n              if (!(clientId === undefined && isLoggedIn === undefined && webId === undefined && refreshToken === undefined)) {\n                _context.next = 37;\n                break;\n              }\n              return _context.abrupt(\"return\", undefined);\n            case 37:\n              return _context.abrupt(\"return\", {\n                sessionId: sessionId,\n                webId: webId,\n                isLoggedIn: isLoggedIn === \"true\",\n                redirectUrl: redirectUrl,\n                refreshToken: refreshToken,\n                issuer: issuer,\n                clientAppId: clientId,\n                clientAppSecret: clientSecret,\n                tokenType: tokenType\n              });\n            case 38:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function get(_x3) {\n        return _get.apply(this, arguments);\n      }\n      return get;\n    }()\n  }, {\n    key: \"getAll\",\n    value: function () {\n      var _getAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              throw new Error(\"Not implemented\");\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      function getAll() {\n        return _getAll.apply(this, arguments);\n      }\n      return getAll;\n    }()\n  }, {\n    key: \"clear\",\n    value: function () {\n      var _clear3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(sessionId) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", _clear2(sessionId, this.storageUtility));\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function clear(_x4) {\n        return _clear3.apply(this, arguments);\n      }\n      return clear;\n    }()\n  }, {\n    key: \"register\",\n    value: function () {\n      var _register = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(_sessionId) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              throw new Error(\"Not implemented\");\n            case 1:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }));\n      function register(_x5) {\n        return _register.apply(this, arguments);\n      }\n      return register;\n    }()\n  }, {\n    key: \"getRegisteredSessionIdAll\",\n    value: function () {\n      var _getRegisteredSessionIdAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              throw new Error(\"Not implemented\");\n            case 1:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5);\n      }));\n      function getRegisteredSessionIdAll() {\n        return _getRegisteredSessionIdAll.apply(this, arguments);\n      }\n      return getRegisteredSessionIdAll;\n    }()\n  }, {\n    key: \"clearAll\",\n    value: function () {\n      var _clearAll = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              throw new Error(\"Not implemented\");\n            case 1:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6);\n      }));\n      function clearAll() {\n        return _clearAll.apply(this, arguments);\n      }\n      return clearAll;\n    }()\n  }]);\n  return SessionInfoManager;\n}();\nexports.SessionInfoManager = SessionInfoManager;","map":{"version":3,"mappings":"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","names":["getUnauthenticatedSession","isLoggedIn","sessionId","fetch","exports","clear","storage","Promise","all","deleteAllUserData","secure","delete","SessionInfoManager","storageUtility","_sessionId","_options","Error","getForUser","webId","clientId","clientSecret","redirectUrl","refreshToken","issuer","_a","tokenType","undefined","clientAppId","clientAppSecret"],"sources":["E:\\react-todo-app\\node_modules\\@inrupt\\solid-client-authn-browser\\src\\sessionInfo\\SessionInfoManager.ts"],"sourcesContent":["//\n// Copyright 2022 Inrupt Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n// Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n/**\n * @hidden\n * @packageDocumentation\n */\n\nimport {\n  ISessionInfo,\n  ISessionInfoManager,\n  ISessionInternalInfo,\n  ISessionInfoManagerOptions,\n  IStorageUtility,\n  isSupportedTokenType,\n} from \"@inrupt/solid-client-authn-core\";\nimport { v4 } from \"uuid\";\nimport { clearOidcPersistentStorage } from \"@inrupt/oidc-client-ext\";\n\nexport function getUnauthenticatedSession(): ISessionInfo & {\n  fetch: typeof fetch;\n} {\n  return {\n    isLoggedIn: false,\n    sessionId: v4(),\n    fetch,\n  };\n}\n\n/**\n * @param sessionId\n * @param storage\n * @hidden\n */\nexport async function clear(\n  sessionId: string,\n  storage: IStorageUtility\n): Promise<void> {\n  await Promise.all([\n    storage.deleteAllUserData(sessionId, { secure: false }),\n    storage.deleteAllUserData(sessionId, { secure: true }),\n    // FIXME: This is needed until the DPoP key is stored safely\n    storage.delete(\"clientKey\", { secure: false }),\n  ]);\n  await clearOidcPersistentStorage();\n}\n\n/**\n * @hidden\n */\nexport class SessionInfoManager implements ISessionInfoManager {\n  constructor(private storageUtility: IStorageUtility) {}\n\n  // eslint-disable-next-line class-methods-use-this\n  update(\n    _sessionId: string,\n    _options: ISessionInfoManagerOptions\n  ): Promise<void> {\n    // const localUserId: string = options.localUserId || this.uuidGenerator.v4();\n    // if (options.loggedIn) {\n    //   return {\n    //     sessionId,\n    //     loggedIn: true,\n    //     webId: options.webId as string,\n    //     neededAction: options.neededAction || { actionType: \"inaction\" },\n    //     state: options.state,\n    //     logout: async (): Promise<void> => {\n    //       // TODO: handle if webid isn't here\n    //       return this.logoutHandler.handle(localUserId);\n    //     },\n    //     fetch: (url: RequestInfo, init?: RequestInit): Promise<Response> => {\n    //       // TODO: handle if webid isn't here\n    //       return this.authenticatedFetcher.handle(\n    //         {\n    //           localUserId,\n    //           type: \"dpop\"\n    //         },\n    //         url,\n    //         init\n    //       );\n    //     }\n    //   };\n    // } else {\n    //   return {\n    //     localUserId,\n    //     loggedIn: false,\n    //     neededAction: options.neededAction || { actionType: \"inaction\" }\n    //   };\n    // }\n    throw new Error(\"Not Implemented\");\n  }\n\n  async get(\n    sessionId: string\n  ): Promise<(ISessionInfo & ISessionInternalInfo) | undefined> {\n    const isLoggedIn = await this.storageUtility.getForUser(\n      sessionId,\n      \"isLoggedIn\",\n      {\n        secure: true,\n      }\n    );\n\n    const webId = await this.storageUtility.getForUser(sessionId, \"webId\", {\n      secure: true,\n    });\n\n    const clientId = await this.storageUtility.getForUser(\n      sessionId,\n      \"clientId\",\n      {\n        secure: false,\n      }\n    );\n\n    const clientSecret = await this.storageUtility.getForUser(\n      sessionId,\n      \"clientSecret\",\n      {\n        secure: false,\n      }\n    );\n\n    const redirectUrl = await this.storageUtility.getForUser(\n      sessionId,\n      \"redirectUrl\",\n      {\n        secure: false,\n      }\n    );\n\n    const refreshToken = await this.storageUtility.getForUser(\n      sessionId,\n      \"refreshToken\",\n      {\n        secure: true,\n      }\n    );\n\n    const issuer = await this.storageUtility.getForUser(sessionId, \"issuer\", {\n      secure: false,\n    });\n\n    const tokenType =\n      (await this.storageUtility.getForUser(sessionId, \"tokenType\", {\n        secure: false,\n      })) ?? \"DPoP\";\n\n    if (!isSupportedTokenType(tokenType)) {\n      throw new Error(`Tokens of type [${tokenType}] are not supported.`);\n    }\n\n    if (\n      clientId === undefined &&\n      isLoggedIn === undefined &&\n      webId === undefined &&\n      refreshToken === undefined\n    ) {\n      return undefined;\n    }\n\n    return {\n      sessionId,\n      webId,\n      isLoggedIn: isLoggedIn === \"true\",\n      redirectUrl,\n      refreshToken,\n      issuer,\n      clientAppId: clientId,\n      clientAppSecret: clientSecret,\n      tokenType,\n    };\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async getAll(): Promise<(ISessionInfo & ISessionInternalInfo)[]> {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * This function removes all session-related information from storage.\n   * @param sessionId the session identifier\n   * @param storage the storage where session info is stored\n   * @hidden\n   */\n  async clear(sessionId: string): Promise<void> {\n    return clear(sessionId, this.storageUtility);\n  }\n\n  /**\n   * Registers a new session, so that its ID can be retrieved.\n   * @param sessionId\n   */\n  async register(_sessionId: string): Promise<void> {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Returns all the registered session IDs. Differs from getAll, which also\n   * returns additional session information.\n   */\n  async getRegisteredSessionIdAll(): Promise<string[]> {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Deletes all information about all sessions, including their registrations.\n   */\n  async clearAll(): Promise<void> {\n    throw new Error(\"Not implemented\");\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}