{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _createForOfIteratorHelper = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _require = require('./context'),\n  isKeyword = _require.isKeyword;\nvar graphTypes = require('./graphTypes');\nvar types = require('./types');\nvar util = require('./util');\nvar JsonLdError = require('./JsonLdError');\nvar api = {};\nmodule.exports = api;\n\n/**\n * Creates a merged JSON-LD node map (node ID => node).\n *\n * @param input the expanded JSON-LD to create a node map of.\n * @param [options] the options to use:\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *\n * @return the node map.\n */\napi.createMergedNodeMap = function (input, options) {\n  options = options || {};\n\n  // produce a map of all subjects and name each bnode\n  var issuer = options.issuer || new util.IdentifierIssuer('_:b');\n  var graphs = {\n    '@default': {}\n  };\n  api.createNodeMap(input, graphs, '@default', issuer);\n\n  // add all non-default graphs to default graph\n  return api.mergeNodeMaps(graphs);\n};\n\n/**\n * Recursively flattens the subjects in the given JSON-LD expanded input\n * into a node map.\n *\n * @param input the JSON-LD expanded input.\n * @param graphs a map of graph name to subject map.\n * @param graph the name of the current graph.\n * @param issuer the blank node identifier issuer.\n * @param name the name assigned to the current input if it is a bnode.\n * @param list the list to append to, null for none.\n */\napi.createNodeMap = function (input, graphs, graph, issuer, name, list) {\n  // recurse through array\n  if (types.isArray(input)) {\n    var _iterator = _createForOfIteratorHelper(input),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var node = _step.value;\n        api.createNodeMap(node, graphs, graph, issuer, undefined, list);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    return;\n  }\n\n  // add non-object to list\n  if (!types.isObject(input)) {\n    if (list) {\n      list.push(input);\n    }\n    return;\n  }\n\n  // add values to list\n  if (graphTypes.isValue(input)) {\n    if ('@type' in input) {\n      var type = input['@type'];\n      // rename @type blank node\n      if (type.indexOf('_:') === 0) {\n        input['@type'] = type = issuer.getId(type);\n      }\n    }\n    if (list) {\n      list.push(input);\n    }\n    return;\n  } else if (list && graphTypes.isList(input)) {\n    var _list = [];\n    api.createNodeMap(input['@list'], graphs, graph, issuer, name, _list);\n    list.push({\n      '@list': _list\n    });\n    return;\n  }\n\n  // Note: At this point, input must be a subject.\n\n  // spec requires @type to be named first, so assign names early\n  if ('@type' in input) {\n    var _types = input['@type'];\n    var _iterator2 = _createForOfIteratorHelper(_types),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var _type = _step2.value;\n        if (_type.indexOf('_:') === 0) {\n          issuer.getId(_type);\n        }\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n\n  // get name for subject\n  if (types.isUndefined(name)) {\n    name = graphTypes.isBlankNode(input) ? issuer.getId(input['@id']) : input['@id'];\n  }\n\n  // add subject reference to list\n  if (list) {\n    list.push({\n      '@id': name\n    });\n  }\n\n  // create new subject or merge into existing one\n  var subjects = graphs[graph];\n  var subject = subjects[name] = subjects[name] || {};\n  subject['@id'] = name;\n  var properties = Object.keys(input).sort();\n  var _iterator3 = _createForOfIteratorHelper(properties),\n    _step3;\n  try {\n    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n      var property = _step3.value;\n      // skip @id\n      if (property === '@id') {\n        continue;\n      }\n\n      // handle reverse properties\n      if (property === '@reverse') {\n        var referencedNode = {\n          '@id': name\n        };\n        var reverseMap = input['@reverse'];\n        for (var reverseProperty in reverseMap) {\n          var items = reverseMap[reverseProperty];\n          var _iterator4 = _createForOfIteratorHelper(items),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var item = _step4.value;\n              var itemName = item['@id'];\n              if (graphTypes.isBlankNode(item)) {\n                itemName = issuer.getId(itemName);\n              }\n              api.createNodeMap(item, graphs, graph, issuer, itemName);\n              util.addValue(subjects[itemName], reverseProperty, referencedNode, {\n                propertyIsArray: true,\n                allowDuplicate: false\n              });\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n        continue;\n      }\n\n      // recurse into graph\n      if (property === '@graph') {\n        // add graph subjects map entry\n        if (!(name in graphs)) {\n          graphs[name] = {};\n        }\n        api.createNodeMap(input[property], graphs, name, issuer);\n        continue;\n      }\n\n      // recurse into included\n      if (property === '@included') {\n        api.createNodeMap(input[property], graphs, graph, issuer);\n        continue;\n      }\n\n      // copy non-@type keywords\n      if (property !== '@type' && isKeyword(property)) {\n        if (property === '@index' && property in subject && (input[property] !== subject[property] || input[property]['@id'] !== subject[property]['@id'])) {\n          throw new JsonLdError('Invalid JSON-LD syntax; conflicting @index property detected.', 'jsonld.SyntaxError', {\n            code: 'conflicting indexes',\n            subject: subject\n          });\n        }\n        subject[property] = input[property];\n        continue;\n      }\n\n      // iterate over objects\n      var objects = input[property];\n\n      // if property is a bnode, assign it a new id\n      if (property.indexOf('_:') === 0) {\n        property = issuer.getId(property);\n      }\n\n      // ensure property is added for empty arrays\n      if (objects.length === 0) {\n        util.addValue(subject, property, [], {\n          propertyIsArray: true\n        });\n        continue;\n      }\n      var _iterator5 = _createForOfIteratorHelper(objects),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var o = _step5.value;\n          if (property === '@type') {\n            // rename @type blank nodes\n            o = o.indexOf('_:') === 0 ? issuer.getId(o) : o;\n          }\n\n          // handle embedded subject or subject reference\n          if (graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {\n            // skip null @id\n            if ('@id' in o && !o['@id']) {\n              continue;\n            }\n\n            // relabel blank node @id\n            var id = graphTypes.isBlankNode(o) ? issuer.getId(o['@id']) : o['@id'];\n\n            // add reference and recurse\n            util.addValue(subject, property, {\n              '@id': id\n            }, {\n              propertyIsArray: true,\n              allowDuplicate: false\n            });\n            api.createNodeMap(o, graphs, graph, issuer, id);\n          } else if (graphTypes.isValue(o)) {\n            util.addValue(subject, property, o, {\n              propertyIsArray: true,\n              allowDuplicate: false\n            });\n          } else if (graphTypes.isList(o)) {\n            // handle @list\n            var _list2 = [];\n            api.createNodeMap(o['@list'], graphs, graph, issuer, name, _list2);\n            o = {\n              '@list': _list2\n            };\n            util.addValue(subject, property, o, {\n              propertyIsArray: true,\n              allowDuplicate: false\n            });\n          } else {\n            // handle @value\n            api.createNodeMap(o, graphs, graph, issuer, name);\n            util.addValue(subject, property, o, {\n              propertyIsArray: true,\n              allowDuplicate: false\n            });\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  } catch (err) {\n    _iterator3.e(err);\n  } finally {\n    _iterator3.f();\n  }\n};\n\n/**\n * Merge separate named graphs into a single merged graph including\n * all nodes from the default graph and named graphs.\n *\n * @param graphs a map of graph name to subject map.\n *\n * @return the merged graph map.\n */\napi.mergeNodeMapGraphs = function (graphs) {\n  var merged = {};\n  var _iterator6 = _createForOfIteratorHelper(Object.keys(graphs).sort()),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var name = _step6.value;\n      var _iterator7 = _createForOfIteratorHelper(Object.keys(graphs[name]).sort()),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var id = _step7.value;\n          var node = graphs[name][id];\n          if (!(id in merged)) {\n            merged[id] = {\n              '@id': id\n            };\n          }\n          var mergedNode = merged[id];\n          var _iterator8 = _createForOfIteratorHelper(Object.keys(node).sort()),\n            _step8;\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              var property = _step8.value;\n              if (isKeyword(property) && property !== '@type') {\n                // copy keywords\n                mergedNode[property] = util.clone(node[property]);\n              } else {\n                // merge objects\n                var _iterator9 = _createForOfIteratorHelper(node[property]),\n                  _step9;\n                try {\n                  for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                    var value = _step9.value;\n                    util.addValue(mergedNode, property, util.clone(value), {\n                      propertyIsArray: true,\n                      allowDuplicate: false\n                    });\n                  }\n                } catch (err) {\n                  _iterator9.e(err);\n                } finally {\n                  _iterator9.f();\n                }\n              }\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  return merged;\n};\napi.mergeNodeMaps = function (graphs) {\n  // add all non-default graphs to default graph\n  var defaultGraph = graphs['@default'];\n  var graphNames = Object.keys(graphs).sort();\n  var _iterator10 = _createForOfIteratorHelper(graphNames),\n    _step10;\n  try {\n    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {\n      var graphName = _step10.value;\n      if (graphName === '@default') {\n        continue;\n      }\n      var nodeMap = graphs[graphName];\n      var subject = defaultGraph[graphName];\n      if (!subject) {\n        defaultGraph[graphName] = subject = {\n          '@id': graphName,\n          '@graph': []\n        };\n      } else if (!('@graph' in subject)) {\n        subject['@graph'] = [];\n      }\n      var graph = subject['@graph'];\n      var _iterator11 = _createForOfIteratorHelper(Object.keys(nodeMap).sort()),\n        _step11;\n      try {\n        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {\n          var id = _step11.value;\n          var node = nodeMap[id];\n          // only add full subjects\n          if (!graphTypes.isSubjectReference(node)) {\n            graph.push(node);\n          }\n        }\n      } catch (err) {\n        _iterator11.e(err);\n      } finally {\n        _iterator11.f();\n      }\n    }\n  } catch (err) {\n    _iterator10.e(err);\n  } finally {\n    _iterator10.f();\n  }\n  return defaultGraph;\n};","map":{"version":3,"names":["require","isKeyword","graphTypes","types","util","JsonLdError","api","module","exports","createMergedNodeMap","input","options","issuer","IdentifierIssuer","graphs","createNodeMap","mergeNodeMaps","graph","name","list","isArray","node","undefined","isObject","push","isValue","type","indexOf","getId","isList","_list","isUndefined","isBlankNode","subjects","subject","properties","Object","keys","sort","property","referencedNode","reverseMap","reverseProperty","items","item","itemName","addValue","propertyIsArray","allowDuplicate","code","objects","length","o","isSubject","isSubjectReference","id","mergeNodeMapGraphs","merged","mergedNode","clone","value","defaultGraph","graphNames","graphName","nodeMap"],"sources":["E:/react-todo-app/node_modules/jsonld/lib/nodeMap.js"],"sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {isKeyword} = require('./context');\nconst graphTypes = require('./graphTypes');\nconst types = require('./types');\nconst util = require('./util');\nconst JsonLdError = require('./JsonLdError');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Creates a merged JSON-LD node map (node ID => node).\n *\n * @param input the expanded JSON-LD to create a node map of.\n * @param [options] the options to use:\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *\n * @return the node map.\n */\napi.createMergedNodeMap = (input, options) => {\n  options = options || {};\n\n  // produce a map of all subjects and name each bnode\n  const issuer = options.issuer || new util.IdentifierIssuer('_:b');\n  const graphs = {'@default': {}};\n  api.createNodeMap(input, graphs, '@default', issuer);\n\n  // add all non-default graphs to default graph\n  return api.mergeNodeMaps(graphs);\n};\n\n/**\n * Recursively flattens the subjects in the given JSON-LD expanded input\n * into a node map.\n *\n * @param input the JSON-LD expanded input.\n * @param graphs a map of graph name to subject map.\n * @param graph the name of the current graph.\n * @param issuer the blank node identifier issuer.\n * @param name the name assigned to the current input if it is a bnode.\n * @param list the list to append to, null for none.\n */\napi.createNodeMap = (input, graphs, graph, issuer, name, list) => {\n  // recurse through array\n  if(types.isArray(input)) {\n    for(const node of input) {\n      api.createNodeMap(node, graphs, graph, issuer, undefined, list);\n    }\n    return;\n  }\n\n  // add non-object to list\n  if(!types.isObject(input)) {\n    if(list) {\n      list.push(input);\n    }\n    return;\n  }\n\n  // add values to list\n  if(graphTypes.isValue(input)) {\n    if('@type' in input) {\n      let type = input['@type'];\n      // rename @type blank node\n      if(type.indexOf('_:') === 0) {\n        input['@type'] = type = issuer.getId(type);\n      }\n    }\n    if(list) {\n      list.push(input);\n    }\n    return;\n  } else if(list && graphTypes.isList(input)) {\n    const _list = [];\n    api.createNodeMap(input['@list'], graphs, graph, issuer, name, _list);\n    list.push({'@list': _list});\n    return;\n  }\n\n  // Note: At this point, input must be a subject.\n\n  // spec requires @type to be named first, so assign names early\n  if('@type' in input) {\n    const types = input['@type'];\n    for(const type of types) {\n      if(type.indexOf('_:') === 0) {\n        issuer.getId(type);\n      }\n    }\n  }\n\n  // get name for subject\n  if(types.isUndefined(name)) {\n    name = graphTypes.isBlankNode(input) ?\n      issuer.getId(input['@id']) : input['@id'];\n  }\n\n  // add subject reference to list\n  if(list) {\n    list.push({'@id': name});\n  }\n\n  // create new subject or merge into existing one\n  const subjects = graphs[graph];\n  const subject = subjects[name] = subjects[name] || {};\n  subject['@id'] = name;\n  const properties = Object.keys(input).sort();\n  for(let property of properties) {\n    // skip @id\n    if(property === '@id') {\n      continue;\n    }\n\n    // handle reverse properties\n    if(property === '@reverse') {\n      const referencedNode = {'@id': name};\n      const reverseMap = input['@reverse'];\n      for(const reverseProperty in reverseMap) {\n        const items = reverseMap[reverseProperty];\n        for(const item of items) {\n          let itemName = item['@id'];\n          if(graphTypes.isBlankNode(item)) {\n            itemName = issuer.getId(itemName);\n          }\n          api.createNodeMap(item, graphs, graph, issuer, itemName);\n          util.addValue(\n            subjects[itemName], reverseProperty, referencedNode,\n            {propertyIsArray: true, allowDuplicate: false});\n        }\n      }\n      continue;\n    }\n\n    // recurse into graph\n    if(property === '@graph') {\n      // add graph subjects map entry\n      if(!(name in graphs)) {\n        graphs[name] = {};\n      }\n      api.createNodeMap(input[property], graphs, name, issuer);\n      continue;\n    }\n\n    // recurse into included\n    if(property === '@included') {\n      api.createNodeMap(input[property], graphs, graph, issuer);\n      continue;\n    }\n\n    // copy non-@type keywords\n    if(property !== '@type' && isKeyword(property)) {\n      if(property === '@index' && property in subject &&\n        (input[property] !== subject[property] ||\n        input[property]['@id'] !== subject[property]['@id'])) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; conflicting @index property detected.',\n          'jsonld.SyntaxError',\n          {code: 'conflicting indexes', subject});\n      }\n      subject[property] = input[property];\n      continue;\n    }\n\n    // iterate over objects\n    const objects = input[property];\n\n    // if property is a bnode, assign it a new id\n    if(property.indexOf('_:') === 0) {\n      property = issuer.getId(property);\n    }\n\n    // ensure property is added for empty arrays\n    if(objects.length === 0) {\n      util.addValue(subject, property, [], {propertyIsArray: true});\n      continue;\n    }\n    for(let o of objects) {\n      if(property === '@type') {\n        // rename @type blank nodes\n        o = (o.indexOf('_:') === 0) ? issuer.getId(o) : o;\n      }\n\n      // handle embedded subject or subject reference\n      if(graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {\n        // skip null @id\n        if('@id' in o && !o['@id']) {\n          continue;\n        }\n\n        // relabel blank node @id\n        const id = graphTypes.isBlankNode(o) ?\n          issuer.getId(o['@id']) : o['@id'];\n\n        // add reference and recurse\n        util.addValue(\n          subject, property, {'@id': id},\n          {propertyIsArray: true, allowDuplicate: false});\n        api.createNodeMap(o, graphs, graph, issuer, id);\n      } else if(graphTypes.isValue(o)) {\n        util.addValue(\n          subject, property, o,\n          {propertyIsArray: true, allowDuplicate: false});\n      } else if(graphTypes.isList(o)) {\n        // handle @list\n        const _list = [];\n        api.createNodeMap(o['@list'], graphs, graph, issuer, name, _list);\n        o = {'@list': _list};\n        util.addValue(\n          subject, property, o,\n          {propertyIsArray: true, allowDuplicate: false});\n      } else {\n        // handle @value\n        api.createNodeMap(o, graphs, graph, issuer, name);\n        util.addValue(\n          subject, property, o, {propertyIsArray: true, allowDuplicate: false});\n      }\n    }\n  }\n};\n\n/**\n * Merge separate named graphs into a single merged graph including\n * all nodes from the default graph and named graphs.\n *\n * @param graphs a map of graph name to subject map.\n *\n * @return the merged graph map.\n */\napi.mergeNodeMapGraphs = graphs => {\n  const merged = {};\n  for(const name of Object.keys(graphs).sort()) {\n    for(const id of Object.keys(graphs[name]).sort()) {\n      const node = graphs[name][id];\n      if(!(id in merged)) {\n        merged[id] = {'@id': id};\n      }\n      const mergedNode = merged[id];\n\n      for(const property of Object.keys(node).sort()) {\n        if(isKeyword(property) && property !== '@type') {\n          // copy keywords\n          mergedNode[property] = util.clone(node[property]);\n        } else {\n          // merge objects\n          for(const value of node[property]) {\n            util.addValue(\n              mergedNode, property, util.clone(value),\n              {propertyIsArray: true, allowDuplicate: false});\n          }\n        }\n      }\n    }\n  }\n\n  return merged;\n};\n\napi.mergeNodeMaps = graphs => {\n  // add all non-default graphs to default graph\n  const defaultGraph = graphs['@default'];\n  const graphNames = Object.keys(graphs).sort();\n  for(const graphName of graphNames) {\n    if(graphName === '@default') {\n      continue;\n    }\n    const nodeMap = graphs[graphName];\n    let subject = defaultGraph[graphName];\n    if(!subject) {\n      defaultGraph[graphName] = subject = {\n        '@id': graphName,\n        '@graph': []\n      };\n    } else if(!('@graph' in subject)) {\n      subject['@graph'] = [];\n    }\n    const graph = subject['@graph'];\n    for(const id of Object.keys(nodeMap).sort()) {\n      const node = nodeMap[id];\n      // only add full subjects\n      if(!graphTypes.isSubjectReference(node)) {\n        graph.push(node);\n      }\n    }\n  }\n  return defaultGraph;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}