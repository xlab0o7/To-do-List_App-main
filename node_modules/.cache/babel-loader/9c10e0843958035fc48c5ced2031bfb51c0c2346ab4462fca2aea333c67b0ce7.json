{"ast":null,"code":"import _assertThisInitialized from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _toConsumableArray from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// **N3Store** objects store N3 quads by graph in memory.\nimport { default as N3DataFactory, termToId, termFromId } from './N3DataFactory';\nimport { Readable } from 'readable-stream';\nimport namespaces from './IRIs';\n\n// ## Constructor\nvar N3Store = /*#__PURE__*/function (_Symbol$iterator) {\n  function N3Store(quads, options) {\n    _classCallCheck(this, N3Store);\n    // The number of quads is initially zero\n    this._size = 0;\n    // `_graphs` contains subject, predicate, and object indexes per graph\n    this._graphs = Object.create(null);\n    // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n    this._id = 0;\n    this._ids = Object.create(null);\n    this._ids['><'] = 0; // dummy entry, so the first actual key is non-zero\n    this._entities = Object.create(null); // inverse of `_ids`\n    // `_blankNodeIndex` is the index of the last automatically named blank node\n    this._blankNodeIndex = 0;\n\n    // Shift parameters if `quads` is not given\n    if (!options && quads && !quads[0]) options = quads, quads = null;\n    options = options || {};\n    this._factory = options.factory || N3DataFactory;\n\n    // Add quads if passed\n    if (quads) this.addQuads(quads);\n  }\n\n  // ## Public properties\n\n  // ### `size` returns the number of quads in the store\n  _createClass(N3Store, [{\n    key: \"size\",\n    get: function get() {\n      // Return the quad count if if was cached\n      var size = this._size;\n      if (size !== null) return size;\n\n      // Calculate the number of quads by counting to the deepest level\n      size = 0;\n      var graphs = this._graphs;\n      var subjects, subject;\n      for (var graphKey in graphs) for (var subjectKey in subjects = graphs[graphKey].subjects) for (var predicateKey in subject = subjects[subjectKey]) size += Object.keys(subject[predicateKey]).length;\n      return this._size = size;\n    }\n\n    // ## Private methods\n\n    // ### `_addToIndex` adds a quad to a three-layered index.\n    // Returns if the index has changed, if the entry did not already exist.\n  }, {\n    key: \"_addToIndex\",\n    value: function _addToIndex(index0, key0, key1, key2) {\n      // Create layers as necessary\n      var index1 = index0[key0] || (index0[key0] = {});\n      var index2 = index1[key1] || (index1[key1] = {});\n      // Setting the key to _any_ value signals the presence of the quad\n      var existed = (key2 in index2);\n      if (!existed) index2[key2] = null;\n      return !existed;\n    }\n\n    // ### `_removeFromIndex` removes a quad from a three-layered index\n  }, {\n    key: \"_removeFromIndex\",\n    value: function _removeFromIndex(index0, key0, key1, key2) {\n      // Remove the quad from the index\n      var index1 = index0[key0],\n        index2 = index1[key1];\n      delete index2[key2];\n\n      // Remove intermediary index layers if they are empty\n      for (var key in index2) return;\n      delete index1[key1];\n      for (var _key in index1) return;\n      delete index0[key0];\n    }\n\n    // ### `_findInIndex` finds a set of quads in a three-layered index.\n    // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n    // Any of these keys can be undefined, which is interpreted as a wildcard.\n    // `name0`, `name1`, and `name2` are the names of the keys at each level,\n    // used when reconstructing the resulting quad\n    // (for instance: _subject_, _predicate_, and _object_).\n    // Finally, `graphId` will be the graph of the created quads.\n  }, {\n    key: \"_findInIndex\",\n    value:\n    /*#__PURE__*/\n    _regeneratorRuntime().mark(function _findInIndex(index0, key0, key1, key2, name0, name1, name2, graphId) {\n      var tmp, index1, index2, entityKeys, graph, parts, value0, value1, values, l;\n      return _regeneratorRuntime().wrap(function _findInIndex$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            entityKeys = this._entities;\n            graph = termFromId(graphId, this._factory);\n            parts = {\n              subject: null,\n              predicate: null,\n              object: null\n            }; // If a key is specified, use only that part of index 0.\n            if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n            _context.t0 = _regeneratorRuntime().keys(index0);\n          case 5:\n            if ((_context.t1 = _context.t0()).done) {\n              _context.next = 28;\n              break;\n            }\n            value0 = _context.t1.value;\n            if (!(index1 = index0[value0])) {\n              _context.next = 26;\n              break;\n            }\n            parts[name0] = termFromId(entityKeys[value0], this._factory);\n            // If a key is specified, use only that part of index 1.\n            if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n            _context.t2 = _regeneratorRuntime().keys(index1);\n          case 11:\n            if ((_context.t3 = _context.t2()).done) {\n              _context.next = 26;\n              break;\n            }\n            value1 = _context.t3.value;\n            if (!(index2 = index1[value1])) {\n              _context.next = 24;\n              break;\n            }\n            parts[name1] = termFromId(entityKeys[value1], this._factory);\n            // If a key is specified, use only that part of index 2, if it exists.\n            values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2); // Create quads for all items found in index 2.\n            l = 0;\n          case 17:\n            if (!(l < values.length)) {\n              _context.next = 24;\n              break;\n            }\n            parts[name2] = termFromId(entityKeys[values[l]], this._factory);\n            _context.next = 21;\n            return this._factory.quad(parts.subject, parts.predicate, parts.object, graph);\n          case 21:\n            l++;\n            _context.next = 17;\n            break;\n          case 24:\n            _context.next = 11;\n            break;\n          case 26:\n            _context.next = 5;\n            break;\n          case 28:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _findInIndex, this);\n    }) // ### `_loop` executes the callback on all keys of index 0\n  }, {\n    key: \"_loop\",\n    value: function _loop(index0, callback) {\n      for (var key0 in index0) callback(key0);\n    }\n\n    // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0\n  }, {\n    key: \"_loopByKey0\",\n    value: function _loopByKey0(index0, key0, callback) {\n      var index1, key1;\n      if (index1 = index0[key0]) {\n        for (key1 in index1) callback(key1);\n      }\n    }\n\n    // ### `_loopByKey1` executes the callback on given keys of all entries in index 0\n  }, {\n    key: \"_loopByKey1\",\n    value: function _loopByKey1(index0, key1, callback) {\n      var key0, index1;\n      for (key0 in index0) {\n        index1 = index0[key0];\n        if (index1[key1]) callback(key0);\n      }\n    }\n\n    // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2\n  }, {\n    key: \"_loopBy2Keys\",\n    value: function _loopBy2Keys(index0, key0, key1, callback) {\n      var index1, index2, key2;\n      if ((index1 = index0[key0]) && (index2 = index1[key1])) {\n        for (key2 in index2) callback(key2);\n      }\n    }\n\n    // ### `_countInIndex` counts matching quads in a three-layered index.\n    // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n    // Any of these keys can be undefined, which is interpreted as a wildcard.\n  }, {\n    key: \"_countInIndex\",\n    value: function _countInIndex(index0, key0, key1, key2) {\n      var count = 0,\n        tmp,\n        index1,\n        index2;\n\n      // If a key is specified, count only that part of index 0\n      if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n      for (var value0 in index0) {\n        if (index1 = index0[value0]) {\n          // If a key is specified, count only that part of index 1\n          if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n          for (var value1 in index1) {\n            if (index2 = index1[value1]) {\n              // If a key is specified, count the quad if it exists\n              if (key2) key2 in index2 && count++;\n              // Otherwise, count all quads\n              else count += Object.keys(index2).length;\n            }\n          }\n        }\n      }\n      return count;\n    }\n\n    // ### `_getGraphs` returns an array with the given graph,\n    // or all graphs if the argument is null or undefined.\n  }, {\n    key: \"_getGraphs\",\n    value: function _getGraphs(graph) {\n      if (!isString(graph)) return this._graphs;\n      var graphs = {};\n      graphs[graph] = this._graphs[graph];\n      return graphs;\n    }\n\n    // ### `_uniqueEntities` returns a function that accepts an entity ID\n    // and passes the corresponding entity to callback if it hasn't occurred before.\n  }, {\n    key: \"_uniqueEntities\",\n    value: function _uniqueEntities(callback) {\n      var _this = this;\n      var uniqueIds = Object.create(null);\n      return function (id) {\n        if (!(id in uniqueIds)) {\n          uniqueIds[id] = true;\n          callback(termFromId(_this._entities[id], _this._factory));\n        }\n      };\n    }\n\n    // ## Public methods\n\n    // ### `add` adds the specified quad to the dataset.\n    // Returns the dataset instance it was called on.\n    // Existing quads, as defined in Quad.equals, will be ignored.\n  }, {\n    key: \"add\",\n    value: function add(quad) {\n      this.addQuad(quad);\n      return this;\n    }\n\n    // ### `addQuad` adds a new quad to the store.\n    // Returns if the quad index has changed, if the quad did not already exist.\n  }, {\n    key: \"addQuad\",\n    value: function addQuad(subject, predicate, object, graph) {\n      // Shift arguments if a quad object is given instead of components\n      if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject;\n\n      // Convert terms to internal string representation\n      subject = termToId(subject);\n      predicate = termToId(predicate);\n      object = termToId(object);\n      graph = termToId(graph);\n\n      // Find the graph that will contain the triple\n      var graphItem = this._graphs[graph];\n      // Create the graph if it doesn't exist yet\n      if (!graphItem) {\n        graphItem = this._graphs[graph] = {\n          subjects: {},\n          predicates: {},\n          objects: {}\n        };\n        // Freezing a graph helps subsequent `add` performance,\n        // and properties will never be modified anyway\n        Object.freeze(graphItem);\n      }\n\n      // Since entities can often be long IRIs, we avoid storing them in every index.\n      // Instead, we have a separate index that maps entities to numbers,\n      // which are then used as keys in the other indexes.\n      var ids = this._ids;\n      var entities = this._entities;\n      subject = ids[subject] || (ids[entities[++this._id] = subject] = this._id);\n      predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);\n      object = ids[object] || (ids[entities[++this._id] = object] = this._id);\n      var changed = this._addToIndex(graphItem.subjects, subject, predicate, object);\n      this._addToIndex(graphItem.predicates, predicate, object, subject);\n      this._addToIndex(graphItem.objects, object, subject, predicate);\n\n      // The cached quad count is now invalid\n      this._size = null;\n      return changed;\n    }\n\n    // ### `addQuads` adds multiple quads to the store\n  }, {\n    key: \"addQuads\",\n    value: function addQuads(quads) {\n      for (var i = 0; i < quads.length; i++) this.addQuad(quads[i]);\n    }\n\n    // ### `delete` removes the specified quad from the dataset.\n    // Returns the dataset instance it was called on.\n  }, {\n    key: \"delete\",\n    value: function _delete(quad) {\n      this.removeQuad(quad);\n      return this;\n    }\n\n    // ### `has` determines whether a dataset includes a certain quad or quad pattern.\n  }, {\n    key: \"has\",\n    value: function has(subjectOrQuad, predicate, object, graph) {\n      if (subjectOrQuad && subjectOrQuad.subject) {\n        var _subjectOrQuad = subjectOrQuad;\n        subjectOrQuad = _subjectOrQuad.subject;\n        predicate = _subjectOrQuad.predicate;\n        object = _subjectOrQuad.object;\n        graph = _subjectOrQuad.graph;\n      }\n      return !this.readQuads(subjectOrQuad, predicate, object, graph).next().done;\n    }\n\n    // ### `import` adds a stream of quads to the store\n  }, {\n    key: \"import\",\n    value: function _import(stream) {\n      var _this2 = this;\n      stream.on('data', function (quad) {\n        _this2.addQuad(quad);\n      });\n      return stream;\n    }\n\n    // ### `removeQuad` removes a quad from the store if it exists\n  }, {\n    key: \"removeQuad\",\n    value: function removeQuad(subject, predicate, object, graph) {\n      // Shift arguments if a quad object is given instead of components\n      if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject;\n\n      // Convert terms to internal string representation\n      subject = termToId(subject);\n      predicate = termToId(predicate);\n      object = termToId(object);\n      graph = termToId(graph);\n\n      // Find internal identifiers for all components\n      // and verify the quad exists.\n      var ids = this._ids,\n        graphs = this._graphs;\n      var graphItem, subjects, predicates;\n      if (!(subject = ids[subject]) || !(predicate = ids[predicate]) || !(object = ids[object]) || !(graphItem = graphs[graph]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object in predicates)) return false;\n\n      // Remove it from all indexes\n      this._removeFromIndex(graphItem.subjects, subject, predicate, object);\n      this._removeFromIndex(graphItem.predicates, predicate, object, subject);\n      this._removeFromIndex(graphItem.objects, object, subject, predicate);\n      if (this._size !== null) this._size--;\n\n      // Remove the graph if it is empty\n      for (subject in graphItem.subjects) return true;\n      delete graphs[graph];\n      return true;\n    }\n\n    // ### `removeQuads` removes multiple quads from the store\n  }, {\n    key: \"removeQuads\",\n    value: function removeQuads(quads) {\n      for (var i = 0; i < quads.length; i++) this.removeQuad(quads[i]);\n    }\n\n    // ### `remove` removes a stream of quads from the store\n  }, {\n    key: \"remove\",\n    value: function remove(stream) {\n      var _this3 = this;\n      stream.on('data', function (quad) {\n        _this3.removeQuad(quad);\n      });\n      return stream;\n    }\n\n    // ### `removeMatches` removes all matching quads from the store\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n  }, {\n    key: \"removeMatches\",\n    value: function removeMatches(subject, predicate, object, graph) {\n      var _this4 = this;\n      var stream = new Readable({\n        objectMode: true\n      });\n      stream._read = function () {\n        var _iterator = _createForOfIteratorHelper(_this4.readQuads(subject, predicate, object, graph)),\n          _step;\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var quad = _step.value;\n            stream.push(quad);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n        stream.push(null);\n      };\n      return this.remove(stream);\n    }\n\n    // ### `deleteGraph` removes all triples with the given graph from the store\n  }, {\n    key: \"deleteGraph\",\n    value: function deleteGraph(graph) {\n      return this.removeMatches(null, null, null, graph);\n    }\n\n    // ### `getQuads` returns an array of quads matching a pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n  }, {\n    key: \"getQuads\",\n    value: function getQuads(subject, predicate, object, graph) {\n      return _toConsumableArray(this.readQuads(subject, predicate, object, graph));\n    }\n\n    // ### `readQuads` returns an generator of quads matching a pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n  }, {\n    key: \"readQuads\",\n    value:\n    /*#__PURE__*/\n    _regeneratorRuntime().mark(function readQuads(subject, predicate, object, graph) {\n      var graphs, ids, content, subjectId, predicateId, objectId, graphId;\n      return _regeneratorRuntime().wrap(function readQuads$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            // Convert terms to internal string representation\n            subject = subject && termToId(subject);\n            predicate = predicate && termToId(predicate);\n            object = object && termToId(object);\n            graph = graph && termToId(graph);\n            graphs = this._getGraphs(graph), ids = this._ids;\n            if (!(isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object]))) {\n              _context2.next = 7;\n              break;\n            }\n            return _context2.abrupt(\"return\");\n          case 7:\n            _context2.t0 = _regeneratorRuntime().keys(graphs);\n          case 8:\n            if ((_context2.t1 = _context2.t0()).done) {\n              _context2.next = 30;\n              break;\n            }\n            graphId = _context2.t1.value;\n            if (!(content = graphs[graphId])) {\n              _context2.next = 28;\n              break;\n            }\n            if (!subjectId) {\n              _context2.next = 19;\n              break;\n            }\n            if (!objectId) {\n              _context2.next = 16;\n              break;\n            }\n            return _context2.delegateYield(this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId), \"t2\", 14);\n          case 14:\n            _context2.next = 17;\n            break;\n          case 16:\n            return _context2.delegateYield(this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId), \"t3\", 17);\n          case 17:\n            _context2.next = 28;\n            break;\n          case 19:\n            if (!predicateId) {\n              _context2.next = 23;\n              break;\n            }\n            return _context2.delegateYield(this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId), \"t4\", 21);\n          case 21:\n            _context2.next = 28;\n            break;\n          case 23:\n            if (!objectId) {\n              _context2.next = 27;\n              break;\n            }\n            return _context2.delegateYield(this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId), \"t5\", 25);\n          case 25:\n            _context2.next = 28;\n            break;\n          case 27:\n            return _context2.delegateYield(this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId), \"t6\", 28);\n          case 28:\n            _context2.next = 8;\n            break;\n          case 30:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, readQuads, this);\n    }) // ### `match` returns a new dataset that is comprised of all quads in the current instance matching the given arguments.\n    // The logic described in Quad Matching is applied for each quad in this dataset to check if it should be included in the output dataset.\n    // Note: This method always returns a new DatasetCore, even if that dataset contains no quads.\n    // Note: Since a DatasetCore is an unordered set, the order of the quads within the returned sequence is arbitrary.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n    // For backwards compatibility, the object return also implements the Readable stream interface.\n  }, {\n    key: \"match\",\n    value: function match(subject, predicate, object, graph) {\n      return new DatasetCoreAndReadableStream(this, subject, predicate, object, graph);\n    }\n\n    // ### `countQuads` returns the number of quads matching a pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n  }, {\n    key: \"countQuads\",\n    value: function countQuads(subject, predicate, object, graph) {\n      // Convert terms to internal string representation\n      subject = subject && termToId(subject);\n      predicate = predicate && termToId(predicate);\n      object = object && termToId(object);\n      graph = graph && termToId(graph);\n      var graphs = this._getGraphs(graph),\n        ids = this._ids;\n      var count = 0,\n        content,\n        subjectId,\n        predicateId,\n        objectId;\n\n      // Translate IRIs to internal index keys.\n      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return 0;\n      for (var graphId in graphs) {\n        // Only if the specified graph contains triples, there can be results\n        if (content = graphs[graphId]) {\n          // Choose the optimal index, based on what fields are present\n          if (subject) {\n            if (object)\n              // If subject and object are given, the object index will be the fastest\n              count += this._countInIndex(content.objects, objectId, subjectId, predicateId);else\n              // If only subject and possibly predicate are given, the subject index will be the fastest\n              count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);\n          } else if (predicate) {\n            // If only predicate and possibly object are given, the predicate index will be the fastest\n            count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);\n          } else {\n            // If only object is possibly given, the object index will be the fastest\n            count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n          }\n        }\n      }\n      return count;\n    }\n\n    // ### `forEach` executes the callback on all quads.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback, subject, predicate, object, graph) {\n      this.some(function (quad) {\n        callback(quad);\n        return false;\n      }, subject, predicate, object, graph);\n    }\n\n    // ### `every` executes the callback on all quads,\n    // and returns `true` if it returns truthy for all them.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n  }, {\n    key: \"every\",\n    value: function every(callback, subject, predicate, object, graph) {\n      var some = false;\n      var every = !this.some(function (quad) {\n        some = true;\n        return !callback(quad);\n      }, subject, predicate, object, graph);\n      return some && every;\n    }\n\n    // ### `some` executes the callback on all quads,\n    // and returns `true` if it returns truthy for any of them.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n  }, {\n    key: \"some\",\n    value: function some(callback, subject, predicate, object, graph) {\n      var _iterator2 = _createForOfIteratorHelper(this.readQuads(subject, predicate, object, graph)),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var quad = _step2.value;\n          if (callback(quad)) return true;\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return false;\n    }\n\n    // ### `getSubjects` returns all subjects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n  }, {\n    key: \"getSubjects\",\n    value: function getSubjects(predicate, object, graph) {\n      var results = [];\n      this.forSubjects(function (s) {\n        results.push(s);\n      }, predicate, object, graph);\n      return results;\n    }\n\n    // ### `forSubjects` executes the callback on all subjects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n  }, {\n    key: \"forSubjects\",\n    value: function forSubjects(callback, predicate, object, graph) {\n      // Convert terms to internal string representation\n      predicate = predicate && termToId(predicate);\n      object = object && termToId(object);\n      graph = graph && termToId(graph);\n      var ids = this._ids,\n        graphs = this._getGraphs(graph);\n      var content, predicateId, objectId;\n      callback = this._uniqueEntities(callback);\n\n      // Translate IRIs to internal index keys.\n      if (isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return;\n      for (graph in graphs) {\n        // Only if the specified graph contains triples, there can be results\n        if (content = graphs[graph]) {\n          // Choose optimal index based on which fields are wildcards\n          if (predicateId) {\n            if (objectId)\n              // If predicate and object are given, the POS index is best.\n              this._loopBy2Keys(content.predicates, predicateId, objectId, callback);else\n              // If only predicate is given, the SPO index is best.\n              this._loopByKey1(content.subjects, predicateId, callback);\n          } else if (objectId)\n            // If only object is given, the OSP index is best.\n            this._loopByKey0(content.objects, objectId, callback);else\n            // If no params given, iterate all the subjects\n            this._loop(content.subjects, callback);\n        }\n      }\n    }\n\n    // ### `getPredicates` returns all predicates that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n  }, {\n    key: \"getPredicates\",\n    value: function getPredicates(subject, object, graph) {\n      var results = [];\n      this.forPredicates(function (p) {\n        results.push(p);\n      }, subject, object, graph);\n      return results;\n    }\n\n    // ### `forPredicates` executes the callback on all predicates that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n  }, {\n    key: \"forPredicates\",\n    value: function forPredicates(callback, subject, object, graph) {\n      // Convert terms to internal string representation\n      subject = subject && termToId(subject);\n      object = object && termToId(object);\n      graph = graph && termToId(graph);\n      var ids = this._ids,\n        graphs = this._getGraphs(graph);\n      var content, subjectId, objectId;\n      callback = this._uniqueEntities(callback);\n\n      // Translate IRIs to internal index keys.\n      if (isString(subject) && !(subjectId = ids[subject]) || isString(object) && !(objectId = ids[object])) return;\n      for (graph in graphs) {\n        // Only if the specified graph contains triples, there can be results\n        if (content = graphs[graph]) {\n          // Choose optimal index based on which fields are wildcards\n          if (subjectId) {\n            if (objectId)\n              // If subject and object are given, the OSP index is best.\n              this._loopBy2Keys(content.objects, objectId, subjectId, callback);else\n              // If only subject is given, the SPO index is best.\n              this._loopByKey0(content.subjects, subjectId, callback);\n          } else if (objectId)\n            // If only object is given, the POS index is best.\n            this._loopByKey1(content.predicates, objectId, callback);else\n            // If no params given, iterate all the predicates.\n            this._loop(content.predicates, callback);\n        }\n      }\n    }\n\n    // ### `getObjects` returns all objects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n  }, {\n    key: \"getObjects\",\n    value: function getObjects(subject, predicate, graph) {\n      var results = [];\n      this.forObjects(function (o) {\n        results.push(o);\n      }, subject, predicate, graph);\n      return results;\n    }\n\n    // ### `forObjects` executes the callback on all objects that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n  }, {\n    key: \"forObjects\",\n    value: function forObjects(callback, subject, predicate, graph) {\n      // Convert terms to internal string representation\n      subject = subject && termToId(subject);\n      predicate = predicate && termToId(predicate);\n      graph = graph && termToId(graph);\n      var ids = this._ids,\n        graphs = this._getGraphs(graph);\n      var content, subjectId, predicateId;\n      callback = this._uniqueEntities(callback);\n\n      // Translate IRIs to internal index keys.\n      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate])) return;\n      for (graph in graphs) {\n        // Only if the specified graph contains triples, there can be results\n        if (content = graphs[graph]) {\n          // Choose optimal index based on which fields are wildcards\n          if (subjectId) {\n            if (predicateId)\n              // If subject and predicate are given, the SPO index is best.\n              this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);else\n              // If only subject is given, the OSP index is best.\n              this._loopByKey1(content.objects, subjectId, callback);\n          } else if (predicateId)\n            // If only predicate is given, the POS index is best.\n            this._loopByKey0(content.predicates, predicateId, callback);else\n            // If no params given, iterate all the objects.\n            this._loop(content.objects, callback);\n        }\n      }\n    }\n\n    // ### `getGraphs` returns all graphs that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n  }, {\n    key: \"getGraphs\",\n    value: function getGraphs(subject, predicate, object) {\n      var results = [];\n      this.forGraphs(function (g) {\n        results.push(g);\n      }, subject, predicate, object);\n      return results;\n    }\n\n    // ### `forGraphs` executes the callback on all graphs that match the pattern.\n    // Setting any field to `undefined` or `null` indicates a wildcard.\n  }, {\n    key: \"forGraphs\",\n    value: function forGraphs(callback, subject, predicate, object) {\n      for (var graph in this._graphs) {\n        this.some(function (quad) {\n          callback(quad.graph);\n          return true; // Halt iteration of some()\n        }, subject, predicate, object, graph);\n      }\n    }\n\n    // ### `createBlankNode` creates a new blank node, returning its name\n  }, {\n    key: \"createBlankNode\",\n    value: function createBlankNode(suggestedName) {\n      var name, index;\n      // Generate a name based on the suggested name\n      if (suggestedName) {\n        name = suggestedName = \"_:\".concat(suggestedName), index = 1;\n        while (this._ids[name]) name = suggestedName + index++;\n      }\n      // Generate a generic blank node name\n      else {\n        do {\n          name = \"_:b\".concat(this._blankNodeIndex++);\n        } while (this._ids[name]);\n      }\n      // Add the blank node to the entities, avoiding the generation of duplicates\n      this._ids[name] = ++this._id;\n      this._entities[this._id] = name;\n      return this._factory.blankNode(name.substr(2));\n    }\n\n    // ### `extractLists` finds and removes all list triples\n    // and returns the items per list.\n  }, {\n    key: \"extractLists\",\n    value: function extractLists() {\n      var _this5 = this;\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$remove = _ref.remove,\n        remove = _ref$remove === void 0 ? false : _ref$remove,\n        _ref$ignoreErrors = _ref.ignoreErrors,\n        ignoreErrors = _ref$ignoreErrors === void 0 ? false : _ref$ignoreErrors;\n      var lists = {}; // has scalar keys so could be a simple Object\n      var onError = ignoreErrors ? function () {\n        return true;\n      } : function (node, message) {\n        throw new Error(\"\".concat(node.value, \" \").concat(message));\n      };\n\n      // Traverse each list from its tail\n      var tails = this.getQuads(null, namespaces.rdf.rest, namespaces.rdf.nil, null);\n      var toRemove = remove ? _toConsumableArray(tails) : [];\n      tails.forEach(function (tailQuad) {\n        var items = []; // the members found as objects of rdf:first quads\n        var malformed = false; // signals whether the current list is malformed\n        var head; // the head of the list (_:b1 in above example)\n        var headPos; // set to subject or object when head is set\n        var graph = tailQuad.graph; // make sure list is in exactly one graph\n\n        // Traverse the list from tail to end\n        var current = tailQuad.subject;\n        while (current && !malformed) {\n          var objectQuads = _this5.getQuads(null, null, current, null);\n          var subjectQuads = _this5.getQuads(current, null, null, null);\n          var quad = void 0,\n            first = null,\n            rest = null,\n            parent = null;\n\n          // Find the first and rest of this list node\n          for (var i = 0; i < subjectQuads.length && !malformed; i++) {\n            quad = subjectQuads[i];\n            if (!quad.graph.equals(graph)) malformed = onError(current, 'not confined to single graph');else if (head) malformed = onError(current, 'has non-list arcs out');\n\n            // one rdf:first\n            else if (quad.predicate.value === namespaces.rdf.first) {\n              if (first) malformed = onError(current, 'has multiple rdf:first arcs');else toRemove.push(first = quad);\n            }\n\n            // one rdf:rest\n            else if (quad.predicate.value === namespaces.rdf.rest) {\n              if (rest) malformed = onError(current, 'has multiple rdf:rest arcs');else toRemove.push(rest = quad);\n            }\n\n            // alien triple\n            else if (objectQuads.length) malformed = onError(current, 'can\\'t be subject and object');else {\n              head = quad; // e.g. { (1 2 3) :p :o }\n              headPos = 'subject';\n            }\n          }\n\n          // { :s :p (1 2) } arrives here with no head\n          // { (1 2) :p :o } arrives here with head set to the list.\n          for (var _i = 0; _i < objectQuads.length && !malformed; ++_i) {\n            quad = objectQuads[_i];\n            if (head) malformed = onError(current, 'can\\'t have coreferences');\n            // one rdf:rest\n            else if (quad.predicate.value === namespaces.rdf.rest) {\n              if (parent) malformed = onError(current, 'has incoming rdf:rest arcs');else parent = quad;\n            } else {\n              head = quad; // e.g. { :s :p (1 2) }\n              headPos = 'object';\n            }\n          }\n\n          // Store the list item and continue with parent\n          if (!first) malformed = onError(current, 'has no list head');else items.unshift(first.object);\n          current = parent && parent.subject;\n        }\n\n        // Don't remove any quads if the list is malformed\n        if (malformed) remove = false;\n        // Store the list under the value of its head\n        else if (head) lists[head[headPos].value] = items;\n      });\n\n      // Remove list quads if requested\n      if (remove) this.removeQuads(toRemove);\n      return lists;\n    }\n\n    // ### Store is an iterable.\n    // Can be used where iterables are expected: for...of loops, array spread operator,\n    // `yield*`, and destructuring assignment (order is not guaranteed).\n  }, {\n    key: _Symbol$iterator,\n    value:\n    /*#__PURE__*/\n    _regeneratorRuntime().mark(function value() {\n      return _regeneratorRuntime().wrap(function value$(_context3) {\n        while (1) switch (_context3.prev = _context3.next) {\n          case 0:\n            return _context3.delegateYield(this.readQuads(), \"t0\", 1);\n          case 1:\n          case \"end\":\n            return _context3.stop();\n        }\n      }, value, this);\n    })\n  }]);\n  return N3Store;\n}(Symbol.iterator); // Determines whether the argument is a string\nexport { N3Store as default };\nfunction isString(s) {\n  return typeof s === 'string' || s instanceof String;\n}\n\n/**\n * A class that implements both DatasetCore and Readable.\n */\nvar DatasetCoreAndReadableStream = /*#__PURE__*/function (_Readable, _Symbol$iterator2) {\n  _inherits(DatasetCoreAndReadableStream, _Readable);\n  var _super = _createSuper(DatasetCoreAndReadableStream);\n  function DatasetCoreAndReadableStream(n3Store, subject, predicate, object, graph) {\n    var _this6;\n    _classCallCheck(this, DatasetCoreAndReadableStream);\n    _this6 = _super.call(this, {\n      objectMode: true\n    });\n    Object.assign(_assertThisInitialized(_this6), {\n      n3Store: n3Store,\n      subject: subject,\n      predicate: predicate,\n      object: object,\n      graph: graph\n    });\n    return _this6;\n  }\n  _createClass(DatasetCoreAndReadableStream, [{\n    key: \"filtered\",\n    get: function get() {\n      if (!this._filtered) {\n        var n3Store = this.n3Store,\n          graph = this.graph,\n          object = this.object,\n          predicate = this.predicate,\n          subject = this.subject;\n        var newStore = this._filtered = new N3Store({\n          factory: n3Store._factory\n        });\n        var _iterator3 = _createForOfIteratorHelper(n3Store.readQuads(subject, predicate, object, graph)),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var quad = _step3.value;\n            newStore.addQuad(quad);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n      return this._filtered;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this.filtered.size;\n    }\n  }, {\n    key: \"_read\",\n    value: function _read() {\n      var _iterator4 = _createForOfIteratorHelper(this),\n        _step4;\n      try {\n        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n          var quad = _step4.value;\n          this.push(quad);\n        }\n      } catch (err) {\n        _iterator4.e(err);\n      } finally {\n        _iterator4.f();\n      }\n      this.push(null);\n    }\n  }, {\n    key: \"add\",\n    value: function add(quad) {\n      return this.filtered.add(quad);\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(quad) {\n      return this.filtered.delete(quad);\n    }\n  }, {\n    key: \"has\",\n    value: function has(quad) {\n      return this.filtered.has(quad);\n    }\n  }, {\n    key: \"match\",\n    value: function match(subject, predicate, object, graph) {\n      return new DatasetCoreAndReadableStream(this.filtered, subject, predicate, object, graph);\n    }\n  }, {\n    key: _Symbol$iterator2,\n    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {\n      return _regeneratorRuntime().wrap(function value$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            return _context4.delegateYield(this._filtered || this.n3Store.readQuads(this.subject, this.predicate, this.object, this.graph), \"t0\", 1);\n          case 1:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, value, this);\n    })\n  }]);\n  return DatasetCoreAndReadableStream;\n}(Readable, Symbol.iterator);","map":{"version":3,"names":["default","N3DataFactory","termToId","termFromId","Readable","namespaces","N3Store","quads","options","_size","_graphs","Object","create","_id","_ids","_entities","_blankNodeIndex","_factory","factory","addQuads","size","graphs","subjects","subject","graphKey","subjectKey","predicateKey","keys","length","index0","key0","key1","key2","index1","index2","existed","key","name0","name1","name2","graphId","entityKeys","graph","parts","predicate","object","tmp","value0","value1","values","l","quad","callback","count","isString","uniqueIds","id","addQuad","graphItem","predicates","objects","freeze","ids","entities","changed","_addToIndex","i","removeQuad","subjectOrQuad","readQuads","next","done","stream","on","_removeFromIndex","objectMode","_read","push","remove","removeMatches","_getGraphs","subjectId","predicateId","objectId","content","_findInIndex","DatasetCoreAndReadableStream","_countInIndex","some","every","results","forSubjects","s","_uniqueEntities","_loopBy2Keys","_loopByKey1","_loopByKey0","_loop","forPredicates","p","forObjects","o","forGraphs","g","suggestedName","name","index","blankNode","substr","ignoreErrors","lists","onError","node","message","Error","value","tails","getQuads","rdf","rest","nil","toRemove","forEach","tailQuad","items","malformed","head","headPos","current","objectQuads","subjectQuads","first","parent","equals","unshift","removeQuads","Symbol","iterator","String","n3Store","assign","_filtered","newStore","filtered","add","delete","has"],"sources":["E:/react-todo-app/node_modules/n3/src/N3Store.js"],"sourcesContent":["// **N3Store** objects store N3 quads by graph in memory.\nimport { default as N3DataFactory, termToId, termFromId } from './N3DataFactory';\nimport { Readable } from 'readable-stream';\nimport namespaces from './IRIs';\n\n// ## Constructor\nexport default class N3Store {\n  constructor(quads, options) {\n    // The number of quads is initially zero\n    this._size = 0;\n    // `_graphs` contains subject, predicate, and object indexes per graph\n    this._graphs = Object.create(null);\n    // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n    this._id = 0;\n    this._ids = Object.create(null);\n    this._ids['><'] = 0; // dummy entry, so the first actual key is non-zero\n    this._entities = Object.create(null); // inverse of `_ids`\n    // `_blankNodeIndex` is the index of the last automatically named blank node\n    this._blankNodeIndex = 0;\n\n    // Shift parameters if `quads` is not given\n    if (!options && quads && !quads[0])\n      options = quads, quads = null;\n    options = options || {};\n    this._factory = options.factory || N3DataFactory;\n\n    // Add quads if passed\n    if (quads)\n      this.addQuads(quads);\n  }\n\n  // ## Public properties\n\n  // ### `size` returns the number of quads in the store\n  get size() {\n    // Return the quad count if if was cached\n    let size = this._size;\n    if (size !== null)\n      return size;\n\n    // Calculate the number of quads by counting to the deepest level\n    size = 0;\n    const graphs = this._graphs;\n    let subjects, subject;\n    for (const graphKey in graphs)\n      for (const subjectKey in (subjects = graphs[graphKey].subjects))\n        for (const predicateKey in (subject = subjects[subjectKey]))\n          size += Object.keys(subject[predicateKey]).length;\n    return this._size = size;\n  }\n\n  // ## Private methods\n\n  // ### `_addToIndex` adds a quad to a three-layered index.\n  // Returns if the index has changed, if the entry did not already exist.\n  _addToIndex(index0, key0, key1, key2) {\n    // Create layers as necessary\n    const index1 = index0[key0] || (index0[key0] = {});\n    const index2 = index1[key1] || (index1[key1] = {});\n    // Setting the key to _any_ value signals the presence of the quad\n    const existed = key2 in index2;\n    if (!existed)\n      index2[key2] = null;\n    return !existed;\n  }\n\n  // ### `_removeFromIndex` removes a quad from a three-layered index\n  _removeFromIndex(index0, key0, key1, key2) {\n    // Remove the quad from the index\n    const index1 = index0[key0], index2 = index1[key1];\n    delete index2[key2];\n\n    // Remove intermediary index layers if they are empty\n    for (const key in index2) return;\n    delete index1[key1];\n    for (const key in index1) return;\n    delete index0[key0];\n  }\n\n  // ### `_findInIndex` finds a set of quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  // `name0`, `name1`, and `name2` are the names of the keys at each level,\n  // used when reconstructing the resulting quad\n  // (for instance: _subject_, _predicate_, and _object_).\n  // Finally, `graphId` will be the graph of the created quads.\n  *_findInIndex(index0, key0, key1, key2, name0, name1, name2, graphId) {\n    let tmp, index1, index2;\n    const entityKeys = this._entities;\n    const graph = termFromId(graphId, this._factory);\n    const parts = { subject: null, predicate: null, object: null };\n\n    // If a key is specified, use only that part of index 0.\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n    for (const value0 in index0) {\n      if (index1 = index0[value0]) {\n        parts[name0] = termFromId(entityKeys[value0], this._factory);\n        // If a key is specified, use only that part of index 1.\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n        for (const value1 in index1) {\n          if (index2 = index1[value1]) {\n            parts[name1] = termFromId(entityKeys[value1], this._factory);\n            // If a key is specified, use only that part of index 2, if it exists.\n            const values = key2 ? (key2 in index2 ? [key2] : []) : Object.keys(index2);\n            // Create quads for all items found in index 2.\n            for (let l = 0; l < values.length; l++) {\n              parts[name2] = termFromId(entityKeys[values[l]], this._factory);\n              yield this._factory.quad(parts.subject, parts.predicate, parts.object, graph);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // ### `_loop` executes the callback on all keys of index 0\n  _loop(index0, callback) {\n    for (const key0 in index0)\n      callback(key0);\n  }\n\n  // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0\n  _loopByKey0(index0, key0, callback) {\n    let index1, key1;\n    if (index1 = index0[key0]) {\n      for (key1 in index1)\n        callback(key1);\n    }\n  }\n\n  // ### `_loopByKey1` executes the callback on given keys of all entries in index 0\n  _loopByKey1(index0, key1, callback) {\n    let key0, index1;\n    for (key0 in index0) {\n      index1 = index0[key0];\n      if (index1[key1])\n        callback(key0);\n    }\n  }\n\n  // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2\n  _loopBy2Keys(index0, key0, key1, callback) {\n    let index1, index2, key2;\n    if ((index1 = index0[key0]) && (index2 = index1[key1])) {\n      for (key2 in index2)\n        callback(key2);\n    }\n  }\n\n  // ### `_countInIndex` counts matching quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  _countInIndex(index0, key0, key1, key2) {\n    let count = 0, tmp, index1, index2;\n\n    // If a key is specified, count only that part of index 0\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n    for (const value0 in index0) {\n      if (index1 = index0[value0]) {\n        // If a key is specified, count only that part of index 1\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n        for (const value1 in index1) {\n          if (index2 = index1[value1]) {\n            // If a key is specified, count the quad if it exists\n            if (key2) (key2 in index2) && count++;\n            // Otherwise, count all quads\n            else count += Object.keys(index2).length;\n          }\n        }\n      }\n    }\n    return count;\n  }\n\n  // ### `_getGraphs` returns an array with the given graph,\n  // or all graphs if the argument is null or undefined.\n  _getGraphs(graph) {\n    if (!isString(graph))\n      return this._graphs;\n    const graphs = {};\n    graphs[graph] = this._graphs[graph];\n    return graphs;\n  }\n\n  // ### `_uniqueEntities` returns a function that accepts an entity ID\n  // and passes the corresponding entity to callback if it hasn't occurred before.\n  _uniqueEntities(callback) {\n    const uniqueIds = Object.create(null);\n    return id => {\n      if (!(id in uniqueIds)) {\n        uniqueIds[id] = true;\n        callback(termFromId(this._entities[id], this._factory));\n      }\n    };\n  }\n\n  // ## Public methods\n\n  // ### `add` adds the specified quad to the dataset.\n  // Returns the dataset instance it was called on.\n  // Existing quads, as defined in Quad.equals, will be ignored.\n  add(quad) {\n    this.addQuad(quad);\n    return this;\n  }\n\n  // ### `addQuad` adds a new quad to the store.\n  // Returns if the quad index has changed, if the quad did not already exist.\n  addQuad(subject, predicate, object, graph) {\n    // Shift arguments if a quad object is given instead of components\n    if (!predicate)\n      graph = subject.graph, object = subject.object,\n        predicate = subject.predicate, subject = subject.subject;\n\n    // Convert terms to internal string representation\n    subject = termToId(subject);\n    predicate = termToId(predicate);\n    object = termToId(object);\n    graph = termToId(graph);\n\n    // Find the graph that will contain the triple\n    let graphItem = this._graphs[graph];\n    // Create the graph if it doesn't exist yet\n    if (!graphItem) {\n      graphItem = this._graphs[graph] = { subjects: {}, predicates: {}, objects: {} };\n      // Freezing a graph helps subsequent `add` performance,\n      // and properties will never be modified anyway\n      Object.freeze(graphItem);\n    }\n\n    // Since entities can often be long IRIs, we avoid storing them in every index.\n    // Instead, we have a separate index that maps entities to numbers,\n    // which are then used as keys in the other indexes.\n    const ids = this._ids;\n    const entities = this._entities;\n    subject   = ids[subject]   || (ids[entities[++this._id] = subject]   = this._id);\n    predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);\n    object    = ids[object]    || (ids[entities[++this._id] = object]    = this._id);\n\n    const changed = this._addToIndex(graphItem.subjects,   subject,   predicate, object);\n    this._addToIndex(graphItem.predicates, predicate, object,    subject);\n    this._addToIndex(graphItem.objects,    object,    subject,   predicate);\n\n    // The cached quad count is now invalid\n    this._size = null;\n    return changed;\n  }\n\n  // ### `addQuads` adds multiple quads to the store\n  addQuads(quads) {\n    for (let i = 0; i < quads.length; i++)\n      this.addQuad(quads[i]);\n  }\n\n  // ### `delete` removes the specified quad from the dataset.\n  // Returns the dataset instance it was called on.\n  delete(quad) {\n    this.removeQuad(quad);\n    return this;\n  }\n\n  // ### `has` determines whether a dataset includes a certain quad or quad pattern.\n  has(subjectOrQuad, predicate, object, graph) {\n    if (subjectOrQuad && subjectOrQuad.subject)\n      ({ subject: subjectOrQuad, predicate, object, graph } = subjectOrQuad);\n    return !this.readQuads(subjectOrQuad, predicate, object, graph).next().done;\n  }\n\n  // ### `import` adds a stream of quads to the store\n  import(stream) {\n    stream.on('data', quad => { this.addQuad(quad); });\n    return stream;\n  }\n\n  // ### `removeQuad` removes a quad from the store if it exists\n  removeQuad(subject, predicate, object, graph) {\n    // Shift arguments if a quad object is given instead of components\n    if (!predicate)\n      graph = subject.graph, object = subject.object,\n        predicate = subject.predicate, subject = subject.subject;\n\n    // Convert terms to internal string representation\n    subject = termToId(subject);\n    predicate = termToId(predicate);\n    object = termToId(object);\n    graph = termToId(graph);\n\n    // Find internal identifiers for all components\n    // and verify the quad exists.\n    const ids = this._ids, graphs = this._graphs;\n    let graphItem, subjects, predicates;\n    if (!(subject    = ids[subject]) || !(predicate = ids[predicate]) ||\n        !(object     = ids[object])  || !(graphItem = graphs[graph])  ||\n        !(subjects   = graphItem.subjects[subject]) ||\n        !(predicates = subjects[predicate]) ||\n        !(object in predicates))\n      return false;\n\n    // Remove it from all indexes\n    this._removeFromIndex(graphItem.subjects,   subject,   predicate, object);\n    this._removeFromIndex(graphItem.predicates, predicate, object,    subject);\n    this._removeFromIndex(graphItem.objects,    object,    subject,   predicate);\n    if (this._size !== null) this._size--;\n\n    // Remove the graph if it is empty\n    for (subject in graphItem.subjects) return true;\n    delete graphs[graph];\n    return true;\n  }\n\n  // ### `removeQuads` removes multiple quads from the store\n  removeQuads(quads) {\n    for (let i = 0; i < quads.length; i++)\n      this.removeQuad(quads[i]);\n  }\n\n  // ### `remove` removes a stream of quads from the store\n  remove(stream) {\n    stream.on('data', quad => { this.removeQuad(quad); });\n    return stream;\n  }\n\n  // ### `removeMatches` removes all matching quads from the store\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  removeMatches(subject, predicate, object, graph) {\n    const stream = new Readable({ objectMode: true });\n\n    stream._read = () => {\n      for (const quad of this.readQuads(subject, predicate, object, graph))\n        stream.push(quad);\n      stream.push(null);\n    };\n\n    return this.remove(stream);\n  }\n\n  // ### `deleteGraph` removes all triples with the given graph from the store\n  deleteGraph(graph) {\n    return this.removeMatches(null, null, null, graph);\n  }\n\n  // ### `getQuads` returns an array of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getQuads(subject, predicate, object, graph) {\n    return [...this.readQuads(subject, predicate, object, graph)];\n  }\n\n  // ### `readQuads` returns an generator of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  *readQuads(subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const graphs = this._getGraphs(graph), ids = this._ids;\n    let content, subjectId, predicateId, objectId;\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject)   && !(subjectId   = ids[subject])   ||\n        isString(predicate) && !(predicateId = ids[predicate]) ||\n        isString(object)    && !(objectId    = ids[object]))\n      return;\n\n    for (const graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subjectId) {\n          if (objectId)\n            // If subject and object are given, the object index will be the fastest\n            yield* this._findInIndex(content.objects, objectId, subjectId, predicateId,\n                              'object', 'subject', 'predicate', graphId);\n          else\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            yield* this._findInIndex(content.subjects, subjectId, predicateId, null,\n                              'subject', 'predicate', 'object', graphId);\n        }\n        else if (predicateId)\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          yield* this._findInIndex(content.predicates, predicateId, objectId, null,\n                            'predicate', 'object', 'subject', graphId);\n        else if (objectId)\n          // If only object is given, the object index will be the fastest\n          yield* this._findInIndex(content.objects, objectId, null, null,\n                            'object', 'subject', 'predicate', graphId);\n        else\n          // If nothing is given, iterate subjects and predicates first\n          yield* this._findInIndex(content.subjects, null, null, null,\n                            'subject', 'predicate', 'object', graphId);\n      }\n    }\n  }\n\n  // ### `match` returns a new dataset that is comprised of all quads in the current instance matching the given arguments.\n  // The logic described in Quad Matching is applied for each quad in this dataset to check if it should be included in the output dataset.\n  // Note: This method always returns a new DatasetCore, even if that dataset contains no quads.\n  // Note: Since a DatasetCore is an unordered set, the order of the quads within the returned sequence is arbitrary.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  // For backwards compatibility, the object return also implements the Readable stream interface.\n  match(subject, predicate, object, graph) {\n    return new DatasetCoreAndReadableStream(this, subject, predicate, object, graph);\n  }\n\n  // ### `countQuads` returns the number of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  countQuads(subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const graphs = this._getGraphs(graph), ids = this._ids;\n    let count = 0, content, subjectId, predicateId, objectId;\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject)   && !(subjectId   = ids[subject])   ||\n        isString(predicate) && !(predicateId = ids[predicate]) ||\n        isString(object)    && !(objectId    = ids[object]))\n      return 0;\n\n    for (const graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subject) {\n          if (object)\n            // If subject and object are given, the object index will be the fastest\n            count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n          else\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);\n        }\n        else if (predicate) {\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);\n        }\n        else {\n          // If only object is possibly given, the object index will be the fastest\n          count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n        }\n      }\n    }\n    return count;\n  }\n\n  // ### `forEach` executes the callback on all quads.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forEach(callback, subject, predicate, object, graph) {\n    this.some(quad => {\n      callback(quad);\n      return false;\n    }, subject, predicate, object, graph);\n  }\n\n  // ### `every` executes the callback on all quads,\n  // and returns `true` if it returns truthy for all them.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  every(callback, subject, predicate, object, graph) {\n    let some = false;\n    const every = !this.some(quad => {\n      some = true;\n      return !callback(quad);\n    }, subject, predicate, object, graph);\n    return some && every;\n  }\n\n  // ### `some` executes the callback on all quads,\n  // and returns `true` if it returns truthy for any of them.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  some(callback, subject, predicate, object, graph) {\n    for (const quad of this.readQuads(subject, predicate, object, graph))\n      if (callback(quad))\n        return true;\n    return false;\n  }\n\n  // ### `getSubjects` returns all subjects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getSubjects(predicate, object, graph) {\n    const results = [];\n    this.forSubjects(s => { results.push(s); }, predicate, object, graph);\n    return results;\n  }\n\n  // ### `forSubjects` executes the callback on all subjects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forSubjects(callback, predicate, object, graph) {\n    // Convert terms to internal string representation\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const ids = this._ids, graphs = this._getGraphs(graph);\n    let content, predicateId, objectId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (isString(predicate) && !(predicateId = ids[predicate]) ||\n        isString(object)    && !(objectId    = ids[object]))\n      return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (predicateId) {\n          if (objectId)\n            // If predicate and object are given, the POS index is best.\n            this._loopBy2Keys(content.predicates, predicateId, objectId, callback);\n          else\n            // If only predicate is given, the SPO index is best.\n            this._loopByKey1(content.subjects, predicateId, callback);\n        }\n        else if (objectId)\n          // If only object is given, the OSP index is best.\n          this._loopByKey0(content.objects, objectId, callback);\n        else\n          // If no params given, iterate all the subjects\n          this._loop(content.subjects, callback);\n      }\n    }\n  }\n\n  // ### `getPredicates` returns all predicates that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getPredicates(subject, object, graph) {\n    const results = [];\n    this.forPredicates(p => { results.push(p); }, subject, object, graph);\n    return results;\n  }\n\n  // ### `forPredicates` executes the callback on all predicates that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forPredicates(callback, subject, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const ids = this._ids, graphs = this._getGraphs(graph);\n    let content, subjectId, objectId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject) && !(subjectId = ids[subject]) ||\n        isString(object)  && !(objectId  = ids[object]))\n      return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (subjectId) {\n          if (objectId)\n            // If subject and object are given, the OSP index is best.\n            this._loopBy2Keys(content.objects, objectId, subjectId, callback);\n          else\n            // If only subject is given, the SPO index is best.\n            this._loopByKey0(content.subjects, subjectId, callback);\n        }\n        else if (objectId)\n          // If only object is given, the POS index is best.\n          this._loopByKey1(content.predicates, objectId, callback);\n        else\n          // If no params given, iterate all the predicates.\n          this._loop(content.predicates, callback);\n      }\n    }\n  }\n\n  // ### `getObjects` returns all objects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getObjects(subject, predicate, graph) {\n    const results = [];\n    this.forObjects(o => { results.push(o); }, subject, predicate, graph);\n    return results;\n  }\n\n  // ### `forObjects` executes the callback on all objects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forObjects(callback, subject, predicate, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    graph = graph && termToId(graph);\n\n    const ids = this._ids, graphs = this._getGraphs(graph);\n    let content, subjectId, predicateId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject)   && !(subjectId   = ids[subject]) ||\n        isString(predicate) && !(predicateId = ids[predicate]))\n      return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (subjectId) {\n          if (predicateId)\n            // If subject and predicate are given, the SPO index is best.\n            this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);\n          else\n            // If only subject is given, the OSP index is best.\n            this._loopByKey1(content.objects, subjectId, callback);\n        }\n        else if (predicateId)\n          // If only predicate is given, the POS index is best.\n          this._loopByKey0(content.predicates, predicateId, callback);\n        else\n          // If no params given, iterate all the objects.\n          this._loop(content.objects, callback);\n      }\n    }\n  }\n\n  // ### `getGraphs` returns all graphs that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getGraphs(subject, predicate, object) {\n    const results = [];\n    this.forGraphs(g => { results.push(g); }, subject, predicate, object);\n    return results;\n  }\n\n  // ### `forGraphs` executes the callback on all graphs that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forGraphs(callback, subject, predicate, object) {\n    for (const graph in this._graphs) {\n      this.some(quad => {\n        callback(quad.graph);\n        return true; // Halt iteration of some()\n      }, subject, predicate, object, graph);\n    }\n  }\n\n  // ### `createBlankNode` creates a new blank node, returning its name\n  createBlankNode(suggestedName) {\n    let name, index;\n    // Generate a name based on the suggested name\n    if (suggestedName) {\n      name = suggestedName = `_:${suggestedName}`, index = 1;\n      while (this._ids[name])\n        name = suggestedName + index++;\n    }\n    // Generate a generic blank node name\n    else {\n      do { name = `_:b${this._blankNodeIndex++}`; }\n      while (this._ids[name]);\n    }\n    // Add the blank node to the entities, avoiding the generation of duplicates\n    this._ids[name] = ++this._id;\n    this._entities[this._id] = name;\n    return this._factory.blankNode(name.substr(2));\n  }\n\n  // ### `extractLists` finds and removes all list triples\n  // and returns the items per list.\n  extractLists({ remove = false, ignoreErrors = false } = {}) {\n    const lists = {}; // has scalar keys so could be a simple Object\n    const onError = ignoreErrors ? (() => true) :\n                  ((node, message) => { throw new Error(`${node.value} ${message}`); });\n\n    // Traverse each list from its tail\n    const tails = this.getQuads(null, namespaces.rdf.rest, namespaces.rdf.nil, null);\n    const toRemove = remove ? [...tails] : [];\n    tails.forEach(tailQuad => {\n      const items = [];             // the members found as objects of rdf:first quads\n      let malformed = false;      // signals whether the current list is malformed\n      let head;                   // the head of the list (_:b1 in above example)\n      let headPos;                // set to subject or object when head is set\n      const graph = tailQuad.graph; // make sure list is in exactly one graph\n\n      // Traverse the list from tail to end\n      let current = tailQuad.subject;\n      while (current && !malformed) {\n        const objectQuads = this.getQuads(null, null, current, null);\n        const subjectQuads = this.getQuads(current, null, null, null);\n        let quad, first = null, rest = null, parent = null;\n\n        // Find the first and rest of this list node\n        for (let i = 0; i < subjectQuads.length && !malformed; i++) {\n          quad = subjectQuads[i];\n          if (!quad.graph.equals(graph))\n            malformed = onError(current, 'not confined to single graph');\n          else if (head)\n            malformed = onError(current, 'has non-list arcs out');\n\n          // one rdf:first\n          else if (quad.predicate.value === namespaces.rdf.first) {\n            if (first)\n              malformed = onError(current, 'has multiple rdf:first arcs');\n            else\n              toRemove.push(first = quad);\n          }\n\n          // one rdf:rest\n          else if (quad.predicate.value === namespaces.rdf.rest) {\n            if (rest)\n              malformed = onError(current, 'has multiple rdf:rest arcs');\n            else\n              toRemove.push(rest = quad);\n          }\n\n          // alien triple\n          else if (objectQuads.length)\n            malformed = onError(current, 'can\\'t be subject and object');\n          else {\n            head = quad; // e.g. { (1 2 3) :p :o }\n            headPos = 'subject';\n          }\n        }\n\n        // { :s :p (1 2) } arrives here with no head\n        // { (1 2) :p :o } arrives here with head set to the list.\n        for (let i = 0; i < objectQuads.length && !malformed; ++i) {\n          quad = objectQuads[i];\n          if (head)\n            malformed = onError(current, 'can\\'t have coreferences');\n          // one rdf:rest\n          else if (quad.predicate.value === namespaces.rdf.rest) {\n            if (parent)\n              malformed = onError(current, 'has incoming rdf:rest arcs');\n            else\n              parent = quad;\n          }\n          else {\n            head = quad; // e.g. { :s :p (1 2) }\n            headPos = 'object';\n          }\n        }\n\n        // Store the list item and continue with parent\n        if (!first)\n          malformed = onError(current, 'has no list head');\n        else\n          items.unshift(first.object);\n        current = parent && parent.subject;\n      }\n\n      // Don't remove any quads if the list is malformed\n      if (malformed)\n        remove = false;\n      // Store the list under the value of its head\n      else if (head)\n        lists[head[headPos].value] = items;\n    });\n\n    // Remove list quads if requested\n    if (remove)\n      this.removeQuads(toRemove);\n    return lists;\n  }\n\n  // ### Store is an iterable.\n  // Can be used where iterables are expected: for...of loops, array spread operator,\n  // `yield*`, and destructuring assignment (order is not guaranteed).\n  *[Symbol.iterator]() {\n    yield* this.readQuads();\n  }\n}\n\n// Determines whether the argument is a string\nfunction isString(s) {\n  return typeof s === 'string' || s instanceof String;\n}\n\n/**\n * A class that implements both DatasetCore and Readable.\n */\nclass DatasetCoreAndReadableStream extends Readable {\n  constructor(n3Store, subject, predicate, object, graph) {\n    super({ objectMode: true });\n    Object.assign(this, { n3Store, subject, predicate, object, graph });\n  }\n\n  get filtered() {\n    if (!this._filtered) {\n      const { n3Store, graph, object, predicate, subject } = this;\n      const newStore = this._filtered = new N3Store({ factory: n3Store._factory });\n      for (const quad of n3Store.readQuads(subject, predicate, object, graph))\n        newStore.addQuad(quad);\n    }\n    return this._filtered;\n  }\n\n  get size() {\n    return this.filtered.size;\n  }\n\n  _read() {\n    for (const quad of this)\n      this.push(quad);\n    this.push(null);\n  }\n\n  add(quad) {\n    return this.filtered.add(quad);\n  }\n\n  delete(quad) {\n    return this.filtered.delete(quad);\n  }\n\n  has(quad) {\n    return this.filtered.has(quad);\n  }\n\n  match(subject, predicate, object, graph) {\n    return new DatasetCoreAndReadableStream(this.filtered, subject, predicate, object, graph);\n  }\n\n  *[Symbol.iterator]() {\n    yield* this._filtered || this.n3Store.readQuads(this.subject, this.predicate, this.object, this.graph);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}