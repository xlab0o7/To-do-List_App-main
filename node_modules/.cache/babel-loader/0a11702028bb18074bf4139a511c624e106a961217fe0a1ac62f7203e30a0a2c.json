{"ast":null,"code":"/*!\n * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _createForOfIteratorHelper = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _asyncToGenerator = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _inherits = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar MessageDigest = require('./MessageDigest');\nvar URDNA2015 = require('./URDNA2015');\nmodule.exports = /*#__PURE__*/function (_URDNA) {\n  _inherits(URDNA2012, _URDNA);\n  var _super = _createSuper(URDNA2012);\n  function URDNA2012() {\n    var _this;\n    _classCallCheck(this, URDNA2012);\n    _this = _super.call(this);\n    _this.name = 'URGNA2012';\n    _this.createMessageDigest = function () {\n      return new MessageDigest('sha1');\n    };\n    return _this;\n  }\n\n  // helper for modifying component during Hash First Degree Quads\n  _createClass(URDNA2012, [{\n    key: \"modifyFirstDegreeComponent\",\n    value: function modifyFirstDegreeComponent(id, component, key) {\n      if (component.termType !== 'BlankNode') {\n        return component;\n      }\n      if (key === 'graph') {\n        return {\n          termType: 'BlankNode',\n          value: '_:g'\n        };\n      }\n      return {\n        termType: 'BlankNode',\n        value: component.value === id ? '_:a' : '_:z'\n      };\n    }\n\n    // helper for getting a related predicate\n  }, {\n    key: \"getRelatedPredicate\",\n    value: function getRelatedPredicate(quad) {\n      return quad.predicate.value;\n    }\n\n    // helper for creating hash to related blank nodes map\n  }, {\n    key: \"createHashToRelated\",\n    value: function () {\n      var _createHashToRelated = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(id, issuer) {\n        var hashToRelated, quads, i, _iterator, _step, quad, position, related, hash, entries;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              // 1) Create a hash to related blank nodes map for storing hashes that\n              // identify related blank nodes.\n              hashToRelated = new Map(); // 2) Get a reference, quads, to the list of quads in the blank node to\n              // quads map for the key identifier.\n              quads = this.blankNodeInfo.get(id).quads; // 3) For each quad in quads:\n              i = 0;\n              _iterator = _createForOfIteratorHelper(quads);\n              _context.prev = 4;\n              _iterator.s();\n            case 6:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 31;\n                break;\n              }\n              quad = _step.value;\n              // 3.1) If the quad's subject is a blank node that does not match\n              // identifier, set hash to the result of the Hash Related Blank Node\n              // algorithm, passing the blank node identifier for subject as related,\n              // quad, path identifier issuer as issuer, and p as position.\n              position = void 0;\n              related = void 0;\n              if (!(quad.subject.termType === 'BlankNode' && quad.subject.value !== id)) {\n                _context.next = 15;\n                break;\n              }\n              related = quad.subject.value;\n              position = 'p';\n              _context.next = 21;\n              break;\n            case 15:\n              if (!(quad.object.termType === 'BlankNode' && quad.object.value !== id)) {\n                _context.next = 20;\n                break;\n              }\n              // 3.2) Otherwise, if quad's object is a blank node that does not match\n              // identifier, to the result of the Hash Related Blank Node algorithm,\n              // passing the blank node identifier for object as related, quad, path\n              // identifier issuer as issuer, and r as position.\n              related = quad.object.value;\n              position = 'r';\n              _context.next = 21;\n              break;\n            case 20:\n              return _context.abrupt(\"continue\", 29);\n            case 21:\n              if (!(++i % 100 === 0)) {\n                _context.next = 24;\n                break;\n              }\n              _context.next = 24;\n              return this._yield();\n            case 24:\n              _context.next = 26;\n              return this.hashRelatedBlankNode(related, quad, issuer, position);\n            case 26:\n              hash = _context.sent;\n              entries = hashToRelated.get(hash);\n              if (entries) {\n                entries.push(related);\n              } else {\n                hashToRelated.set(hash, [related]);\n              }\n            case 29:\n              _context.next = 6;\n              break;\n            case 31:\n              _context.next = 36;\n              break;\n            case 33:\n              _context.prev = 33;\n              _context.t0 = _context[\"catch\"](4);\n              _iterator.e(_context.t0);\n            case 36:\n              _context.prev = 36;\n              _iterator.f();\n              return _context.finish(36);\n            case 39:\n              return _context.abrupt(\"return\", hashToRelated);\n            case 40:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[4, 33, 36, 39]]);\n      }));\n      function createHashToRelated(_x, _x2) {\n        return _createHashToRelated.apply(this, arguments);\n      }\n      return createHashToRelated;\n    }()\n  }]);\n  return URDNA2012;\n}(URDNA2015);","map":{"version":3,"names":["MessageDigest","require","URDNA2015","module","exports","name","createMessageDigest","id","component","key","termType","value","quad","predicate","issuer","hashToRelated","Map","quads","blankNodeInfo","get","i","position","related","subject","object","_yield","hashRelatedBlankNode","hash","entries","push","set"],"sources":["E:/react-todo-app/node_modules/rdf-canonize/lib/URGNA2012.js"],"sourcesContent":["/*!\n * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst MessageDigest = require('./MessageDigest');\nconst URDNA2015 = require('./URDNA2015');\n\nmodule.exports = class URDNA2012 extends URDNA2015 {\n  constructor() {\n    super();\n    this.name = 'URGNA2012';\n    this.createMessageDigest = () => new MessageDigest('sha1');\n  }\n\n  // helper for modifying component during Hash First Degree Quads\n  modifyFirstDegreeComponent(id, component, key) {\n    if(component.termType !== 'BlankNode') {\n      return component;\n    }\n    if(key === 'graph') {\n      return {\n        termType: 'BlankNode',\n        value: '_:g'\n      };\n    }\n    return {\n      termType: 'BlankNode',\n      value: (component.value === id ? '_:a' : '_:z')\n    };\n  }\n\n  // helper for getting a related predicate\n  getRelatedPredicate(quad) {\n    return quad.predicate.value;\n  }\n\n  // helper for creating hash to related blank nodes map\n  async createHashToRelated(id, issuer) {\n    // 1) Create a hash to related blank nodes map for storing hashes that\n    // identify related blank nodes.\n    const hashToRelated = new Map();\n\n    // 2) Get a reference, quads, to the list of quads in the blank node to\n    // quads map for the key identifier.\n    const quads = this.blankNodeInfo.get(id).quads;\n\n    // 3) For each quad in quads:\n    let i = 0;\n    for(const quad of quads) {\n      // 3.1) If the quad's subject is a blank node that does not match\n      // identifier, set hash to the result of the Hash Related Blank Node\n      // algorithm, passing the blank node identifier for subject as related,\n      // quad, path identifier issuer as issuer, and p as position.\n      let position;\n      let related;\n      if(quad.subject.termType === 'BlankNode' && quad.subject.value !== id) {\n        related = quad.subject.value;\n        position = 'p';\n      } else if(\n        quad.object.termType === 'BlankNode' && quad.object.value !== id) {\n        // 3.2) Otherwise, if quad's object is a blank node that does not match\n        // identifier, to the result of the Hash Related Blank Node algorithm,\n        // passing the blank node identifier for object as related, quad, path\n        // identifier issuer as issuer, and r as position.\n        related = quad.object.value;\n        position = 'r';\n      } else {\n        // 3.3) Otherwise, continue to the next quad.\n        continue;\n      }\n      // Note: batch hashing related blank nodes 100 at a time\n      if(++i % 100 === 0) {\n        await this._yield();\n      }\n      // 3.4) Add a mapping of hash to the blank node identifier for the\n      // component that matched (subject or object) to hash to related blank\n      // nodes map, adding an entry as necessary.\n      const hash = await this.hashRelatedBlankNode(\n        related, quad, issuer, position);\n      const entries = hashToRelated.get(hash);\n      if(entries) {\n        entries.push(related);\n      } else {\n        hashToRelated.set(hash, [related]);\n      }\n    }\n\n    return hashToRelated;\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}