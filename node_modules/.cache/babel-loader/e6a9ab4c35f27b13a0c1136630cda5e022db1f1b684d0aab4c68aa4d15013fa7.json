{"ast":null,"code":"/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _toConsumableArray = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _regeneratorRuntime = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _slicedToArray = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _asyncToGenerator = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar util = require('./util');\nvar JsonLdError = require('./JsonLdError');\nvar _require = require('./types'),\n  _isArray = _require.isArray,\n  _isObject = _require.isObject,\n  _isString = _require.isString,\n  _isUndefined = _require.isUndefined;\nvar _require2 = require('./url'),\n  _isAbsoluteIri = _require2.isAbsolute,\n  _isRelativeIri = _require2.isRelative,\n  prependBase = _require2.prependBase;\nvar _require3 = require('./util'),\n  _asArray = _require3.asArray,\n  _compareShortestLeast = _require3.compareShortestLeast;\nvar INITIAL_CONTEXT_CACHE = new Map();\nvar INITIAL_CONTEXT_CACHE_MAX_SIZE = 10000;\nvar KEYWORD_PATTERN = /^@[a-zA-Z]+$/;\nvar api = {};\nmodule.exports = api;\n\n/**\n * Processes a local context and returns a new active context.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context to process.\n * @param options the context processing options.\n * @param propagate `true` if `false`, retains any previously defined term,\n *   which can be rolled back when the descending into a new node object.\n * @param overrideProtected `false` allows protected terms to be modified.\n *\n * @return a Promise that resolves to the new active context.\n */\napi.process = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {\n    var activeCtx, localCtx, options, _ref$propagate, propagate, _ref$overrideProtecte, overrideProtected, _ref$cycles, cycles, ctxs, resolved, rval, _iterator, _step, resolvedContext, ctx, protectedMode, _processed, oldActiveCtx, _i, _Object$entries, _Object$entries$_i, term, _protected, processed, defined, base, value, _value, _value2, _value3, _value4, resolvedImport, processedImport, importCtx, key, _key, keyCtx, process, url;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          activeCtx = _ref.activeCtx, localCtx = _ref.localCtx, options = _ref.options, _ref$propagate = _ref.propagate, propagate = _ref$propagate === void 0 ? true : _ref$propagate, _ref$overrideProtecte = _ref.overrideProtected, overrideProtected = _ref$overrideProtecte === void 0 ? false : _ref$overrideProtecte, _ref$cycles = _ref.cycles, cycles = _ref$cycles === void 0 ? new Set() : _ref$cycles;\n          // normalize local context to an array of @context objects\n          if (_isObject(localCtx) && '@context' in localCtx && _isArray(localCtx['@context'])) {\n            localCtx = localCtx['@context'];\n          }\n          ctxs = _asArray(localCtx); // no contexts in array, return current active context w/o changes\n          if (!(ctxs.length === 0)) {\n            _context.next = 5;\n            break;\n          }\n          return _context.abrupt(\"return\", activeCtx);\n        case 5:\n          _context.next = 7;\n          return options.contextResolver.resolve({\n            activeCtx: activeCtx,\n            context: localCtx,\n            documentLoader: options.documentLoader,\n            base: options.base\n          });\n        case 7:\n          resolved = _context.sent;\n          // override propagate if first resolved context has `@propagate`\n          if (_isObject(resolved[0].document) && typeof resolved[0].document['@propagate'] === 'boolean') {\n            // retrieve early, error checking done later\n            propagate = resolved[0].document['@propagate'];\n          }\n\n          // process each context in order, update active context\n          // on each iteration to ensure proper caching\n          rval = activeCtx; // track the previous context\n          // if not propagating, make sure rval has a previous context\n          if (!propagate && !rval.previousContext) {\n            // clone `rval` context before updating\n            rval = rval.clone();\n            rval.previousContext = activeCtx;\n          }\n          _iterator = _createForOfIteratorHelper(resolved);\n          _context.prev = 12;\n          _iterator.s();\n        case 14:\n          if ((_step = _iterator.n()).done) {\n            _context.next = 164;\n            break;\n          }\n          resolvedContext = _step.value;\n          ctx = resolvedContext.document; // update active context to one computed from last iteration\n          activeCtx = rval;\n\n          // reset to initial context\n          if (!(ctx === null)) {\n            _context.next = 40;\n            break;\n          }\n          if (!(!overrideProtected && Object.keys(activeCtx.protected).length !== 0)) {\n            _context.next = 38;\n            break;\n          }\n          protectedMode = options && options.protectedMode || 'error';\n          if (!(protectedMode === 'error')) {\n            _context.next = 25;\n            break;\n          }\n          throw new JsonLdError('Tried to nullify a context with protected terms outside of ' + 'a term definition.', 'jsonld.SyntaxError', {\n            code: 'invalid context nullification'\n          });\n        case 25:\n          if (!(protectedMode === 'warn')) {\n            _context.next = 37;\n            break;\n          }\n          // FIXME: remove logging and use a handler\n          console.warn('WARNING: invalid context nullification');\n\n          // get processed context from cache if available\n          _processed = resolvedContext.getProcessed(activeCtx);\n          if (!_processed) {\n            _context.next = 31;\n            break;\n          }\n          rval = activeCtx = _processed;\n          return _context.abrupt(\"continue\", 162);\n        case 31:\n          oldActiveCtx = activeCtx; // copy all protected term definitions to fresh initial context\n          rval = activeCtx = api.getInitialContext(options).clone();\n          for (_i = 0, _Object$entries = Object.entries(oldActiveCtx.protected); _i < _Object$entries.length; _i++) {\n            _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), term = _Object$entries$_i[0], _protected = _Object$entries$_i[1];\n            if (_protected) {\n              activeCtx.mappings[term] = util.clone(oldActiveCtx.mappings[term]);\n            }\n          }\n          activeCtx.protected = util.clone(oldActiveCtx.protected);\n\n          // cache processed result\n          resolvedContext.setProcessed(oldActiveCtx, rval);\n          return _context.abrupt(\"continue\", 162);\n        case 37:\n          throw new JsonLdError('Invalid protectedMode.', 'jsonld.SyntaxError', {\n            code: 'invalid protected mode',\n            context: localCtx,\n            protectedMode: protectedMode\n          });\n        case 38:\n          rval = activeCtx = api.getInitialContext(options).clone();\n          return _context.abrupt(\"continue\", 162);\n        case 40:\n          // get processed context from cache if available\n          processed = resolvedContext.getProcessed(activeCtx);\n          if (!processed) {\n            _context.next = 44;\n            break;\n          }\n          rval = activeCtx = processed;\n          return _context.abrupt(\"continue\", 162);\n        case 44:\n          // dereference @context key if present\n          if (_isObject(ctx) && '@context' in ctx) {\n            ctx = ctx['@context'];\n          }\n\n          // context must be an object by now, all URLs retrieved before this call\n          if (_isObject(ctx)) {\n            _context.next = 47;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; @context must be an object.', 'jsonld.SyntaxError', {\n            code: 'invalid local context',\n            context: ctx\n          });\n        case 47:\n          // TODO: there is likely a `previousContext` cloning optimization that\n          // could be applied here (no need to copy it under certain conditions)\n\n          // clone context before updating it\n          rval = rval.clone();\n\n          // define context mappings for keys in local context\n          defined = new Map(); // handle @version\n          if (!('@version' in ctx)) {\n            _context.next = 57;\n            break;\n          }\n          if (!(ctx['@version'] !== 1.1)) {\n            _context.next = 52;\n            break;\n          }\n          throw new JsonLdError('Unsupported JSON-LD version: ' + ctx['@version'], 'jsonld.UnsupportedVersion', {\n            code: 'invalid @version value',\n            context: ctx\n          });\n        case 52:\n          if (!(activeCtx.processingMode && activeCtx.processingMode === 'json-ld-1.0')) {\n            _context.next = 54;\n            break;\n          }\n          throw new JsonLdError('@version: ' + ctx['@version'] + ' not compatible with ' + activeCtx.processingMode, 'jsonld.ProcessingModeConflict', {\n            code: 'processing mode conflict',\n            context: ctx\n          });\n        case 54:\n          rval.processingMode = 'json-ld-1.1';\n          rval['@version'] = ctx['@version'];\n          defined.set('@version', true);\n        case 57:\n          // if not set explicitly, set processingMode to \"json-ld-1.1\"\n          rval.processingMode = rval.processingMode || activeCtx.processingMode;\n\n          // handle @base\n          if (!('@base' in ctx)) {\n            _context.next = 70;\n            break;\n          }\n          base = ctx['@base'];\n          if (!(base === null || _isAbsoluteIri(base))) {\n            _context.next = 63;\n            break;\n          }\n          _context.next = 68;\n          break;\n        case 63:\n          if (!_isRelativeIri(base)) {\n            _context.next = 67;\n            break;\n          }\n          base = prependBase(rval['@base'], base);\n          _context.next = 68;\n          break;\n        case 67:\n          throw new JsonLdError('Invalid JSON-LD syntax; the value of \"@base\" in a ' + '@context must be an absolute IRI, a relative IRI, or null.', 'jsonld.SyntaxError', {\n            code: 'invalid base IRI',\n            context: ctx\n          });\n        case 68:\n          rval['@base'] = base;\n          defined.set('@base', true);\n        case 70:\n          if (!('@vocab' in ctx)) {\n            _context.next = 86;\n            break;\n          }\n          value = ctx['@vocab'];\n          if (!(value === null)) {\n            _context.next = 76;\n            break;\n          }\n          delete rval['@vocab'];\n          _context.next = 85;\n          break;\n        case 76:\n          if (_isString(value)) {\n            _context.next = 80;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; the value of \"@vocab\" in a ' + '@context must be a string or null.', 'jsonld.SyntaxError', {\n            code: 'invalid vocab mapping',\n            context: ctx\n          });\n        case 80:\n          if (!(!_isAbsoluteIri(value) && api.processingMode(rval, 1.0))) {\n            _context.next = 84;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; the value of \"@vocab\" in a ' + '@context must be an absolute IRI.', 'jsonld.SyntaxError', {\n            code: 'invalid vocab mapping',\n            context: ctx\n          });\n        case 84:\n          rval['@vocab'] = _expandIri(rval, value, {\n            vocab: true,\n            base: true\n          }, undefined, undefined, options);\n        case 85:\n          defined.set('@vocab', true);\n        case 86:\n          if (!('@language' in ctx)) {\n            _context.next = 98;\n            break;\n          }\n          _value = ctx['@language'];\n          if (!(_value === null)) {\n            _context.next = 92;\n            break;\n          }\n          delete rval['@language'];\n          _context.next = 97;\n          break;\n        case 92:\n          if (_isString(_value)) {\n            _context.next = 96;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; the value of \"@language\" in a ' + '@context must be a string or null.', 'jsonld.SyntaxError', {\n            code: 'invalid default language',\n            context: ctx\n          });\n        case 96:\n          rval['@language'] = _value.toLowerCase();\n        case 97:\n          defined.set('@language', true);\n        case 98:\n          if (!('@direction' in ctx)) {\n            _context.next = 112;\n            break;\n          }\n          _value2 = ctx['@direction'];\n          if (!(activeCtx.processingMode === 'json-ld-1.0')) {\n            _context.next = 102;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; @direction not compatible with ' + activeCtx.processingMode, 'jsonld.SyntaxError', {\n            code: 'invalid context member',\n            context: ctx\n          });\n        case 102:\n          if (!(_value2 === null)) {\n            _context.next = 106;\n            break;\n          }\n          delete rval['@direction'];\n          _context.next = 111;\n          break;\n        case 106:\n          if (!(_value2 !== 'ltr' && _value2 !== 'rtl')) {\n            _context.next = 110;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; the value of \"@direction\" in a ' + '@context must be null, \"ltr\", or \"rtl\".', 'jsonld.SyntaxError', {\n            code: 'invalid base direction',\n            context: ctx\n          });\n        case 110:\n          rval['@direction'] = _value2;\n        case 111:\n          defined.set('@direction', true);\n        case 112:\n          if (!('@propagate' in ctx)) {\n            _context.next = 119;\n            break;\n          }\n          _value3 = ctx['@propagate'];\n          if (!(activeCtx.processingMode === 'json-ld-1.0')) {\n            _context.next = 116;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; @propagate not compatible with ' + activeCtx.processingMode, 'jsonld.SyntaxError', {\n            code: 'invalid context entry',\n            context: ctx\n          });\n        case 116:\n          if (!(typeof _value3 !== 'boolean')) {\n            _context.next = 118;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; @propagate value must be a boolean.', 'jsonld.SyntaxError', {\n            code: 'invalid @propagate value',\n            context: localCtx\n          });\n        case 118:\n          defined.set('@propagate', true);\n        case 119:\n          if (!('@import' in ctx)) {\n            _context.next = 141;\n            break;\n          }\n          _value4 = ctx['@import'];\n          if (!(activeCtx.processingMode === 'json-ld-1.0')) {\n            _context.next = 123;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; @import not compatible with ' + activeCtx.processingMode, 'jsonld.SyntaxError', {\n            code: 'invalid context entry',\n            context: ctx\n          });\n        case 123:\n          if (_isString(_value4)) {\n            _context.next = 125;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; @import must be a string.', 'jsonld.SyntaxError', {\n            code: 'invalid @import value',\n            context: localCtx\n          });\n        case 125:\n          _context.next = 127;\n          return options.contextResolver.resolve({\n            activeCtx: activeCtx,\n            context: _value4,\n            documentLoader: options.documentLoader,\n            base: options.base\n          });\n        case 127:\n          resolvedImport = _context.sent;\n          if (!(resolvedImport.length !== 1)) {\n            _context.next = 130;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; @import must reference a single context.', 'jsonld.SyntaxError', {\n            code: 'invalid remote context',\n            context: localCtx\n          });\n        case 130:\n          processedImport = resolvedImport[0].getProcessed(activeCtx);\n          if (!processedImport) {\n            _context.next = 135;\n            break;\n          }\n          // Note: if the same context were used in this active context\n          // as a reference context, then processed_input might not\n          // be a dict.\n          ctx = processedImport;\n          _context.next = 140;\n          break;\n        case 135:\n          importCtx = resolvedImport[0].document;\n          if (!('@import' in importCtx)) {\n            _context.next = 138;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax: ' + 'imported context must not include @import.', 'jsonld.SyntaxError', {\n            code: 'invalid context entry',\n            context: localCtx\n          });\n        case 138:\n          // merge ctx into importCtx and replace rval with the result\n          for (key in importCtx) {\n            if (!ctx.hasOwnProperty(key)) {\n              ctx[key] = importCtx[key];\n            }\n          }\n\n          // Note: this could potenially conflict if the import\n          // were used in the same active context as a referenced\n          // context and an import. In this case, we\n          // could override the cached result, but seems unlikely.\n          resolvedImport[0].setProcessed(activeCtx, ctx);\n        case 140:\n          defined.set('@import', true);\n        case 141:\n          // handle @protected; determine whether this sub-context is declaring\n          // all its terms to be \"protected\" (exceptions can be made on a\n          // per-definition basis)\n          defined.set('@protected', ctx['@protected'] || false);\n\n          // process all other keys\n          _context.t0 = _regeneratorRuntime().keys(ctx);\n        case 143:\n          if ((_context.t1 = _context.t0()).done) {\n            _context.next = 161;\n            break;\n          }\n          _key = _context.t1.value;\n          api.createTermDefinition({\n            activeCtx: rval,\n            localCtx: ctx,\n            term: _key,\n            defined: defined,\n            options: options,\n            overrideProtected: overrideProtected\n          });\n          if (!(_isObject(ctx[_key]) && '@context' in ctx[_key])) {\n            _context.next = 159;\n            break;\n          }\n          keyCtx = ctx[_key]['@context'];\n          process = true;\n          if (_isString(keyCtx)) {\n            url = prependBase(options.base, keyCtx); // track processed contexts to avoid scoped context recursion\n            if (cycles.has(url)) {\n              process = false;\n            } else {\n              cycles.add(url);\n            }\n          }\n          // parse context to validate\n          if (!process) {\n            _context.next = 159;\n            break;\n          }\n          _context.prev = 151;\n          _context.next = 154;\n          return api.process({\n            activeCtx: rval.clone(),\n            localCtx: ctx[_key]['@context'],\n            overrideProtected: true,\n            options: options,\n            cycles: cycles\n          });\n        case 154:\n          _context.next = 159;\n          break;\n        case 156:\n          _context.prev = 156;\n          _context.t2 = _context[\"catch\"](151);\n          throw new JsonLdError('Invalid JSON-LD syntax; invalid scoped context.', 'jsonld.SyntaxError', {\n            code: 'invalid scoped context',\n            context: ctx[_key]['@context'],\n            term: _key\n          });\n        case 159:\n          _context.next = 143;\n          break;\n        case 161:\n          // cache processed result\n          resolvedContext.setProcessed(activeCtx, rval);\n        case 162:\n          _context.next = 14;\n          break;\n        case 164:\n          _context.next = 169;\n          break;\n        case 166:\n          _context.prev = 166;\n          _context.t3 = _context[\"catch\"](12);\n          _iterator.e(_context.t3);\n        case 169:\n          _context.prev = 169;\n          _iterator.f();\n          return _context.finish(169);\n        case 172:\n          return _context.abrupt(\"return\", rval);\n        case 173:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[12, 166, 169, 172], [151, 156]]);\n  }));\n  return function (_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * Creates a term definition during context processing.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context being processed.\n * @param term the term in the local context to define the mapping for.\n * @param defined a map of defining/defined keys to detect cycles and prevent\n *          double definitions.\n * @param {Object} [options] - creation options.\n * @param {string} [options.protectedMode=\"error\"] - \"error\" to throw error\n *   on `@protected` constraint violation, \"warn\" to allow violations and\n *   signal a warning.\n * @param overrideProtected `false` allows protected terms to be modified.\n */\napi.createTermDefinition = function (_ref3) {\n  var activeCtx = _ref3.activeCtx,\n    localCtx = _ref3.localCtx,\n    term = _ref3.term,\n    defined = _ref3.defined,\n    options = _ref3.options,\n    _ref3$overrideProtect = _ref3.overrideProtected,\n    overrideProtected = _ref3$overrideProtect === void 0 ? false : _ref3$overrideProtect;\n  if (defined.has(term)) {\n    // term already defined\n    if (defined.get(term)) {\n      return;\n    }\n    // cycle detected\n    throw new JsonLdError('Cyclical context definition detected.', 'jsonld.CyclicalContext', {\n      code: 'cyclic IRI mapping',\n      context: localCtx,\n      term: term\n    });\n  }\n\n  // now defining term\n  defined.set(term, false);\n\n  // get context term value\n  var value;\n  if (localCtx.hasOwnProperty(term)) {\n    value = localCtx[term];\n  }\n  if (term === '@type' && _isObject(value) && (value['@container'] || '@set') === '@set' && api.processingMode(activeCtx, 1.1)) {\n    var _validKeys = ['@container', '@id', '@protected'];\n    var keys = Object.keys(value);\n    if (keys.length === 0 || keys.some(function (k) {\n      return !_validKeys.includes(k);\n    })) {\n      throw new JsonLdError('Invalid JSON-LD syntax; keywords cannot be overridden.', 'jsonld.SyntaxError', {\n        code: 'keyword redefinition',\n        context: localCtx,\n        term: term\n      });\n    }\n  } else if (api.isKeyword(term)) {\n    throw new JsonLdError('Invalid JSON-LD syntax; keywords cannot be overridden.', 'jsonld.SyntaxError', {\n      code: 'keyword redefinition',\n      context: localCtx,\n      term: term\n    });\n  } else if (term.match(KEYWORD_PATTERN)) {\n    // FIXME: remove logging and use a handler\n    console.warn('WARNING: terms beginning with \"@\" are reserved' + ' for future use and ignored', {\n      term: term\n    });\n    return;\n  } else if (term === '') {\n    throw new JsonLdError('Invalid JSON-LD syntax; a term cannot be an empty string.', 'jsonld.SyntaxError', {\n      code: 'invalid term definition',\n      context: localCtx\n    });\n  }\n\n  // keep reference to previous mapping for potential `@protected` check\n  var previousMapping = activeCtx.mappings.get(term);\n\n  // remove old mapping\n  if (activeCtx.mappings.has(term)) {\n    activeCtx.mappings.delete(term);\n  }\n\n  // convert short-hand value to object w/@id\n  var simpleTerm = false;\n  if (_isString(value) || value === null) {\n    simpleTerm = true;\n    value = {\n      '@id': value\n    };\n  }\n  if (!_isObject(value)) {\n    throw new JsonLdError('Invalid JSON-LD syntax; @context term values must be ' + 'strings or objects.', 'jsonld.SyntaxError', {\n      code: 'invalid term definition',\n      context: localCtx\n    });\n  }\n\n  // create new mapping\n  var mapping = {};\n  activeCtx.mappings.set(term, mapping);\n  mapping.reverse = false;\n\n  // make sure term definition only has expected keywords\n  var validKeys = ['@container', '@id', '@language', '@reverse', '@type'];\n\n  // JSON-LD 1.1 support\n  if (api.processingMode(activeCtx, 1.1)) {\n    validKeys.push('@context', '@direction', '@index', '@nest', '@prefix', '@protected');\n  }\n  for (var kw in value) {\n    if (!validKeys.includes(kw)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a term definition must not contain ' + kw, 'jsonld.SyntaxError', {\n        code: 'invalid term definition',\n        context: localCtx\n      });\n    }\n  }\n\n  // always compute whether term has a colon as an optimization for\n  // _compactIri\n  var colon = term.indexOf(':');\n  mapping._termHasColon = colon > 0;\n  if ('@reverse' in value) {\n    if ('@id' in value) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a @reverse term definition must not ' + 'contain @id.', 'jsonld.SyntaxError', {\n        code: 'invalid reverse property',\n        context: localCtx\n      });\n    }\n    if ('@nest' in value) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a @reverse term definition must not ' + 'contain @nest.', 'jsonld.SyntaxError', {\n        code: 'invalid reverse property',\n        context: localCtx\n      });\n    }\n    var reverse = value['@reverse'];\n    if (!_isString(reverse)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a @context @reverse value must be a string.', 'jsonld.SyntaxError', {\n        code: 'invalid IRI mapping',\n        context: localCtx\n      });\n    }\n    if (!api.isKeyword(reverse) && reverse.match(KEYWORD_PATTERN)) {\n      // FIXME: remove logging and use a handler\n      console.warn('WARNING: values beginning with \"@\" are reserved' + ' for future use and ignored', {\n        reverse: reverse\n      });\n      if (previousMapping) {\n        activeCtx.mappings.set(term, previousMapping);\n      } else {\n        activeCtx.mappings.delete(term);\n      }\n      return;\n    }\n\n    // expand and add @id mapping\n    var _id = _expandIri(activeCtx, reverse, {\n      vocab: true,\n      base: false\n    }, localCtx, defined, options);\n    if (!_isAbsoluteIri(_id)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a @context @reverse value must be an ' + 'absolute IRI or a blank node identifier.', 'jsonld.SyntaxError', {\n        code: 'invalid IRI mapping',\n        context: localCtx\n      });\n    }\n    mapping['@id'] = _id;\n    mapping.reverse = true;\n  } else if ('@id' in value) {\n    var _id2 = value['@id'];\n    if (_id2 && !_isString(_id2)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; a @context @id value must be an array ' + 'of strings or a string.', 'jsonld.SyntaxError', {\n        code: 'invalid IRI mapping',\n        context: localCtx\n      });\n    }\n    if (_id2 === null) {\n      // reserve a null term, which may be protected\n      mapping['@id'] = null;\n    } else if (!api.isKeyword(_id2) && _id2.match(KEYWORD_PATTERN)) {\n      // FIXME: remove logging and use a handler\n      console.warn('WARNING: values beginning with \"@\" are reserved' + ' for future use and ignored', {\n        id: _id2\n      });\n      if (previousMapping) {\n        activeCtx.mappings.set(term, previousMapping);\n      } else {\n        activeCtx.mappings.delete(term);\n      }\n      return;\n    } else if (_id2 !== term) {\n      // expand and add @id mapping\n      _id2 = _expandIri(activeCtx, _id2, {\n        vocab: true,\n        base: false\n      }, localCtx, defined, options);\n      if (!_isAbsoluteIri(_id2) && !api.isKeyword(_id2)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; a @context @id value must be an ' + 'absolute IRI, a blank node identifier, or a keyword.', 'jsonld.SyntaxError', {\n          code: 'invalid IRI mapping',\n          context: localCtx\n        });\n      }\n\n      // if term has the form of an IRI it must map the same\n      if (term.match(/(?::[^:])|\\//)) {\n        var termDefined = new Map(defined).set(term, true);\n        var termIri = _expandIri(activeCtx, term, {\n          vocab: true,\n          base: false\n        }, localCtx, termDefined, options);\n        if (termIri !== _id2) {\n          throw new JsonLdError('Invalid JSON-LD syntax; term in form of IRI must ' + 'expand to definition.', 'jsonld.SyntaxError', {\n            code: 'invalid IRI mapping',\n            context: localCtx\n          });\n        }\n      }\n      mapping['@id'] = _id2;\n      // indicate if this term may be used as a compact IRI prefix\n      mapping._prefix = simpleTerm && !mapping._termHasColon && _id2.match(/[:\\/\\?#\\[\\]@]$/);\n    }\n  }\n  if (!('@id' in mapping)) {\n    // see if the term has a prefix\n    if (mapping._termHasColon) {\n      var prefix = term.substr(0, colon);\n      if (localCtx.hasOwnProperty(prefix)) {\n        // define parent prefix\n        api.createTermDefinition({\n          activeCtx: activeCtx,\n          localCtx: localCtx,\n          term: prefix,\n          defined: defined,\n          options: options\n        });\n      }\n      if (activeCtx.mappings.has(prefix)) {\n        // set @id based on prefix parent\n        var suffix = term.substr(colon + 1);\n        mapping['@id'] = activeCtx.mappings.get(prefix)['@id'] + suffix;\n      } else {\n        // term is an absolute IRI\n        mapping['@id'] = term;\n      }\n    } else if (term === '@type') {\n      // Special case, were we've previously determined that container is @set\n      mapping['@id'] = term;\n    } else {\n      // non-IRIs *must* define @ids if @vocab is not available\n      if (!('@vocab' in activeCtx)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; @context terms must define an @id.', 'jsonld.SyntaxError', {\n          code: 'invalid IRI mapping',\n          context: localCtx,\n          term: term\n        });\n      }\n      // prepend vocab to term\n      mapping['@id'] = activeCtx['@vocab'] + term;\n    }\n  }\n\n  // Handle term protection\n  if (value['@protected'] === true || defined.get('@protected') === true && value['@protected'] !== false) {\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n  }\n\n  // IRI mapping now defined\n  defined.set(term, true);\n  if ('@type' in value) {\n    var type = value['@type'];\n    if (!_isString(type)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must be a string.', 'jsonld.SyntaxError', {\n        code: 'invalid type mapping',\n        context: localCtx\n      });\n    }\n    if (type === '@json' || type === '@none') {\n      if (api.processingMode(activeCtx, 1.0)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must not be ' + \"\\\"\".concat(type, \"\\\" in JSON-LD 1.0 mode.\"), 'jsonld.SyntaxError', {\n          code: 'invalid type mapping',\n          context: localCtx\n        });\n      }\n    } else if (type !== '@id' && type !== '@vocab') {\n      // expand @type to full IRI\n      type = _expandIri(activeCtx, type, {\n        vocab: true,\n        base: false\n      }, localCtx, defined, options);\n      if (!_isAbsoluteIri(type)) {\n        throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must be an ' + 'absolute IRI.', 'jsonld.SyntaxError', {\n          code: 'invalid type mapping',\n          context: localCtx\n        });\n      }\n      if (type.indexOf('_:') === 0) {\n        throw new JsonLdError('Invalid JSON-LD syntax; an @context @type value must be an IRI, ' + 'not a blank node identifier.', 'jsonld.SyntaxError', {\n          code: 'invalid type mapping',\n          context: localCtx\n        });\n      }\n    }\n\n    // add @type to mapping\n    mapping['@type'] = type;\n  }\n  if ('@container' in value) {\n    // normalize container to an array form\n    var container = _isString(value['@container']) ? [value['@container']] : value['@container'] || [];\n    var validContainers = ['@list', '@set', '@index', '@language'];\n    var isValid = true;\n    var hasSet = container.includes('@set');\n\n    // JSON-LD 1.1 support\n    if (api.processingMode(activeCtx, 1.1)) {\n      validContainers.push('@graph', '@id', '@type');\n\n      // check container length\n      if (container.includes('@list')) {\n        if (container.length !== 1) {\n          throw new JsonLdError('Invalid JSON-LD syntax; @context @container with @list must ' + 'have no other values', 'jsonld.SyntaxError', {\n            code: 'invalid container mapping',\n            context: localCtx\n          });\n        }\n      } else if (container.includes('@graph')) {\n        if (container.some(function (key) {\n          return key !== '@graph' && key !== '@id' && key !== '@index' && key !== '@set';\n        })) {\n          throw new JsonLdError('Invalid JSON-LD syntax; @context @container with @graph must ' + 'have no other values other than @id, @index, and @set', 'jsonld.SyntaxError', {\n            code: 'invalid container mapping',\n            context: localCtx\n          });\n        }\n      } else {\n        // otherwise, container may also include @set\n        isValid &= container.length <= (hasSet ? 2 : 1);\n      }\n      if (container.includes('@type')) {\n        // If mapping does not have an @type,\n        // set it to @id\n        mapping['@type'] = mapping['@type'] || '@id';\n\n        // type mapping must be either @id or @vocab\n        if (!['@id', '@vocab'].includes(mapping['@type'])) {\n          throw new JsonLdError('Invalid JSON-LD syntax; container: @type requires @type to be ' + '@id or @vocab.', 'jsonld.SyntaxError', {\n            code: 'invalid type mapping',\n            context: localCtx\n          });\n        }\n      }\n    } else {\n      // in JSON-LD 1.0, container must not be an array (it must be a string,\n      // which is one of the validContainers)\n      isValid &= !_isArray(value['@container']);\n\n      // check container length\n      isValid &= container.length <= 1;\n    }\n\n    // check against valid containers\n    isValid &= container.every(function (c) {\n      return validContainers.includes(c);\n    });\n\n    // @set not allowed with @list\n    isValid &= !(hasSet && container.includes('@list'));\n    if (!isValid) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context @container value must be ' + 'one of the following: ' + validContainers.join(', '), 'jsonld.SyntaxError', {\n        code: 'invalid container mapping',\n        context: localCtx\n      });\n    }\n    if (mapping.reverse && !container.every(function (c) {\n      return ['@index', '@set'].includes(c);\n    })) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context @container value for a @reverse ' + 'type definition must be @index or @set.', 'jsonld.SyntaxError', {\n        code: 'invalid reverse property',\n        context: localCtx\n      });\n    }\n\n    // add @container to mapping\n    mapping['@container'] = container;\n  }\n\n  // property indexing\n  if ('@index' in value) {\n    if (!('@container' in value) || !mapping['@container'].includes('@index')) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @index without @index in @container: ' + \"\\\"\".concat(value['@index'], \"\\\" on term \\\"\").concat(term, \"\\\".\"), 'jsonld.SyntaxError', {\n        code: 'invalid term definition',\n        context: localCtx\n      });\n    }\n    if (!_isString(value['@index']) || value['@index'].indexOf('@') === 0) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @index must expand to an IRI: ' + \"\\\"\".concat(value['@index'], \"\\\" on term \\\"\").concat(term, \"\\\".\"), 'jsonld.SyntaxError', {\n        code: 'invalid term definition',\n        context: localCtx\n      });\n    }\n    mapping['@index'] = value['@index'];\n  }\n\n  // scoped contexts\n  if ('@context' in value) {\n    mapping['@context'] = value['@context'];\n  }\n  if ('@language' in value && !('@type' in value)) {\n    var language = value['@language'];\n    if (language !== null && !_isString(language)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context @language value must be ' + 'a string or null.', 'jsonld.SyntaxError', {\n        code: 'invalid language mapping',\n        context: localCtx\n      });\n    }\n\n    // add @language to mapping\n    if (language !== null) {\n      language = language.toLowerCase();\n    }\n    mapping['@language'] = language;\n  }\n\n  // term may be used as a prefix\n  if ('@prefix' in value) {\n    if (term.match(/:|\\//)) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context @prefix used on a compact IRI term', 'jsonld.SyntaxError', {\n        code: 'invalid term definition',\n        context: localCtx\n      });\n    }\n    if (api.isKeyword(mapping['@id'])) {\n      throw new JsonLdError('Invalid JSON-LD syntax; keywords may not be used as prefixes', 'jsonld.SyntaxError', {\n        code: 'invalid term definition',\n        context: localCtx\n      });\n    }\n    if (typeof value['@prefix'] === 'boolean') {\n      mapping._prefix = value['@prefix'] === true;\n    } else {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context value for @prefix must be boolean', 'jsonld.SyntaxError', {\n        code: 'invalid @prefix value',\n        context: localCtx\n      });\n    }\n  }\n  if ('@direction' in value) {\n    var direction = value['@direction'];\n    if (direction !== null && direction !== 'ltr' && direction !== 'rtl') {\n      throw new JsonLdError('Invalid JSON-LD syntax; @direction value must be ' + 'null, \"ltr\", or \"rtl\".', 'jsonld.SyntaxError', {\n        code: 'invalid base direction',\n        context: localCtx\n      });\n    }\n    mapping['@direction'] = direction;\n  }\n  if ('@nest' in value) {\n    var nest = value['@nest'];\n    if (!_isString(nest) || nest !== '@nest' && nest.indexOf('@') === 0) {\n      throw new JsonLdError('Invalid JSON-LD syntax; @context @nest value must be ' + 'a string which is not a keyword other than @nest.', 'jsonld.SyntaxError', {\n        code: 'invalid @nest value',\n        context: localCtx\n      });\n    }\n    mapping['@nest'] = nest;\n  }\n\n  // disallow aliasing @context and @preserve\n  var id = mapping['@id'];\n  if (id === '@context' || id === '@preserve') {\n    throw new JsonLdError('Invalid JSON-LD syntax; @context and @preserve cannot be aliased.', 'jsonld.SyntaxError', {\n      code: 'invalid keyword alias',\n      context: localCtx\n    });\n  }\n\n  // Check for overriding protected terms\n  if (previousMapping && previousMapping.protected && !overrideProtected) {\n    // force new term to continue to be protected and see if the mappings would\n    // be equal\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n    if (!_deepCompare(previousMapping, mapping)) {\n      var protectedMode = options && options.protectedMode || 'error';\n      if (protectedMode === 'error') {\n        throw new JsonLdError(\"Invalid JSON-LD syntax; tried to redefine \\\"\".concat(term, \"\\\" which is a \") + 'protected term.', 'jsonld.SyntaxError', {\n          code: 'protected term redefinition',\n          context: localCtx,\n          term: term\n        });\n      } else if (protectedMode === 'warn') {\n        // FIXME: remove logging and use a handler\n        console.warn('WARNING: protected term redefinition', {\n          term: term\n        });\n        return;\n      }\n      throw new JsonLdError('Invalid protectedMode.', 'jsonld.SyntaxError', {\n        code: 'invalid protected mode',\n        context: localCtx,\n        term: term,\n        protectedMode: protectedMode\n      });\n    }\n  }\n};\n\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\napi.expandIri = function (activeCtx, value, relativeTo, options) {\n  return _expandIri(activeCtx, value, relativeTo, undefined, undefined, options);\n};\n\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param localCtx the local context being processed (only given if called\n *          during context processing).\n * @param defined a map for tracking cycles in context definitions (only given\n *          if called during context processing).\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandIri(activeCtx, value, relativeTo, localCtx, defined, options) {\n  // already expanded\n  if (value === null || !_isString(value) || api.isKeyword(value)) {\n    return value;\n  }\n\n  // ignore non-keyword things that look like a keyword\n  if (value.match(KEYWORD_PATTERN)) {\n    return null;\n  }\n\n  // define term dependency if not defined\n  if (localCtx && localCtx.hasOwnProperty(value) && defined.get(value) !== true) {\n    api.createTermDefinition({\n      activeCtx: activeCtx,\n      localCtx: localCtx,\n      term: value,\n      defined: defined,\n      options: options\n    });\n  }\n  relativeTo = relativeTo || {};\n  if (relativeTo.vocab) {\n    var mapping = activeCtx.mappings.get(value);\n\n    // value is explicitly ignored with a null mapping\n    if (mapping === null) {\n      return null;\n    }\n    if (_isObject(mapping) && '@id' in mapping) {\n      // value is a term\n      return mapping['@id'];\n    }\n  }\n\n  // split value into prefix:suffix\n  var colon = value.indexOf(':');\n  if (colon > 0) {\n    var prefix = value.substr(0, colon);\n    var suffix = value.substr(colon + 1);\n\n    // do not expand blank nodes (prefix of '_') or already-absolute\n    // IRIs (suffix of '//')\n    if (prefix === '_' || suffix.indexOf('//') === 0) {\n      return value;\n    }\n\n    // prefix dependency not defined, define it\n    if (localCtx && localCtx.hasOwnProperty(prefix)) {\n      api.createTermDefinition({\n        activeCtx: activeCtx,\n        localCtx: localCtx,\n        term: prefix,\n        defined: defined,\n        options: options\n      });\n    }\n\n    // use mapping if prefix is defined\n    var _mapping = activeCtx.mappings.get(prefix);\n    if (_mapping && _mapping._prefix) {\n      return _mapping['@id'] + suffix;\n    }\n\n    // already absolute IRI\n    if (_isAbsoluteIri(value)) {\n      return value;\n    }\n  }\n\n  // prepend vocab\n  if (relativeTo.vocab && '@vocab' in activeCtx) {\n    return activeCtx['@vocab'] + value;\n  }\n\n  // prepend base\n  if (relativeTo.base && '@base' in activeCtx) {\n    if (activeCtx['@base']) {\n      // The null case preserves value as potentially relative\n      return prependBase(prependBase(options.base, activeCtx['@base']), value);\n    }\n  } else if (relativeTo.base) {\n    return prependBase(options.base, value);\n  }\n  return value;\n}\n\n/**\n * Gets the initial context.\n *\n * @param options the options to use:\n *          [base] the document base IRI.\n *\n * @return the initial context.\n */\napi.getInitialContext = function (options) {\n  var key = JSON.stringify({\n    processingMode: options.processingMode\n  });\n  var cached = INITIAL_CONTEXT_CACHE.get(key);\n  if (cached) {\n    return cached;\n  }\n  var initialContext = {\n    processingMode: options.processingMode,\n    mappings: new Map(),\n    inverse: null,\n    getInverse: _createInverseContext,\n    clone: _cloneActiveContext,\n    revertToPreviousContext: _revertToPreviousContext,\n    protected: {}\n  };\n  // TODO: consider using LRU cache instead\n  if (INITIAL_CONTEXT_CACHE.size === INITIAL_CONTEXT_CACHE_MAX_SIZE) {\n    // clear whole cache -- assumes scenario where the cache fills means\n    // the cache isn't being used very efficiently anyway\n    INITIAL_CONTEXT_CACHE.clear();\n  }\n  INITIAL_CONTEXT_CACHE.set(key, initialContext);\n  return initialContext;\n\n  /**\n   * Generates an inverse context for use in the compaction algorithm, if\n   * not already generated for the given active context.\n   *\n   * @return the inverse context.\n   */\n  function _createInverseContext() {\n    var activeCtx = this;\n\n    // lazily create inverse\n    if (activeCtx.inverse) {\n      return activeCtx.inverse;\n    }\n    var inverse = activeCtx.inverse = {};\n\n    // variables for building fast CURIE map\n    var fastCurieMap = activeCtx.fastCurieMap = {};\n    var irisToTerms = {};\n\n    // handle default language\n    var defaultLanguage = (activeCtx['@language'] || '@none').toLowerCase();\n\n    // handle default direction\n    var defaultDirection = activeCtx['@direction'];\n\n    // create term selections for each mapping in the context, ordered by\n    // shortest and then lexicographically least\n    var mappings = activeCtx.mappings;\n    var terms = _toConsumableArray(mappings.keys()).sort(_compareShortestLeast);\n    var _iterator2 = _createForOfIteratorHelper(terms),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var term = _step2.value;\n        var mapping = mappings.get(term);\n        if (mapping === null) {\n          continue;\n        }\n        var container = mapping['@container'] || '@none';\n        container = [].concat(container).sort().join('');\n        if (mapping['@id'] === null) {\n          continue;\n        }\n        // iterate over every IRI in the mapping\n        var ids = _asArray(mapping['@id']);\n        var _iterator3 = _createForOfIteratorHelper(ids),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var iri = _step3.value;\n            var entry = inverse[iri];\n            var isKeyword = api.isKeyword(iri);\n            if (!entry) {\n              // initialize entry\n              inverse[iri] = entry = {};\n              if (!isKeyword && !mapping._termHasColon) {\n                // init IRI to term map and fast CURIE prefixes\n                irisToTerms[iri] = [term];\n                var fastCurieEntry = {\n                  iri: iri,\n                  terms: irisToTerms[iri]\n                };\n                if (iri[0] in fastCurieMap) {\n                  fastCurieMap[iri[0]].push(fastCurieEntry);\n                } else {\n                  fastCurieMap[iri[0]] = [fastCurieEntry];\n                }\n              }\n            } else if (!isKeyword && !mapping._termHasColon) {\n              // add IRI to term match\n              irisToTerms[iri].push(term);\n            }\n\n            // add new entry\n            if (!entry[container]) {\n              entry[container] = {\n                '@language': {},\n                '@type': {},\n                '@any': {}\n              };\n            }\n            entry = entry[container];\n            _addPreferredTerm(term, entry['@any'], '@none');\n            if (mapping.reverse) {\n              // term is preferred for values using @reverse\n              _addPreferredTerm(term, entry['@type'], '@reverse');\n            } else if (mapping['@type'] === '@none') {\n              _addPreferredTerm(term, entry['@any'], '@none');\n              _addPreferredTerm(term, entry['@language'], '@none');\n              _addPreferredTerm(term, entry['@type'], '@none');\n            } else if ('@type' in mapping) {\n              // term is preferred for values using specific type\n              _addPreferredTerm(term, entry['@type'], mapping['@type']);\n            } else if ('@language' in mapping && '@direction' in mapping) {\n              // term is preferred for values using specific language and direction\n              var language = mapping['@language'];\n              var direction = mapping['@direction'];\n              if (language && direction) {\n                _addPreferredTerm(term, entry['@language'], \"\".concat(language, \"_\").concat(direction).toLowerCase());\n              } else if (language) {\n                _addPreferredTerm(term, entry['@language'], language.toLowerCase());\n              } else if (direction) {\n                _addPreferredTerm(term, entry['@language'], \"_\".concat(direction));\n              } else {\n                _addPreferredTerm(term, entry['@language'], '@null');\n              }\n            } else if ('@language' in mapping) {\n              _addPreferredTerm(term, entry['@language'], (mapping['@language'] || '@null').toLowerCase());\n            } else if ('@direction' in mapping) {\n              if (mapping['@direction']) {\n                _addPreferredTerm(term, entry['@language'], \"_\".concat(mapping['@direction']));\n              } else {\n                _addPreferredTerm(term, entry['@language'], '@none');\n              }\n            } else if (defaultDirection) {\n              _addPreferredTerm(term, entry['@language'], \"_\".concat(defaultDirection));\n              _addPreferredTerm(term, entry['@language'], '@none');\n              _addPreferredTerm(term, entry['@type'], '@none');\n            } else {\n              // add entries for no type and no language\n              _addPreferredTerm(term, entry['@language'], defaultLanguage);\n              _addPreferredTerm(term, entry['@language'], '@none');\n              _addPreferredTerm(term, entry['@type'], '@none');\n            }\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n\n      // build fast CURIE map\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    for (var _key2 in fastCurieMap) {\n      _buildIriMap(fastCurieMap, _key2, 1);\n    }\n    return inverse;\n  }\n\n  /**\n   * Runs a recursive algorithm to build a lookup map for quickly finding\n   * potential CURIEs.\n   *\n   * @param iriMap the map to build.\n   * @param key the current key in the map to work on.\n   * @param idx the index into the IRI to compare.\n   */\n  function _buildIriMap(iriMap, key, idx) {\n    var entries = iriMap[key];\n    var next = iriMap[key] = {};\n    var iri;\n    var letter;\n    var _iterator4 = _createForOfIteratorHelper(entries),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var entry = _step4.value;\n        iri = entry.iri;\n        if (idx >= iri.length) {\n          letter = '';\n        } else {\n          letter = iri[idx];\n        }\n        if (letter in next) {\n          next[letter].push(entry);\n        } else {\n          next[letter] = [entry];\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n    for (var _key3 in next) {\n      if (_key3 === '') {\n        continue;\n      }\n      _buildIriMap(next, _key3, idx + 1);\n    }\n  }\n\n  /**\n   * Adds the term for the given entry if not already added.\n   *\n   * @param term the term to add.\n   * @param entry the inverse context typeOrLanguage entry to add to.\n   * @param typeOrLanguageValue the key in the entry to add to.\n   */\n  function _addPreferredTerm(term, entry, typeOrLanguageValue) {\n    if (!entry.hasOwnProperty(typeOrLanguageValue)) {\n      entry[typeOrLanguageValue] = term;\n    }\n  }\n\n  /**\n   * Clones an active context, creating a child active context.\n   *\n   * @return a clone (child) of the active context.\n   */\n  function _cloneActiveContext() {\n    var child = {};\n    child.mappings = util.clone(this.mappings);\n    child.clone = this.clone;\n    child.inverse = null;\n    child.getInverse = this.getInverse;\n    child.protected = util.clone(this.protected);\n    if (this.previousContext) {\n      child.previousContext = this.previousContext.clone();\n    }\n    child.revertToPreviousContext = this.revertToPreviousContext;\n    if ('@base' in this) {\n      child['@base'] = this['@base'];\n    }\n    if ('@language' in this) {\n      child['@language'] = this['@language'];\n    }\n    if ('@vocab' in this) {\n      child['@vocab'] = this['@vocab'];\n    }\n    return child;\n  }\n\n  /**\n   * Reverts any type-scoped context in this active context to the previous\n   * context.\n   */\n  function _revertToPreviousContext() {\n    if (!this.previousContext) {\n      return this;\n    }\n    return this.previousContext.clone();\n  }\n};\n\n/**\n * Gets the value for the given active context key and type, null if none is\n * set or undefined if none is set and type is '@context'.\n *\n * @param ctx the active context.\n * @param key the context key.\n * @param [type] the type of value to get (eg: '@id', '@type'), if not\n *          specified gets the entire entry for a key, null if not found.\n *\n * @return the value, null, or undefined.\n */\napi.getContextValue = function (ctx, key, type) {\n  // invalid key\n  if (key === null) {\n    if (type === '@context') {\n      return undefined;\n    }\n    return null;\n  }\n\n  // get specific entry information\n  if (ctx.mappings.has(key)) {\n    var entry = ctx.mappings.get(key);\n    if (_isUndefined(type)) {\n      // return whole entry\n      return entry;\n    }\n    if (entry.hasOwnProperty(type)) {\n      // return entry value for type\n      return entry[type];\n    }\n  }\n\n  // get default language\n  if (type === '@language' && type in ctx) {\n    return ctx[type];\n  }\n\n  // get default direction\n  if (type === '@direction' && type in ctx) {\n    return ctx[type];\n  }\n  if (type === '@context') {\n    return undefined;\n  }\n  return null;\n};\n\n/**\n * Processing Mode check.\n *\n * @param activeCtx the current active context.\n * @param version the string or numeric version to check.\n *\n * @return boolean.\n */\napi.processingMode = function (activeCtx, version) {\n  if (version.toString() >= '1.1') {\n    return !activeCtx.processingMode || activeCtx.processingMode >= 'json-ld-' + version.toString();\n  } else {\n    return activeCtx.processingMode === 'json-ld-1.0';\n  }\n};\n\n/**\n * Returns whether or not the given value is a keyword.\n *\n * @param v the value to check.\n *\n * @return true if the value is a keyword, false if not.\n */\napi.isKeyword = function (v) {\n  if (!_isString(v) || v[0] !== '@') {\n    return false;\n  }\n  switch (v) {\n    case '@base':\n    case '@container':\n    case '@context':\n    case '@default':\n    case '@direction':\n    case '@embed':\n    case '@explicit':\n    case '@graph':\n    case '@id':\n    case '@included':\n    case '@index':\n    case '@json':\n    case '@language':\n    case '@list':\n    case '@nest':\n    case '@none':\n    case '@omitDefault':\n    case '@prefix':\n    case '@preserve':\n    case '@protected':\n    case '@requireAll':\n    case '@reverse':\n    case '@set':\n    case '@type':\n    case '@value':\n    case '@version':\n    case '@vocab':\n      return true;\n  }\n  return false;\n};\nfunction _deepCompare(x1, x2) {\n  // compare `null` or primitive types directly\n  if (!(x1 && typeof x1 === 'object') || !(x2 && typeof x2 === 'object')) {\n    return x1 === x2;\n  }\n  // x1 and x2 are objects (also potentially arrays)\n  var x1Array = Array.isArray(x1);\n  if (x1Array !== Array.isArray(x2)) {\n    return false;\n  }\n  if (x1Array) {\n    if (x1.length !== x2.length) {\n      return false;\n    }\n    for (var i = 0; i < x1.length; ++i) {\n      if (!_deepCompare(x1[i], x2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // x1 and x2 are non-array objects\n  var k1s = Object.keys(x1);\n  var k2s = Object.keys(x2);\n  if (k1s.length !== k2s.length) {\n    return false;\n  }\n  for (var k1 in x1) {\n    var v1 = x1[k1];\n    var v2 = x2[k1];\n    // special case: `@container` can be in any order\n    if (k1 === '@container') {\n      if (Array.isArray(v1) && Array.isArray(v2)) {\n        v1 = v1.slice().sort();\n        v2 = v2.slice().sort();\n      }\n    }\n    if (!_deepCompare(v1, v2)) {\n      return false;\n    }\n  }\n  return true;\n}","map":{"version":3,"names":["util","require","JsonLdError","_isArray","isArray","_isObject","isObject","_isString","isString","_isUndefined","isUndefined","_isAbsoluteIri","isAbsolute","_isRelativeIri","isRelative","prependBase","_asArray","asArray","_compareShortestLeast","compareShortestLeast","INITIAL_CONTEXT_CACHE","Map","INITIAL_CONTEXT_CACHE_MAX_SIZE","KEYWORD_PATTERN","api","module","exports","process","activeCtx","localCtx","options","propagate","overrideProtected","cycles","Set","ctxs","length","contextResolver","resolve","context","documentLoader","base","resolved","document","rval","previousContext","clone","resolvedContext","ctx","Object","keys","protected","protectedMode","code","console","warn","processed","getProcessed","oldActiveCtx","getInitialContext","entries","term","_protected","mappings","setProcessed","defined","processingMode","set","value","_expandIri","vocab","undefined","toLowerCase","resolvedImport","processedImport","importCtx","key","hasOwnProperty","createTermDefinition","keyCtx","url","has","add","get","validKeys","some","k","includes","isKeyword","match","previousMapping","delete","simpleTerm","mapping","reverse","push","kw","colon","indexOf","_termHasColon","id","termDefined","termIri","_prefix","prefix","substr","suffix","type","container","validContainers","isValid","hasSet","every","c","join","language","direction","nest","_deepCompare","expandIri","relativeTo","JSON","stringify","cached","initialContext","inverse","getInverse","_createInverseContext","_cloneActiveContext","revertToPreviousContext","_revertToPreviousContext","size","clear","fastCurieMap","irisToTerms","defaultLanguage","defaultDirection","terms","sort","concat","ids","iri","entry","fastCurieEntry","_addPreferredTerm","_buildIriMap","iriMap","idx","next","letter","typeOrLanguageValue","child","getContextValue","version","toString","v","x1","x2","x1Array","Array","i","k1s","k2s","k1","v1","v2","slice"],"sources":["E:/react-todo-app/node_modules/jsonld/lib/context.js"],"sourcesContent":["/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst util = require('./util');\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isAbsolute: _isAbsoluteIri,\n  isRelative: _isRelativeIri,\n  prependBase\n} = require('./url');\n\nconst {\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = require('./util');\n\nconst INITIAL_CONTEXT_CACHE = new Map();\nconst INITIAL_CONTEXT_CACHE_MAX_SIZE = 10000;\nconst KEYWORD_PATTERN = /^@[a-zA-Z]+$/;\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Processes a local context and returns a new active context.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context to process.\n * @param options the context processing options.\n * @param propagate `true` if `false`, retains any previously defined term,\n *   which can be rolled back when the descending into a new node object.\n * @param overrideProtected `false` allows protected terms to be modified.\n *\n * @return a Promise that resolves to the new active context.\n */\napi.process = async ({\n  activeCtx, localCtx, options,\n  propagate = true,\n  overrideProtected = false,\n  cycles = new Set()\n}) => {\n  // normalize local context to an array of @context objects\n  if(_isObject(localCtx) && '@context' in localCtx &&\n    _isArray(localCtx['@context'])) {\n    localCtx = localCtx['@context'];\n  }\n  const ctxs = _asArray(localCtx);\n\n  // no contexts in array, return current active context w/o changes\n  if(ctxs.length === 0) {\n    return activeCtx;\n  }\n\n  // resolve contexts\n  const resolved = await options.contextResolver.resolve({\n    activeCtx,\n    context: localCtx,\n    documentLoader: options.documentLoader,\n    base: options.base\n  });\n\n  // override propagate if first resolved context has `@propagate`\n  if(_isObject(resolved[0].document) &&\n    typeof resolved[0].document['@propagate'] === 'boolean') {\n    // retrieve early, error checking done later\n    propagate = resolved[0].document['@propagate'];\n  }\n\n  // process each context in order, update active context\n  // on each iteration to ensure proper caching\n  let rval = activeCtx;\n\n  // track the previous context\n  // if not propagating, make sure rval has a previous context\n  if(!propagate && !rval.previousContext) {\n    // clone `rval` context before updating\n    rval = rval.clone();\n    rval.previousContext = activeCtx;\n  }\n\n  for(const resolvedContext of resolved) {\n    let {document: ctx} = resolvedContext;\n\n    // update active context to one computed from last iteration\n    activeCtx = rval;\n\n    // reset to initial context\n    if(ctx === null) {\n      // We can't nullify if there are protected terms and we're\n      // not allowing overrides (e.g. processing a property term scoped context)\n      if(!overrideProtected &&\n        Object.keys(activeCtx.protected).length !== 0) {\n        const protectedMode = (options && options.protectedMode) || 'error';\n        if(protectedMode === 'error') {\n          throw new JsonLdError(\n            'Tried to nullify a context with protected terms outside of ' +\n            'a term definition.',\n            'jsonld.SyntaxError',\n            {code: 'invalid context nullification'});\n        } else if(protectedMode === 'warn') {\n          // FIXME: remove logging and use a handler\n          console.warn('WARNING: invalid context nullification');\n\n          // get processed context from cache if available\n          const processed = resolvedContext.getProcessed(activeCtx);\n          if(processed) {\n            rval = activeCtx = processed;\n            continue;\n          }\n\n          const oldActiveCtx = activeCtx;\n          // copy all protected term definitions to fresh initial context\n          rval = activeCtx = api.getInitialContext(options).clone();\n          for(const [term, _protected] of\n            Object.entries(oldActiveCtx.protected)) {\n            if(_protected) {\n              activeCtx.mappings[term] =\n                util.clone(oldActiveCtx.mappings[term]);\n            }\n          }\n          activeCtx.protected = util.clone(oldActiveCtx.protected);\n\n          // cache processed result\n          resolvedContext.setProcessed(oldActiveCtx, rval);\n          continue;\n        }\n        throw new JsonLdError(\n          'Invalid protectedMode.',\n          'jsonld.SyntaxError',\n          {code: 'invalid protected mode', context: localCtx, protectedMode});\n      }\n      rval = activeCtx = api.getInitialContext(options).clone();\n      continue;\n    }\n\n    // get processed context from cache if available\n    const processed = resolvedContext.getProcessed(activeCtx);\n    if(processed) {\n      rval = activeCtx = processed;\n      continue;\n    }\n\n    // dereference @context key if present\n    if(_isObject(ctx) && '@context' in ctx) {\n      ctx = ctx['@context'];\n    }\n\n    // context must be an object by now, all URLs retrieved before this call\n    if(!_isObject(ctx)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context must be an object.',\n        'jsonld.SyntaxError', {code: 'invalid local context', context: ctx});\n    }\n\n    // TODO: there is likely a `previousContext` cloning optimization that\n    // could be applied here (no need to copy it under certain conditions)\n\n    // clone context before updating it\n    rval = rval.clone();\n\n    // define context mappings for keys in local context\n    const defined = new Map();\n\n    // handle @version\n    if('@version' in ctx) {\n      if(ctx['@version'] !== 1.1) {\n        throw new JsonLdError(\n          'Unsupported JSON-LD version: ' + ctx['@version'],\n          'jsonld.UnsupportedVersion',\n          {code: 'invalid @version value', context: ctx});\n      }\n      if(activeCtx.processingMode &&\n        activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          '@version: ' + ctx['@version'] + ' not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.ProcessingModeConflict',\n          {code: 'processing mode conflict', context: ctx});\n      }\n      rval.processingMode = 'json-ld-1.1';\n      rval['@version'] = ctx['@version'];\n      defined.set('@version', true);\n    }\n\n    // if not set explicitly, set processingMode to \"json-ld-1.1\"\n    rval.processingMode =\n      rval.processingMode || activeCtx.processingMode;\n\n    // handle @base\n    if('@base' in ctx) {\n      let base = ctx['@base'];\n\n      if(base === null || _isAbsoluteIri(base)) {\n        // no action\n      } else if(_isRelativeIri(base)) {\n        base = prependBase(rval['@base'], base);\n      } else {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@base\" in a ' +\n          '@context must be an absolute IRI, a relative IRI, or null.',\n          'jsonld.SyntaxError', {code: 'invalid base IRI', context: ctx});\n      }\n\n      rval['@base'] = base;\n      defined.set('@base', true);\n    }\n\n    // handle @vocab\n    if('@vocab' in ctx) {\n      const value = ctx['@vocab'];\n      if(value === null) {\n        delete rval['@vocab'];\n      } else if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@vocab\" in a ' +\n          '@context must be a string or null.',\n          'jsonld.SyntaxError', {code: 'invalid vocab mapping', context: ctx});\n      } else if(!_isAbsoluteIri(value) && api.processingMode(rval, 1.0)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@vocab\" in a ' +\n          '@context must be an absolute IRI.',\n          'jsonld.SyntaxError', {code: 'invalid vocab mapping', context: ctx});\n      } else {\n        rval['@vocab'] = _expandIri(rval, value, {vocab: true, base: true},\n          undefined, undefined, options);\n      }\n      defined.set('@vocab', true);\n    }\n\n    // handle @language\n    if('@language' in ctx) {\n      const value = ctx['@language'];\n      if(value === null) {\n        delete rval['@language'];\n      } else if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@language\" in a ' +\n          '@context must be a string or null.',\n          'jsonld.SyntaxError',\n          {code: 'invalid default language', context: ctx});\n      } else {\n        rval['@language'] = value.toLowerCase();\n      }\n      defined.set('@language', true);\n    }\n\n    // handle @direction\n    if('@direction' in ctx) {\n      const value = ctx['@direction'];\n      if(activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @direction not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.SyntaxError',\n          {code: 'invalid context member', context: ctx});\n      }\n      if(value === null) {\n        delete rval['@direction'];\n      } else if(value !== 'ltr' && value !== 'rtl') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; the value of \"@direction\" in a ' +\n          '@context must be null, \"ltr\", or \"rtl\".',\n          'jsonld.SyntaxError',\n          {code: 'invalid base direction', context: ctx});\n      } else {\n        rval['@direction'] = value;\n      }\n      defined.set('@direction', true);\n    }\n\n    // handle @propagate\n    // note: we've already extracted it, here we just do error checking\n    if('@propagate' in ctx) {\n      const value = ctx['@propagate'];\n      if(activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @propagate not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.SyntaxError',\n          {code: 'invalid context entry', context: ctx});\n      }\n      if(typeof value !== 'boolean') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @propagate value must be a boolean.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @propagate value', context: localCtx});\n      }\n      defined.set('@propagate', true);\n    }\n\n    // handle @import\n    if('@import' in ctx) {\n      const value = ctx['@import'];\n      if(activeCtx.processingMode === 'json-ld-1.0') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @import not compatible with ' +\n          activeCtx.processingMode,\n          'jsonld.SyntaxError',\n          {code: 'invalid context entry', context: ctx});\n      }\n      if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @import must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @import value', context: localCtx});\n      }\n\n      // resolve contexts\n      const resolvedImport = await options.contextResolver.resolve({\n        activeCtx,\n        context: value,\n        documentLoader: options.documentLoader,\n        base: options.base\n      });\n      if(resolvedImport.length !== 1) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @import must reference a single context.',\n          'jsonld.SyntaxError',\n          {code: 'invalid remote context', context: localCtx});\n      }\n      const processedImport = resolvedImport[0].getProcessed(activeCtx);\n      if(processedImport) {\n        // Note: if the same context were used in this active context\n        // as a reference context, then processed_input might not\n        // be a dict.\n        ctx = processedImport;\n      } else {\n        const importCtx = resolvedImport[0].document;\n        if('@import' in importCtx) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax: ' +\n            'imported context must not include @import.',\n            'jsonld.SyntaxError',\n            {code: 'invalid context entry', context: localCtx});\n        }\n\n        // merge ctx into importCtx and replace rval with the result\n        for(const key in importCtx) {\n          if(!ctx.hasOwnProperty(key)) {\n            ctx[key] = importCtx[key];\n          }\n        }\n\n        // Note: this could potenially conflict if the import\n        // were used in the same active context as a referenced\n        // context and an import. In this case, we\n        // could override the cached result, but seems unlikely.\n        resolvedImport[0].setProcessed(activeCtx, ctx);\n      }\n\n      defined.set('@import', true);\n    }\n\n    // handle @protected; determine whether this sub-context is declaring\n    // all its terms to be \"protected\" (exceptions can be made on a\n    // per-definition basis)\n    defined.set('@protected', ctx['@protected'] || false);\n\n    // process all other keys\n    for(const key in ctx) {\n      api.createTermDefinition({\n        activeCtx: rval,\n        localCtx: ctx,\n        term: key,\n        defined,\n        options,\n        overrideProtected\n      });\n\n      if(_isObject(ctx[key]) && '@context' in ctx[key]) {\n        const keyCtx = ctx[key]['@context'];\n        let process = true;\n        if(_isString(keyCtx)) {\n          const url = prependBase(options.base, keyCtx);\n          // track processed contexts to avoid scoped context recursion\n          if(cycles.has(url)) {\n            process = false;\n          } else {\n            cycles.add(url);\n          }\n        }\n        // parse context to validate\n        if(process) {\n          try {\n            await api.process({\n              activeCtx: rval.clone(),\n              localCtx: ctx[key]['@context'],\n              overrideProtected: true,\n              options,\n              cycles\n            });\n          } catch(e) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; invalid scoped context.',\n              'jsonld.SyntaxError',\n              {\n                code: 'invalid scoped context',\n                context: ctx[key]['@context'],\n                term: key\n              });\n          }\n        }\n      }\n    }\n\n    // cache processed result\n    resolvedContext.setProcessed(activeCtx, rval);\n  }\n\n  return rval;\n};\n\n/**\n * Creates a term definition during context processing.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context being processed.\n * @param term the term in the local context to define the mapping for.\n * @param defined a map of defining/defined keys to detect cycles and prevent\n *          double definitions.\n * @param {Object} [options] - creation options.\n * @param {string} [options.protectedMode=\"error\"] - \"error\" to throw error\n *   on `@protected` constraint violation, \"warn\" to allow violations and\n *   signal a warning.\n * @param overrideProtected `false` allows protected terms to be modified.\n */\napi.createTermDefinition = ({\n  activeCtx,\n  localCtx,\n  term,\n  defined,\n  options,\n  overrideProtected = false,\n}) => {\n  if(defined.has(term)) {\n    // term already defined\n    if(defined.get(term)) {\n      return;\n    }\n    // cycle detected\n    throw new JsonLdError(\n      'Cyclical context definition detected.',\n      'jsonld.CyclicalContext',\n      {code: 'cyclic IRI mapping', context: localCtx, term});\n  }\n\n  // now defining term\n  defined.set(term, false);\n\n  // get context term value\n  let value;\n  if(localCtx.hasOwnProperty(term)) {\n    value = localCtx[term];\n  }\n\n  if(term === '@type' &&\n     _isObject(value) &&\n     (value['@container'] || '@set') === '@set' &&\n     api.processingMode(activeCtx, 1.1)) {\n\n    const validKeys = ['@container', '@id', '@protected'];\n    const keys = Object.keys(value);\n    if(keys.length === 0 || keys.some(k => !validKeys.includes(k))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; keywords cannot be overridden.',\n        'jsonld.SyntaxError',\n        {code: 'keyword redefinition', context: localCtx, term});\n    }\n  } else if(api.isKeyword(term)) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; keywords cannot be overridden.',\n      'jsonld.SyntaxError',\n      {code: 'keyword redefinition', context: localCtx, term});\n  } else if(term.match(KEYWORD_PATTERN)) {\n    // FIXME: remove logging and use a handler\n    console.warn('WARNING: terms beginning with \"@\" are reserved' +\n      ' for future use and ignored', {term});\n    return;\n  } else if(term === '') {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; a term cannot be an empty string.',\n      'jsonld.SyntaxError',\n      {code: 'invalid term definition', context: localCtx});\n  }\n\n  // keep reference to previous mapping for potential `@protected` check\n  const previousMapping = activeCtx.mappings.get(term);\n\n  // remove old mapping\n  if(activeCtx.mappings.has(term)) {\n    activeCtx.mappings.delete(term);\n  }\n\n  // convert short-hand value to object w/@id\n  let simpleTerm = false;\n  if(_isString(value) || value === null) {\n    simpleTerm = true;\n    value = {'@id': value};\n  }\n\n  if(!_isObject(value)) {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; @context term values must be ' +\n      'strings or objects.',\n      'jsonld.SyntaxError',\n      {code: 'invalid term definition', context: localCtx});\n  }\n\n  // create new mapping\n  const mapping = {};\n  activeCtx.mappings.set(term, mapping);\n  mapping.reverse = false;\n\n  // make sure term definition only has expected keywords\n  const validKeys = ['@container', '@id', '@language', '@reverse', '@type'];\n\n  // JSON-LD 1.1 support\n  if(api.processingMode(activeCtx, 1.1)) {\n    validKeys.push(\n      '@context', '@direction', '@index', '@nest', '@prefix', '@protected');\n  }\n\n  for(const kw in value) {\n    if(!validKeys.includes(kw)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a term definition must not contain ' + kw,\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n  }\n\n  // always compute whether term has a colon as an optimization for\n  // _compactIri\n  const colon = term.indexOf(':');\n  mapping._termHasColon = (colon > 0);\n\n  if('@reverse' in value) {\n    if('@id' in value) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @reverse term definition must not ' +\n        'contain @id.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n    if('@nest' in value) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @reverse term definition must not ' +\n        'contain @nest.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n    const reverse = value['@reverse'];\n    if(!_isString(reverse)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @reverse value must be a string.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n\n    if(!api.isKeyword(reverse) && reverse.match(KEYWORD_PATTERN)) {\n      // FIXME: remove logging and use a handler\n      console.warn('WARNING: values beginning with \"@\" are reserved' +\n        ' for future use and ignored', {reverse});\n      if(previousMapping) {\n        activeCtx.mappings.set(term, previousMapping);\n      } else {\n        activeCtx.mappings.delete(term);\n      }\n      return;\n    }\n\n    // expand and add @id mapping\n    const id = _expandIri(\n      activeCtx, reverse, {vocab: true, base: false}, localCtx, defined,\n      options);\n    if(!_isAbsoluteIri(id)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @reverse value must be an ' +\n        'absolute IRI or a blank node identifier.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n\n    mapping['@id'] = id;\n    mapping.reverse = true;\n  } else if('@id' in value) {\n    let id = value['@id'];\n    if(id && !_isString(id)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; a @context @id value must be an array ' +\n        'of strings or a string.',\n        'jsonld.SyntaxError', {code: 'invalid IRI mapping', context: localCtx});\n    }\n    if(id === null) {\n      // reserve a null term, which may be protected\n      mapping['@id'] = null;\n    } else if(!api.isKeyword(id) && id.match(KEYWORD_PATTERN)) {\n      // FIXME: remove logging and use a handler\n      console.warn('WARNING: values beginning with \"@\" are reserved' +\n        ' for future use and ignored', {id});\n      if(previousMapping) {\n        activeCtx.mappings.set(term, previousMapping);\n      } else {\n        activeCtx.mappings.delete(term);\n      }\n      return;\n    } else if(id !== term) {\n      // expand and add @id mapping\n      id = _expandIri(\n        activeCtx, id, {vocab: true, base: false}, localCtx, defined, options);\n      if(!_isAbsoluteIri(id) && !api.isKeyword(id)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; a @context @id value must be an ' +\n          'absolute IRI, a blank node identifier, or a keyword.',\n          'jsonld.SyntaxError',\n          {code: 'invalid IRI mapping', context: localCtx});\n      }\n\n      // if term has the form of an IRI it must map the same\n      if(term.match(/(?::[^:])|\\//)) {\n        const termDefined = new Map(defined).set(term, true);\n        const termIri = _expandIri(\n          activeCtx, term, {vocab: true, base: false},\n          localCtx, termDefined, options);\n        if(termIri !== id) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; term in form of IRI must ' +\n            'expand to definition.',\n            'jsonld.SyntaxError',\n            {code: 'invalid IRI mapping', context: localCtx});\n        }\n      }\n\n      mapping['@id'] = id;\n      // indicate if this term may be used as a compact IRI prefix\n      mapping._prefix = (simpleTerm &&\n        !mapping._termHasColon &&\n        id.match(/[:\\/\\?#\\[\\]@]$/));\n    }\n  }\n\n  if(!('@id' in mapping)) {\n    // see if the term has a prefix\n    if(mapping._termHasColon) {\n      const prefix = term.substr(0, colon);\n      if(localCtx.hasOwnProperty(prefix)) {\n        // define parent prefix\n        api.createTermDefinition({\n          activeCtx, localCtx, term: prefix, defined, options\n        });\n      }\n\n      if(activeCtx.mappings.has(prefix)) {\n        // set @id based on prefix parent\n        const suffix = term.substr(colon + 1);\n        mapping['@id'] = activeCtx.mappings.get(prefix)['@id'] + suffix;\n      } else {\n        // term is an absolute IRI\n        mapping['@id'] = term;\n      }\n    } else if(term === '@type') {\n      // Special case, were we've previously determined that container is @set\n      mapping['@id'] = term;\n    } else {\n      // non-IRIs *must* define @ids if @vocab is not available\n      if(!('@vocab' in activeCtx)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; @context terms must define an @id.',\n          'jsonld.SyntaxError',\n          {code: 'invalid IRI mapping', context: localCtx, term});\n      }\n      // prepend vocab to term\n      mapping['@id'] = activeCtx['@vocab'] + term;\n    }\n  }\n\n  // Handle term protection\n  if(value['@protected'] === true ||\n    (defined.get('@protected') === true && value['@protected'] !== false)) {\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n  }\n\n  // IRI mapping now defined\n  defined.set(term, true);\n\n  if('@type' in value) {\n    let type = value['@type'];\n    if(!_isString(type)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an @context @type value must be a string.',\n        'jsonld.SyntaxError',\n        {code: 'invalid type mapping', context: localCtx});\n    }\n\n    if((type === '@json' || type === '@none')) {\n      if(api.processingMode(activeCtx, 1.0)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must not be ' +\n          `\"${type}\" in JSON-LD 1.0 mode.`,\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n    } else if(type !== '@id' && type !== '@vocab') {\n      // expand @type to full IRI\n      type = _expandIri(\n        activeCtx, type, {vocab: true, base: false}, localCtx, defined,\n        options);\n      if(!_isAbsoluteIri(type)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must be an ' +\n          'absolute IRI.',\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n      if(type.indexOf('_:') === 0) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; an @context @type value must be an IRI, ' +\n          'not a blank node identifier.',\n          'jsonld.SyntaxError',\n          {code: 'invalid type mapping', context: localCtx});\n      }\n    }\n\n    // add @type to mapping\n    mapping['@type'] = type;\n  }\n\n  if('@container' in value) {\n    // normalize container to an array form\n    const container = _isString(value['@container']) ?\n      [value['@container']] : (value['@container'] || []);\n    const validContainers = ['@list', '@set', '@index', '@language'];\n    let isValid = true;\n    const hasSet = container.includes('@set');\n\n    // JSON-LD 1.1 support\n    if(api.processingMode(activeCtx, 1.1)) {\n      validContainers.push('@graph', '@id', '@type');\n\n      // check container length\n      if(container.includes('@list')) {\n        if(container.length !== 1) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; @context @container with @list must ' +\n            'have no other values',\n            'jsonld.SyntaxError',\n            {code: 'invalid container mapping', context: localCtx});\n        }\n      } else if(container.includes('@graph')) {\n        if(container.some(key =>\n          key !== '@graph' && key !== '@id' && key !== '@index' &&\n          key !== '@set')) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; @context @container with @graph must ' +\n            'have no other values other than @id, @index, and @set',\n            'jsonld.SyntaxError',\n            {code: 'invalid container mapping', context: localCtx});\n        }\n      } else {\n        // otherwise, container may also include @set\n        isValid &= container.length <= (hasSet ? 2 : 1);\n      }\n\n      if(container.includes('@type')) {\n        // If mapping does not have an @type,\n        // set it to @id\n        mapping['@type'] = mapping['@type'] || '@id';\n\n        // type mapping must be either @id or @vocab\n        if(!['@id', '@vocab'].includes(mapping['@type'])) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; container: @type requires @type to be ' +\n            '@id or @vocab.',\n            'jsonld.SyntaxError',\n            {code: 'invalid type mapping', context: localCtx});\n        }\n      }\n    } else {\n      // in JSON-LD 1.0, container must not be an array (it must be a string,\n      // which is one of the validContainers)\n      isValid &= !_isArray(value['@container']);\n\n      // check container length\n      isValid &= container.length <= 1;\n    }\n\n    // check against valid containers\n    isValid &= container.every(c => validContainers.includes(c));\n\n    // @set not allowed with @list\n    isValid &= !(hasSet && container.includes('@list'));\n\n    if(!isValid) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @container value must be ' +\n        'one of the following: ' + validContainers.join(', '),\n        'jsonld.SyntaxError',\n        {code: 'invalid container mapping', context: localCtx});\n    }\n\n    if(mapping.reverse &&\n      !container.every(c => ['@index', '@set'].includes(c))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @container value for a @reverse ' +\n        'type definition must be @index or @set.', 'jsonld.SyntaxError',\n        {code: 'invalid reverse property', context: localCtx});\n    }\n\n    // add @container to mapping\n    mapping['@container'] = container;\n  }\n\n  // property indexing\n  if('@index' in value) {\n    if(!('@container' in value) || !mapping['@container'].includes('@index')) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @index without @index in @container: ' +\n        `\"${value['@index']}\" on term \"${term}\".`, 'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    if(!_isString(value['@index']) || value['@index'].indexOf('@') === 0) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @index must expand to an IRI: ' +\n        `\"${value['@index']}\" on term \"${term}\".`, 'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    mapping['@index'] = value['@index'];\n  }\n\n  // scoped contexts\n  if('@context' in value) {\n    mapping['@context'] = value['@context'];\n  }\n\n  if('@language' in value && !('@type' in value)) {\n    let language = value['@language'];\n    if(language !== null && !_isString(language)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @language value must be ' +\n        'a string or null.', 'jsonld.SyntaxError',\n        {code: 'invalid language mapping', context: localCtx});\n    }\n\n    // add @language to mapping\n    if(language !== null) {\n      language = language.toLowerCase();\n    }\n    mapping['@language'] = language;\n  }\n\n  // term may be used as a prefix\n  if('@prefix' in value) {\n    if(term.match(/:|\\//)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @prefix used on a compact IRI term',\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    if(api.isKeyword(mapping['@id'])) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; keywords may not be used as prefixes',\n        'jsonld.SyntaxError',\n        {code: 'invalid term definition', context: localCtx});\n    }\n    if(typeof value['@prefix'] === 'boolean') {\n      mapping._prefix = value['@prefix'] === true;\n    } else {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context value for @prefix must be boolean',\n        'jsonld.SyntaxError',\n        {code: 'invalid @prefix value', context: localCtx});\n    }\n  }\n\n  if('@direction' in value) {\n    const direction = value['@direction'];\n    if(direction !== null && direction !== 'ltr' && direction !== 'rtl') {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @direction value must be ' +\n        'null, \"ltr\", or \"rtl\".',\n        'jsonld.SyntaxError',\n        {code: 'invalid base direction', context: localCtx});\n    }\n    mapping['@direction'] = direction;\n  }\n\n  if('@nest' in value) {\n    const nest = value['@nest'];\n    if(!_isString(nest) || (nest !== '@nest' && nest.indexOf('@') === 0)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; @context @nest value must be ' +\n        'a string which is not a keyword other than @nest.',\n        'jsonld.SyntaxError',\n        {code: 'invalid @nest value', context: localCtx});\n    }\n    mapping['@nest'] = nest;\n  }\n\n  // disallow aliasing @context and @preserve\n  const id = mapping['@id'];\n  if(id === '@context' || id === '@preserve') {\n    throw new JsonLdError(\n      'Invalid JSON-LD syntax; @context and @preserve cannot be aliased.',\n      'jsonld.SyntaxError', {code: 'invalid keyword alias', context: localCtx});\n  }\n\n  // Check for overriding protected terms\n  if(previousMapping && previousMapping.protected && !overrideProtected) {\n    // force new term to continue to be protected and see if the mappings would\n    // be equal\n    activeCtx.protected[term] = true;\n    mapping.protected = true;\n    if(!_deepCompare(previousMapping, mapping)) {\n      const protectedMode = (options && options.protectedMode) || 'error';\n      if(protectedMode === 'error') {\n        throw new JsonLdError(\n          `Invalid JSON-LD syntax; tried to redefine \"${term}\" which is a ` +\n          'protected term.',\n          'jsonld.SyntaxError',\n          {code: 'protected term redefinition', context: localCtx, term});\n      } else if(protectedMode === 'warn') {\n        // FIXME: remove logging and use a handler\n        console.warn('WARNING: protected term redefinition', {term});\n        return;\n      }\n      throw new JsonLdError(\n        'Invalid protectedMode.',\n        'jsonld.SyntaxError',\n        {code: 'invalid protected mode', context: localCtx, term,\n          protectedMode});\n    }\n  }\n};\n\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\napi.expandIri = (activeCtx, value, relativeTo, options) => {\n  return _expandIri(activeCtx, value, relativeTo, undefined, undefined,\n    options);\n};\n\n/**\n * Expands a string to a full IRI. The string may be a term, a prefix, a\n * relative IRI, or an absolute IRI. The associated absolute IRI will be\n * returned.\n *\n * @param activeCtx the current active context.\n * @param value the string to expand.\n * @param relativeTo options for how to resolve relative IRIs:\n *          base: true to resolve against the base IRI, false not to.\n *          vocab: true to concatenate after @vocab, false not to.\n * @param localCtx the local context being processed (only given if called\n *          during context processing).\n * @param defined a map for tracking cycles in context definitions (only given\n *          if called during context processing).\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandIri(activeCtx, value, relativeTo, localCtx, defined, options) {\n  // already expanded\n  if(value === null || !_isString(value) || api.isKeyword(value)) {\n    return value;\n  }\n\n  // ignore non-keyword things that look like a keyword\n  if(value.match(KEYWORD_PATTERN)) {\n    return null;\n  }\n\n  // define term dependency if not defined\n  if(localCtx && localCtx.hasOwnProperty(value) &&\n    defined.get(value) !== true) {\n    api.createTermDefinition({\n      activeCtx, localCtx, term: value, defined, options\n    });\n  }\n\n  relativeTo = relativeTo || {};\n  if(relativeTo.vocab) {\n    const mapping = activeCtx.mappings.get(value);\n\n    // value is explicitly ignored with a null mapping\n    if(mapping === null) {\n      return null;\n    }\n\n    if(_isObject(mapping) && '@id' in mapping) {\n      // value is a term\n      return mapping['@id'];\n    }\n  }\n\n  // split value into prefix:suffix\n  const colon = value.indexOf(':');\n  if(colon > 0) {\n    const prefix = value.substr(0, colon);\n    const suffix = value.substr(colon + 1);\n\n    // do not expand blank nodes (prefix of '_') or already-absolute\n    // IRIs (suffix of '//')\n    if(prefix === '_' || suffix.indexOf('//') === 0) {\n      return value;\n    }\n\n    // prefix dependency not defined, define it\n    if(localCtx && localCtx.hasOwnProperty(prefix)) {\n      api.createTermDefinition({\n        activeCtx, localCtx, term: prefix, defined, options\n      });\n    }\n\n    // use mapping if prefix is defined\n    const mapping = activeCtx.mappings.get(prefix);\n    if(mapping && mapping._prefix) {\n      return mapping['@id'] + suffix;\n    }\n\n    // already absolute IRI\n    if(_isAbsoluteIri(value)) {\n      return value;\n    }\n  }\n\n  // prepend vocab\n  if(relativeTo.vocab && '@vocab' in activeCtx) {\n    return activeCtx['@vocab'] + value;\n  }\n\n  // prepend base\n  if(relativeTo.base && '@base' in activeCtx) {\n    if(activeCtx['@base']) {\n      // The null case preserves value as potentially relative\n      return prependBase(prependBase(options.base, activeCtx['@base']), value);\n    }\n  } else if(relativeTo.base) {\n    return prependBase(options.base, value);\n  }\n\n  return value;\n}\n\n/**\n * Gets the initial context.\n *\n * @param options the options to use:\n *          [base] the document base IRI.\n *\n * @return the initial context.\n */\napi.getInitialContext = options => {\n  const key = JSON.stringify({processingMode: options.processingMode});\n  const cached = INITIAL_CONTEXT_CACHE.get(key);\n  if(cached) {\n    return cached;\n  }\n\n  const initialContext = {\n    processingMode: options.processingMode,\n    mappings: new Map(),\n    inverse: null,\n    getInverse: _createInverseContext,\n    clone: _cloneActiveContext,\n    revertToPreviousContext: _revertToPreviousContext,\n    protected: {}\n  };\n  // TODO: consider using LRU cache instead\n  if(INITIAL_CONTEXT_CACHE.size === INITIAL_CONTEXT_CACHE_MAX_SIZE) {\n    // clear whole cache -- assumes scenario where the cache fills means\n    // the cache isn't being used very efficiently anyway\n    INITIAL_CONTEXT_CACHE.clear();\n  }\n  INITIAL_CONTEXT_CACHE.set(key, initialContext);\n  return initialContext;\n\n  /**\n   * Generates an inverse context for use in the compaction algorithm, if\n   * not already generated for the given active context.\n   *\n   * @return the inverse context.\n   */\n  function _createInverseContext() {\n    const activeCtx = this;\n\n    // lazily create inverse\n    if(activeCtx.inverse) {\n      return activeCtx.inverse;\n    }\n    const inverse = activeCtx.inverse = {};\n\n    // variables for building fast CURIE map\n    const fastCurieMap = activeCtx.fastCurieMap = {};\n    const irisToTerms = {};\n\n    // handle default language\n    const defaultLanguage = (activeCtx['@language'] || '@none').toLowerCase();\n\n    // handle default direction\n    const defaultDirection = activeCtx['@direction'];\n\n    // create term selections for each mapping in the context, ordered by\n    // shortest and then lexicographically least\n    const mappings = activeCtx.mappings;\n    const terms = [...mappings.keys()].sort(_compareShortestLeast);\n    for(const term of terms) {\n      const mapping = mappings.get(term);\n      if(mapping === null) {\n        continue;\n      }\n\n      let container = mapping['@container'] || '@none';\n      container = [].concat(container).sort().join('');\n\n      if(mapping['@id'] === null) {\n        continue;\n      }\n      // iterate over every IRI in the mapping\n      const ids = _asArray(mapping['@id']);\n      for(const iri of ids) {\n        let entry = inverse[iri];\n        const isKeyword = api.isKeyword(iri);\n\n        if(!entry) {\n          // initialize entry\n          inverse[iri] = entry = {};\n\n          if(!isKeyword && !mapping._termHasColon) {\n            // init IRI to term map and fast CURIE prefixes\n            irisToTerms[iri] = [term];\n            const fastCurieEntry = {iri, terms: irisToTerms[iri]};\n            if(iri[0] in fastCurieMap) {\n              fastCurieMap[iri[0]].push(fastCurieEntry);\n            } else {\n              fastCurieMap[iri[0]] = [fastCurieEntry];\n            }\n          }\n        } else if(!isKeyword && !mapping._termHasColon) {\n          // add IRI to term match\n          irisToTerms[iri].push(term);\n        }\n\n        // add new entry\n        if(!entry[container]) {\n          entry[container] = {\n            '@language': {},\n            '@type': {},\n            '@any': {}\n          };\n        }\n        entry = entry[container];\n        _addPreferredTerm(term, entry['@any'], '@none');\n\n        if(mapping.reverse) {\n          // term is preferred for values using @reverse\n          _addPreferredTerm(term, entry['@type'], '@reverse');\n        } else if(mapping['@type'] === '@none') {\n          _addPreferredTerm(term, entry['@any'], '@none');\n          _addPreferredTerm(term, entry['@language'], '@none');\n          _addPreferredTerm(term, entry['@type'], '@none');\n        } else if('@type' in mapping) {\n          // term is preferred for values using specific type\n          _addPreferredTerm(term, entry['@type'], mapping['@type']);\n        } else if('@language' in mapping && '@direction' in mapping) {\n          // term is preferred for values using specific language and direction\n          const language = mapping['@language'];\n          const direction = mapping['@direction'];\n          if(language && direction) {\n            _addPreferredTerm(term, entry['@language'],\n              `${language}_${direction}`.toLowerCase());\n          } else if(language) {\n            _addPreferredTerm(term, entry['@language'], language.toLowerCase());\n          } else if(direction) {\n            _addPreferredTerm(term, entry['@language'], `_${direction}`);\n          } else {\n            _addPreferredTerm(term, entry['@language'], '@null');\n          }\n        } else if('@language' in mapping) {\n          _addPreferredTerm(term, entry['@language'],\n            (mapping['@language'] || '@null').toLowerCase());\n        } else if('@direction' in mapping) {\n          if(mapping['@direction']) {\n            _addPreferredTerm(term, entry['@language'],\n              `_${mapping['@direction']}`);\n          } else {\n            _addPreferredTerm(term, entry['@language'], '@none');\n          }\n        } else if(defaultDirection) {\n          _addPreferredTerm(term, entry['@language'], `_${defaultDirection}`);\n          _addPreferredTerm(term, entry['@language'], '@none');\n          _addPreferredTerm(term, entry['@type'], '@none');\n        } else {\n          // add entries for no type and no language\n          _addPreferredTerm(term, entry['@language'], defaultLanguage);\n          _addPreferredTerm(term, entry['@language'], '@none');\n          _addPreferredTerm(term, entry['@type'], '@none');\n        }\n      }\n    }\n\n    // build fast CURIE map\n    for(const key in fastCurieMap) {\n      _buildIriMap(fastCurieMap, key, 1);\n    }\n\n    return inverse;\n  }\n\n  /**\n   * Runs a recursive algorithm to build a lookup map for quickly finding\n   * potential CURIEs.\n   *\n   * @param iriMap the map to build.\n   * @param key the current key in the map to work on.\n   * @param idx the index into the IRI to compare.\n   */\n  function _buildIriMap(iriMap, key, idx) {\n    const entries = iriMap[key];\n    const next = iriMap[key] = {};\n\n    let iri;\n    let letter;\n    for(const entry of entries) {\n      iri = entry.iri;\n      if(idx >= iri.length) {\n        letter = '';\n      } else {\n        letter = iri[idx];\n      }\n      if(letter in next) {\n        next[letter].push(entry);\n      } else {\n        next[letter] = [entry];\n      }\n    }\n\n    for(const key in next) {\n      if(key === '') {\n        continue;\n      }\n      _buildIriMap(next, key, idx + 1);\n    }\n  }\n\n  /**\n   * Adds the term for the given entry if not already added.\n   *\n   * @param term the term to add.\n   * @param entry the inverse context typeOrLanguage entry to add to.\n   * @param typeOrLanguageValue the key in the entry to add to.\n   */\n  function _addPreferredTerm(term, entry, typeOrLanguageValue) {\n    if(!entry.hasOwnProperty(typeOrLanguageValue)) {\n      entry[typeOrLanguageValue] = term;\n    }\n  }\n\n  /**\n   * Clones an active context, creating a child active context.\n   *\n   * @return a clone (child) of the active context.\n   */\n  function _cloneActiveContext() {\n    const child = {};\n    child.mappings = util.clone(this.mappings);\n    child.clone = this.clone;\n    child.inverse = null;\n    child.getInverse = this.getInverse;\n    child.protected = util.clone(this.protected);\n    if(this.previousContext) {\n      child.previousContext = this.previousContext.clone();\n    }\n    child.revertToPreviousContext = this.revertToPreviousContext;\n    if('@base' in this) {\n      child['@base'] = this['@base'];\n    }\n    if('@language' in this) {\n      child['@language'] = this['@language'];\n    }\n    if('@vocab' in this) {\n      child['@vocab'] = this['@vocab'];\n    }\n    return child;\n  }\n\n  /**\n   * Reverts any type-scoped context in this active context to the previous\n   * context.\n   */\n  function _revertToPreviousContext() {\n    if(!this.previousContext) {\n      return this;\n    }\n    return this.previousContext.clone();\n  }\n};\n\n/**\n * Gets the value for the given active context key and type, null if none is\n * set or undefined if none is set and type is '@context'.\n *\n * @param ctx the active context.\n * @param key the context key.\n * @param [type] the type of value to get (eg: '@id', '@type'), if not\n *          specified gets the entire entry for a key, null if not found.\n *\n * @return the value, null, or undefined.\n */\napi.getContextValue = (ctx, key, type) => {\n  // invalid key\n  if(key === null) {\n    if(type === '@context') {\n      return undefined;\n    }\n    return null;\n  }\n\n  // get specific entry information\n  if(ctx.mappings.has(key)) {\n    const entry = ctx.mappings.get(key);\n\n    if(_isUndefined(type)) {\n      // return whole entry\n      return entry;\n    }\n    if(entry.hasOwnProperty(type)) {\n      // return entry value for type\n      return entry[type];\n    }\n  }\n\n  // get default language\n  if(type === '@language' && type in ctx) {\n    return ctx[type];\n  }\n\n  // get default direction\n  if(type === '@direction' && type in ctx) {\n    return ctx[type];\n  }\n\n  if(type === '@context') {\n    return undefined;\n  }\n  return null;\n};\n\n/**\n * Processing Mode check.\n *\n * @param activeCtx the current active context.\n * @param version the string or numeric version to check.\n *\n * @return boolean.\n */\napi.processingMode = (activeCtx, version) => {\n  if(version.toString() >= '1.1') {\n    return !activeCtx.processingMode ||\n      activeCtx.processingMode >= 'json-ld-' + version.toString();\n  } else {\n    return activeCtx.processingMode === 'json-ld-1.0';\n  }\n};\n\n/**\n * Returns whether or not the given value is a keyword.\n *\n * @param v the value to check.\n *\n * @return true if the value is a keyword, false if not.\n */\napi.isKeyword = v => {\n  if(!_isString(v) || v[0] !== '@') {\n    return false;\n  }\n  switch(v) {\n    case '@base':\n    case '@container':\n    case '@context':\n    case '@default':\n    case '@direction':\n    case '@embed':\n    case '@explicit':\n    case '@graph':\n    case '@id':\n    case '@included':\n    case '@index':\n    case '@json':\n    case '@language':\n    case '@list':\n    case '@nest':\n    case '@none':\n    case '@omitDefault':\n    case '@prefix':\n    case '@preserve':\n    case '@protected':\n    case '@requireAll':\n    case '@reverse':\n    case '@set':\n    case '@type':\n    case '@value':\n    case '@version':\n    case '@vocab':\n      return true;\n  }\n  return false;\n};\n\nfunction _deepCompare(x1, x2) {\n  // compare `null` or primitive types directly\n  if((!(x1 && typeof x1 === 'object')) ||\n     (!(x2 && typeof x2 === 'object'))) {\n    return x1 === x2;\n  }\n  // x1 and x2 are objects (also potentially arrays)\n  const x1Array = Array.isArray(x1);\n  if(x1Array !== Array.isArray(x2)) {\n    return false;\n  }\n  if(x1Array) {\n    if(x1.length !== x2.length) {\n      return false;\n    }\n    for(let i = 0; i < x1.length; ++i) {\n      if(!_deepCompare(x1[i], x2[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // x1 and x2 are non-array objects\n  const k1s = Object.keys(x1);\n  const k2s = Object.keys(x2);\n  if(k1s.length !== k2s.length) {\n    return false;\n  }\n  for(const k1 in x1) {\n    let v1 = x1[k1];\n    let v2 = x2[k1];\n    // special case: `@container` can be in any order\n    if(k1 === '@container') {\n      if(Array.isArray(v1) && Array.isArray(v2)) {\n        v1 = v1.slice().sort();\n        v2 = v2.slice().sort();\n      }\n    }\n    if(!_deepCompare(v1, v2)) {\n      return false;\n    }\n  }\n  return true;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}