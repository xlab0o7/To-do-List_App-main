{"ast":null,"code":"import _regeneratorRuntime from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { encode as base64url } from '../../runtime/base64url.js';\nimport _sign from '../../runtime/sign.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport var FlattenedSign = /*#__PURE__*/function () {\n  function FlattenedSign(payload) {\n    _classCallCheck(this, FlattenedSign);\n    if (!(payload instanceof Uint8Array)) {\n      throw new TypeError('payload must be an instance of Uint8Array');\n    }\n    this._payload = payload;\n  }\n  _createClass(FlattenedSign, [{\n    key: \"setProtectedHeader\",\n    value: function setProtectedHeader(protectedHeader) {\n      if (this._protectedHeader) {\n        throw new TypeError('setProtectedHeader can only be called once');\n      }\n      this._protectedHeader = protectedHeader;\n      return this;\n    }\n  }, {\n    key: \"setUnprotectedHeader\",\n    value: function setUnprotectedHeader(unprotectedHeader) {\n      if (this._unprotectedHeader) {\n        throw new TypeError('setUnprotectedHeader can only be called once');\n      }\n      this._unprotectedHeader = unprotectedHeader;\n      return this;\n    }\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key, options) {\n        var joseHeader, extensions, b64, alg, payload, protectedHeader, data, signature, jws;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!this._protectedHeader && !this._unprotectedHeader)) {\n                _context.next = 2;\n                break;\n              }\n              throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n            case 2:\n              if (isDisjoint(this._protectedHeader, this._unprotectedHeader)) {\n                _context.next = 4;\n                break;\n              }\n              throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n            case 4:\n              joseHeader = _objectSpread(_objectSpread({}, this._protectedHeader), this._unprotectedHeader);\n              extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n              b64 = true;\n              if (!extensions.has('b64')) {\n                _context.next = 11;\n                break;\n              }\n              b64 = this._protectedHeader.b64;\n              if (!(typeof b64 !== 'boolean')) {\n                _context.next = 11;\n                break;\n              }\n              throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            case 11:\n              alg = joseHeader.alg;\n              if (!(typeof alg !== 'string' || !alg)) {\n                _context.next = 14;\n                break;\n              }\n              throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n            case 14:\n              checkKeyType(alg, key, 'sign');\n              payload = this._payload;\n              if (b64) {\n                payload = encoder.encode(base64url(payload));\n              }\n              if (this._protectedHeader) {\n                protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n              } else {\n                protectedHeader = encoder.encode('');\n              }\n              data = concat(protectedHeader, encoder.encode('.'), payload);\n              _context.next = 21;\n              return _sign(alg, key, data);\n            case 21:\n              signature = _context.sent;\n              jws = {\n                signature: base64url(signature),\n                payload: ''\n              };\n              if (b64) {\n                jws.payload = decoder.decode(payload);\n              }\n              if (this._unprotectedHeader) {\n                jws.header = this._unprotectedHeader;\n              }\n              if (this._protectedHeader) {\n                jws.protected = decoder.decode(protectedHeader);\n              }\n              return _context.abrupt(\"return\", jws);\n            case 27:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function sign(_x, _x2) {\n        return _sign2.apply(this, arguments);\n      }\n      return sign;\n    }()\n  }]);\n  return FlattenedSign;\n}();","map":{"version":3,"names":["encode","base64url","sign","isDisjoint","JWSInvalid","encoder","decoder","concat","checkKeyType","validateCrit","FlattenedSign","payload","Uint8Array","TypeError","_payload","protectedHeader","_protectedHeader","unprotectedHeader","_unprotectedHeader","key","options","joseHeader","extensions","Map","crit","b64","has","alg","JSON","stringify","data","signature","jws","decode","header","protected"],"sources":["E:/react-todo-app/node_modules/jose/dist/browser/jws/flattened/sign.js"],"sourcesContent":["import { encode as base64url } from '../../runtime/base64url.js';\nimport sign from '../../runtime/sign.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { JWSInvalid } from '../../util/errors.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport class FlattenedSign {\n    constructor(payload) {\n        if (!(payload instanceof Uint8Array)) {\n            throw new TypeError('payload must be an instance of Uint8Array');\n        }\n        this._payload = payload;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    async sign(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader) {\n            throw new JWSInvalid('either setProtectedHeader or setUnprotectedHeader must be called before #sign()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader)) {\n            throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n        };\n        const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        let b64 = true;\n        if (extensions.has('b64')) {\n            b64 = this._protectedHeader.b64;\n            if (typeof b64 !== 'boolean') {\n                throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n            }\n        }\n        const { alg } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        checkKeyType(alg, key, 'sign');\n        let payload = this._payload;\n        if (b64) {\n            payload = encoder.encode(base64url(payload));\n        }\n        let protectedHeader;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        const data = concat(protectedHeader, encoder.encode('.'), payload);\n        const signature = await sign(alg, key, data);\n        const jws = {\n            signature: base64url(signature),\n            payload: '',\n        };\n        if (b64) {\n            jws.payload = decoder.decode(payload);\n        }\n        if (this._unprotectedHeader) {\n            jws.header = this._unprotectedHeader;\n        }\n        if (this._protectedHeader) {\n            jws.protected = decoder.decode(protectedHeader);\n        }\n        return jws;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}