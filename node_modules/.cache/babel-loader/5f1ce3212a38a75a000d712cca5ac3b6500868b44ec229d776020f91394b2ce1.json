{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {\n  isKeyword\n} = require('./context');\nconst graphTypes = require('./graphTypes');\nconst types = require('./types');\nconst util = require('./util');\nconst JsonLdError = require('./JsonLdError');\nconst api = {};\nmodule.exports = api;\n\n/**\n * Creates a merged JSON-LD node map (node ID => node).\n *\n * @param input the expanded JSON-LD to create a node map of.\n * @param [options] the options to use:\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *\n * @return the node map.\n */\napi.createMergedNodeMap = (input, options) => {\n  options = options || {};\n\n  // produce a map of all subjects and name each bnode\n  const issuer = options.issuer || new util.IdentifierIssuer('_:b');\n  const graphs = {\n    '@default': {}\n  };\n  api.createNodeMap(input, graphs, '@default', issuer);\n\n  // add all non-default graphs to default graph\n  return api.mergeNodeMaps(graphs);\n};\n\n/**\n * Recursively flattens the subjects in the given JSON-LD expanded input\n * into a node map.\n *\n * @param input the JSON-LD expanded input.\n * @param graphs a map of graph name to subject map.\n * @param graph the name of the current graph.\n * @param issuer the blank node identifier issuer.\n * @param name the name assigned to the current input if it is a bnode.\n * @param list the list to append to, null for none.\n */\napi.createNodeMap = (input, graphs, graph, issuer, name, list) => {\n  // recurse through array\n  if (types.isArray(input)) {\n    for (const node of input) {\n      api.createNodeMap(node, graphs, graph, issuer, undefined, list);\n    }\n    return;\n  }\n\n  // add non-object to list\n  if (!types.isObject(input)) {\n    if (list) {\n      list.push(input);\n    }\n    return;\n  }\n\n  // add values to list\n  if (graphTypes.isValue(input)) {\n    if ('@type' in input) {\n      let type = input['@type'];\n      // rename @type blank node\n      if (type.indexOf('_:') === 0) {\n        input['@type'] = type = issuer.getId(type);\n      }\n    }\n    if (list) {\n      list.push(input);\n    }\n    return;\n  } else if (list && graphTypes.isList(input)) {\n    const _list = [];\n    api.createNodeMap(input['@list'], graphs, graph, issuer, name, _list);\n    list.push({\n      '@list': _list\n    });\n    return;\n  }\n\n  // Note: At this point, input must be a subject.\n\n  // spec requires @type to be named first, so assign names early\n  if ('@type' in input) {\n    const types = input['@type'];\n    for (const type of types) {\n      if (type.indexOf('_:') === 0) {\n        issuer.getId(type);\n      }\n    }\n  }\n\n  // get name for subject\n  if (types.isUndefined(name)) {\n    name = graphTypes.isBlankNode(input) ? issuer.getId(input['@id']) : input['@id'];\n  }\n\n  // add subject reference to list\n  if (list) {\n    list.push({\n      '@id': name\n    });\n  }\n\n  // create new subject or merge into existing one\n  const subjects = graphs[graph];\n  const subject = subjects[name] = subjects[name] || {};\n  subject['@id'] = name;\n  const properties = Object.keys(input).sort();\n  for (let property of properties) {\n    // skip @id\n    if (property === '@id') {\n      continue;\n    }\n\n    // handle reverse properties\n    if (property === '@reverse') {\n      const referencedNode = {\n        '@id': name\n      };\n      const reverseMap = input['@reverse'];\n      for (const reverseProperty in reverseMap) {\n        const items = reverseMap[reverseProperty];\n        for (const item of items) {\n          let itemName = item['@id'];\n          if (graphTypes.isBlankNode(item)) {\n            itemName = issuer.getId(itemName);\n          }\n          api.createNodeMap(item, graphs, graph, issuer, itemName);\n          util.addValue(subjects[itemName], reverseProperty, referencedNode, {\n            propertyIsArray: true,\n            allowDuplicate: false\n          });\n        }\n      }\n      continue;\n    }\n\n    // recurse into graph\n    if (property === '@graph') {\n      // add graph subjects map entry\n      if (!(name in graphs)) {\n        graphs[name] = {};\n      }\n      api.createNodeMap(input[property], graphs, name, issuer);\n      continue;\n    }\n\n    // recurse into included\n    if (property === '@included') {\n      api.createNodeMap(input[property], graphs, graph, issuer);\n      continue;\n    }\n\n    // copy non-@type keywords\n    if (property !== '@type' && isKeyword(property)) {\n      if (property === '@index' && property in subject && (input[property] !== subject[property] || input[property]['@id'] !== subject[property]['@id'])) {\n        throw new JsonLdError('Invalid JSON-LD syntax; conflicting @index property detected.', 'jsonld.SyntaxError', {\n          code: 'conflicting indexes',\n          subject\n        });\n      }\n      subject[property] = input[property];\n      continue;\n    }\n\n    // iterate over objects\n    const objects = input[property];\n\n    // if property is a bnode, assign it a new id\n    if (property.indexOf('_:') === 0) {\n      property = issuer.getId(property);\n    }\n\n    // ensure property is added for empty arrays\n    if (objects.length === 0) {\n      util.addValue(subject, property, [], {\n        propertyIsArray: true\n      });\n      continue;\n    }\n    for (let o of objects) {\n      if (property === '@type') {\n        // rename @type blank nodes\n        o = o.indexOf('_:') === 0 ? issuer.getId(o) : o;\n      }\n\n      // handle embedded subject or subject reference\n      if (graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {\n        // skip null @id\n        if ('@id' in o && !o['@id']) {\n          continue;\n        }\n\n        // relabel blank node @id\n        const id = graphTypes.isBlankNode(o) ? issuer.getId(o['@id']) : o['@id'];\n\n        // add reference and recurse\n        util.addValue(subject, property, {\n          '@id': id\n        }, {\n          propertyIsArray: true,\n          allowDuplicate: false\n        });\n        api.createNodeMap(o, graphs, graph, issuer, id);\n      } else if (graphTypes.isValue(o)) {\n        util.addValue(subject, property, o, {\n          propertyIsArray: true,\n          allowDuplicate: false\n        });\n      } else if (graphTypes.isList(o)) {\n        // handle @list\n        const _list = [];\n        api.createNodeMap(o['@list'], graphs, graph, issuer, name, _list);\n        o = {\n          '@list': _list\n        };\n        util.addValue(subject, property, o, {\n          propertyIsArray: true,\n          allowDuplicate: false\n        });\n      } else {\n        // handle @value\n        api.createNodeMap(o, graphs, graph, issuer, name);\n        util.addValue(subject, property, o, {\n          propertyIsArray: true,\n          allowDuplicate: false\n        });\n      }\n    }\n  }\n};\n\n/**\n * Merge separate named graphs into a single merged graph including\n * all nodes from the default graph and named graphs.\n *\n * @param graphs a map of graph name to subject map.\n *\n * @return the merged graph map.\n */\napi.mergeNodeMapGraphs = graphs => {\n  const merged = {};\n  for (const name of Object.keys(graphs).sort()) {\n    for (const id of Object.keys(graphs[name]).sort()) {\n      const node = graphs[name][id];\n      if (!(id in merged)) {\n        merged[id] = {\n          '@id': id\n        };\n      }\n      const mergedNode = merged[id];\n      for (const property of Object.keys(node).sort()) {\n        if (isKeyword(property) && property !== '@type') {\n          // copy keywords\n          mergedNode[property] = util.clone(node[property]);\n        } else {\n          // merge objects\n          for (const value of node[property]) {\n            util.addValue(mergedNode, property, util.clone(value), {\n              propertyIsArray: true,\n              allowDuplicate: false\n            });\n          }\n        }\n      }\n    }\n  }\n  return merged;\n};\napi.mergeNodeMaps = graphs => {\n  // add all non-default graphs to default graph\n  const defaultGraph = graphs['@default'];\n  const graphNames = Object.keys(graphs).sort();\n  for (const graphName of graphNames) {\n    if (graphName === '@default') {\n      continue;\n    }\n    const nodeMap = graphs[graphName];\n    let subject = defaultGraph[graphName];\n    if (!subject) {\n      defaultGraph[graphName] = subject = {\n        '@id': graphName,\n        '@graph': []\n      };\n    } else if (!('@graph' in subject)) {\n      subject['@graph'] = [];\n    }\n    const graph = subject['@graph'];\n    for (const id of Object.keys(nodeMap).sort()) {\n      const node = nodeMap[id];\n      // only add full subjects\n      if (!graphTypes.isSubjectReference(node)) {\n        graph.push(node);\n      }\n    }\n  }\n  return defaultGraph;\n};","map":{"version":3,"names":["isKeyword","require","graphTypes","types","util","JsonLdError","api","module","exports","createMergedNodeMap","input","options","issuer","IdentifierIssuer","graphs","createNodeMap","mergeNodeMaps","graph","name","list","isArray","node","undefined","isObject","push","isValue","type","indexOf","getId","isList","_list","isUndefined","isBlankNode","subjects","subject","properties","Object","keys","sort","property","referencedNode","reverseMap","reverseProperty","items","item","itemName","addValue","propertyIsArray","allowDuplicate","code","objects","length","o","isSubject","isSubjectReference","id","mergeNodeMapGraphs","merged","mergedNode","clone","value","defaultGraph","graphNames","graphName","nodeMap"],"sources":["G:/To-do-List_App-main/node_modules/jsonld/lib/nodeMap.js"],"sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {isKeyword} = require('./context');\nconst graphTypes = require('./graphTypes');\nconst types = require('./types');\nconst util = require('./util');\nconst JsonLdError = require('./JsonLdError');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Creates a merged JSON-LD node map (node ID => node).\n *\n * @param input the expanded JSON-LD to create a node map of.\n * @param [options] the options to use:\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *\n * @return the node map.\n */\napi.createMergedNodeMap = (input, options) => {\n  options = options || {};\n\n  // produce a map of all subjects and name each bnode\n  const issuer = options.issuer || new util.IdentifierIssuer('_:b');\n  const graphs = {'@default': {}};\n  api.createNodeMap(input, graphs, '@default', issuer);\n\n  // add all non-default graphs to default graph\n  return api.mergeNodeMaps(graphs);\n};\n\n/**\n * Recursively flattens the subjects in the given JSON-LD expanded input\n * into a node map.\n *\n * @param input the JSON-LD expanded input.\n * @param graphs a map of graph name to subject map.\n * @param graph the name of the current graph.\n * @param issuer the blank node identifier issuer.\n * @param name the name assigned to the current input if it is a bnode.\n * @param list the list to append to, null for none.\n */\napi.createNodeMap = (input, graphs, graph, issuer, name, list) => {\n  // recurse through array\n  if(types.isArray(input)) {\n    for(const node of input) {\n      api.createNodeMap(node, graphs, graph, issuer, undefined, list);\n    }\n    return;\n  }\n\n  // add non-object to list\n  if(!types.isObject(input)) {\n    if(list) {\n      list.push(input);\n    }\n    return;\n  }\n\n  // add values to list\n  if(graphTypes.isValue(input)) {\n    if('@type' in input) {\n      let type = input['@type'];\n      // rename @type blank node\n      if(type.indexOf('_:') === 0) {\n        input['@type'] = type = issuer.getId(type);\n      }\n    }\n    if(list) {\n      list.push(input);\n    }\n    return;\n  } else if(list && graphTypes.isList(input)) {\n    const _list = [];\n    api.createNodeMap(input['@list'], graphs, graph, issuer, name, _list);\n    list.push({'@list': _list});\n    return;\n  }\n\n  // Note: At this point, input must be a subject.\n\n  // spec requires @type to be named first, so assign names early\n  if('@type' in input) {\n    const types = input['@type'];\n    for(const type of types) {\n      if(type.indexOf('_:') === 0) {\n        issuer.getId(type);\n      }\n    }\n  }\n\n  // get name for subject\n  if(types.isUndefined(name)) {\n    name = graphTypes.isBlankNode(input) ?\n      issuer.getId(input['@id']) : input['@id'];\n  }\n\n  // add subject reference to list\n  if(list) {\n    list.push({'@id': name});\n  }\n\n  // create new subject or merge into existing one\n  const subjects = graphs[graph];\n  const subject = subjects[name] = subjects[name] || {};\n  subject['@id'] = name;\n  const properties = Object.keys(input).sort();\n  for(let property of properties) {\n    // skip @id\n    if(property === '@id') {\n      continue;\n    }\n\n    // handle reverse properties\n    if(property === '@reverse') {\n      const referencedNode = {'@id': name};\n      const reverseMap = input['@reverse'];\n      for(const reverseProperty in reverseMap) {\n        const items = reverseMap[reverseProperty];\n        for(const item of items) {\n          let itemName = item['@id'];\n          if(graphTypes.isBlankNode(item)) {\n            itemName = issuer.getId(itemName);\n          }\n          api.createNodeMap(item, graphs, graph, issuer, itemName);\n          util.addValue(\n            subjects[itemName], reverseProperty, referencedNode,\n            {propertyIsArray: true, allowDuplicate: false});\n        }\n      }\n      continue;\n    }\n\n    // recurse into graph\n    if(property === '@graph') {\n      // add graph subjects map entry\n      if(!(name in graphs)) {\n        graphs[name] = {};\n      }\n      api.createNodeMap(input[property], graphs, name, issuer);\n      continue;\n    }\n\n    // recurse into included\n    if(property === '@included') {\n      api.createNodeMap(input[property], graphs, graph, issuer);\n      continue;\n    }\n\n    // copy non-@type keywords\n    if(property !== '@type' && isKeyword(property)) {\n      if(property === '@index' && property in subject &&\n        (input[property] !== subject[property] ||\n        input[property]['@id'] !== subject[property]['@id'])) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; conflicting @index property detected.',\n          'jsonld.SyntaxError',\n          {code: 'conflicting indexes', subject});\n      }\n      subject[property] = input[property];\n      continue;\n    }\n\n    // iterate over objects\n    const objects = input[property];\n\n    // if property is a bnode, assign it a new id\n    if(property.indexOf('_:') === 0) {\n      property = issuer.getId(property);\n    }\n\n    // ensure property is added for empty arrays\n    if(objects.length === 0) {\n      util.addValue(subject, property, [], {propertyIsArray: true});\n      continue;\n    }\n    for(let o of objects) {\n      if(property === '@type') {\n        // rename @type blank nodes\n        o = (o.indexOf('_:') === 0) ? issuer.getId(o) : o;\n      }\n\n      // handle embedded subject or subject reference\n      if(graphTypes.isSubject(o) || graphTypes.isSubjectReference(o)) {\n        // skip null @id\n        if('@id' in o && !o['@id']) {\n          continue;\n        }\n\n        // relabel blank node @id\n        const id = graphTypes.isBlankNode(o) ?\n          issuer.getId(o['@id']) : o['@id'];\n\n        // add reference and recurse\n        util.addValue(\n          subject, property, {'@id': id},\n          {propertyIsArray: true, allowDuplicate: false});\n        api.createNodeMap(o, graphs, graph, issuer, id);\n      } else if(graphTypes.isValue(o)) {\n        util.addValue(\n          subject, property, o,\n          {propertyIsArray: true, allowDuplicate: false});\n      } else if(graphTypes.isList(o)) {\n        // handle @list\n        const _list = [];\n        api.createNodeMap(o['@list'], graphs, graph, issuer, name, _list);\n        o = {'@list': _list};\n        util.addValue(\n          subject, property, o,\n          {propertyIsArray: true, allowDuplicate: false});\n      } else {\n        // handle @value\n        api.createNodeMap(o, graphs, graph, issuer, name);\n        util.addValue(\n          subject, property, o, {propertyIsArray: true, allowDuplicate: false});\n      }\n    }\n  }\n};\n\n/**\n * Merge separate named graphs into a single merged graph including\n * all nodes from the default graph and named graphs.\n *\n * @param graphs a map of graph name to subject map.\n *\n * @return the merged graph map.\n */\napi.mergeNodeMapGraphs = graphs => {\n  const merged = {};\n  for(const name of Object.keys(graphs).sort()) {\n    for(const id of Object.keys(graphs[name]).sort()) {\n      const node = graphs[name][id];\n      if(!(id in merged)) {\n        merged[id] = {'@id': id};\n      }\n      const mergedNode = merged[id];\n\n      for(const property of Object.keys(node).sort()) {\n        if(isKeyword(property) && property !== '@type') {\n          // copy keywords\n          mergedNode[property] = util.clone(node[property]);\n        } else {\n          // merge objects\n          for(const value of node[property]) {\n            util.addValue(\n              mergedNode, property, util.clone(value),\n              {propertyIsArray: true, allowDuplicate: false});\n          }\n        }\n      }\n    }\n  }\n\n  return merged;\n};\n\napi.mergeNodeMaps = graphs => {\n  // add all non-default graphs to default graph\n  const defaultGraph = graphs['@default'];\n  const graphNames = Object.keys(graphs).sort();\n  for(const graphName of graphNames) {\n    if(graphName === '@default') {\n      continue;\n    }\n    const nodeMap = graphs[graphName];\n    let subject = defaultGraph[graphName];\n    if(!subject) {\n      defaultGraph[graphName] = subject = {\n        '@id': graphName,\n        '@graph': []\n      };\n    } else if(!('@graph' in subject)) {\n      subject['@graph'] = [];\n    }\n    const graph = subject['@graph'];\n    for(const id of Object.keys(nodeMap).sort()) {\n      const node = nodeMap[id];\n      // only add full subjects\n      if(!graphTypes.isSubjectReference(node)) {\n        graph.push(node);\n      }\n    }\n  }\n  return defaultGraph;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}