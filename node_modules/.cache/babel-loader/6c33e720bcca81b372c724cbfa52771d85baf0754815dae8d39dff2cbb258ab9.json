{"ast":null,"code":"import _regeneratorRuntime from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectWithoutProperties from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _asyncToGenerator from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar _excluded = [\"payload\"];\nimport { FlattenedSign } from '../flattened/sign.js';\nimport { JWSInvalid } from '../../util/errors.js';\nvar IndividualSignature = /*#__PURE__*/function () {\n  function IndividualSignature(sig, key, options) {\n    _classCallCheck(this, IndividualSignature);\n    this.parent = sig;\n    this.key = key;\n    this.options = options;\n  }\n  _createClass(IndividualSignature, [{\n    key: \"setProtectedHeader\",\n    value: function setProtectedHeader(protectedHeader) {\n      if (this.protectedHeader) {\n        throw new TypeError('setProtectedHeader can only be called once');\n      }\n      this.protectedHeader = protectedHeader;\n      return this;\n    }\n  }, {\n    key: \"setUnprotectedHeader\",\n    value: function setUnprotectedHeader(unprotectedHeader) {\n      if (this.unprotectedHeader) {\n        throw new TypeError('setUnprotectedHeader can only be called once');\n      }\n      this.unprotectedHeader = unprotectedHeader;\n      return this;\n    }\n  }, {\n    key: \"addSignature\",\n    value: function addSignature() {\n      var _this$parent;\n      return (_this$parent = this.parent).addSignature.apply(_this$parent, arguments);\n    }\n  }, {\n    key: \"sign\",\n    value: function sign() {\n      var _this$parent2;\n      return (_this$parent2 = this.parent).sign.apply(_this$parent2, arguments);\n    }\n  }, {\n    key: \"done\",\n    value: function done() {\n      return this.parent;\n    }\n  }]);\n  return IndividualSignature;\n}();\nexport var GeneralSign = /*#__PURE__*/function () {\n  function GeneralSign(payload) {\n    _classCallCheck(this, GeneralSign);\n    this._signatures = [];\n    this._payload = payload;\n  }\n  _createClass(GeneralSign, [{\n    key: \"addSignature\",\n    value: function addSignature(key, options) {\n      var signature = new IndividualSignature(this, key, options);\n      this._signatures.push(signature);\n      return signature;\n    }\n  }, {\n    key: \"sign\",\n    value: function () {\n      var _sign = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var jws, i, signature, flattened, _yield$flattened$sign, payload, rest;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (this._signatures.length) {\n                _context.next = 2;\n                break;\n              }\n              throw new JWSInvalid('at least one signature must be added');\n            case 2:\n              jws = {\n                signatures: [],\n                payload: ''\n              };\n              i = 0;\n            case 4:\n              if (!(i < this._signatures.length)) {\n                _context.next = 24;\n                break;\n              }\n              signature = this._signatures[i];\n              flattened = new FlattenedSign(this._payload);\n              flattened.setProtectedHeader(signature.protectedHeader);\n              flattened.setUnprotectedHeader(signature.unprotectedHeader);\n              _context.next = 11;\n              return flattened.sign(signature.key, signature.options);\n            case 11:\n              _yield$flattened$sign = _context.sent;\n              payload = _yield$flattened$sign.payload;\n              rest = _objectWithoutProperties(_yield$flattened$sign, _excluded);\n              if (!(i === 0)) {\n                _context.next = 18;\n                break;\n              }\n              jws.payload = payload;\n              _context.next = 20;\n              break;\n            case 18:\n              if (!(jws.payload !== payload)) {\n                _context.next = 20;\n                break;\n              }\n              throw new JWSInvalid('inconsistent use of JWS Unencoded Payload Option (RFC7797)');\n            case 20:\n              jws.signatures.push(rest);\n            case 21:\n              i++;\n              _context.next = 4;\n              break;\n            case 24:\n              return _context.abrupt(\"return\", jws);\n            case 25:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function sign() {\n        return _sign.apply(this, arguments);\n      }\n      return sign;\n    }()\n  }]);\n  return GeneralSign;\n}();","map":{"version":3,"names":["FlattenedSign","JWSInvalid","IndividualSignature","sig","key","options","parent","protectedHeader","TypeError","unprotectedHeader","addSignature","sign","GeneralSign","payload","_signatures","_payload","signature","push","length","jws","signatures","i","flattened","setProtectedHeader","setUnprotectedHeader","rest"],"sources":["E:/react-todo-app/node_modules/jose/dist/browser/jws/general/sign.js"],"sourcesContent":["import { FlattenedSign } from '../flattened/sign.js';\nimport { JWSInvalid } from '../../util/errors.js';\nclass IndividualSignature {\n    constructor(sig, key, options) {\n        this.parent = sig;\n        this.key = key;\n        this.options = options;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this.protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this.protectedHeader = protectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    addSignature(...args) {\n        return this.parent.addSignature(...args);\n    }\n    sign(...args) {\n        return this.parent.sign(...args);\n    }\n    done() {\n        return this.parent;\n    }\n}\nexport class GeneralSign {\n    constructor(payload) {\n        this._signatures = [];\n        this._payload = payload;\n    }\n    addSignature(key, options) {\n        const signature = new IndividualSignature(this, key, options);\n        this._signatures.push(signature);\n        return signature;\n    }\n    async sign() {\n        if (!this._signatures.length) {\n            throw new JWSInvalid('at least one signature must be added');\n        }\n        const jws = {\n            signatures: [],\n            payload: '',\n        };\n        for (let i = 0; i < this._signatures.length; i++) {\n            const signature = this._signatures[i];\n            const flattened = new FlattenedSign(this._payload);\n            flattened.setProtectedHeader(signature.protectedHeader);\n            flattened.setUnprotectedHeader(signature.unprotectedHeader);\n            const { payload, ...rest } = await flattened.sign(signature.key, signature.options);\n            if (i === 0) {\n                jws.payload = payload;\n            }\n            else if (jws.payload !== payload) {\n                throw new JWSInvalid('inconsistent use of JWS Unencoded Payload Option (RFC7797)');\n            }\n            jws.signatures.push(rest);\n        }\n        return jws;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}