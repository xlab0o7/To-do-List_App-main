{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _objectSpread = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _classCallCheck = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _assertThisInitialized = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/assertThisInitialized.js\").default;\nvar _inherits = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/inherits.js\").default;\nvar _createSuper = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createSuper.js\").default;\nvar _asyncToGenerator = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Session = exports.silentlyAuthenticate = void 0;\nvar events_1 = require(\"events\");\nvar solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\nvar uuid_1 = require(\"uuid\");\nvar dependencies_1 = require(\"./dependencies\");\nvar constant_1 = require(\"./constant\");\nfunction silentlyAuthenticate(_x, _x2, _x3) {\n  return _silentlyAuthenticate.apply(this, arguments);\n}\nfunction _silentlyAuthenticate() {\n  _silentlyAuthenticate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(sessionId, clientAuthn, session) {\n    var _a, storedSessionInfo;\n    return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n      while (1) switch (_context6.prev = _context6.next) {\n        case 0:\n          _context6.next = 2;\n          return clientAuthn.validateCurrentSession(sessionId);\n        case 2:\n          storedSessionInfo = _context6.sent;\n          if (!(storedSessionInfo !== null)) {\n            _context6.next = 8;\n            break;\n          }\n          window.localStorage.setItem(constant_1.KEY_CURRENT_URL, window.location.href);\n          _context6.next = 7;\n          return clientAuthn.login({\n            sessionId: sessionId,\n            prompt: \"none\",\n            oidcIssuer: storedSessionInfo.issuer,\n            redirectUrl: storedSessionInfo.redirectUrl,\n            clientId: storedSessionInfo.clientAppId,\n            clientSecret: storedSessionInfo.clientAppSecret,\n            tokenType: (_a = storedSessionInfo.tokenType) !== null && _a !== void 0 ? _a : \"DPoP\"\n          }, session);\n        case 7:\n          return _context6.abrupt(\"return\", true);\n        case 8:\n          return _context6.abrupt(\"return\", false);\n        case 9:\n        case \"end\":\n          return _context6.stop();\n      }\n    }, _callee6);\n  }));\n  return _silentlyAuthenticate.apply(this, arguments);\n}\nexports.silentlyAuthenticate = silentlyAuthenticate;\nfunction isLoggedIn(sessionInfo) {\n  return !!(sessionInfo === null || sessionInfo === void 0 ? void 0 : sessionInfo.isLoggedIn);\n}\nvar Session = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(Session, _events_1$EventEmitte);\n  var _super = _createSuper(Session);\n  function Session() {\n    var _this;\n    var sessionOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var sessionId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    _classCallCheck(this, Session);\n    _this = _super.call(this);\n    _this.tokenRequestInProgress = false;\n    _this.login = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {\n        var _a;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _this.clientAuthentication.login(_objectSpread(_objectSpread({\n                sessionId: _this.info.sessionId\n              }, options), {}, {\n                tokenType: (_a = options.tokenType) !== null && _a !== void 0 ? _a : \"DPoP\"\n              }), _assertThisInitialized(_this));\n            case 2:\n              return _context.abrupt(\"return\", new Promise(function () {}));\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function (_x4) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    _this.fetch = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(url, init) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", _this.clientAuthentication.fetch(url, init));\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      return function (_x5, _x6) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    _this.internalLogout = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(emitSignal) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              window.localStorage.removeItem(constant_1.KEY_CURRENT_SESSION);\n              _context3.next = 3;\n              return _this.clientAuthentication.logout(_this.info.sessionId);\n            case 3:\n              _this.info.isLoggedIn = false;\n              if (emitSignal) {\n                _this.emit(solid_client_authn_core_1.EVENTS.LOGOUT);\n              }\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }));\n      return function (_x7) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n    _this.logout = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            return _context4.abrupt(\"return\", _this.internalLogout(true));\n          case 1:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }));\n    _this.handleIncomingRedirect = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n      var inputOptions,\n        _a,\n        options,\n        url,\n        sessionInfo,\n        currentUrl,\n        storedSessionId,\n        attemptedSilentAuthentication,\n        _args5 = arguments;\n      return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n        while (1) switch (_context5.prev = _context5.next) {\n          case 0:\n            inputOptions = _args5.length > 0 && _args5[0] !== undefined ? _args5[0] : {};\n            if (!_this.info.isLoggedIn) {\n              _context5.next = 3;\n              break;\n            }\n            return _context5.abrupt(\"return\", _this.info);\n          case 3:\n            if (!_this.tokenRequestInProgress) {\n              _context5.next = 5;\n              break;\n            }\n            return _context5.abrupt(\"return\", undefined);\n          case 5:\n            options = typeof inputOptions === \"string\" ? {\n              url: inputOptions\n            } : inputOptions;\n            url = (_a = options.url) !== null && _a !== void 0 ? _a : window.location.href;\n            _this.tokenRequestInProgress = true;\n            _context5.next = 10;\n            return _this.clientAuthentication.handleIncomingRedirect(url, _assertThisInitialized(_this));\n          case 10:\n            sessionInfo = _context5.sent;\n            if (!isLoggedIn(sessionInfo)) {\n              _context5.next = 17;\n              break;\n            }\n            _this.setSessionInfo(sessionInfo);\n            currentUrl = window.localStorage.getItem(constant_1.KEY_CURRENT_URL);\n            if (currentUrl === null) {\n              _this.emit(solid_client_authn_core_1.EVENTS.LOGIN);\n            } else {\n              window.localStorage.removeItem(constant_1.KEY_CURRENT_URL);\n              _this.emit(solid_client_authn_core_1.EVENTS.SESSION_RESTORED, currentUrl);\n            }\n            _context5.next = 25;\n            break;\n          case 17:\n            if (!(options.restorePreviousSession === true)) {\n              _context5.next = 25;\n              break;\n            }\n            storedSessionId = window.localStorage.getItem(constant_1.KEY_CURRENT_SESSION);\n            if (!(storedSessionId !== null)) {\n              _context5.next = 25;\n              break;\n            }\n            _context5.next = 22;\n            return silentlyAuthenticate(storedSessionId, _this.clientAuthentication, _assertThisInitialized(_this));\n          case 22:\n            attemptedSilentAuthentication = _context5.sent;\n            if (!attemptedSilentAuthentication) {\n              _context5.next = 25;\n              break;\n            }\n            return _context5.abrupt(\"return\", new Promise(function () {}));\n          case 25:\n            _this.tokenRequestInProgress = false;\n            return _context5.abrupt(\"return\", sessionInfo);\n          case 27:\n          case \"end\":\n            return _context5.stop();\n        }\n      }, _callee5);\n    }));\n    if (sessionOptions.clientAuthentication) {\n      _this.clientAuthentication = sessionOptions.clientAuthentication;\n    } else if (sessionOptions.secureStorage && sessionOptions.insecureStorage) {\n      _this.clientAuthentication = (0, dependencies_1.getClientAuthenticationWithDependencies)({\n        secureStorage: sessionOptions.secureStorage,\n        insecureStorage: sessionOptions.insecureStorage\n      });\n    } else {\n      _this.clientAuthentication = (0, dependencies_1.getClientAuthenticationWithDependencies)({});\n    }\n    if (sessionOptions.sessionInfo) {\n      _this.info = {\n        sessionId: sessionOptions.sessionInfo.sessionId,\n        isLoggedIn: false,\n        webId: sessionOptions.sessionInfo.webId\n      };\n    } else {\n      _this.info = {\n        sessionId: sessionId !== null && sessionId !== void 0 ? sessionId : (0, uuid_1.v4)(),\n        isLoggedIn: false\n      };\n    }\n    _this.on(solid_client_authn_core_1.EVENTS.LOGIN, function () {\n      return window.localStorage.setItem(constant_1.KEY_CURRENT_SESSION, _this.info.sessionId);\n    });\n    _this.on(solid_client_authn_core_1.EVENTS.SESSION_EXPIRED, function () {\n      return _this.internalLogout(false);\n    });\n    _this.on(solid_client_authn_core_1.EVENTS.ERROR, function () {\n      return _this.internalLogout(false);\n    });\n    return _this;\n  }\n  _createClass(Session, [{\n    key: \"onLogin\",\n    value: function onLogin(callback) {\n      this.on(solid_client_authn_core_1.EVENTS.LOGIN, callback);\n    }\n  }, {\n    key: \"onLogout\",\n    value: function onLogout(callback) {\n      this.on(solid_client_authn_core_1.EVENTS.LOGOUT, callback);\n    }\n  }, {\n    key: \"onError\",\n    value: function onError(callback) {\n      this.on(solid_client_authn_core_1.EVENTS.ERROR, callback);\n    }\n  }, {\n    key: \"onSessionRestore\",\n    value: function onSessionRestore(callback) {\n      this.on(solid_client_authn_core_1.EVENTS.SESSION_RESTORED, callback);\n    }\n  }, {\n    key: \"onSessionExpiration\",\n    value: function onSessionExpiration(callback) {\n      this.on(solid_client_authn_core_1.EVENTS.SESSION_EXPIRED, callback);\n    }\n  }, {\n    key: \"setSessionInfo\",\n    value: function setSessionInfo(sessionInfo) {\n      var _this2 = this;\n      this.info.isLoggedIn = sessionInfo.isLoggedIn;\n      this.info.webId = sessionInfo.webId;\n      this.info.sessionId = sessionInfo.sessionId;\n      this.info.expirationDate = sessionInfo.expirationDate;\n      this.on(solid_client_authn_core_1.EVENTS.SESSION_EXTENDED, function (expiresIn) {\n        _this2.info.expirationDate = Date.now() + expiresIn * 1000;\n      });\n    }\n  }]);\n  return Session;\n}(events_1.EventEmitter);\nexports.Session = Session;","map":{"version":3,"mappings":"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","names":["silentlyAuthenticate","sessionId","clientAuthn","session","validateCurrentSession","storedSessionInfo","window","localStorage","setItem","constant_1","location","href","login","prompt","oidcIssuer","issuer","redirectUrl","clientId","clientAppId","clientSecret","clientAppSecret","tokenType","exports","isLoggedIn","sessionInfo","Session","sessionOptions","undefined","options","clientAuthentication","info","Promise","url","init","fetch","emitSignal","removeItem","logout","emit","solid_client_authn_core_1","LOGOUT","internalLogout","inputOptions","tokenRequestInProgress","handleIncomingRedirect","setSessionInfo","currentUrl","getItem","LOGIN","SESSION_RESTORED","restorePreviousSession","storedSessionId","attemptedSilentAuthentication","secureStorage","insecureStorage","webId","on","SESSION_EXPIRED","ERROR","callback","expirationDate","SESSION_EXTENDED","expiresIn","Date","now","events_1"],"sources":["E:\\react-todo-app\\node_modules\\@inrupt\\solid-client-authn-browser\\src\\Session.ts"],"sourcesContent":["//\n// Copyright 2022 Inrupt Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n// Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n/**\n * @hidden\n */\nimport { EventEmitter } from \"events\";\nimport {\n  EVENTS,\n  ILoginInputOptions,\n  ISessionInfo,\n  IStorage,\n} from \"@inrupt/solid-client-authn-core\";\nimport { v4 } from \"uuid\";\nimport ClientAuthentication from \"./ClientAuthentication\";\nimport { getClientAuthenticationWithDependencies } from \"./dependencies\";\nimport { KEY_CURRENT_SESSION, KEY_CURRENT_URL } from \"./constant\";\n\nexport interface ISessionOptions {\n  /**\n   * A private storage, unreachable to other scripts on the page. Typically in-memory.\n   */\n  secureStorage: IStorage;\n  /**\n   * A storage where non-sensitive information may be stored, potentially longer-lived than the secure storage.\n   */\n  insecureStorage: IStorage;\n  /**\n   * Details about the current session\n   */\n  sessionInfo: ISessionInfo;\n  /**\n   * An instance of the library core. Typically obtained using `getClientAuthenticationWithDependencies`.\n   */\n  clientAuthentication: ClientAuthentication;\n}\n\nexport interface IHandleIncomingRedirectOptions {\n  /**\n   * If the user has signed in before, setting this to `true` will automatically\n   * redirect them to their Solid Identity Provider, which will then attempt to\n   * re-activate the session and send the user back to your app without\n   * requiring user interaction.\n   * If your app's access has not expired yet and re-activation completed\n   * successfully, a `sessionRestore` event will be fired with the URL the user\n   * was at before they were redirected to their Solid Identity Provider.\n   * {@see onSessionRestore}\n   */\n  restorePreviousSession?: boolean;\n\n  /**\n   * Inrupt's Enterprise Solid Server can set a cookie to allow the browser to\n   * access private resources on a Pod. In order to mitigate the logout-on-refresh\n   * issue on the short term, the server also implemented a session endpoint\n   * enabling the client app to know whether the cookie is set. When a user\n   * logs in to a server that has that capability enabled, applications that set\n   * this option to `true` will be able to make use of it.\n   *\n   * If your app supports the newest session restore approach, and `restorePreviousSession`\n   * is set to true, this option is automatically set to false, but your app will\n   * not be logged out when reloaded.\n   *\n   * `useEssSession` defaults to false and will be removed in the future; to\n   * preserve sessions across page reloads, use of `restorePreviousSession` is\n   * recommended.\n   *\n   * @deprecated unreleased\n   */\n  useEssSession?: boolean;\n  /**\n   * The URL of the page handling the redirect, including the query\n   * parameters — these contain the information to process the login.\n   * Note: as a convenience, if no URL value is specified here, we default to\n   * using the browser's current location.\n   */\n  url?: string;\n}\n\nexport async function silentlyAuthenticate(\n  sessionId: string,\n  clientAuthn: ClientAuthentication,\n  session: Session\n): Promise<boolean> {\n  const storedSessionInfo = await clientAuthn.validateCurrentSession(sessionId);\n  if (storedSessionInfo !== null) {\n    // It can be really useful to save the user's current browser location,\n    // so that we can restore it after completing the silent authentication\n    // on incoming redirect. This way, the user is eventually redirected back\n    // to the page they were on and not to the app's redirect page.\n    window.localStorage.setItem(KEY_CURRENT_URL, window.location.href);\n    await clientAuthn.login(\n      {\n        sessionId,\n        prompt: \"none\",\n        oidcIssuer: storedSessionInfo.issuer,\n        redirectUrl: storedSessionInfo.redirectUrl,\n        clientId: storedSessionInfo.clientAppId,\n        clientSecret: storedSessionInfo.clientAppSecret,\n        tokenType: storedSessionInfo.tokenType ?? \"DPoP\",\n      },\n      session\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction isLoggedIn(\n  sessionInfo?: ISessionInfo\n): sessionInfo is ISessionInfo & { isLoggedIn: true } {\n  return !!sessionInfo?.isLoggedIn;\n}\n\n/**\n * A {@link Session} object represents a user's session on an application. The session holds state, as it stores information enabling acces to private resources after login for instance.\n */\nexport class Session extends EventEmitter {\n  /**\n   * Information regarding the current session.\n   */\n  public readonly info: ISessionInfo;\n\n  private clientAuthentication: ClientAuthentication;\n\n  private tokenRequestInProgress = false;\n\n  /**\n   * Session object constructor. Typically called as follows:\n   *\n   * ```typescript\n   * const session = new Session();\n   * ```\n   *\n   * See also [getDefaultSession](https://docs.inrupt.com/developer-tools/api/javascript/solid-client-authn-browser/functions.html#getdefaultsession).\n   *\n   * @param sessionOptions The options enabling the correct instantiation of\n   * the session. Either both storages or clientAuthentication are required. For\n   * more information, see {@link ISessionOptions}.\n   * @param sessionId A string uniquely identifying the session.\n   *\n   */\n  constructor(\n    sessionOptions: Partial<ISessionOptions> = {},\n    sessionId: string | undefined = undefined\n  ) {\n    super();\n\n    if (sessionOptions.clientAuthentication) {\n      this.clientAuthentication = sessionOptions.clientAuthentication;\n    } else if (sessionOptions.secureStorage && sessionOptions.insecureStorage) {\n      this.clientAuthentication = getClientAuthenticationWithDependencies({\n        secureStorage: sessionOptions.secureStorage,\n        insecureStorage: sessionOptions.insecureStorage,\n      });\n    } else {\n      this.clientAuthentication = getClientAuthenticationWithDependencies({});\n    }\n\n    if (sessionOptions.sessionInfo) {\n      this.info = {\n        sessionId: sessionOptions.sessionInfo.sessionId,\n        isLoggedIn: false,\n        webId: sessionOptions.sessionInfo.webId,\n      };\n    } else {\n      this.info = {\n        sessionId: sessionId ?? v4(),\n        isLoggedIn: false,\n      };\n    }\n\n    // When a session is logged in, we want to track its ID in local storage to\n    // enable silent refresh. The current session ID specifically stored in 'localStorage'\n    // (as opposed to using our storage abstraction layer) because it is only\n    // used in a browser-specific mechanism.\n    this.on(EVENTS.LOGIN, () =>\n      window.localStorage.setItem(KEY_CURRENT_SESSION, this.info.sessionId)\n    );\n\n    this.on(EVENTS.SESSION_EXPIRED, () => this.internalLogout(false));\n\n    this.on(EVENTS.ERROR, () => this.internalLogout(false));\n  }\n\n  /**\n   * Triggers the login process. Note that this method will redirect the user away from your app.\n   *\n   * @param options Parameter to customize the login behaviour. In particular, two options are mandatory: `options.oidcIssuer`, the user's identity provider, and `options.redirectUrl`, the URL to which the user will be redirected after logging in their identity provider.\n   * @returns This method should redirect the user away from the app: it does not return anything. The login process is completed by {@linkcode handleIncomingRedirect}.\n   */\n  // Define these functions as properties so that they don't get accidentally re-bound.\n  // Isn't Javascript fun?\n  login = async (options: ILoginInputOptions): Promise<void> => {\n    await this.clientAuthentication.login(\n      {\n        sessionId: this.info.sessionId,\n        ...options,\n        // Defaults the token type to DPoP\n        tokenType: options.tokenType ?? \"DPoP\",\n      },\n      this\n    );\n    // `login` redirects the user away from the app,\n    // so unless it throws an error, there is no code that should run afterwards\n    // (since there is no \"after\" in the lifetime of the script).\n    // Hence, this Promise never resolves:\n    return new Promise(() => {});\n  };\n\n  /**\n   * Fetches data using available login information. If the user is not logged in, this will behave as a regular `fetch`. The signature of this method is identical to the [canonical `fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n   *\n   * @param url The URL from which data should be fetched.\n   * @param init Optional parameters customizing the request, by specifying an HTTP method, headers, a body, etc. Follows the [WHATWG Fetch Standard](https://fetch.spec.whatwg.org/).\n   */\n  fetch: typeof fetch = async (url, init) => {\n    return this.clientAuthentication.fetch(url, init);\n  };\n\n  /**\n   * An internal logout function, to control whether or not the logout signal\n   * should be sent, i.e. if the logout was user-initiated or is the result of\n   * an external event.\n   *\n   * @hidden\n   */\n  private internalLogout = async (emitSignal: boolean): Promise<void> => {\n    // Clearing this value means that silent refresh will no longer be attempted.\n    // In particular, in the case of a silent authentication error it prevents\n    // from getting stuck in an authentication retries loop.\n    window.localStorage.removeItem(KEY_CURRENT_SESSION);\n    await this.clientAuthentication.logout(this.info.sessionId);\n    this.info.isLoggedIn = false;\n    if (emitSignal) {\n      this.emit(EVENTS.LOGOUT);\n    }\n  };\n\n  /**\n   * Logs the user out of the application. This does not log the user out of their Solid identity provider, and should not redirect the user away.\n   */\n  logout = async (): Promise<void> => this.internalLogout(true);\n\n  /**\n   * Completes the login process by processing the information provided by the\n   * Solid identity provider through redirect.\n   *\n   * @param options See {@see IHandleIncomingRedirectOptions}.\n   */\n  handleIncomingRedirect = async (\n    inputOptions: string | IHandleIncomingRedirectOptions = {}\n  ): Promise<ISessionInfo | undefined> => {\n    if (this.info.isLoggedIn) {\n      return this.info;\n    }\n\n    if (this.tokenRequestInProgress) {\n      return undefined;\n    }\n    const options =\n      typeof inputOptions === \"string\" ? { url: inputOptions } : inputOptions;\n    const url = options.url ?? window.location.href;\n\n    this.tokenRequestInProgress = true;\n    const sessionInfo = await this.clientAuthentication.handleIncomingRedirect(\n      url,\n      this\n    );\n    if (isLoggedIn(sessionInfo)) {\n      this.setSessionInfo(sessionInfo);\n      const currentUrl = window.localStorage.getItem(KEY_CURRENT_URL);\n      if (currentUrl === null) {\n        // The login event can only be triggered **after** the user has been\n        // redirected from the IdP with access and ID tokens.\n        this.emit(EVENTS.LOGIN);\n      } else {\n        // If an URL is stored in local storage, we are being logged in after a\n        // silent authentication, so remove our currently stored URL location\n        // to clean up our state now that we are completing the re-login process.\n        window.localStorage.removeItem(KEY_CURRENT_URL);\n        this.emit(EVENTS.SESSION_RESTORED, currentUrl);\n      }\n    } else if (options.restorePreviousSession === true) {\n      // Silent authentication happens after a refresh, which means there are no\n      // OAuth params in the current location IRI. It can only succeed if a session\n      // was previously logged in, in which case its ID will be present with a known\n      // identifier in local storage.\n      // Check if we have a locally stored session ID...\n      const storedSessionId = window.localStorage.getItem(KEY_CURRENT_SESSION);\n      // ...if not, then there is no ID token, and so silent authentication cannot happen, but\n      // if we do have a stored session ID, attempt to re-authenticate now silently.\n      if (storedSessionId !== null) {\n        const attemptedSilentAuthentication = await silentlyAuthenticate(\n          storedSessionId,\n          this.clientAuthentication,\n          this\n        );\n        // At this point, we know that the main window will imminently be redirected.\n        // However, this redirect is asynchronous and there is no way to halt execution\n        // until it happens precisely. That's why the current Promise simply does not\n        // resolve.\n        if (attemptedSilentAuthentication) {\n          return new Promise(() => {});\n        }\n      }\n    }\n    this.tokenRequestInProgress = false;\n    return sessionInfo;\n  };\n\n  /**\n   * Register a callback function to be called when a user completes login.\n   *\n   * The callback is called when {@link handleIncomingRedirect} completes successfully.\n   *\n   * @param callback The function called when a user completes login.\n   */\n  onLogin(callback: () => unknown): void {\n    this.on(EVENTS.LOGIN, callback);\n  }\n\n  /**\n   * Register a callback function to be called when a user logs out:\n   *\n   * @param callback The function called when a user completes logout.\n   */\n  onLogout(callback: () => unknown): void {\n    this.on(EVENTS.LOGOUT, callback);\n  }\n\n  /**\n   * Register a callback function to be called when a user logs out:\n   *\n   * @param callback The function called when an error occurs.\n   * @since 1.11.0\n   */\n  onError(\n    callback: (\n      error: string | null,\n      errorDescription?: string | null\n    ) => unknown\n  ): void {\n    this.on(EVENTS.ERROR, callback);\n  }\n\n  /**\n   * Register a callback function to be called when a session is restored.\n   *\n   * Note: the callback will be called with the saved value of the 'current URL'\n   * at the time the session was restored.\n   *\n   * @param callback The function called when a user's already logged-in session is restored, e.g., after a silent authentication is completed after a page refresh.\n   */\n  onSessionRestore(callback: (currentUrl: string) => unknown): void {\n    this.on(EVENTS.SESSION_RESTORED, callback);\n  }\n\n  /**\n   * Register a callback that runs when the session expires and can no longer\n   * make authenticated requests, but following a user logout.\n   * @param callback The function that runs on session expiration.\n   * @since 1.11.0\n   */\n  onSessionExpiration(callback: () => unknown): void {\n    this.on(EVENTS.SESSION_EXPIRED, callback);\n  }\n\n  private setSessionInfo(\n    sessionInfo: ISessionInfo & { isLoggedIn: true }\n  ): void {\n    this.info.isLoggedIn = sessionInfo.isLoggedIn;\n    this.info.webId = sessionInfo.webId;\n    this.info.sessionId = sessionInfo.sessionId;\n    this.info.expirationDate = sessionInfo.expirationDate;\n    this.on(EVENTS.SESSION_EXTENDED, (expiresIn: number) => {\n      this.info.expirationDate = Date.now() + expiresIn * 1000;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}