{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _slicedToArray = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _regeneratorRuntime = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _createForOfIteratorHelper = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _asyncToGenerator = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar JsonLdError = require('./JsonLdError');\nvar graphTypes = require('./graphTypes');\nvar types = require('./types');\nvar util = require('./util');\n\n// constants\nvar _require = require('./constants'),\n  RDF_LIST = _require.RDF_LIST,\n  RDF_FIRST = _require.RDF_FIRST,\n  RDF_REST = _require.RDF_REST,\n  RDF_NIL = _require.RDF_NIL,\n  RDF_TYPE = _require.RDF_TYPE,\n  RDF_JSON_LITERAL = _require.RDF_JSON_LITERAL,\n  XSD_BOOLEAN = _require.XSD_BOOLEAN,\n  XSD_DOUBLE = _require.XSD_DOUBLE,\n  XSD_INTEGER = _require.XSD_INTEGER,\n  XSD_STRING = _require.XSD_STRING;\nvar REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;\nvar api = {};\nmodule.exports = api;\n\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset the RDF dataset.\n * @param options the RDF serialization options.\n *\n * @return a Promise that resolves to the JSON-LD output.\n */\napi.fromRDF = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(dataset, _ref) {\n    var _ref$useRdfType, useRdfType, _ref$useNativeTypes, useNativeTypes, _ref$rdfDirection, rdfDirection, defaultGraph, graphMap, referencedOnce, _iterator, _step, quad, _name, nodeMap, s, p, o, _node, objectIsNode, value, object, name, graphObject, nil, _iterator2, _step2, usage, node, property, head, list, listNodes, nodeKeyCount, _i, _listNodes, listNode, result, subjects, _iterator3, _step3, subject, _node2, graph, _graphObject, graphSubjects, _iterator4, _step4, graphSubject, _node3;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          _ref$useRdfType = _ref.useRdfType, useRdfType = _ref$useRdfType === void 0 ? false : _ref$useRdfType, _ref$useNativeTypes = _ref.useNativeTypes, useNativeTypes = _ref$useNativeTypes === void 0 ? false : _ref$useNativeTypes, _ref$rdfDirection = _ref.rdfDirection, rdfDirection = _ref$rdfDirection === void 0 ? null : _ref$rdfDirection;\n          defaultGraph = {};\n          graphMap = {\n            '@default': defaultGraph\n          };\n          referencedOnce = {};\n          _iterator = _createForOfIteratorHelper(dataset);\n          _context.prev = 5;\n          _iterator.s();\n        case 7:\n          if ((_step = _iterator.n()).done) {\n            _context.next = 28;\n            break;\n          }\n          quad = _step.value;\n          // TODO: change 'name' to 'graph'\n          _name = quad.graph.termType === 'DefaultGraph' ? '@default' : quad.graph.value;\n          if (!(_name in graphMap)) {\n            graphMap[_name] = {};\n          }\n          if (_name !== '@default' && !(_name in defaultGraph)) {\n            defaultGraph[_name] = {\n              '@id': _name\n            };\n          }\n          nodeMap = graphMap[_name]; // get subject, predicate, object\n          s = quad.subject.value;\n          p = quad.predicate.value;\n          o = quad.object;\n          if (!(s in nodeMap)) {\n            nodeMap[s] = {\n              '@id': s\n            };\n          }\n          _node = nodeMap[s];\n          objectIsNode = o.termType.endsWith('Node');\n          if (objectIsNode && !(o.value in nodeMap)) {\n            nodeMap[o.value] = {\n              '@id': o.value\n            };\n          }\n          if (!(p === RDF_TYPE && !useRdfType && objectIsNode)) {\n            _context.next = 23;\n            break;\n          }\n          util.addValue(_node, '@type', o.value, {\n            propertyIsArray: true\n          });\n          return _context.abrupt(\"continue\", 26);\n        case 23:\n          value = _RDFToObject(o, useNativeTypes, rdfDirection);\n          util.addValue(_node, p, value, {\n            propertyIsArray: true\n          });\n\n          // object may be an RDF list/partial list node but we can't know easily\n          // until all triples are read\n          if (objectIsNode) {\n            if (o.value === RDF_NIL) {\n              // track rdf:nil uniquely per graph\n              object = nodeMap[o.value];\n              if (!('usages' in object)) {\n                object.usages = [];\n              }\n              object.usages.push({\n                node: _node,\n                property: p,\n                value: value\n              });\n            } else if (o.value in referencedOnce) {\n              // object referenced more than once\n              referencedOnce[o.value] = false;\n            } else {\n              // keep track of single reference\n              referencedOnce[o.value] = {\n                node: _node,\n                property: p,\n                value: value\n              };\n            }\n          }\n        case 26:\n          _context.next = 7;\n          break;\n        case 28:\n          _context.next = 33;\n          break;\n        case 30:\n          _context.prev = 30;\n          _context.t0 = _context[\"catch\"](5);\n          _iterator.e(_context.t0);\n        case 33:\n          _context.prev = 33;\n          _iterator.f();\n          return _context.finish(33);\n        case 36:\n          _context.t1 = _regeneratorRuntime().keys(graphMap);\n        case 37:\n          if ((_context.t2 = _context.t1()).done) {\n            _context.next = 84;\n            break;\n          }\n          name = _context.t2.value;\n          graphObject = graphMap[name]; // no @lists to be converted, continue\n          if (RDF_NIL in graphObject) {\n            _context.next = 42;\n            break;\n          }\n          return _context.abrupt(\"continue\", 37);\n        case 42:\n          // iterate backwards through each RDF list\n          nil = graphObject[RDF_NIL];\n          if (nil.usages) {\n            _context.next = 45;\n            break;\n          }\n          return _context.abrupt(\"continue\", 37);\n        case 45:\n          _iterator2 = _createForOfIteratorHelper(nil.usages);\n          _context.prev = 46;\n          _iterator2.s();\n        case 48:\n          if ((_step2 = _iterator2.n()).done) {\n            _context.next = 73;\n            break;\n          }\n          usage = _step2.value;\n          node = usage.node;\n          property = usage.property;\n          head = usage.value;\n          list = [];\n          listNodes = []; // ensure node is a well-formed list node; it must:\n          // 1. Be referenced only once.\n          // 2. Have an array for rdf:first that has 1 item.\n          // 3. Have an array for rdf:rest that has 1 item.\n          // 4. Have no keys other than: @id, rdf:first, rdf:rest, and,\n          //   optionally, @type where the value is rdf:List.\n          nodeKeyCount = Object.keys(node).length;\n        case 56:\n          if (!(property === RDF_REST && types.isObject(referencedOnce[node['@id']]) && types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 && types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 && (nodeKeyCount === 3 || nodeKeyCount === 4 && types.isArray(node['@type']) && node['@type'].length === 1 && node['@type'][0] === RDF_LIST))) {\n            _context.next = 68;\n            break;\n          }\n          list.push(node[RDF_FIRST][0]);\n          listNodes.push(node['@id']);\n\n          // get next node, moving backwards through list\n          usage = referencedOnce[node['@id']];\n          node = usage.node;\n          property = usage.property;\n          head = usage.value;\n          nodeKeyCount = Object.keys(node).length;\n\n          // if node is not a blank node, then list head found\n          if (graphTypes.isBlankNode(node)) {\n            _context.next = 66;\n            break;\n          }\n          return _context.abrupt(\"break\", 68);\n        case 66:\n          _context.next = 56;\n          break;\n        case 68:\n          // transform list into @list object\n          delete head['@id'];\n          head['@list'] = list.reverse();\n          for (_i = 0, _listNodes = listNodes; _i < _listNodes.length; _i++) {\n            listNode = _listNodes[_i];\n            delete graphObject[listNode];\n          }\n        case 71:\n          _context.next = 48;\n          break;\n        case 73:\n          _context.next = 78;\n          break;\n        case 75:\n          _context.prev = 75;\n          _context.t3 = _context[\"catch\"](46);\n          _iterator2.e(_context.t3);\n        case 78:\n          _context.prev = 78;\n          _iterator2.f();\n          return _context.finish(78);\n        case 81:\n          delete nil.usages;\n          _context.next = 37;\n          break;\n        case 84:\n          result = [];\n          subjects = Object.keys(defaultGraph).sort();\n          _iterator3 = _createForOfIteratorHelper(subjects);\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              subject = _step3.value;\n              _node2 = defaultGraph[subject];\n              if (subject in graphMap) {\n                graph = _node2['@graph'] = [];\n                _graphObject = graphMap[subject];\n                graphSubjects = Object.keys(_graphObject).sort();\n                _iterator4 = _createForOfIteratorHelper(graphSubjects);\n                try {\n                  for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                    graphSubject = _step4.value;\n                    _node3 = _graphObject[graphSubject]; // only add full subjects to top-level\n                    if (!graphTypes.isSubjectReference(_node3)) {\n                      graph.push(_node3);\n                    }\n                  }\n                } catch (err) {\n                  _iterator4.e(err);\n                } finally {\n                  _iterator4.f();\n                }\n              }\n              // only add full subjects to top-level\n              if (!graphTypes.isSubjectReference(_node2)) {\n                result.push(_node2);\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          return _context.abrupt(\"return\", result);\n        case 89:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[5, 30, 33, 36], [46, 75, 78, 81]]);\n  }));\n  return function (_x, _x2) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * Converts an RDF triple object to a JSON-LD object.\n *\n * @param o the RDF triple object to convert.\n * @param useNativeTypes true to output native types, false not to.\n *\n * @return the JSON-LD object.\n */\nfunction _RDFToObject(o, useNativeTypes, rdfDirection) {\n  // convert NamedNode/BlankNode object to JSON-LD\n  if (o.termType.endsWith('Node')) {\n    return {\n      '@id': o.value\n    };\n  }\n\n  // convert literal to JSON-LD\n  var rval = {\n    '@value': o.value\n  };\n\n  // add language\n  if (o.language) {\n    rval['@language'] = o.language;\n  } else {\n    var type = o.datatype.value;\n    if (!type) {\n      type = XSD_STRING;\n    }\n    if (type === RDF_JSON_LITERAL) {\n      type = '@json';\n      try {\n        rval['@value'] = JSON.parse(rval['@value']);\n      } catch (e) {\n        throw new JsonLdError('JSON literal could not be parsed.', 'jsonld.InvalidJsonLiteral', {\n          code: 'invalid JSON literal',\n          value: rval['@value'],\n          cause: e\n        });\n      }\n    }\n    // use native types for certain xsd types\n    if (useNativeTypes) {\n      if (type === XSD_BOOLEAN) {\n        if (rval['@value'] === 'true') {\n          rval['@value'] = true;\n        } else if (rval['@value'] === 'false') {\n          rval['@value'] = false;\n        }\n      } else if (types.isNumeric(rval['@value'])) {\n        if (type === XSD_INTEGER) {\n          var i = parseInt(rval['@value'], 10);\n          if (i.toFixed(0) === rval['@value']) {\n            rval['@value'] = i;\n          }\n        } else if (type === XSD_DOUBLE) {\n          rval['@value'] = parseFloat(rval['@value']);\n        }\n      }\n      // do not add native type\n      if (![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {\n        rval['@type'] = type;\n      }\n    } else if (rdfDirection === 'i18n-datatype' && type.startsWith('https://www.w3.org/ns/i18n#')) {\n      var _type$split = type.split(/[#_]/),\n        _type$split2 = _slicedToArray(_type$split, 3),\n        language = _type$split2[1],\n        direction = _type$split2[2];\n      if (language.length > 0) {\n        rval['@language'] = language;\n        if (!language.match(REGEX_BCP47)) {\n          console.warn(\"@language must be valid BCP47: \".concat(language));\n        }\n      }\n      rval['@direction'] = direction;\n    } else if (type !== XSD_STRING) {\n      rval['@type'] = type;\n    }\n  }\n  return rval;\n}","map":{"version":3,"names":["JsonLdError","require","graphTypes","types","util","RDF_LIST","RDF_FIRST","RDF_REST","RDF_NIL","RDF_TYPE","RDF_JSON_LITERAL","XSD_BOOLEAN","XSD_DOUBLE","XSD_INTEGER","XSD_STRING","REGEX_BCP47","api","module","exports","fromRDF","dataset","useRdfType","useNativeTypes","rdfDirection","defaultGraph","graphMap","referencedOnce","quad","name","graph","termType","value","nodeMap","s","subject","p","predicate","o","object","node","objectIsNode","endsWith","addValue","propertyIsArray","_RDFToObject","usages","push","property","graphObject","nil","usage","head","list","listNodes","nodeKeyCount","Object","keys","length","isObject","isArray","isBlankNode","reverse","listNode","result","subjects","sort","graphSubjects","graphSubject","isSubjectReference","rval","language","type","datatype","JSON","parse","e","code","cause","isNumeric","i","parseInt","toFixed","parseFloat","includes","startsWith","split","direction","match","console","warn"],"sources":["E:/react-todo-app/node_modules/jsonld/lib/fromRdf.js"],"sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\nconst graphTypes = require('./graphTypes');\nconst types = require('./types');\nconst util = require('./util');\n\n// constants\nconst {\n  // RDF,\n  RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  // RDF_LANGSTRING,\n\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING,\n} = require('./constants');\n\nconst REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset the RDF dataset.\n * @param options the RDF serialization options.\n *\n * @return a Promise that resolves to the JSON-LD output.\n */\napi.fromRDF = async (\n  dataset,\n  {\n    useRdfType = false,\n    useNativeTypes = false,\n    rdfDirection = null\n  }\n) => {\n  const defaultGraph = {};\n  const graphMap = {'@default': defaultGraph};\n  const referencedOnce = {};\n\n  for(const quad of dataset) {\n    // TODO: change 'name' to 'graph'\n    const name = (quad.graph.termType === 'DefaultGraph') ?\n      '@default' : quad.graph.value;\n    if(!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if(name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {'@id': name};\n    }\n\n    const nodeMap = graphMap[name];\n\n    // get subject, predicate, object\n    const s = quad.subject.value;\n    const p = quad.predicate.value;\n    const o = quad.object;\n\n    if(!(s in nodeMap)) {\n      nodeMap[s] = {'@id': s};\n    }\n    const node = nodeMap[s];\n\n    const objectIsNode = o.termType.endsWith('Node');\n    if(objectIsNode && !(o.value in nodeMap)) {\n      nodeMap[o.value] = {'@id': o.value};\n    }\n\n    if(p === RDF_TYPE && !useRdfType && objectIsNode) {\n      util.addValue(node, '@type', o.value, {propertyIsArray: true});\n      continue;\n    }\n\n    const value = _RDFToObject(o, useNativeTypes, rdfDirection);\n    util.addValue(node, p, value, {propertyIsArray: true});\n\n    // object may be an RDF list/partial list node but we can't know easily\n    // until all triples are read\n    if(objectIsNode) {\n      if(o.value === RDF_NIL) {\n        // track rdf:nil uniquely per graph\n        const object = nodeMap[o.value];\n        if(!('usages' in object)) {\n          object.usages = [];\n        }\n        object.usages.push({\n          node,\n          property: p,\n          value\n        });\n      } else if(o.value in referencedOnce) {\n        // object referenced more than once\n        referencedOnce[o.value] = false;\n      } else {\n        // keep track of single reference\n        referencedOnce[o.value] = {\n          node,\n          property: p,\n          value\n        };\n      }\n    }\n  }\n\n  /*\n  for(let name in dataset) {\n    const graph = dataset[name];\n    if(!(name in graphMap)) {\n      graphMap[name] = {};\n    }\n    if(name !== '@default' && !(name in defaultGraph)) {\n      defaultGraph[name] = {'@id': name};\n    }\n    const nodeMap = graphMap[name];\n    for(let ti = 0; ti < graph.length; ++ti) {\n      const triple = graph[ti];\n\n      // get subject, predicate, object\n      const s = triple.subject.value;\n      const p = triple.predicate.value;\n      const o = triple.object;\n\n      if(!(s in nodeMap)) {\n        nodeMap[s] = {'@id': s};\n      }\n      const node = nodeMap[s];\n\n      const objectIsId = (o.type === 'IRI' || o.type === 'blank node');\n      if(objectIsId && !(o.value in nodeMap)) {\n        nodeMap[o.value] = {'@id': o.value};\n      }\n\n      if(p === RDF_TYPE && !useRdfType && objectIsId) {\n        util.addValue(node, '@type', o.value, {propertyIsArray: true});\n        continue;\n      }\n\n      const value = _RDFToObject(o, useNativeTypes);\n      util.addValue(node, p, value, {propertyIsArray: true});\n\n      // object may be an RDF list/partial list node but we can't know easily\n      // until all triples are read\n      if(objectIsId) {\n        if(o.value === RDF_NIL) {\n          // track rdf:nil uniquely per graph\n          const object = nodeMap[o.value];\n          if(!('usages' in object)) {\n            object.usages = [];\n          }\n          object.usages.push({\n            node: node,\n            property: p,\n            value: value\n          });\n        } else if(o.value in referencedOnce) {\n          // object referenced more than once\n          referencedOnce[o.value] = false;\n        } else {\n          // keep track of single reference\n          referencedOnce[o.value] = {\n            node: node,\n            property: p,\n            value: value\n          };\n        }\n      }\n    }\n  }*/\n\n  // convert linked lists to @list arrays\n  for(const name in graphMap) {\n    const graphObject = graphMap[name];\n\n    // no @lists to be converted, continue\n    if(!(RDF_NIL in graphObject)) {\n      continue;\n    }\n\n    // iterate backwards through each RDF list\n    const nil = graphObject[RDF_NIL];\n    if(!nil.usages) {\n      continue;\n    }\n    for(let usage of nil.usages) {\n      let node = usage.node;\n      let property = usage.property;\n      let head = usage.value;\n      const list = [];\n      const listNodes = [];\n\n      // ensure node is a well-formed list node; it must:\n      // 1. Be referenced only once.\n      // 2. Have an array for rdf:first that has 1 item.\n      // 3. Have an array for rdf:rest that has 1 item.\n      // 4. Have no keys other than: @id, rdf:first, rdf:rest, and,\n      //   optionally, @type where the value is rdf:List.\n      let nodeKeyCount = Object.keys(node).length;\n      while(property === RDF_REST &&\n        types.isObject(referencedOnce[node['@id']]) &&\n        types.isArray(node[RDF_FIRST]) && node[RDF_FIRST].length === 1 &&\n        types.isArray(node[RDF_REST]) && node[RDF_REST].length === 1 &&\n        (nodeKeyCount === 3 ||\n          (nodeKeyCount === 4 && types.isArray(node['@type']) &&\n          node['@type'].length === 1 && node['@type'][0] === RDF_LIST))) {\n        list.push(node[RDF_FIRST][0]);\n        listNodes.push(node['@id']);\n\n        // get next node, moving backwards through list\n        usage = referencedOnce[node['@id']];\n        node = usage.node;\n        property = usage.property;\n        head = usage.value;\n        nodeKeyCount = Object.keys(node).length;\n\n        // if node is not a blank node, then list head found\n        if(!graphTypes.isBlankNode(node)) {\n          break;\n        }\n      }\n\n      // transform list into @list object\n      delete head['@id'];\n      head['@list'] = list.reverse();\n      for(const listNode of listNodes) {\n        delete graphObject[listNode];\n      }\n    }\n\n    delete nil.usages;\n  }\n\n  const result = [];\n  const subjects = Object.keys(defaultGraph).sort();\n  for(const subject of subjects) {\n    const node = defaultGraph[subject];\n    if(subject in graphMap) {\n      const graph = node['@graph'] = [];\n      const graphObject = graphMap[subject];\n      const graphSubjects = Object.keys(graphObject).sort();\n      for(const graphSubject of graphSubjects) {\n        const node = graphObject[graphSubject];\n        // only add full subjects to top-level\n        if(!graphTypes.isSubjectReference(node)) {\n          graph.push(node);\n        }\n      }\n    }\n    // only add full subjects to top-level\n    if(!graphTypes.isSubjectReference(node)) {\n      result.push(node);\n    }\n  }\n\n  return result;\n};\n\n/**\n * Converts an RDF triple object to a JSON-LD object.\n *\n * @param o the RDF triple object to convert.\n * @param useNativeTypes true to output native types, false not to.\n *\n * @return the JSON-LD object.\n */\nfunction _RDFToObject(o, useNativeTypes, rdfDirection) {\n  // convert NamedNode/BlankNode object to JSON-LD\n  if(o.termType.endsWith('Node')) {\n    return {'@id': o.value};\n  }\n\n  // convert literal to JSON-LD\n  const rval = {'@value': o.value};\n\n  // add language\n  if(o.language) {\n    rval['@language'] = o.language;\n  } else {\n    let type = o.datatype.value;\n    if(!type) {\n      type = XSD_STRING;\n    }\n    if(type === RDF_JSON_LITERAL) {\n      type = '@json';\n      try {\n        rval['@value'] = JSON.parse(rval['@value']);\n      } catch(e) {\n        throw new JsonLdError(\n          'JSON literal could not be parsed.',\n          'jsonld.InvalidJsonLiteral',\n          {code: 'invalid JSON literal', value: rval['@value'], cause: e});\n      }\n    }\n    // use native types for certain xsd types\n    if(useNativeTypes) {\n      if(type === XSD_BOOLEAN) {\n        if(rval['@value'] === 'true') {\n          rval['@value'] = true;\n        } else if(rval['@value'] === 'false') {\n          rval['@value'] = false;\n        }\n      } else if(types.isNumeric(rval['@value'])) {\n        if(type === XSD_INTEGER) {\n          const i = parseInt(rval['@value'], 10);\n          if(i.toFixed(0) === rval['@value']) {\n            rval['@value'] = i;\n          }\n        } else if(type === XSD_DOUBLE) {\n          rval['@value'] = parseFloat(rval['@value']);\n        }\n      }\n      // do not add native type\n      if(![XSD_BOOLEAN, XSD_INTEGER, XSD_DOUBLE, XSD_STRING].includes(type)) {\n        rval['@type'] = type;\n      }\n    } else if(rdfDirection === 'i18n-datatype' &&\n      type.startsWith('https://www.w3.org/ns/i18n#')) {\n      const [, language, direction] = type.split(/[#_]/);\n      if(language.length > 0) {\n        rval['@language'] = language;\n        if(!language.match(REGEX_BCP47)) {\n          console.warn(`@language must be valid BCP47: ${language}`);\n        }\n      }\n      rval['@direction'] = direction;\n    } else if(type !== XSD_STRING) {\n      rval['@type'] = type;\n    }\n  }\n\n  return rval;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}