{"ast":null,"code":"import { OidcClient, WebStorageStateStore } from '@inrupt/oidc-client';\nexport { CordovaIFrameNavigator, CordovaPopupNavigator, InMemoryWebStorage, Log, OidcClient, SessionMonitor, User, UserManager, Version, WebStorageStateStore } from '@inrupt/oidc-client';\nimport { determineSigningAlg, PREFERRED_SIGNING_ALG, getWebidFromTokenPayload, OidcProviderError, InvalidResponseError, generateDpopKeyPair, createDpopHeader, DEFAULT_SCOPES } from '@inrupt/solid-client-authn-core';\nfunction processErrorResponse(responseBody, options) {\n  var _a, _b, _c, _d;\n  if (responseBody.error === \"invalid_redirect_uri\") {\n    throw new Error(`Dynamic client registration failed: the provided redirect uri [${(_a = options.redirectUrl) === null || _a === void 0 ? void 0 : _a.toString()}] is invalid - ${(_b = responseBody.error_description) !== null && _b !== void 0 ? _b : \"\"}`);\n  }\n  if (responseBody.error === \"invalid_client_metadata\") {\n    throw new Error(`Dynamic client registration failed: the provided client metadata ${JSON.stringify(options)} is invalid - ${(_c = responseBody.error_description) !== null && _c !== void 0 ? _c : \"\"}`);\n  }\n  throw new Error(`Dynamic client registration failed: ${responseBody.error} - ${(_d = responseBody.error_description) !== null && _d !== void 0 ? _d : \"\"}`);\n}\nfunction validateRegistrationResponse(responseBody, options) {\n  if (responseBody.client_id === undefined) {\n    throw new Error(`Dynamic client registration failed: no client_id has been found on ${JSON.stringify(responseBody)}`);\n  }\n  if (options.redirectUrl && (responseBody.redirect_uris === undefined || responseBody.redirect_uris[0] !== options.redirectUrl.toString())) {\n    throw new Error(`Dynamic client registration failed: the returned redirect URIs ${JSON.stringify(responseBody.redirect_uris)} don't match the provided ${JSON.stringify([options.redirectUrl.toString()])}`);\n  }\n}\nasync function registerClient(options, issuerConfig) {\n  var _a;\n  if (!issuerConfig.registrationEndpoint) {\n    throw new Error(\"Dynamic Registration could not be completed because the issuer has no registration endpoint.\");\n  }\n  if (!Array.isArray(issuerConfig.idTokenSigningAlgValuesSupported)) {\n    throw new Error(\"The OIDC issuer discovery profile is missing the 'id_token_signing_alg_values_supported' value, which is mandatory.\");\n  }\n  const signingAlg = determineSigningAlg(issuerConfig.idTokenSigningAlgValuesSupported, PREFERRED_SIGNING_ALG);\n  const config = {\n    client_name: options.clientName,\n    application_type: \"web\",\n    redirect_uris: [(_a = options.redirectUrl) === null || _a === void 0 ? void 0 : _a.toString()],\n    subject_type: \"public\",\n    token_endpoint_auth_method: \"client_secret_basic\",\n    id_token_signed_response_alg: signingAlg,\n    grant_types: [\"authorization_code\", \"refresh_token\"]\n  };\n  const headers = {\n    \"Content-Type\": \"application/json\"\n  };\n  const registerResponse = await fetch(issuerConfig.registrationEndpoint.toString(), {\n    method: \"POST\",\n    headers,\n    body: JSON.stringify(config)\n  });\n  if (registerResponse.ok) {\n    const responseBody = await registerResponse.json();\n    validateRegistrationResponse(responseBody, options);\n    return {\n      clientId: responseBody.client_id,\n      clientSecret: responseBody.client_secret,\n      idTokenSignedResponseAlg: responseBody.id_token_signed_response_alg,\n      clientType: \"dynamic\"\n    };\n  }\n  if (registerResponse.status === 400) {\n    processErrorResponse(await registerResponse.json(), options);\n  }\n  throw new Error(`Dynamic client registration failed: the server returned ${registerResponse.status} ${registerResponse.statusText} - ${await registerResponse.text()}`);\n}\nfunction hasError(value) {\n  return value.error !== undefined && typeof value.error === \"string\";\n}\nfunction hasErrorDescription(value) {\n  return value.error_description !== undefined && typeof value.error_description === \"string\";\n}\nfunction hasErrorUri(value) {\n  return value.error_uri !== undefined && typeof value.error_uri === \"string\";\n}\nfunction hasAccessToken(value) {\n  return value.access_token !== undefined && typeof value.access_token === \"string\";\n}\nfunction hasIdToken(value) {\n  return value.id_token !== undefined && typeof value.id_token === \"string\";\n}\nfunction hasRefreshToken(value) {\n  return value.refresh_token !== undefined && typeof value.refresh_token === \"string\";\n}\nfunction hasTokenType(value) {\n  return value.token_type !== undefined && typeof value.token_type === \"string\";\n}\nfunction hasExpiresIn(value) {\n  return value.expires_in === undefined || typeof value.expires_in === \"number\";\n}\nfunction validatePreconditions(issuer, data) {\n  if (data.grantType && (!issuer.grantTypesSupported || !issuer.grantTypesSupported.includes(data.grantType))) {\n    throw new Error(`The issuer [${issuer.issuer}] does not support the [${data.grantType}] grant`);\n  }\n  if (!issuer.tokenEndpoint) {\n    throw new Error(`This issuer [${issuer.issuer}] does not have a token endpoint`);\n  }\n}\nfunction validateTokenEndpointResponse(tokenResponse, dpop) {\n  if (hasError(tokenResponse)) {\n    throw new OidcProviderError(`Token endpoint returned error [${tokenResponse.error}]${hasErrorDescription(tokenResponse) ? `: ${tokenResponse.error_description}` : \"\"}${hasErrorUri(tokenResponse) ? ` (see ${tokenResponse.error_uri})` : \"\"}`, tokenResponse.error, hasErrorDescription(tokenResponse) ? tokenResponse.error_description : undefined);\n  }\n  if (!hasAccessToken(tokenResponse)) {\n    throw new InvalidResponseError([\"access_token\"]);\n  }\n  if (!hasIdToken(tokenResponse)) {\n    throw new InvalidResponseError([\"id_token\"]);\n  }\n  if (!hasTokenType(tokenResponse)) {\n    throw new InvalidResponseError([\"token_type\"]);\n  }\n  if (!hasExpiresIn(tokenResponse)) {\n    throw new InvalidResponseError([\"expires_in\"]);\n  }\n  if (!dpop && tokenResponse.token_type.toLowerCase() !== \"bearer\") {\n    throw new Error(`Invalid token endpoint response: requested a [Bearer] token, but got a 'token_type' value of [${tokenResponse.token_type}].`);\n  }\n  return tokenResponse;\n}\nasync function getTokens(issuer, client, data, dpop) {\n  validatePreconditions(issuer, data);\n  const headers = {\n    \"content-type\": \"application/x-www-form-urlencoded\"\n  };\n  let dpopKey;\n  if (dpop) {\n    dpopKey = await generateDpopKeyPair();\n    headers.DPoP = await createDpopHeader(issuer.tokenEndpoint, \"POST\", dpopKey);\n  }\n  if (client.clientSecret) {\n    headers.Authorization = `Basic ${btoa(`${client.clientId}:${client.clientSecret}`)}`;\n  }\n  const requestBody = {\n    grant_type: data.grantType,\n    redirect_uri: data.redirectUrl,\n    code: data.code,\n    code_verifier: data.codeVerifier,\n    client_id: client.clientId\n  };\n  const tokenRequestInit = {\n    method: \"POST\",\n    headers,\n    body: new URLSearchParams(requestBody).toString()\n  };\n  const rawTokenResponse = await await fetch(issuer.tokenEndpoint, tokenRequestInit);\n  const jsonTokenResponse = await rawTokenResponse.json();\n  const tokenResponse = validateTokenEndpointResponse(jsonTokenResponse, dpop);\n  const webId = await getWebidFromTokenPayload(tokenResponse.id_token, issuer.jwksUri, issuer.issuer, client.clientId);\n  return {\n    accessToken: tokenResponse.access_token,\n    idToken: tokenResponse.id_token,\n    refreshToken: hasRefreshToken(tokenResponse) ? tokenResponse.refresh_token : undefined,\n    webId,\n    dpopKey,\n    expiresIn: tokenResponse.expires_in\n  };\n}\nasync function getBearerToken(redirectUrl) {\n  let signinResponse;\n  try {\n    const client = new OidcClient({\n      response_mode: \"query\",\n      loadUserInfo: false\n    });\n    signinResponse = await client.processSigninResponse(redirectUrl);\n    if (client.settings.metadata === undefined) {\n      throw new Error(\"Cannot retrieve issuer metadata from client information in storage.\");\n    }\n    if (client.settings.metadata.jwks_uri === undefined) {\n      throw new Error(\"Missing some issuer metadata from client information in storage: 'jwks_uri' is undefined\");\n    }\n    if (client.settings.metadata.issuer === undefined) {\n      throw new Error(\"Missing some issuer metadata from client information in storage: 'issuer' is undefined\");\n    }\n    if (client.settings.client_id === undefined) {\n      throw new Error(\"Missing some client information in storage: 'client_id' is undefined\");\n    }\n    const webId = await getWebidFromTokenPayload(signinResponse.id_token, client.settings.metadata.jwks_uri, client.settings.metadata.issuer, client.settings.client_id);\n    return {\n      accessToken: signinResponse.access_token,\n      idToken: signinResponse.id_token,\n      webId,\n      refreshToken: signinResponse.refresh_token\n    };\n  } catch (err) {\n    throw new Error(`Problem handling Auth Code Grant (Flow) redirect - URL [${redirectUrl}]: ${err}`);\n  }\n}\nasync function getDpopToken(issuer, client, data) {\n  return getTokens(issuer, client, data, true);\n}\nconst isValidUrl = url => {\n  try {\n    new URL(url);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n};\nasync function refresh(refreshToken, issuer, client, dpopKey) {\n  if (client.clientId === undefined) {\n    throw new Error(\"No client ID available when trying to refresh the access token.\");\n  }\n  const requestBody = {\n    grant_type: \"refresh_token\",\n    refresh_token: refreshToken,\n    scope: DEFAULT_SCOPES\n  };\n  let dpopHeader = {};\n  if (dpopKey !== undefined) {\n    dpopHeader = {\n      DPoP: await createDpopHeader(issuer.tokenEndpoint, \"POST\", dpopKey)\n    };\n  }\n  let authHeader = {};\n  if (client.clientSecret !== undefined) {\n    authHeader = {\n      Authorization: `Basic ${btoa(`${client.clientId}:${client.clientSecret}`)}`\n    };\n  } else if (isValidUrl(client.clientId)) {\n    requestBody.client_id = client.clientId;\n  }\n  const rawResponse = await fetch(issuer.tokenEndpoint, {\n    method: \"POST\",\n    body: new URLSearchParams(requestBody).toString(),\n    headers: {\n      ...dpopHeader,\n      ...authHeader,\n      \"Content-Type\": \"application/x-www-form-urlencoded\"\n    }\n  });\n  let response;\n  try {\n    response = await rawResponse.json();\n  } catch (e) {\n    throw new Error(`The token endpoint of issuer ${issuer.issuer} returned a malformed response.`);\n  }\n  const validatedResponse = validateTokenEndpointResponse(response, dpopKey !== undefined);\n  const webId = await getWebidFromTokenPayload(validatedResponse.id_token, issuer.jwksUri, issuer.issuer, client.clientId);\n  return {\n    accessToken: validatedResponse.access_token,\n    idToken: validatedResponse.id_token,\n    refreshToken: typeof validatedResponse.refresh_token === \"string\" ? validatedResponse.refresh_token : undefined,\n    webId,\n    dpopKey,\n    expiresIn: validatedResponse.expires_in\n  };\n}\nfunction removeOidcQueryParam(redirectUrl) {\n  const cleanedUrl = new URL(redirectUrl);\n  cleanedUrl.searchParams.delete(\"code\");\n  cleanedUrl.searchParams.delete(\"state\");\n  cleanedUrl.hash = \"\";\n  return cleanedUrl.toString();\n}\nasync function clearOidcPersistentStorage() {\n  const client = new OidcClient({\n    response_mode: \"query\"\n  });\n  await client.clearStaleState(new WebStorageStateStore({}));\n  const myStorage = window.localStorage;\n  const itemsToRemove = [];\n  for (let i = 0; i <= myStorage.length; i += 1) {\n    const key = myStorage.key(i);\n    if (key && (key.match(/^oidc\\..+$/) || key.match(/^solidClientAuthenticationUser:.+$/))) {\n      itemsToRemove.push(key);\n    }\n  }\n  itemsToRemove.forEach(key => myStorage.removeItem(key));\n}\nexport { clearOidcPersistentStorage, getBearerToken, getDpopToken, refresh, registerClient, removeOidcQueryParam };","map":{"version":3,"names":["OidcClient","WebStorageStateStore","CordovaIFrameNavigator","CordovaPopupNavigator","InMemoryWebStorage","Log","SessionMonitor","User","UserManager","Version","determineSigningAlg","PREFERRED_SIGNING_ALG","getWebidFromTokenPayload","OidcProviderError","InvalidResponseError","generateDpopKeyPair","createDpopHeader","DEFAULT_SCOPES","processErrorResponse","responseBody","options","_a","_b","_c","_d","error","Error","redirectUrl","toString","error_description","JSON","stringify","validateRegistrationResponse","client_id","undefined","redirect_uris","registerClient","issuerConfig","registrationEndpoint","Array","isArray","idTokenSigningAlgValuesSupported","signingAlg","config","client_name","clientName","application_type","subject_type","token_endpoint_auth_method","id_token_signed_response_alg","grant_types","headers","registerResponse","fetch","method","body","ok","json","clientId","clientSecret","client_secret","idTokenSignedResponseAlg","clientType","status","statusText","text","hasError","value","hasErrorDescription","hasErrorUri","error_uri","hasAccessToken","access_token","hasIdToken","id_token","hasRefreshToken","refresh_token","hasTokenType","token_type","hasExpiresIn","expires_in","validatePreconditions","issuer","data","grantType","grantTypesSupported","includes","tokenEndpoint","validateTokenEndpointResponse","tokenResponse","dpop","toLowerCase","getTokens","client","dpopKey","DPoP","Authorization","btoa","requestBody","grant_type","redirect_uri","code","code_verifier","codeVerifier","tokenRequestInit","URLSearchParams","rawTokenResponse","jsonTokenResponse","webId","jwksUri","accessToken","idToken","refreshToken","expiresIn","getBearerToken","signinResponse","response_mode","loadUserInfo","processSigninResponse","settings","metadata","jwks_uri","err","getDpopToken","isValidUrl","url","URL","refresh","scope","dpopHeader","authHeader","rawResponse","response","e","validatedResponse","removeOidcQueryParam","cleanedUrl","searchParams","delete","hash","clearOidcPersistentStorage","clearStaleState","myStorage","window","localStorage","itemsToRemove","i","length","key","match","push","forEach","removeItem"],"sources":["E:/react-todo-app/node_modules/@inrupt/oidc-client-ext/dist/index.es.js"],"sourcesContent":["import { OidcClient, WebStorageStateStore } from '@inrupt/oidc-client';\nexport { CordovaIFrameNavigator, CordovaPopupNavigator, InMemoryWebStorage, Log, OidcClient, SessionMonitor, User, UserManager, Version, WebStorageStateStore } from '@inrupt/oidc-client';\nimport { determineSigningAlg, PREFERRED_SIGNING_ALG, getWebidFromTokenPayload, OidcProviderError, InvalidResponseError, generateDpopKeyPair, createDpopHeader, DEFAULT_SCOPES } from '@inrupt/solid-client-authn-core';\n\nfunction processErrorResponse(responseBody, options) {\r\n    var _a, _b, _c, _d;\r\n    if (responseBody.error === \"invalid_redirect_uri\") {\r\n        throw new Error(`Dynamic client registration failed: the provided redirect uri [${(_a = options.redirectUrl) === null || _a === void 0 ? void 0 : _a.toString()}] is invalid - ${(_b = responseBody.error_description) !== null && _b !== void 0 ? _b : \"\"}`);\r\n    }\r\n    if (responseBody.error === \"invalid_client_metadata\") {\r\n        throw new Error(`Dynamic client registration failed: the provided client metadata ${JSON.stringify(options)} is invalid - ${(_c = responseBody.error_description) !== null && _c !== void 0 ? _c : \"\"}`);\r\n    }\r\n    throw new Error(`Dynamic client registration failed: ${responseBody.error} - ${(_d = responseBody.error_description) !== null && _d !== void 0 ? _d : \"\"}`);\r\n}\r\nfunction validateRegistrationResponse(responseBody, options) {\r\n    if (responseBody.client_id === undefined) {\r\n        throw new Error(`Dynamic client registration failed: no client_id has been found on ${JSON.stringify(responseBody)}`);\r\n    }\r\n    if (options.redirectUrl &&\r\n        (responseBody.redirect_uris === undefined ||\r\n            responseBody.redirect_uris[0] !== options.redirectUrl.toString())) {\r\n        throw new Error(`Dynamic client registration failed: the returned redirect URIs ${JSON.stringify(responseBody.redirect_uris)} don't match the provided ${JSON.stringify([\r\n            options.redirectUrl.toString(),\r\n        ])}`);\r\n    }\r\n}\r\nasync function registerClient(options, issuerConfig) {\r\n    var _a;\r\n    if (!issuerConfig.registrationEndpoint) {\r\n        throw new Error(\"Dynamic Registration could not be completed because the issuer has no registration endpoint.\");\r\n    }\r\n    if (!Array.isArray(issuerConfig.idTokenSigningAlgValuesSupported)) {\r\n        throw new Error(\"The OIDC issuer discovery profile is missing the 'id_token_signing_alg_values_supported' value, which is mandatory.\");\r\n    }\r\n    const signingAlg = determineSigningAlg(issuerConfig.idTokenSigningAlgValuesSupported, PREFERRED_SIGNING_ALG);\r\n    const config = {\r\n        client_name: options.clientName,\r\n        application_type: \"web\",\r\n        redirect_uris: [(_a = options.redirectUrl) === null || _a === void 0 ? void 0 : _a.toString()],\r\n        subject_type: \"public\",\r\n        token_endpoint_auth_method: \"client_secret_basic\",\r\n        id_token_signed_response_alg: signingAlg,\r\n        grant_types: [\"authorization_code\", \"refresh_token\"],\r\n    };\r\n    const headers = {\r\n        \"Content-Type\": \"application/json\",\r\n    };\r\n    const registerResponse = await fetch(issuerConfig.registrationEndpoint.toString(), {\r\n        method: \"POST\",\r\n        headers,\r\n        body: JSON.stringify(config),\r\n    });\r\n    if (registerResponse.ok) {\r\n        const responseBody = await registerResponse.json();\r\n        validateRegistrationResponse(responseBody, options);\r\n        return {\r\n            clientId: responseBody.client_id,\r\n            clientSecret: responseBody.client_secret,\r\n            idTokenSignedResponseAlg: responseBody.id_token_signed_response_alg,\r\n            clientType: \"dynamic\",\r\n        };\r\n    }\r\n    if (registerResponse.status === 400) {\r\n        processErrorResponse(await registerResponse.json(), options);\r\n    }\r\n    throw new Error(`Dynamic client registration failed: the server returned ${registerResponse.status} ${registerResponse.statusText} - ${await registerResponse.text()}`);\r\n}\n\nfunction hasError(value) {\r\n    return value.error !== undefined && typeof value.error === \"string\";\r\n}\r\nfunction hasErrorDescription(value) {\r\n    return (value.error_description !== undefined &&\r\n        typeof value.error_description === \"string\");\r\n}\r\nfunction hasErrorUri(value) {\r\n    return value.error_uri !== undefined && typeof value.error_uri === \"string\";\r\n}\r\nfunction hasAccessToken(value) {\r\n    return (value.access_token !== undefined && typeof value.access_token === \"string\");\r\n}\r\nfunction hasIdToken(value) {\r\n    return value.id_token !== undefined && typeof value.id_token === \"string\";\r\n}\r\nfunction hasRefreshToken(value) {\r\n    return (value.refresh_token !== undefined && typeof value.refresh_token === \"string\");\r\n}\r\nfunction hasTokenType(value) {\r\n    return value.token_type !== undefined && typeof value.token_type === \"string\";\r\n}\r\nfunction hasExpiresIn(value) {\r\n    return value.expires_in === undefined || typeof value.expires_in === \"number\";\r\n}\r\nfunction validatePreconditions(issuer, data) {\r\n    if (data.grantType &&\r\n        (!issuer.grantTypesSupported ||\r\n            !issuer.grantTypesSupported.includes(data.grantType))) {\r\n        throw new Error(`The issuer [${issuer.issuer}] does not support the [${data.grantType}] grant`);\r\n    }\r\n    if (!issuer.tokenEndpoint) {\r\n        throw new Error(`This issuer [${issuer.issuer}] does not have a token endpoint`);\r\n    }\r\n}\r\nfunction validateTokenEndpointResponse(tokenResponse, dpop) {\r\n    if (hasError(tokenResponse)) {\r\n        throw new OidcProviderError(`Token endpoint returned error [${tokenResponse.error}]${hasErrorDescription(tokenResponse)\r\n            ? `: ${tokenResponse.error_description}`\r\n            : \"\"}${hasErrorUri(tokenResponse) ? ` (see ${tokenResponse.error_uri})` : \"\"}`, tokenResponse.error, hasErrorDescription(tokenResponse)\r\n            ? tokenResponse.error_description\r\n            : undefined);\r\n    }\r\n    if (!hasAccessToken(tokenResponse)) {\r\n        throw new InvalidResponseError([\"access_token\"]);\r\n    }\r\n    if (!hasIdToken(tokenResponse)) {\r\n        throw new InvalidResponseError([\"id_token\"]);\r\n    }\r\n    if (!hasTokenType(tokenResponse)) {\r\n        throw new InvalidResponseError([\"token_type\"]);\r\n    }\r\n    if (!hasExpiresIn(tokenResponse)) {\r\n        throw new InvalidResponseError([\"expires_in\"]);\r\n    }\r\n    if (!dpop && tokenResponse.token_type.toLowerCase() !== \"bearer\") {\r\n        throw new Error(`Invalid token endpoint response: requested a [Bearer] token, but got a 'token_type' value of [${tokenResponse.token_type}].`);\r\n    }\r\n    return tokenResponse;\r\n}\r\nasync function getTokens(issuer, client, data, dpop) {\r\n    validatePreconditions(issuer, data);\r\n    const headers = {\r\n        \"content-type\": \"application/x-www-form-urlencoded\",\r\n    };\r\n    let dpopKey;\r\n    if (dpop) {\r\n        dpopKey = await generateDpopKeyPair();\r\n        headers.DPoP = await createDpopHeader(issuer.tokenEndpoint, \"POST\", dpopKey);\r\n    }\r\n    if (client.clientSecret) {\r\n        headers.Authorization = `Basic ${btoa(`${client.clientId}:${client.clientSecret}`)}`;\r\n    }\r\n    const requestBody = {\r\n        grant_type: data.grantType,\r\n        redirect_uri: data.redirectUrl,\r\n        code: data.code,\r\n        code_verifier: data.codeVerifier,\r\n        client_id: client.clientId,\r\n    };\r\n    const tokenRequestInit = {\r\n        method: \"POST\",\r\n        headers,\r\n        body: new URLSearchParams(requestBody).toString(),\r\n    };\r\n    const rawTokenResponse = await await fetch(issuer.tokenEndpoint, tokenRequestInit);\r\n    const jsonTokenResponse = (await rawTokenResponse.json());\r\n    const tokenResponse = validateTokenEndpointResponse(jsonTokenResponse, dpop);\r\n    const webId = await getWebidFromTokenPayload(tokenResponse.id_token, issuer.jwksUri, issuer.issuer, client.clientId);\r\n    return {\r\n        accessToken: tokenResponse.access_token,\r\n        idToken: tokenResponse.id_token,\r\n        refreshToken: hasRefreshToken(tokenResponse)\r\n            ? tokenResponse.refresh_token\r\n            : undefined,\r\n        webId,\r\n        dpopKey,\r\n        expiresIn: tokenResponse.expires_in,\r\n    };\r\n}\r\nasync function getBearerToken(redirectUrl) {\r\n    let signinResponse;\r\n    try {\r\n        const client = new OidcClient({\r\n            response_mode: \"query\",\r\n            loadUserInfo: false,\r\n        });\r\n        signinResponse = await client.processSigninResponse(redirectUrl);\r\n        if (client.settings.metadata === undefined) {\r\n            throw new Error(\"Cannot retrieve issuer metadata from client information in storage.\");\r\n        }\r\n        if (client.settings.metadata.jwks_uri === undefined) {\r\n            throw new Error(\"Missing some issuer metadata from client information in storage: 'jwks_uri' is undefined\");\r\n        }\r\n        if (client.settings.metadata.issuer === undefined) {\r\n            throw new Error(\"Missing some issuer metadata from client information in storage: 'issuer' is undefined\");\r\n        }\r\n        if (client.settings.client_id === undefined) {\r\n            throw new Error(\"Missing some client information in storage: 'client_id' is undefined\");\r\n        }\r\n        const webId = await getWebidFromTokenPayload(signinResponse.id_token, client.settings.metadata.jwks_uri, client.settings.metadata.issuer, client.settings.client_id);\r\n        return {\r\n            accessToken: signinResponse.access_token,\r\n            idToken: signinResponse.id_token,\r\n            webId,\r\n            refreshToken: signinResponse.refresh_token,\r\n        };\r\n    }\r\n    catch (err) {\r\n        throw new Error(`Problem handling Auth Code Grant (Flow) redirect - URL [${redirectUrl}]: ${err}`);\r\n    }\r\n}\r\nasync function getDpopToken(issuer, client, data) {\r\n    return getTokens(issuer, client, data, true);\r\n}\n\nconst isValidUrl = (url) => {\r\n    try {\r\n        new URL(url);\r\n        return true;\r\n    }\r\n    catch (_a) {\r\n        return false;\r\n    }\r\n};\r\nasync function refresh(refreshToken, issuer, client, dpopKey) {\r\n    if (client.clientId === undefined) {\r\n        throw new Error(\"No client ID available when trying to refresh the access token.\");\r\n    }\r\n    const requestBody = {\r\n        grant_type: \"refresh_token\",\r\n        refresh_token: refreshToken,\r\n        scope: DEFAULT_SCOPES,\r\n    };\r\n    let dpopHeader = {};\r\n    if (dpopKey !== undefined) {\r\n        dpopHeader = {\r\n            DPoP: await createDpopHeader(issuer.tokenEndpoint, \"POST\", dpopKey),\r\n        };\r\n    }\r\n    let authHeader = {};\r\n    if (client.clientSecret !== undefined) {\r\n        authHeader = {\r\n            Authorization: `Basic ${btoa(`${client.clientId}:${client.clientSecret}`)}`,\r\n        };\r\n    }\r\n    else if (isValidUrl(client.clientId)) {\r\n        requestBody.client_id = client.clientId;\r\n    }\r\n    const rawResponse = await fetch(issuer.tokenEndpoint, {\r\n        method: \"POST\",\r\n        body: new URLSearchParams(requestBody).toString(),\r\n        headers: {\r\n            ...dpopHeader,\r\n            ...authHeader,\r\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\r\n        },\r\n    });\r\n    let response;\r\n    try {\r\n        response = await rawResponse.json();\r\n    }\r\n    catch (e) {\r\n        throw new Error(`The token endpoint of issuer ${issuer.issuer} returned a malformed response.`);\r\n    }\r\n    const validatedResponse = validateTokenEndpointResponse(response, dpopKey !== undefined);\r\n    const webId = await getWebidFromTokenPayload(validatedResponse.id_token, issuer.jwksUri, issuer.issuer, client.clientId);\r\n    return {\r\n        accessToken: validatedResponse.access_token,\r\n        idToken: validatedResponse.id_token,\r\n        refreshToken: typeof validatedResponse.refresh_token === \"string\"\r\n            ? validatedResponse.refresh_token\r\n            : undefined,\r\n        webId,\r\n        dpopKey,\r\n        expiresIn: validatedResponse.expires_in,\r\n    };\r\n}\n\nfunction removeOidcQueryParam(redirectUrl) {\r\n    const cleanedUrl = new URL(redirectUrl);\r\n    cleanedUrl.searchParams.delete(\"code\");\r\n    cleanedUrl.searchParams.delete(\"state\");\r\n    cleanedUrl.hash = \"\";\r\n    return cleanedUrl.toString();\r\n}\r\nasync function clearOidcPersistentStorage() {\r\n    const client = new OidcClient({\r\n        response_mode: \"query\",\r\n    });\r\n    await client.clearStaleState(new WebStorageStateStore({}));\r\n    const myStorage = window.localStorage;\r\n    const itemsToRemove = [];\r\n    for (let i = 0; i <= myStorage.length; i += 1) {\r\n        const key = myStorage.key(i);\r\n        if (key &&\r\n            (key.match(/^oidc\\..+$/) ||\r\n                key.match(/^solidClientAuthenticationUser:.+$/))) {\r\n            itemsToRemove.push(key);\r\n        }\r\n    }\r\n    itemsToRemove.forEach((key) => myStorage.removeItem(key));\r\n}\n\nexport { clearOidcPersistentStorage, getBearerToken, getDpopToken, refresh, registerClient, removeOidcQueryParam };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}