{"ast":null,"code":"import _regeneratorRuntime from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { decode as base64url } from '../../runtime/base64url.js';\nimport verify from '../../runtime/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder } from '../../lib/buffer_utils.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nexport function flattenedVerify(_x, _x2, _x3) {\n  return _flattenedVerify.apply(this, arguments);\n}\nfunction _flattenedVerify() {\n  _flattenedVerify = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(jws, key, options) {\n    var _a, parsedProt, protectedHeader, joseHeader, extensions, b64, alg, algorithms, resolvedKey, data, signature, verified, payload, result;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (isObject(jws)) {\n            _context.next = 2;\n            break;\n          }\n          throw new JWSInvalid('Flattened JWS must be an object');\n        case 2:\n          if (!(jws.protected === undefined && jws.header === undefined)) {\n            _context.next = 4;\n            break;\n          }\n          throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n        case 4:\n          if (!(jws.protected !== undefined && typeof jws.protected !== 'string')) {\n            _context.next = 6;\n            break;\n          }\n          throw new JWSInvalid('JWS Protected Header incorrect type');\n        case 6:\n          if (!(jws.payload === undefined)) {\n            _context.next = 8;\n            break;\n          }\n          throw new JWSInvalid('JWS Payload missing');\n        case 8:\n          if (!(typeof jws.signature !== 'string')) {\n            _context.next = 10;\n            break;\n          }\n          throw new JWSInvalid('JWS Signature missing or incorrect type');\n        case 10:\n          if (!(jws.header !== undefined && !isObject(jws.header))) {\n            _context.next = 12;\n            break;\n          }\n          throw new JWSInvalid('JWS Unprotected Header incorrect type');\n        case 12:\n          parsedProt = {};\n          if (!jws.protected) {\n            _context.next = 22;\n            break;\n          }\n          _context.prev = 14;\n          protectedHeader = base64url(jws.protected);\n          parsedProt = JSON.parse(decoder.decode(protectedHeader));\n          _context.next = 22;\n          break;\n        case 19:\n          _context.prev = 19;\n          _context.t0 = _context[\"catch\"](14);\n          throw new JWSInvalid('JWS Protected Header is invalid');\n        case 22:\n          if (isDisjoint(parsedProt, jws.header)) {\n            _context.next = 24;\n            break;\n          }\n          throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n        case 24:\n          joseHeader = _objectSpread(_objectSpread({}, parsedProt), jws.header);\n          extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n          b64 = true;\n          if (!extensions.has('b64')) {\n            _context.next = 31;\n            break;\n          }\n          b64 = parsedProt.b64;\n          if (!(typeof b64 !== 'boolean')) {\n            _context.next = 31;\n            break;\n          }\n          throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        case 31:\n          alg = joseHeader.alg;\n          if (!(typeof alg !== 'string' || !alg)) {\n            _context.next = 34;\n            break;\n          }\n          throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n        case 34:\n          algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n          if (!(algorithms && !algorithms.has(alg))) {\n            _context.next = 37;\n            break;\n          }\n          throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n        case 37:\n          if (!b64) {\n            _context.next = 42;\n            break;\n          }\n          if (!(typeof jws.payload !== 'string')) {\n            _context.next = 40;\n            break;\n          }\n          throw new JWSInvalid('JWS Payload must be a string');\n        case 40:\n          _context.next = 44;\n          break;\n        case 42:\n          if (!(typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array))) {\n            _context.next = 44;\n            break;\n          }\n          throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n        case 44:\n          resolvedKey = false;\n          if (!(typeof key === 'function')) {\n            _context.next = 50;\n            break;\n          }\n          _context.next = 48;\n          return key(parsedProt, jws);\n        case 48:\n          key = _context.sent;\n          resolvedKey = true;\n        case 50:\n          checkKeyType(alg, key, 'verify');\n          data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n          signature = base64url(jws.signature);\n          _context.next = 55;\n          return verify(alg, key, signature, data);\n        case 55:\n          verified = _context.sent;\n          if (verified) {\n            _context.next = 58;\n            break;\n          }\n          throw new JWSSignatureVerificationFailed();\n        case 58:\n          if (b64) {\n            payload = base64url(jws.payload);\n          } else if (typeof jws.payload === 'string') {\n            payload = encoder.encode(jws.payload);\n          } else {\n            payload = jws.payload;\n          }\n          result = {\n            payload: payload\n          };\n          if (jws.protected !== undefined) {\n            result.protectedHeader = parsedProt;\n          }\n          if (jws.header !== undefined) {\n            result.unprotectedHeader = jws.header;\n          }\n          if (!resolvedKey) {\n            _context.next = 64;\n            break;\n          }\n          return _context.abrupt(\"return\", _objectSpread(_objectSpread({}, result), {}, {\n            key: key\n          }));\n        case 64:\n          return _context.abrupt(\"return\", result);\n        case 65:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[14, 19]]);\n  }));\n  return _flattenedVerify.apply(this, arguments);\n}","map":{"version":3,"names":["decode","base64url","verify","JOSEAlgNotAllowed","JWSInvalid","JWSSignatureVerificationFailed","concat","encoder","decoder","isDisjoint","isObject","checkKeyType","validateCrit","validateAlgorithms","flattenedVerify","jws","key","options","protected","undefined","header","payload","signature","parsedProt","protectedHeader","JSON","parse","joseHeader","extensions","Map","crit","b64","has","alg","algorithms","Uint8Array","resolvedKey","data","encode","_a","verified","result","unprotectedHeader"],"sources":["E:/react-todo-app/node_modules/jose/dist/browser/jws/flattened/verify.js"],"sourcesContent":["import { decode as base64url } from '../../runtime/base64url.js';\nimport verify from '../../runtime/verify.js';\nimport { JOSEAlgNotAllowed, JWSInvalid, JWSSignatureVerificationFailed } from '../../util/errors.js';\nimport { concat, encoder, decoder } from '../../lib/buffer_utils.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport isObject from '../../lib/is_object.js';\nimport checkKeyType from '../../lib/check_key_type.js';\nimport validateCrit from '../../lib/validate_crit.js';\nimport validateAlgorithms from '../../lib/validate_algorithms.js';\nexport async function flattenedVerify(jws, key, options) {\n    var _a;\n    if (!isObject(jws)) {\n        throw new JWSInvalid('Flattened JWS must be an object');\n    }\n    if (jws.protected === undefined && jws.header === undefined) {\n        throw new JWSInvalid('Flattened JWS must have either of the \"protected\" or \"header\" members');\n    }\n    if (jws.protected !== undefined && typeof jws.protected !== 'string') {\n        throw new JWSInvalid('JWS Protected Header incorrect type');\n    }\n    if (jws.payload === undefined) {\n        throw new JWSInvalid('JWS Payload missing');\n    }\n    if (typeof jws.signature !== 'string') {\n        throw new JWSInvalid('JWS Signature missing or incorrect type');\n    }\n    if (jws.header !== undefined && !isObject(jws.header)) {\n        throw new JWSInvalid('JWS Unprotected Header incorrect type');\n    }\n    let parsedProt = {};\n    if (jws.protected) {\n        try {\n            const protectedHeader = base64url(jws.protected);\n            parsedProt = JSON.parse(decoder.decode(protectedHeader));\n        }\n        catch (_b) {\n            throw new JWSInvalid('JWS Protected Header is invalid');\n        }\n    }\n    if (!isDisjoint(parsedProt, jws.header)) {\n        throw new JWSInvalid('JWS Protected and JWS Unprotected Header Parameter names must be disjoint');\n    }\n    const joseHeader = {\n        ...parsedProt,\n        ...jws.header,\n    };\n    const extensions = validateCrit(JWSInvalid, new Map([['b64', true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);\n    let b64 = true;\n    if (extensions.has('b64')) {\n        b64 = parsedProt.b64;\n        if (typeof b64 !== 'boolean') {\n            throw new JWSInvalid('The \"b64\" (base64url-encode payload) Header Parameter must be a boolean');\n        }\n    }\n    const { alg } = joseHeader;\n    if (typeof alg !== 'string' || !alg) {\n        throw new JWSInvalid('JWS \"alg\" (Algorithm) Header Parameter missing or invalid');\n    }\n    const algorithms = options && validateAlgorithms('algorithms', options.algorithms);\n    if (algorithms && !algorithms.has(alg)) {\n        throw new JOSEAlgNotAllowed('\"alg\" (Algorithm) Header Parameter not allowed');\n    }\n    if (b64) {\n        if (typeof jws.payload !== 'string') {\n            throw new JWSInvalid('JWS Payload must be a string');\n        }\n    }\n    else if (typeof jws.payload !== 'string' && !(jws.payload instanceof Uint8Array)) {\n        throw new JWSInvalid('JWS Payload must be a string or an Uint8Array instance');\n    }\n    let resolvedKey = false;\n    if (typeof key === 'function') {\n        key = await key(parsedProt, jws);\n        resolvedKey = true;\n    }\n    checkKeyType(alg, key, 'verify');\n    const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ''), encoder.encode('.'), typeof jws.payload === 'string' ? encoder.encode(jws.payload) : jws.payload);\n    const signature = base64url(jws.signature);\n    const verified = await verify(alg, key, signature, data);\n    if (!verified) {\n        throw new JWSSignatureVerificationFailed();\n    }\n    let payload;\n    if (b64) {\n        payload = base64url(jws.payload);\n    }\n    else if (typeof jws.payload === 'string') {\n        payload = encoder.encode(jws.payload);\n    }\n    else {\n        payload = jws.payload;\n    }\n    const result = { payload };\n    if (jws.protected !== undefined) {\n        result.protectedHeader = parsedProt;\n    }\n    if (jws.header !== undefined) {\n        result.unprotectedHeader = jws.header;\n    }\n    if (resolvedKey) {\n        return { ...result, key };\n    }\n    return result;\n}\n"],"mappings":";;;AAAA,SAASA,MAAM,IAAIC,SAAS,QAAQ,4BAA4B;AAChE,OAAOC,MAAM,MAAM,yBAAyB;AAC5C,SAASC,iBAAiB,EAAEC,UAAU,EAAEC,8BAA8B,QAAQ,sBAAsB;AACpG,SAASC,MAAM,EAAEC,OAAO,EAAEC,OAAO,QAAQ,2BAA2B;AACpE,OAAOC,UAAU,MAAM,0BAA0B;AACjD,OAAOC,QAAQ,MAAM,wBAAwB;AAC7C,OAAOC,YAAY,MAAM,6BAA6B;AACtD,OAAOC,YAAY,MAAM,4BAA4B;AACrD,OAAOC,kBAAkB,MAAM,kCAAkC;AACjE,gBAAsBC,eAAe;EAAA;AAAA;AA8FpC;EAAA,8EA9FM,iBAA+BC,GAAG,EAAEC,GAAG,EAAEC,OAAO;IAAA;IAAA;MAAA;QAAA;UAAA,IAE9CP,QAAQ,CAACK,GAAG,CAAC;YAAA;YAAA;UAAA;UAAA,MACR,IAAIX,UAAU,CAAC,iCAAiC,CAAC;QAAA;UAAA,MAEvDW,GAAG,CAACG,SAAS,KAAKC,SAAS,IAAIJ,GAAG,CAACK,MAAM,KAAKD,SAAS;YAAA;YAAA;UAAA;UAAA,MACjD,IAAIf,UAAU,CAAC,uEAAuE,CAAC;QAAA;UAAA,MAE7FW,GAAG,CAACG,SAAS,KAAKC,SAAS,IAAI,OAAOJ,GAAG,CAACG,SAAS,KAAK,QAAQ;YAAA;YAAA;UAAA;UAAA,MAC1D,IAAId,UAAU,CAAC,qCAAqC,CAAC;QAAA;UAAA,MAE3DW,GAAG,CAACM,OAAO,KAAKF,SAAS;YAAA;YAAA;UAAA;UAAA,MACnB,IAAIf,UAAU,CAAC,qBAAqB,CAAC;QAAA;UAAA,MAE3C,OAAOW,GAAG,CAACO,SAAS,KAAK,QAAQ;YAAA;YAAA;UAAA;UAAA,MAC3B,IAAIlB,UAAU,CAAC,yCAAyC,CAAC;QAAA;UAAA,MAE/DW,GAAG,CAACK,MAAM,KAAKD,SAAS,IAAI,CAACT,QAAQ,CAACK,GAAG,CAACK,MAAM,CAAC;YAAA;YAAA;UAAA;UAAA,MAC3C,IAAIhB,UAAU,CAAC,uCAAuC,CAAC;QAAA;UAE7DmB,UAAU,GAAG,CAAC,CAAC;UAAA,KACfR,GAAG,CAACG,SAAS;YAAA;YAAA;UAAA;UAAA;UAEHM,eAAe,GAAGvB,SAAS,CAACc,GAAG,CAACG,SAAS,CAAC;UAChDK,UAAU,GAAGE,IAAI,CAACC,KAAK,CAAClB,OAAO,CAACR,MAAM,CAACwB,eAAe,CAAC,CAAC;UAAC;UAAA;QAAA;UAAA;UAAA;UAAA,MAGnD,IAAIpB,UAAU,CAAC,iCAAiC,CAAC;QAAA;UAAA,IAG1DK,UAAU,CAACc,UAAU,EAAER,GAAG,CAACK,MAAM,CAAC;YAAA;YAAA;UAAA;UAAA,MAC7B,IAAIhB,UAAU,CAAC,2EAA2E,CAAC;QAAA;UAE/FuB,UAAU,mCACTJ,UAAU,GACVR,GAAG,CAACK,MAAM;UAEXQ,UAAU,GAAGhB,YAAY,CAACR,UAAU,EAAE,IAAIyB,GAAG,CAAC,CAAC,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC,CAAC,EAAEZ,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACa,IAAI,EAAEP,UAAU,EAAEI,UAAU,CAAC;UACzJI,GAAG,GAAG,IAAI;UAAA,KACVH,UAAU,CAACI,GAAG,CAAC,KAAK,CAAC;YAAA;YAAA;UAAA;UACrBD,GAAG,GAAGR,UAAU,CAACQ,GAAG;UAAC,MACjB,OAAOA,GAAG,KAAK,SAAS;YAAA;YAAA;UAAA;UAAA,MAClB,IAAI3B,UAAU,CAAC,yEAAyE,CAAC;QAAA;UAG/F6B,GAAG,GAAKN,UAAU,CAAlBM,GAAG;UAAA,MACP,OAAOA,GAAG,KAAK,QAAQ,IAAI,CAACA,GAAG;YAAA;YAAA;UAAA;UAAA,MACzB,IAAI7B,UAAU,CAAC,2DAA2D,CAAC;QAAA;UAE/E8B,UAAU,GAAGjB,OAAO,IAAIJ,kBAAkB,CAAC,YAAY,EAAEI,OAAO,CAACiB,UAAU,CAAC;UAAA,MAC9EA,UAAU,IAAI,CAACA,UAAU,CAACF,GAAG,CAACC,GAAG,CAAC;YAAA;YAAA;UAAA;UAAA,MAC5B,IAAI9B,iBAAiB,CAAC,gDAAgD,CAAC;QAAA;UAAA,KAE7E4B,GAAG;YAAA;YAAA;UAAA;UAAA,MACC,OAAOhB,GAAG,CAACM,OAAO,KAAK,QAAQ;YAAA;YAAA;UAAA;UAAA,MACzB,IAAIjB,UAAU,CAAC,8BAA8B,CAAC;QAAA;UAAA;UAAA;QAAA;UAAA,MAGnD,OAAOW,GAAG,CAACM,OAAO,KAAK,QAAQ,IAAI,EAAEN,GAAG,CAACM,OAAO,YAAYc,UAAU,CAAC;YAAA;YAAA;UAAA;UAAA,MACtE,IAAI/B,UAAU,CAAC,wDAAwD,CAAC;QAAA;UAE9EgC,WAAW,GAAG,KAAK;UAAA,MACnB,OAAOpB,GAAG,KAAK,UAAU;YAAA;YAAA;UAAA;UAAA;UAAA,OACbA,GAAG,CAACO,UAAU,EAAER,GAAG,CAAC;QAAA;UAAhCC,GAAG;UACHoB,WAAW,GAAG,IAAI;QAAC;UAEvBzB,YAAY,CAACsB,GAAG,EAAEjB,GAAG,EAAE,QAAQ,CAAC;UAC1BqB,IAAI,GAAG/B,MAAM,CAACC,OAAO,CAAC+B,MAAM,CAAC,CAACC,EAAE,GAAGxB,GAAG,CAACG,SAAS,MAAM,IAAI,IAAIqB,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,EAAE,CAAC,EAAEhC,OAAO,CAAC+B,MAAM,CAAC,GAAG,CAAC,EAAE,OAAOvB,GAAG,CAACM,OAAO,KAAK,QAAQ,GAAGd,OAAO,CAAC+B,MAAM,CAACvB,GAAG,CAACM,OAAO,CAAC,GAAGN,GAAG,CAACM,OAAO,CAAC;UACzLC,SAAS,GAAGrB,SAAS,CAACc,GAAG,CAACO,SAAS,CAAC;UAAA;UAAA,OACnBpB,MAAM,CAAC+B,GAAG,EAAEjB,GAAG,EAAEM,SAAS,EAAEe,IAAI,CAAC;QAAA;UAAlDG,QAAQ;UAAA,IACTA,QAAQ;YAAA;YAAA;UAAA;UAAA,MACH,IAAInC,8BAA8B,EAAE;QAAA;UAG9C,IAAI0B,GAAG,EAAE;YACLV,OAAO,GAAGpB,SAAS,CAACc,GAAG,CAACM,OAAO,CAAC;UACpC,CAAC,MACI,IAAI,OAAON,GAAG,CAACM,OAAO,KAAK,QAAQ,EAAE;YACtCA,OAAO,GAAGd,OAAO,CAAC+B,MAAM,CAACvB,GAAG,CAACM,OAAO,CAAC;UACzC,CAAC,MACI;YACDA,OAAO,GAAGN,GAAG,CAACM,OAAO;UACzB;UACMoB,MAAM,GAAG;YAAEpB,OAAO,EAAPA;UAAQ,CAAC;UAC1B,IAAIN,GAAG,CAACG,SAAS,KAAKC,SAAS,EAAE;YAC7BsB,MAAM,CAACjB,eAAe,GAAGD,UAAU;UACvC;UACA,IAAIR,GAAG,CAACK,MAAM,KAAKD,SAAS,EAAE;YAC1BsB,MAAM,CAACC,iBAAiB,GAAG3B,GAAG,CAACK,MAAM;UACzC;UAAC,KACGgB,WAAW;YAAA;YAAA;UAAA;UAAA,iEACCK,MAAM;YAAEzB,GAAG,EAAHA;UAAG;QAAA;UAAA,iCAEpByB,MAAM;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA,CAChB;EAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}