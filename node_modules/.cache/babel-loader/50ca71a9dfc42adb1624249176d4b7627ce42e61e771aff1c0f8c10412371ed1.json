{"ast":null,"code":"'use strict';\n\nvar _objectSpread = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _regeneratorRuntime = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _classCallCheck = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require('../../ours/primordials'),\n  StringPrototypeSlice = _require.StringPrototypeSlice,\n  SymbolIterator = _require.SymbolIterator,\n  TypedArrayPrototypeSet = _require.TypedArrayPrototypeSet,\n  Uint8Array = _require.Uint8Array;\nvar _require2 = require('buffer'),\n  Buffer = _require2.Buffer;\nvar _require3 = require('../../ours/util'),\n  inspect = _require3.inspect;\nmodule.exports = /*#__PURE__*/function (_Symbol$for) {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n  _createClass(BufferList, [{\n    key: \"push\",\n    value: function push(v) {\n      var entry = {\n        data: v,\n        next: null\n      };\n      if (this.length > 0) this.tail.next = entry;else this.head = entry;\n      this.tail = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(v) {\n      var entry = {\n        data: v,\n        next: this.head\n      };\n      if (this.length === 0) this.tail = entry;\n      this.head = entry;\n      ++this.length;\n    }\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      if (this.length === 0) return;\n      var ret = this.head.data;\n      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n      --this.length;\n      return ret;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.head = this.tail = null;\n      this.length = 0;\n    }\n  }, {\n    key: \"join\",\n    value: function join(s) {\n      if (this.length === 0) return '';\n      var p = this.head;\n      var ret = '' + p.data;\n      while ((p = p.next) !== null) ret += s + p.data;\n      return ret;\n    }\n  }, {\n    key: \"concat\",\n    value: function concat(n) {\n      if (this.length === 0) return Buffer.alloc(0);\n      var ret = Buffer.allocUnsafe(n >>> 0);\n      var p = this.head;\n      var i = 0;\n      while (p) {\n        TypedArrayPrototypeSet(ret, p.data, i);\n        i += p.data.length;\n        p = p.next;\n      }\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes or characters from the buffered data.\n  }, {\n    key: \"consume\",\n    value: function consume(n, hasStrings) {\n      var data = this.head.data;\n      if (n < data.length) {\n        // `slice` is the same for buffers and strings.\n        var slice = data.slice(0, n);\n        this.head.data = data.slice(n);\n        return slice;\n      }\n      if (n === data.length) {\n        // First chunk is a perfect match.\n        return this.shift();\n      }\n      // Result spans more than one buffer.\n      return hasStrings ? this._getString(n) : this._getBuffer(n);\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.head.data;\n    }\n  }, {\n    key: SymbolIterator,\n    value: /*#__PURE__*/_regeneratorRuntime().mark(function value() {\n      var p;\n      return _regeneratorRuntime().wrap(function value$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            p = this.head;\n          case 1:\n            if (!p) {\n              _context.next = 7;\n              break;\n            }\n            _context.next = 4;\n            return p.data;\n          case 4:\n            p = p.next;\n            _context.next = 1;\n            break;\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }, value, this);\n    }) // Consumes a specified amount of characters from the buffered data.\n  }, {\n    key: \"_getString\",\n    value: function _getString(n) {\n      var ret = '';\n      var p = this.head;\n      var c = 0;\n      do {\n        var str = p.data;\n        if (n > str.length) {\n          ret += str;\n          n -= str.length;\n        } else {\n          if (n === str.length) {\n            ret += str;\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            ret += StringPrototypeSlice(str, 0, n);\n            this.head = p;\n            p.data = StringPrototypeSlice(str, n);\n          }\n          break;\n        }\n        ++c;\n      } while ((p = p.next) !== null);\n      this.length -= c;\n      return ret;\n    }\n\n    // Consumes a specified amount of bytes from the buffered data.\n  }, {\n    key: \"_getBuffer\",\n    value: function _getBuffer(n) {\n      var ret = Buffer.allocUnsafe(n);\n      var retLen = n;\n      var p = this.head;\n      var c = 0;\n      do {\n        var buf = p.data;\n        if (n > buf.length) {\n          TypedArrayPrototypeSet(ret, buf, retLen - n);\n          n -= buf.length;\n        } else {\n          if (n === buf.length) {\n            TypedArrayPrototypeSet(ret, buf, retLen - n);\n            ++c;\n            if (p.next) this.head = p.next;else this.head = this.tail = null;\n          } else {\n            TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n);\n            this.head = p;\n            p.data = buf.slice(n);\n          }\n          break;\n        }\n        ++c;\n      } while ((p = p.next) !== null);\n      this.length -= c;\n      return ret;\n    }\n\n    // Make sure the linked list only shows the minimal necessary information.\n  }, {\n    key: _Symbol$for,\n    value: function value(_, options) {\n      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {\n        // Only inspect one level.\n        depth: 0,\n        // It should not recurse.\n        customInspect: false\n      }));\n    }\n  }]);\n  return BufferList;\n}(Symbol.for('nodejs.util.inspect.custom'));","map":{"version":3,"names":["require","StringPrototypeSlice","SymbolIterator","TypedArrayPrototypeSet","Uint8Array","Buffer","inspect","module","exports","head","tail","length","v","entry","data","next","ret","s","p","n","alloc","allocUnsafe","i","hasStrings","slice","shift","_getString","_getBuffer","c","str","retLen","buf","buffer","byteOffset","_","options","depth","customInspect","Symbol","for"],"sources":["E:/react-todo-app/node_modules/n3/node_modules/readable-stream/lib/internal/streams/buffer_list.js"],"sourcesContent":["'use strict'\n\nconst { StringPrototypeSlice, SymbolIterator, TypedArrayPrototypeSet, Uint8Array } = require('../../ours/primordials')\nconst { Buffer } = require('buffer')\nconst { inspect } = require('../../ours/util')\nmodule.exports = class BufferList {\n  constructor() {\n    this.head = null\n    this.tail = null\n    this.length = 0\n  }\n  push(v) {\n    const entry = {\n      data: v,\n      next: null\n    }\n    if (this.length > 0) this.tail.next = entry\n    else this.head = entry\n    this.tail = entry\n    ++this.length\n  }\n  unshift(v) {\n    const entry = {\n      data: v,\n      next: this.head\n    }\n    if (this.length === 0) this.tail = entry\n    this.head = entry\n    ++this.length\n  }\n  shift() {\n    if (this.length === 0) return\n    const ret = this.head.data\n    if (this.length === 1) this.head = this.tail = null\n    else this.head = this.head.next\n    --this.length\n    return ret\n  }\n  clear() {\n    this.head = this.tail = null\n    this.length = 0\n  }\n  join(s) {\n    if (this.length === 0) return ''\n    let p = this.head\n    let ret = '' + p.data\n    while ((p = p.next) !== null) ret += s + p.data\n    return ret\n  }\n  concat(n) {\n    if (this.length === 0) return Buffer.alloc(0)\n    const ret = Buffer.allocUnsafe(n >>> 0)\n    let p = this.head\n    let i = 0\n    while (p) {\n      TypedArrayPrototypeSet(ret, p.data, i)\n      i += p.data.length\n      p = p.next\n    }\n    return ret\n  }\n\n  // Consumes a specified amount of bytes or characters from the buffered data.\n  consume(n, hasStrings) {\n    const data = this.head.data\n    if (n < data.length) {\n      // `slice` is the same for buffers and strings.\n      const slice = data.slice(0, n)\n      this.head.data = data.slice(n)\n      return slice\n    }\n    if (n === data.length) {\n      // First chunk is a perfect match.\n      return this.shift()\n    }\n    // Result spans more than one buffer.\n    return hasStrings ? this._getString(n) : this._getBuffer(n)\n  }\n  first() {\n    return this.head.data\n  }\n  *[SymbolIterator]() {\n    for (let p = this.head; p; p = p.next) {\n      yield p.data\n    }\n  }\n\n  // Consumes a specified amount of characters from the buffered data.\n  _getString(n) {\n    let ret = ''\n    let p = this.head\n    let c = 0\n    do {\n      const str = p.data\n      if (n > str.length) {\n        ret += str\n        n -= str.length\n      } else {\n        if (n === str.length) {\n          ret += str\n          ++c\n          if (p.next) this.head = p.next\n          else this.head = this.tail = null\n        } else {\n          ret += StringPrototypeSlice(str, 0, n)\n          this.head = p\n          p.data = StringPrototypeSlice(str, n)\n        }\n        break\n      }\n      ++c\n    } while ((p = p.next) !== null)\n    this.length -= c\n    return ret\n  }\n\n  // Consumes a specified amount of bytes from the buffered data.\n  _getBuffer(n) {\n    const ret = Buffer.allocUnsafe(n)\n    const retLen = n\n    let p = this.head\n    let c = 0\n    do {\n      const buf = p.data\n      if (n > buf.length) {\n        TypedArrayPrototypeSet(ret, buf, retLen - n)\n        n -= buf.length\n      } else {\n        if (n === buf.length) {\n          TypedArrayPrototypeSet(ret, buf, retLen - n)\n          ++c\n          if (p.next) this.head = p.next\n          else this.head = this.tail = null\n        } else {\n          TypedArrayPrototypeSet(ret, new Uint8Array(buf.buffer, buf.byteOffset, n), retLen - n)\n          this.head = p\n          p.data = buf.slice(n)\n        }\n        break\n      }\n      ++c\n    } while ((p = p.next) !== null)\n    this.length -= c\n    return ret\n  }\n\n  // Make sure the linked list only shows the minimal necessary information.\n  [Symbol.for('nodejs.util.inspect.custom')](_, options) {\n    return inspect(this, {\n      ...options,\n      // Only inspect one level.\n      depth: 0,\n      // It should not recurse.\n      customInspect: false\n    })\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}