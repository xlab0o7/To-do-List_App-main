{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _createForOfIteratorHelper = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _require = require('./nodeMap'),\n  createNodeMap = _require.createNodeMap;\nvar _require2 = require('./context'),\n  isKeyword = _require2.isKeyword;\nvar graphTypes = require('./graphTypes');\nvar jsonCanonicalize = require('canonicalize');\nvar types = require('./types');\nvar util = require('./util');\nvar _require3 = require('./constants'),\n  RDF_FIRST = _require3.RDF_FIRST,\n  RDF_REST = _require3.RDF_REST,\n  RDF_NIL = _require3.RDF_NIL,\n  RDF_TYPE = _require3.RDF_TYPE,\n  RDF_JSON_LITERAL = _require3.RDF_JSON_LITERAL,\n  RDF_LANGSTRING = _require3.RDF_LANGSTRING,\n  XSD_BOOLEAN = _require3.XSD_BOOLEAN,\n  XSD_DOUBLE = _require3.XSD_DOUBLE,\n  XSD_INTEGER = _require3.XSD_INTEGER,\n  XSD_STRING = _require3.XSD_STRING;\nvar _require4 = require('./url'),\n  _isAbsoluteIri = _require4.isAbsolute;\nvar api = {};\nmodule.exports = api;\n\n/**\n * Outputs an RDF dataset for the expanded JSON-LD input.\n *\n * @param input the expanded JSON-LD input.\n * @param options the RDF serialization options.\n *\n * @return the RDF dataset.\n */\napi.toRDF = function (input, options) {\n  // create node map for default graph (and any named graphs)\n  var issuer = new util.IdentifierIssuer('_:b');\n  var nodeMap = {\n    '@default': {}\n  };\n  createNodeMap(input, nodeMap, '@default', issuer);\n  var dataset = [];\n  var graphNames = Object.keys(nodeMap).sort();\n  var _iterator = _createForOfIteratorHelper(graphNames),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var graphName = _step.value;\n      var graphTerm = void 0;\n      if (graphName === '@default') {\n        graphTerm = {\n          termType: 'DefaultGraph',\n          value: ''\n        };\n      } else if (_isAbsoluteIri(graphName)) {\n        if (graphName.startsWith('_:')) {\n          graphTerm = {\n            termType: 'BlankNode'\n          };\n        } else {\n          graphTerm = {\n            termType: 'NamedNode'\n          };\n        }\n        graphTerm.value = graphName;\n      } else {\n        // skip relative IRIs (not valid RDF)\n        continue;\n      }\n      _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return dataset;\n};\n\n/**\n * Adds RDF quads for a particular graph to the given dataset.\n *\n * @param dataset the dataset to append RDF quads to.\n * @param graph the graph to create RDF quads for.\n * @param graphTerm the graph term for each quad.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param options the RDF serialization options.\n *\n * @return the array of RDF triples for the given graph.\n */\nfunction _graphToRDF(dataset, graph, graphTerm, issuer, options) {\n  var ids = Object.keys(graph).sort();\n  var _iterator2 = _createForOfIteratorHelper(ids),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var id = _step2.value;\n      var node = graph[id];\n      var properties = Object.keys(node).sort();\n      var _iterator3 = _createForOfIteratorHelper(properties),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var property = _step3.value;\n          var items = node[property];\n          if (property === '@type') {\n            property = RDF_TYPE;\n          } else if (isKeyword(property)) {\n            continue;\n          }\n          var _iterator4 = _createForOfIteratorHelper(items),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var item = _step4.value;\n              // RDF subject\n              var subject = {\n                termType: id.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n                value: id\n              };\n\n              // skip relative IRI subjects (not valid RDF)\n              if (!_isAbsoluteIri(id)) {\n                continue;\n              }\n\n              // RDF predicate\n              var predicate = {\n                termType: property.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n                value: property\n              };\n\n              // skip relative IRI predicates (not valid RDF)\n              if (!_isAbsoluteIri(property)) {\n                continue;\n              }\n\n              // skip blank node predicates unless producing generalized RDF\n              if (predicate.termType === 'BlankNode' && !options.produceGeneralizedRdf) {\n                continue;\n              }\n\n              // convert list, value or node object to triple\n              var object = _objectToRDF(item, issuer, dataset, graphTerm, options.rdfDirection);\n              // skip null objects (they are relative IRIs)\n              if (object) {\n                dataset.push({\n                  subject: subject,\n                  predicate: predicate,\n                  object: object,\n                  graph: graphTerm\n                });\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n\n/**\n * Converts a @list value into linked list of blank node RDF quads\n * (an RDF collection).\n *\n * @param list the @list value.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the array of quads to append to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the head of the list.\n */\nfunction _listToRDF(list, issuer, dataset, graphTerm, rdfDirection) {\n  var first = {\n    termType: 'NamedNode',\n    value: RDF_FIRST\n  };\n  var rest = {\n    termType: 'NamedNode',\n    value: RDF_REST\n  };\n  var nil = {\n    termType: 'NamedNode',\n    value: RDF_NIL\n  };\n  var last = list.pop();\n  // Result is the head of the list\n  var result = last ? {\n    termType: 'BlankNode',\n    value: issuer.getId()\n  } : nil;\n  var subject = result;\n  var _iterator5 = _createForOfIteratorHelper(list),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var item = _step5.value;\n      var _object = _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection);\n      var next = {\n        termType: 'BlankNode',\n        value: issuer.getId()\n      };\n      dataset.push({\n        subject: subject,\n        predicate: first,\n        object: _object,\n        graph: graphTerm\n      });\n      dataset.push({\n        subject: subject,\n        predicate: rest,\n        object: next,\n        graph: graphTerm\n      });\n      subject = next;\n    }\n\n    // Tail of list\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  if (last) {\n    var object = _objectToRDF(last, issuer, dataset, graphTerm, rdfDirection);\n    dataset.push({\n      subject: subject,\n      predicate: first,\n      object: object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject: subject,\n      predicate: rest,\n      object: nil,\n      graph: graphTerm\n    });\n  }\n  return result;\n}\n\n/**\n * Converts a JSON-LD value object to an RDF literal or a JSON-LD string,\n * node object to an RDF resource, or adds a list.\n *\n * @param item the JSON-LD value or node object.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the dataset to append RDF quads to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the RDF literal or RDF resource.\n */\nfunction _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection) {\n  var object = {};\n\n  // convert value object to RDF\n  if (graphTypes.isValue(item)) {\n    object.termType = 'Literal';\n    object.value = undefined;\n    object.datatype = {\n      termType: 'NamedNode'\n    };\n    var value = item['@value'];\n    var datatype = item['@type'] || null;\n\n    // convert to XSD/JSON datatypes as appropriate\n    if (datatype === '@json') {\n      object.value = jsonCanonicalize(value);\n      object.datatype.value = RDF_JSON_LITERAL;\n    } else if (types.isBoolean(value)) {\n      object.value = value.toString();\n      object.datatype.value = datatype || XSD_BOOLEAN;\n    } else if (types.isDouble(value) || datatype === XSD_DOUBLE) {\n      if (!types.isDouble(value)) {\n        value = parseFloat(value);\n      }\n      // canonical double representation\n      object.value = value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n      object.datatype.value = datatype || XSD_DOUBLE;\n    } else if (types.isNumber(value)) {\n      object.value = value.toFixed(0);\n      object.datatype.value = datatype || XSD_INTEGER;\n    } else if (rdfDirection === 'i18n-datatype' && '@direction' in item) {\n      var _datatype = 'https://www.w3.org/ns/i18n#' + (item['@language'] || '') + \"_\".concat(item['@direction']);\n      object.datatype.value = _datatype;\n      object.value = value;\n    } else if ('@language' in item) {\n      object.value = value;\n      object.datatype.value = datatype || RDF_LANGSTRING;\n      object.language = item['@language'];\n    } else {\n      object.value = value;\n      object.datatype.value = datatype || XSD_STRING;\n    }\n  } else if (graphTypes.isList(item)) {\n    var _list = _listToRDF(item['@list'], issuer, dataset, graphTerm, rdfDirection);\n    object.termType = _list.termType;\n    object.value = _list.value;\n  } else {\n    // convert string/node object to RDF\n    var id = types.isObject(item) ? item['@id'] : item;\n    object.termType = id.startsWith('_:') ? 'BlankNode' : 'NamedNode';\n    object.value = id;\n  }\n\n  // skip relative IRIs, not valid RDF\n  if (object.termType === 'NamedNode' && !_isAbsoluteIri(object.value)) {\n    return null;\n  }\n  return object;\n}","map":{"version":3,"names":["require","createNodeMap","isKeyword","graphTypes","jsonCanonicalize","types","util","RDF_FIRST","RDF_REST","RDF_NIL","RDF_TYPE","RDF_JSON_LITERAL","RDF_LANGSTRING","XSD_BOOLEAN","XSD_DOUBLE","XSD_INTEGER","XSD_STRING","_isAbsoluteIri","isAbsolute","api","module","exports","toRDF","input","options","issuer","IdentifierIssuer","nodeMap","dataset","graphNames","Object","keys","sort","graphName","graphTerm","termType","value","startsWith","_graphToRDF","graph","ids","id","node","properties","property","items","item","subject","predicate","produceGeneralizedRdf","object","_objectToRDF","rdfDirection","push","_listToRDF","list","first","rest","nil","last","pop","result","getId","next","isValue","undefined","datatype","isBoolean","toString","isDouble","parseFloat","toExponential","replace","isNumber","toFixed","language","isList","_list","isObject"],"sources":["E:/react-todo-app/node_modules/jsonld/lib/toRdf.js"],"sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {createNodeMap} = require('./nodeMap');\nconst {isKeyword} = require('./context');\nconst graphTypes = require('./graphTypes');\nconst jsonCanonicalize = require('canonicalize');\nconst types = require('./types');\nconst util = require('./util');\n\nconst {\n  // RDF,\n  // RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  RDF_LANGSTRING,\n\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING,\n} = require('./constants');\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = require('./url');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Outputs an RDF dataset for the expanded JSON-LD input.\n *\n * @param input the expanded JSON-LD input.\n * @param options the RDF serialization options.\n *\n * @return the RDF dataset.\n */\napi.toRDF = (input, options) => {\n  // create node map for default graph (and any named graphs)\n  const issuer = new util.IdentifierIssuer('_:b');\n  const nodeMap = {'@default': {}};\n  createNodeMap(input, nodeMap, '@default', issuer);\n\n  const dataset = [];\n  const graphNames = Object.keys(nodeMap).sort();\n  for(const graphName of graphNames) {\n    let graphTerm;\n    if(graphName === '@default') {\n      graphTerm = {termType: 'DefaultGraph', value: ''};\n    } else if(_isAbsoluteIri(graphName)) {\n      if(graphName.startsWith('_:')) {\n        graphTerm = {termType: 'BlankNode'};\n      } else {\n        graphTerm = {termType: 'NamedNode'};\n      }\n      graphTerm.value = graphName;\n    } else {\n      // skip relative IRIs (not valid RDF)\n      continue;\n    }\n    _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);\n  }\n\n  return dataset;\n};\n\n/**\n * Adds RDF quads for a particular graph to the given dataset.\n *\n * @param dataset the dataset to append RDF quads to.\n * @param graph the graph to create RDF quads for.\n * @param graphTerm the graph term for each quad.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param options the RDF serialization options.\n *\n * @return the array of RDF triples for the given graph.\n */\nfunction _graphToRDF(dataset, graph, graphTerm, issuer, options) {\n  const ids = Object.keys(graph).sort();\n  for(const id of ids) {\n    const node = graph[id];\n    const properties = Object.keys(node).sort();\n    for(let property of properties) {\n      const items = node[property];\n      if(property === '@type') {\n        property = RDF_TYPE;\n      } else if(isKeyword(property)) {\n        continue;\n      }\n\n      for(const item of items) {\n        // RDF subject\n        const subject = {\n          termType: id.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: id\n        };\n\n        // skip relative IRI subjects (not valid RDF)\n        if(!_isAbsoluteIri(id)) {\n          continue;\n        }\n\n        // RDF predicate\n        const predicate = {\n          termType: property.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: property\n        };\n\n        // skip relative IRI predicates (not valid RDF)\n        if(!_isAbsoluteIri(property)) {\n          continue;\n        }\n\n        // skip blank node predicates unless producing generalized RDF\n        if(predicate.termType === 'BlankNode' &&\n          !options.produceGeneralizedRdf) {\n          continue;\n        }\n\n        // convert list, value or node object to triple\n        const object =\n          _objectToRDF(item, issuer, dataset, graphTerm, options.rdfDirection);\n        // skip null objects (they are relative IRIs)\n        if(object) {\n          dataset.push({\n            subject,\n            predicate,\n            object,\n            graph: graphTerm\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * Converts a @list value into linked list of blank node RDF quads\n * (an RDF collection).\n *\n * @param list the @list value.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the array of quads to append to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the head of the list.\n */\nfunction _listToRDF(list, issuer, dataset, graphTerm, rdfDirection) {\n  const first = {termType: 'NamedNode', value: RDF_FIRST};\n  const rest = {termType: 'NamedNode', value: RDF_REST};\n  const nil = {termType: 'NamedNode', value: RDF_NIL};\n\n  const last = list.pop();\n  // Result is the head of the list\n  const result = last ? {termType: 'BlankNode', value: issuer.getId()} : nil;\n  let subject = result;\n\n  for(const item of list) {\n    const object = _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection);\n    const next = {termType: 'BlankNode', value: issuer.getId()};\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: next,\n      graph: graphTerm\n    });\n    subject = next;\n  }\n\n  // Tail of list\n  if(last) {\n    const object = _objectToRDF(last, issuer, dataset, graphTerm, rdfDirection);\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: nil,\n      graph: graphTerm\n    });\n  }\n\n  return result;\n}\n\n/**\n * Converts a JSON-LD value object to an RDF literal or a JSON-LD string,\n * node object to an RDF resource, or adds a list.\n *\n * @param item the JSON-LD value or node object.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the dataset to append RDF quads to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the RDF literal or RDF resource.\n */\nfunction _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection) {\n  const object = {};\n\n  // convert value object to RDF\n  if(graphTypes.isValue(item)) {\n    object.termType = 'Literal';\n    object.value = undefined;\n    object.datatype = {\n      termType: 'NamedNode'\n    };\n    let value = item['@value'];\n    const datatype = item['@type'] || null;\n\n    // convert to XSD/JSON datatypes as appropriate\n    if(datatype === '@json') {\n      object.value = jsonCanonicalize(value);\n      object.datatype.value = RDF_JSON_LITERAL;\n    } else if(types.isBoolean(value)) {\n      object.value = value.toString();\n      object.datatype.value = datatype || XSD_BOOLEAN;\n    } else if(types.isDouble(value) || datatype === XSD_DOUBLE) {\n      if(!types.isDouble(value)) {\n        value = parseFloat(value);\n      }\n      // canonical double representation\n      object.value = value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n      object.datatype.value = datatype || XSD_DOUBLE;\n    } else if(types.isNumber(value)) {\n      object.value = value.toFixed(0);\n      object.datatype.value = datatype || XSD_INTEGER;\n    } else if(rdfDirection === 'i18n-datatype' &&\n      '@direction' in item) {\n      const datatype = 'https://www.w3.org/ns/i18n#' +\n        (item['@language'] || '') +\n        `_${item['@direction']}`;\n      object.datatype.value = datatype;\n      object.value = value;\n    } else if('@language' in item) {\n      object.value = value;\n      object.datatype.value = datatype || RDF_LANGSTRING;\n      object.language = item['@language'];\n    } else {\n      object.value = value;\n      object.datatype.value = datatype || XSD_STRING;\n    }\n  } else if(graphTypes.isList(item)) {\n    const _list =\n      _listToRDF(item['@list'], issuer, dataset, graphTerm, rdfDirection);\n    object.termType = _list.termType;\n    object.value = _list.value;\n  } else {\n    // convert string/node object to RDF\n    const id = types.isObject(item) ? item['@id'] : item;\n    object.termType = id.startsWith('_:') ? 'BlankNode' : 'NamedNode';\n    object.value = id;\n  }\n\n  // skip relative IRIs, not valid RDF\n  if(object.termType === 'NamedNode' && !_isAbsoluteIri(object.value)) {\n    return null;\n  }\n\n  return object;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}