{"ast":null,"code":"import _regeneratorRuntime from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _objectSpread from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { encode as base64url } from '../../runtime/base64url.js';\nimport _encrypt from '../../runtime/encrypt.js';\nimport { deflate } from '../../runtime/zlib.js';\nimport generateIv from '../../lib/iv.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport var unprotected = Symbol();\nexport var FlattenedEncrypt = /*#__PURE__*/function () {\n  function FlattenedEncrypt(plaintext) {\n    _classCallCheck(this, FlattenedEncrypt);\n    if (!(plaintext instanceof Uint8Array)) {\n      throw new TypeError('plaintext must be an instance of Uint8Array');\n    }\n    this._plaintext = plaintext;\n  }\n  _createClass(FlattenedEncrypt, [{\n    key: \"setKeyManagementParameters\",\n    value: function setKeyManagementParameters(parameters) {\n      if (this._keyManagementParameters) {\n        throw new TypeError('setKeyManagementParameters can only be called once');\n      }\n      this._keyManagementParameters = parameters;\n      return this;\n    }\n  }, {\n    key: \"setProtectedHeader\",\n    value: function setProtectedHeader(protectedHeader) {\n      if (this._protectedHeader) {\n        throw new TypeError('setProtectedHeader can only be called once');\n      }\n      this._protectedHeader = protectedHeader;\n      return this;\n    }\n  }, {\n    key: \"setSharedUnprotectedHeader\",\n    value: function setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n      if (this._sharedUnprotectedHeader) {\n        throw new TypeError('setSharedUnprotectedHeader can only be called once');\n      }\n      this._sharedUnprotectedHeader = sharedUnprotectedHeader;\n      return this;\n    }\n  }, {\n    key: \"setUnprotectedHeader\",\n    value: function setUnprotectedHeader(unprotectedHeader) {\n      if (this._unprotectedHeader) {\n        throw new TypeError('setUnprotectedHeader can only be called once');\n      }\n      this._unprotectedHeader = unprotectedHeader;\n      return this;\n    }\n  }, {\n    key: \"setAdditionalAuthenticatedData\",\n    value: function setAdditionalAuthenticatedData(aad) {\n      this._aad = aad;\n      return this;\n    }\n  }, {\n    key: \"setContentEncryptionKey\",\n    value: function setContentEncryptionKey(cek) {\n      if (this._cek) {\n        throw new TypeError('setContentEncryptionKey can only be called once');\n      }\n      this._cek = cek;\n      return this;\n    }\n  }, {\n    key: \"setInitializationVector\",\n    value: function setInitializationVector(iv) {\n      if (this._iv) {\n        throw new TypeError('setInitializationVector can only be called once');\n      }\n      this._iv = iv;\n      return this;\n    }\n  }, {\n    key: \"encrypt\",\n    value: function () {\n      var _encrypt2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(key, options) {\n        var joseHeader, alg, enc, encryptedKey, cek, parameters, _yield$encryptKeyMana, additionalData, protectedHeader, aadMember, ciphertext, tag, deflated, _yield$_encrypt, _yield$_encrypt2, jwe;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!(!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader)) {\n                _context.next = 2;\n                break;\n              }\n              throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n            case 2:\n              if (isDisjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {\n                _context.next = 4;\n                break;\n              }\n              throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n            case 4:\n              joseHeader = _objectSpread(_objectSpread(_objectSpread({}, this._protectedHeader), this._unprotectedHeader), this._sharedUnprotectedHeader);\n              validateCrit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n              if (!(joseHeader.zip !== undefined)) {\n                _context.next = 11;\n                break;\n              }\n              if (!(!this._protectedHeader || !this._protectedHeader.zip)) {\n                _context.next = 9;\n                break;\n              }\n              throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n            case 9:\n              if (!(joseHeader.zip !== 'DEF')) {\n                _context.next = 11;\n                break;\n              }\n              throw new JOSENotSupported('Unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n            case 11:\n              alg = joseHeader.alg, enc = joseHeader.enc;\n              if (!(typeof alg !== 'string' || !alg)) {\n                _context.next = 14;\n                break;\n              }\n              throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n            case 14:\n              if (!(typeof enc !== 'string' || !enc)) {\n                _context.next = 16;\n                break;\n              }\n              throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n            case 16:\n              if (!(alg === 'dir')) {\n                _context.next = 21;\n                break;\n              }\n              if (!this._cek) {\n                _context.next = 19;\n                break;\n              }\n              throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');\n            case 19:\n              _context.next = 24;\n              break;\n            case 21:\n              if (!(alg === 'ECDH-ES')) {\n                _context.next = 24;\n                break;\n              }\n              if (!this._cek) {\n                _context.next = 24;\n                break;\n              }\n              throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');\n            case 24:\n              _context.next = 26;\n              return encryptKeyManagement(alg, enc, key, this._cek, this._keyManagementParameters);\n            case 26:\n              _yield$encryptKeyMana = _context.sent;\n              cek = _yield$encryptKeyMana.cek;\n              encryptedKey = _yield$encryptKeyMana.encryptedKey;\n              parameters = _yield$encryptKeyMana.parameters;\n              if (parameters) {\n                if (options && unprotected in options) {\n                  if (!this._unprotectedHeader) {\n                    this.setUnprotectedHeader(parameters);\n                  } else {\n                    this._unprotectedHeader = _objectSpread(_objectSpread({}, this._unprotectedHeader), parameters);\n                  }\n                } else {\n                  if (!this._protectedHeader) {\n                    this.setProtectedHeader(parameters);\n                  } else {\n                    this._protectedHeader = _objectSpread(_objectSpread({}, this._protectedHeader), parameters);\n                  }\n                }\n              }\n              this._iv || (this._iv = generateIv(enc));\n              if (this._protectedHeader) {\n                protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n              } else {\n                protectedHeader = encoder.encode('');\n              }\n              if (this._aad) {\n                aadMember = base64url(this._aad);\n                additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(aadMember));\n              } else {\n                additionalData = protectedHeader;\n              }\n              if (!(joseHeader.zip === 'DEF')) {\n                _context.next = 45;\n                break;\n              }\n              _context.next = 37;\n              return ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);\n            case 37:\n              deflated = _context.sent;\n              _context.next = 40;\n              return _encrypt(enc, deflated, cek, this._iv, additionalData);\n            case 40:\n              _yield$_encrypt = _context.sent;\n              ciphertext = _yield$_encrypt.ciphertext;\n              tag = _yield$_encrypt.tag;\n              _context.next = 51;\n              break;\n            case 45:\n              ;\n              _context.next = 48;\n              return _encrypt(enc, this._plaintext, cek, this._iv, additionalData);\n            case 48:\n              _yield$_encrypt2 = _context.sent;\n              ciphertext = _yield$_encrypt2.ciphertext;\n              tag = _yield$_encrypt2.tag;\n            case 51:\n              jwe = {\n                ciphertext: base64url(ciphertext),\n                iv: base64url(this._iv),\n                tag: base64url(tag)\n              };\n              if (encryptedKey) {\n                jwe.encrypted_key = base64url(encryptedKey);\n              }\n              if (aadMember) {\n                jwe.aad = aadMember;\n              }\n              if (this._protectedHeader) {\n                jwe.protected = decoder.decode(protectedHeader);\n              }\n              if (this._sharedUnprotectedHeader) {\n                jwe.unprotected = this._sharedUnprotectedHeader;\n              }\n              if (this._unprotectedHeader) {\n                jwe.header = this._unprotectedHeader;\n              }\n              return _context.abrupt(\"return\", jwe);\n            case 58:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function encrypt(_x, _x2) {\n        return _encrypt2.apply(this, arguments);\n      }\n      return encrypt;\n    }()\n  }]);\n  return FlattenedEncrypt;\n}();","map":{"version":3,"names":["encode","base64url","encrypt","deflate","generateIv","encryptKeyManagement","JOSENotSupported","JWEInvalid","isDisjoint","encoder","decoder","concat","validateCrit","unprotected","Symbol","FlattenedEncrypt","plaintext","Uint8Array","TypeError","_plaintext","parameters","_keyManagementParameters","protectedHeader","_protectedHeader","sharedUnprotectedHeader","_sharedUnprotectedHeader","unprotectedHeader","_unprotectedHeader","aad","_aad","cek","_cek","iv","_iv","key","options","joseHeader","Map","crit","zip","undefined","alg","enc","encryptedKey","setUnprotectedHeader","setProtectedHeader","JSON","stringify","aadMember","additionalData","deflateRaw","deflated","ciphertext","tag","jwe","encrypted_key","protected","decode","header"],"sources":["E:/react-todo-app/node_modules/jose/dist/browser/jwe/flattened/encrypt.js"],"sourcesContent":["import { encode as base64url } from '../../runtime/base64url.js';\nimport encrypt from '../../runtime/encrypt.js';\nimport { deflate } from '../../runtime/zlib.js';\nimport generateIv from '../../lib/iv.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { JOSENotSupported, JWEInvalid } from '../../util/errors.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport { encoder, decoder, concat } from '../../lib/buffer_utils.js';\nimport validateCrit from '../../lib/validate_crit.js';\nexport const unprotected = Symbol();\nexport class FlattenedEncrypt {\n    constructor(plaintext) {\n        if (!(plaintext instanceof Uint8Array)) {\n            throw new TypeError('plaintext must be an instance of Uint8Array');\n        }\n        this._plaintext = plaintext;\n    }\n    setKeyManagementParameters(parameters) {\n        if (this._keyManagementParameters) {\n            throw new TypeError('setKeyManagementParameters can only be called once');\n        }\n        this._keyManagementParameters = parameters;\n        return this;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._sharedUnprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._sharedUnprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    setContentEncryptionKey(cek) {\n        if (this._cek) {\n            throw new TypeError('setContentEncryptionKey can only be called once');\n        }\n        this._cek = cek;\n        return this;\n    }\n    setInitializationVector(iv) {\n        if (this._iv) {\n            throw new TypeError('setInitializationVector can only be called once');\n        }\n        this._iv = iv;\n        return this;\n    }\n    async encrypt(key, options) {\n        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {\n            throw new JWEInvalid('either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()');\n        }\n        if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {\n            throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n        }\n        const joseHeader = {\n            ...this._protectedHeader,\n            ...this._unprotectedHeader,\n            ...this._sharedUnprotectedHeader,\n        };\n        validateCrit(JWEInvalid, new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);\n        if (joseHeader.zip !== undefined) {\n            if (!this._protectedHeader || !this._protectedHeader.zip) {\n                throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n            }\n            if (joseHeader.zip !== 'DEF') {\n                throw new JOSENotSupported('Unsupported JWE \"zip\" (Compression Algorithm) Header Parameter value');\n            }\n        }\n        const { alg, enc } = joseHeader;\n        if (typeof alg !== 'string' || !alg) {\n            throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n        }\n        if (typeof enc !== 'string' || !enc) {\n            throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n        }\n        let encryptedKey;\n        if (alg === 'dir') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Encryption');\n            }\n        }\n        else if (alg === 'ECDH-ES') {\n            if (this._cek) {\n                throw new TypeError('setContentEncryptionKey cannot be called when using Direct Key Agreement');\n            }\n        }\n        let cek;\n        {\n            let parameters;\n            ({ cek, encryptedKey, parameters } = await encryptKeyManagement(alg, enc, key, this._cek, this._keyManagementParameters));\n            if (parameters) {\n                if (options && unprotected in options) {\n                    if (!this._unprotectedHeader) {\n                        this.setUnprotectedHeader(parameters);\n                    }\n                    else {\n                        this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };\n                    }\n                }\n                else {\n                    if (!this._protectedHeader) {\n                        this.setProtectedHeader(parameters);\n                    }\n                    else {\n                        this._protectedHeader = { ...this._protectedHeader, ...parameters };\n                    }\n                }\n            }\n        }\n        this._iv || (this._iv = generateIv(enc));\n        let additionalData;\n        let protectedHeader;\n        let aadMember;\n        if (this._protectedHeader) {\n            protectedHeader = encoder.encode(base64url(JSON.stringify(this._protectedHeader)));\n        }\n        else {\n            protectedHeader = encoder.encode('');\n        }\n        if (this._aad) {\n            aadMember = base64url(this._aad);\n            additionalData = concat(protectedHeader, encoder.encode('.'), encoder.encode(aadMember));\n        }\n        else {\n            additionalData = protectedHeader;\n        }\n        let ciphertext;\n        let tag;\n        if (joseHeader.zip === 'DEF') {\n            const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);\n            ({ ciphertext, tag } = await encrypt(enc, deflated, cek, this._iv, additionalData));\n        }\n        else {\n            ;\n            ({ ciphertext, tag } = await encrypt(enc, this._plaintext, cek, this._iv, additionalData));\n        }\n        const jwe = {\n            ciphertext: base64url(ciphertext),\n            iv: base64url(this._iv),\n            tag: base64url(tag),\n        };\n        if (encryptedKey) {\n            jwe.encrypted_key = base64url(encryptedKey);\n        }\n        if (aadMember) {\n            jwe.aad = aadMember;\n        }\n        if (this._protectedHeader) {\n            jwe.protected = decoder.decode(protectedHeader);\n        }\n        if (this._sharedUnprotectedHeader) {\n            jwe.unprotected = this._sharedUnprotectedHeader;\n        }\n        if (this._unprotectedHeader) {\n            jwe.header = this._unprotectedHeader;\n        }\n        return jwe;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}