{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Session = exports.silentlyAuthenticate = void 0;\nconst events_1 = require(\"events\");\nconst solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\nconst uuid_1 = require(\"uuid\");\nconst dependencies_1 = require(\"./dependencies\");\nconst constant_1 = require(\"./constant\");\nasync function silentlyAuthenticate(sessionId, clientAuthn, session) {\n  var _a;\n  const storedSessionInfo = await clientAuthn.validateCurrentSession(sessionId);\n  if (storedSessionInfo !== null) {\n    window.localStorage.setItem(constant_1.KEY_CURRENT_URL, window.location.href);\n    await clientAuthn.login({\n      sessionId,\n      prompt: \"none\",\n      oidcIssuer: storedSessionInfo.issuer,\n      redirectUrl: storedSessionInfo.redirectUrl,\n      clientId: storedSessionInfo.clientAppId,\n      clientSecret: storedSessionInfo.clientAppSecret,\n      tokenType: (_a = storedSessionInfo.tokenType) !== null && _a !== void 0 ? _a : \"DPoP\"\n    }, session);\n    return true;\n  }\n  return false;\n}\nexports.silentlyAuthenticate = silentlyAuthenticate;\nfunction isLoggedIn(sessionInfo) {\n  return !!(sessionInfo === null || sessionInfo === void 0 ? void 0 : sessionInfo.isLoggedIn);\n}\nclass Session extends events_1.EventEmitter {\n  constructor() {\n    var _this;\n    let sessionOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let sessionId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n    super();\n    _this = this;\n    this.tokenRequestInProgress = false;\n    this.login = async options => {\n      var _a;\n      await this.clientAuthentication.login({\n        sessionId: this.info.sessionId,\n        ...options,\n        tokenType: (_a = options.tokenType) !== null && _a !== void 0 ? _a : \"DPoP\"\n      }, this);\n      return new Promise(() => {});\n    };\n    this.fetch = async (url, init) => {\n      return this.clientAuthentication.fetch(url, init);\n    };\n    this.internalLogout = async emitSignal => {\n      window.localStorage.removeItem(constant_1.KEY_CURRENT_SESSION);\n      await this.clientAuthentication.logout(this.info.sessionId);\n      this.info.isLoggedIn = false;\n      if (emitSignal) {\n        this.emit(solid_client_authn_core_1.EVENTS.LOGOUT);\n      }\n    };\n    this.logout = async () => this.internalLogout(true);\n    this.handleIncomingRedirect = async function () {\n      let inputOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _a;\n      if (_this.info.isLoggedIn) {\n        return _this.info;\n      }\n      if (_this.tokenRequestInProgress) {\n        return undefined;\n      }\n      const options = typeof inputOptions === \"string\" ? {\n        url: inputOptions\n      } : inputOptions;\n      const url = (_a = options.url) !== null && _a !== void 0 ? _a : window.location.href;\n      _this.tokenRequestInProgress = true;\n      const sessionInfo = await _this.clientAuthentication.handleIncomingRedirect(url, _this);\n      if (isLoggedIn(sessionInfo)) {\n        _this.setSessionInfo(sessionInfo);\n        const currentUrl = window.localStorage.getItem(constant_1.KEY_CURRENT_URL);\n        if (currentUrl === null) {\n          _this.emit(solid_client_authn_core_1.EVENTS.LOGIN);\n        } else {\n          window.localStorage.removeItem(constant_1.KEY_CURRENT_URL);\n          _this.emit(solid_client_authn_core_1.EVENTS.SESSION_RESTORED, currentUrl);\n        }\n      } else if (options.restorePreviousSession === true) {\n        const storedSessionId = window.localStorage.getItem(constant_1.KEY_CURRENT_SESSION);\n        if (storedSessionId !== null) {\n          const attemptedSilentAuthentication = await silentlyAuthenticate(storedSessionId, _this.clientAuthentication, _this);\n          if (attemptedSilentAuthentication) {\n            return new Promise(() => {});\n          }\n        }\n      }\n      _this.tokenRequestInProgress = false;\n      return sessionInfo;\n    };\n    if (sessionOptions.clientAuthentication) {\n      this.clientAuthentication = sessionOptions.clientAuthentication;\n    } else if (sessionOptions.secureStorage && sessionOptions.insecureStorage) {\n      this.clientAuthentication = (0, dependencies_1.getClientAuthenticationWithDependencies)({\n        secureStorage: sessionOptions.secureStorage,\n        insecureStorage: sessionOptions.insecureStorage\n      });\n    } else {\n      this.clientAuthentication = (0, dependencies_1.getClientAuthenticationWithDependencies)({});\n    }\n    if (sessionOptions.sessionInfo) {\n      this.info = {\n        sessionId: sessionOptions.sessionInfo.sessionId,\n        isLoggedIn: false,\n        webId: sessionOptions.sessionInfo.webId\n      };\n    } else {\n      this.info = {\n        sessionId: sessionId !== null && sessionId !== void 0 ? sessionId : (0, uuid_1.v4)(),\n        isLoggedIn: false\n      };\n    }\n    this.on(solid_client_authn_core_1.EVENTS.LOGIN, () => window.localStorage.setItem(constant_1.KEY_CURRENT_SESSION, this.info.sessionId));\n    this.on(solid_client_authn_core_1.EVENTS.SESSION_EXPIRED, () => this.internalLogout(false));\n    this.on(solid_client_authn_core_1.EVENTS.ERROR, () => this.internalLogout(false));\n  }\n  onLogin(callback) {\n    this.on(solid_client_authn_core_1.EVENTS.LOGIN, callback);\n  }\n  onLogout(callback) {\n    this.on(solid_client_authn_core_1.EVENTS.LOGOUT, callback);\n  }\n  onError(callback) {\n    this.on(solid_client_authn_core_1.EVENTS.ERROR, callback);\n  }\n  onSessionRestore(callback) {\n    this.on(solid_client_authn_core_1.EVENTS.SESSION_RESTORED, callback);\n  }\n  onSessionExpiration(callback) {\n    this.on(solid_client_authn_core_1.EVENTS.SESSION_EXPIRED, callback);\n  }\n  setSessionInfo(sessionInfo) {\n    this.info.isLoggedIn = sessionInfo.isLoggedIn;\n    this.info.webId = sessionInfo.webId;\n    this.info.sessionId = sessionInfo.sessionId;\n    this.info.expirationDate = sessionInfo.expirationDate;\n    this.on(solid_client_authn_core_1.EVENTS.SESSION_EXTENDED, expiresIn => {\n      this.info.expirationDate = Date.now() + expiresIn * 1000;\n    });\n  }\n}\nexports.Session = Session;","map":{"version":3,"mappings":"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","names":["silentlyAuthenticate","sessionId","clientAuthn","session","storedSessionInfo","validateCurrentSession","window","localStorage","setItem","constant_1","location","href","login","prompt","oidcIssuer","issuer","redirectUrl","clientId","clientAppId","clientSecret","clientAppSecret","tokenType","exports","isLoggedIn","sessionInfo","Session","events_1","constructor","sessionOptions","undefined","options","clientAuthentication","info","Promise","url","init","fetch","emitSignal","removeItem","logout","emit","solid_client_authn_core_1","LOGOUT","internalLogout","inputOptions","tokenRequestInProgress","handleIncomingRedirect","setSessionInfo","currentUrl","getItem","LOGIN","SESSION_RESTORED","restorePreviousSession","storedSessionId","attemptedSilentAuthentication","secureStorage","insecureStorage","webId","on","SESSION_EXPIRED","ERROR","onLogin","callback","onLogout","onError","onSessionRestore","onSessionExpiration","expirationDate","SESSION_EXTENDED","expiresIn","Date","now"],"sources":["G:\\To-do-List_App-main\\node_modules\\@inrupt\\solid-client-authn-browser\\src\\Session.ts"],"sourcesContent":["//\n// Copyright 2022 Inrupt Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n// Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n/**\n * @hidden\n */\nimport { EventEmitter } from \"events\";\nimport {\n  EVENTS,\n  ILoginInputOptions,\n  ISessionInfo,\n  IStorage,\n} from \"@inrupt/solid-client-authn-core\";\nimport { v4 } from \"uuid\";\nimport ClientAuthentication from \"./ClientAuthentication\";\nimport { getClientAuthenticationWithDependencies } from \"./dependencies\";\nimport { KEY_CURRENT_SESSION, KEY_CURRENT_URL } from \"./constant\";\n\nexport interface ISessionOptions {\n  /**\n   * A private storage, unreachable to other scripts on the page. Typically in-memory.\n   */\n  secureStorage: IStorage;\n  /**\n   * A storage where non-sensitive information may be stored, potentially longer-lived than the secure storage.\n   */\n  insecureStorage: IStorage;\n  /**\n   * Details about the current session\n   */\n  sessionInfo: ISessionInfo;\n  /**\n   * An instance of the library core. Typically obtained using `getClientAuthenticationWithDependencies`.\n   */\n  clientAuthentication: ClientAuthentication;\n}\n\nexport interface IHandleIncomingRedirectOptions {\n  /**\n   * If the user has signed in before, setting this to `true` will automatically\n   * redirect them to their Solid Identity Provider, which will then attempt to\n   * re-activate the session and send the user back to your app without\n   * requiring user interaction.\n   * If your app's access has not expired yet and re-activation completed\n   * successfully, a `sessionRestore` event will be fired with the URL the user\n   * was at before they were redirected to their Solid Identity Provider.\n   * {@see onSessionRestore}\n   */\n  restorePreviousSession?: boolean;\n\n  /**\n   * Inrupt's Enterprise Solid Server can set a cookie to allow the browser to\n   * access private resources on a Pod. In order to mitigate the logout-on-refresh\n   * issue on the short term, the server also implemented a session endpoint\n   * enabling the client app to know whether the cookie is set. When a user\n   * logs in to a server that has that capability enabled, applications that set\n   * this option to `true` will be able to make use of it.\n   *\n   * If your app supports the newest session restore approach, and `restorePreviousSession`\n   * is set to true, this option is automatically set to false, but your app will\n   * not be logged out when reloaded.\n   *\n   * `useEssSession` defaults to false and will be removed in the future; to\n   * preserve sessions across page reloads, use of `restorePreviousSession` is\n   * recommended.\n   *\n   * @deprecated unreleased\n   */\n  useEssSession?: boolean;\n  /**\n   * The URL of the page handling the redirect, including the query\n   * parameters â€” these contain the information to process the login.\n   * Note: as a convenience, if no URL value is specified here, we default to\n   * using the browser's current location.\n   */\n  url?: string;\n}\n\nexport async function silentlyAuthenticate(\n  sessionId: string,\n  clientAuthn: ClientAuthentication,\n  session: Session\n): Promise<boolean> {\n  const storedSessionInfo = await clientAuthn.validateCurrentSession(sessionId);\n  if (storedSessionInfo !== null) {\n    // It can be really useful to save the user's current browser location,\n    // so that we can restore it after completing the silent authentication\n    // on incoming redirect. This way, the user is eventually redirected back\n    // to the page they were on and not to the app's redirect page.\n    window.localStorage.setItem(KEY_CURRENT_URL, window.location.href);\n    await clientAuthn.login(\n      {\n        sessionId,\n        prompt: \"none\",\n        oidcIssuer: storedSessionInfo.issuer,\n        redirectUrl: storedSessionInfo.redirectUrl,\n        clientId: storedSessionInfo.clientAppId,\n        clientSecret: storedSessionInfo.clientAppSecret,\n        tokenType: storedSessionInfo.tokenType ?? \"DPoP\",\n      },\n      session\n    );\n    return true;\n  }\n  return false;\n}\n\nfunction isLoggedIn(\n  sessionInfo?: ISessionInfo\n): sessionInfo is ISessionInfo & { isLoggedIn: true } {\n  return !!sessionInfo?.isLoggedIn;\n}\n\n/**\n * A {@link Session} object represents a user's session on an application. The session holds state, as it stores information enabling acces to private resources after login for instance.\n */\nexport class Session extends EventEmitter {\n  /**\n   * Information regarding the current session.\n   */\n  public readonly info: ISessionInfo;\n\n  private clientAuthentication: ClientAuthentication;\n\n  private tokenRequestInProgress = false;\n\n  /**\n   * Session object constructor. Typically called as follows:\n   *\n   * ```typescript\n   * const session = new Session();\n   * ```\n   *\n   * See also [getDefaultSession](https://docs.inrupt.com/developer-tools/api/javascript/solid-client-authn-browser/functions.html#getdefaultsession).\n   *\n   * @param sessionOptions The options enabling the correct instantiation of\n   * the session. Either both storages or clientAuthentication are required. For\n   * more information, see {@link ISessionOptions}.\n   * @param sessionId A string uniquely identifying the session.\n   *\n   */\n  constructor(\n    sessionOptions: Partial<ISessionOptions> = {},\n    sessionId: string | undefined = undefined\n  ) {\n    super();\n\n    if (sessionOptions.clientAuthentication) {\n      this.clientAuthentication = sessionOptions.clientAuthentication;\n    } else if (sessionOptions.secureStorage && sessionOptions.insecureStorage) {\n      this.clientAuthentication = getClientAuthenticationWithDependencies({\n        secureStorage: sessionOptions.secureStorage,\n        insecureStorage: sessionOptions.insecureStorage,\n      });\n    } else {\n      this.clientAuthentication = getClientAuthenticationWithDependencies({});\n    }\n\n    if (sessionOptions.sessionInfo) {\n      this.info = {\n        sessionId: sessionOptions.sessionInfo.sessionId,\n        isLoggedIn: false,\n        webId: sessionOptions.sessionInfo.webId,\n      };\n    } else {\n      this.info = {\n        sessionId: sessionId ?? v4(),\n        isLoggedIn: false,\n      };\n    }\n\n    // When a session is logged in, we want to track its ID in local storage to\n    // enable silent refresh. The current session ID specifically stored in 'localStorage'\n    // (as opposed to using our storage abstraction layer) because it is only\n    // used in a browser-specific mechanism.\n    this.on(EVENTS.LOGIN, () =>\n      window.localStorage.setItem(KEY_CURRENT_SESSION, this.info.sessionId)\n    );\n\n    this.on(EVENTS.SESSION_EXPIRED, () => this.internalLogout(false));\n\n    this.on(EVENTS.ERROR, () => this.internalLogout(false));\n  }\n\n  /**\n   * Triggers the login process. Note that this method will redirect the user away from your app.\n   *\n   * @param options Parameter to customize the login behaviour. In particular, two options are mandatory: `options.oidcIssuer`, the user's identity provider, and `options.redirectUrl`, the URL to which the user will be redirected after logging in their identity provider.\n   * @returns This method should redirect the user away from the app: it does not return anything. The login process is completed by {@linkcode handleIncomingRedirect}.\n   */\n  // Define these functions as properties so that they don't get accidentally re-bound.\n  // Isn't Javascript fun?\n  login = async (options: ILoginInputOptions): Promise<void> => {\n    await this.clientAuthentication.login(\n      {\n        sessionId: this.info.sessionId,\n        ...options,\n        // Defaults the token type to DPoP\n        tokenType: options.tokenType ?? \"DPoP\",\n      },\n      this\n    );\n    // `login` redirects the user away from the app,\n    // so unless it throws an error, there is no code that should run afterwards\n    // (since there is no \"after\" in the lifetime of the script).\n    // Hence, this Promise never resolves:\n    return new Promise(() => {});\n  };\n\n  /**\n   * Fetches data using available login information. If the user is not logged in, this will behave as a regular `fetch`. The signature of this method is identical to the [canonical `fetch`](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n   *\n   * @param url The URL from which data should be fetched.\n   * @param init Optional parameters customizing the request, by specifying an HTTP method, headers, a body, etc. Follows the [WHATWG Fetch Standard](https://fetch.spec.whatwg.org/).\n   */\n  fetch: typeof fetch = async (url, init) => {\n    return this.clientAuthentication.fetch(url, init);\n  };\n\n  /**\n   * An internal logout function, to control whether or not the logout signal\n   * should be sent, i.e. if the logout was user-initiated or is the result of\n   * an external event.\n   *\n   * @hidden\n   */\n  private internalLogout = async (emitSignal: boolean): Promise<void> => {\n    // Clearing this value means that silent refresh will no longer be attempted.\n    // In particular, in the case of a silent authentication error it prevents\n    // from getting stuck in an authentication retries loop.\n    window.localStorage.removeItem(KEY_CURRENT_SESSION);\n    await this.clientAuthentication.logout(this.info.sessionId);\n    this.info.isLoggedIn = false;\n    if (emitSignal) {\n      this.emit(EVENTS.LOGOUT);\n    }\n  };\n\n  /**\n   * Logs the user out of the application. This does not log the user out of their Solid identity provider, and should not redirect the user away.\n   */\n  logout = async (): Promise<void> => this.internalLogout(true);\n\n  /**\n   * Completes the login process by processing the information provided by the\n   * Solid identity provider through redirect.\n   *\n   * @param options See {@see IHandleIncomingRedirectOptions}.\n   */\n  handleIncomingRedirect = async (\n    inputOptions: string | IHandleIncomingRedirectOptions = {}\n  ): Promise<ISessionInfo | undefined> => {\n    if (this.info.isLoggedIn) {\n      return this.info;\n    }\n\n    if (this.tokenRequestInProgress) {\n      return undefined;\n    }\n    const options =\n      typeof inputOptions === \"string\" ? { url: inputOptions } : inputOptions;\n    const url = options.url ?? window.location.href;\n\n    this.tokenRequestInProgress = true;\n    const sessionInfo = await this.clientAuthentication.handleIncomingRedirect(\n      url,\n      this\n    );\n    if (isLoggedIn(sessionInfo)) {\n      this.setSessionInfo(sessionInfo);\n      const currentUrl = window.localStorage.getItem(KEY_CURRENT_URL);\n      if (currentUrl === null) {\n        // The login event can only be triggered **after** the user has been\n        // redirected from the IdP with access and ID tokens.\n        this.emit(EVENTS.LOGIN);\n      } else {\n        // If an URL is stored in local storage, we are being logged in after a\n        // silent authentication, so remove our currently stored URL location\n        // to clean up our state now that we are completing the re-login process.\n        window.localStorage.removeItem(KEY_CURRENT_URL);\n        this.emit(EVENTS.SESSION_RESTORED, currentUrl);\n      }\n    } else if (options.restorePreviousSession === true) {\n      // Silent authentication happens after a refresh, which means there are no\n      // OAuth params in the current location IRI. It can only succeed if a session\n      // was previously logged in, in which case its ID will be present with a known\n      // identifier in local storage.\n      // Check if we have a locally stored session ID...\n      const storedSessionId = window.localStorage.getItem(KEY_CURRENT_SESSION);\n      // ...if not, then there is no ID token, and so silent authentication cannot happen, but\n      // if we do have a stored session ID, attempt to re-authenticate now silently.\n      if (storedSessionId !== null) {\n        const attemptedSilentAuthentication = await silentlyAuthenticate(\n          storedSessionId,\n          this.clientAuthentication,\n          this\n        );\n        // At this point, we know that the main window will imminently be redirected.\n        // However, this redirect is asynchronous and there is no way to halt execution\n        // until it happens precisely. That's why the current Promise simply does not\n        // resolve.\n        if (attemptedSilentAuthentication) {\n          return new Promise(() => {});\n        }\n      }\n    }\n    this.tokenRequestInProgress = false;\n    return sessionInfo;\n  };\n\n  /**\n   * Register a callback function to be called when a user completes login.\n   *\n   * The callback is called when {@link handleIncomingRedirect} completes successfully.\n   *\n   * @param callback The function called when a user completes login.\n   */\n  onLogin(callback: () => unknown): void {\n    this.on(EVENTS.LOGIN, callback);\n  }\n\n  /**\n   * Register a callback function to be called when a user logs out:\n   *\n   * @param callback The function called when a user completes logout.\n   */\n  onLogout(callback: () => unknown): void {\n    this.on(EVENTS.LOGOUT, callback);\n  }\n\n  /**\n   * Register a callback function to be called when a user logs out:\n   *\n   * @param callback The function called when an error occurs.\n   * @since 1.11.0\n   */\n  onError(\n    callback: (\n      error: string | null,\n      errorDescription?: string | null\n    ) => unknown\n  ): void {\n    this.on(EVENTS.ERROR, callback);\n  }\n\n  /**\n   * Register a callback function to be called when a session is restored.\n   *\n   * Note: the callback will be called with the saved value of the 'current URL'\n   * at the time the session was restored.\n   *\n   * @param callback The function called when a user's already logged-in session is restored, e.g., after a silent authentication is completed after a page refresh.\n   */\n  onSessionRestore(callback: (currentUrl: string) => unknown): void {\n    this.on(EVENTS.SESSION_RESTORED, callback);\n  }\n\n  /**\n   * Register a callback that runs when the session expires and can no longer\n   * make authenticated requests, but following a user logout.\n   * @param callback The function that runs on session expiration.\n   * @since 1.11.0\n   */\n  onSessionExpiration(callback: () => unknown): void {\n    this.on(EVENTS.SESSION_EXPIRED, callback);\n  }\n\n  private setSessionInfo(\n    sessionInfo: ISessionInfo & { isLoggedIn: true }\n  ): void {\n    this.info.isLoggedIn = sessionInfo.isLoggedIn;\n    this.info.webId = sessionInfo.webId;\n    this.info.sessionId = sessionInfo.sessionId;\n    this.info.expirationDate = sessionInfo.expirationDate;\n    this.on(EVENTS.SESSION_EXTENDED, (expiresIn: number) => {\n      this.info.expirationDate = Date.now() + expiresIn * 1000;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}