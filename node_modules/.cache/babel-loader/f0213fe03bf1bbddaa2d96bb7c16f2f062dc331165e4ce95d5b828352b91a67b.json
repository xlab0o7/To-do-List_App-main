{"ast":null,"code":"import _objectSpread from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _regeneratorRuntime from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { decode as decodeBase64URL, encodeBase64, decodeBase64 } from '../runtime/base64url.js';\nimport { fromSPKI as importPublic } from '../runtime/asn1.js';\nimport { fromPKCS8 as importPrivate } from '../runtime/asn1.js';\nimport asKeyObject from '../runtime/jwk_to_key.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport formatPEM from '../lib/format_pem.js';\nimport isObject from '../lib/is_object.js';\nfunction getElement(seq) {\n  var result = [];\n  var next = 0;\n  while (next < seq.length) {\n    var nextPart = parseElement(seq.subarray(next));\n    result.push(nextPart);\n    next += nextPart.byteLength;\n  }\n  return result;\n}\nfunction parseElement(bytes) {\n  var position = 0;\n  var tag = bytes[0] & 0x1f;\n  position++;\n  if (tag === 0x1f) {\n    tag = 0;\n    while (bytes[position] >= 0x80) {\n      tag = tag * 128 + bytes[position] - 0x80;\n      position++;\n    }\n    tag = tag * 128 + bytes[position] - 0x80;\n    position++;\n  }\n  var length = 0;\n  if (bytes[position] < 0x80) {\n    length = bytes[position];\n    position++;\n  } else if (length === 0x80) {\n    length = 0;\n    while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {\n      if (length > bytes.byteLength) {\n        throw new TypeError('invalid indefinite form length');\n      }\n      length++;\n    }\n    var _byteLength = position + length + 2;\n    return {\n      byteLength: _byteLength,\n      contents: bytes.subarray(position, position + length),\n      raw: bytes.subarray(0, _byteLength)\n    };\n  } else {\n    var numberOfDigits = bytes[position] & 0x7f;\n    position++;\n    length = 0;\n    for (var i = 0; i < numberOfDigits; i++) {\n      length = length * 256 + bytes[position];\n      position++;\n    }\n  }\n  var byteLength = position + length;\n  return {\n    byteLength: byteLength,\n    contents: bytes.subarray(position, byteLength),\n    raw: bytes.subarray(0, byteLength)\n  };\n}\nfunction spkiFromX509(buf) {\n  var tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);\n  return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 0xa0 ? 6 : 5].raw);\n}\nfunction getSPKI(x509) {\n  var pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '');\n  var raw = decodeBase64(pem);\n  return formatPEM(spkiFromX509(raw), 'PUBLIC KEY');\n}\nexport function importSPKI(_x, _x2, _x3) {\n  return _importSPKI.apply(this, arguments);\n}\nfunction _importSPKI() {\n  _importSPKI = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(spki, alg, options) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (!(typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0)) {\n            _context.next = 2;\n            break;\n          }\n          throw new TypeError('\"spki\" must be SPKI formatted string');\n        case 2:\n          return _context.abrupt(\"return\", importPublic(spki, alg, options));\n        case 3:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _importSPKI.apply(this, arguments);\n}\nexport function importX509(_x4, _x5, _x6) {\n  return _importX.apply(this, arguments);\n}\nfunction _importX() {\n  _importX = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(x509, alg, options) {\n    var spki;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          if (!(typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0)) {\n            _context2.next = 2;\n            break;\n          }\n          throw new TypeError('\"x509\" must be X.509 formatted string');\n        case 2:\n          _context2.prev = 2;\n          spki = getSPKI(x509);\n          _context2.next = 9;\n          break;\n        case 6:\n          _context2.prev = 6;\n          _context2.t0 = _context2[\"catch\"](2);\n          throw new TypeError('failed to parse the X.509 certificate', {\n            cause: _context2.t0\n          });\n        case 9:\n          return _context2.abrupt(\"return\", importPublic(spki, alg, options));\n        case 10:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[2, 6]]);\n  }));\n  return _importX.apply(this, arguments);\n}\nexport function importPKCS8(_x7, _x8, _x9) {\n  return _importPKCS.apply(this, arguments);\n}\nfunction _importPKCS() {\n  _importPKCS = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(pkcs8, alg, options) {\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          if (!(typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0)) {\n            _context3.next = 2;\n            break;\n          }\n          throw new TypeError('\"pkcs8\" must be PKCS#8 formatted string');\n        case 2:\n          return _context3.abrupt(\"return\", importPrivate(pkcs8, alg, options));\n        case 3:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3);\n  }));\n  return _importPKCS.apply(this, arguments);\n}\nexport function importJWK(_x10, _x11, _x12) {\n  return _importJWK.apply(this, arguments);\n}\nfunction _importJWK() {\n  _importJWK = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(jwk, alg, octAsKeyObject) {\n    var _a;\n    return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n      while (1) switch (_context4.prev = _context4.next) {\n        case 0:\n          if (isObject(jwk)) {\n            _context4.next = 2;\n            break;\n          }\n          throw new TypeError('JWK must be an object');\n        case 2:\n          alg || (alg = jwk.alg);\n          if (!(typeof alg !== 'string' || !alg)) {\n            _context4.next = 5;\n            break;\n          }\n          throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n        case 5:\n          _context4.t0 = jwk.kty;\n          _context4.next = _context4.t0 === 'oct' ? 8 : _context4.t0 === 'RSA' ? 14 : _context4.t0 === 'EC' ? 16 : _context4.t0 === 'OKP' ? 16 : 17;\n          break;\n        case 8:\n          if (!(typeof jwk.k !== 'string' || !jwk.k)) {\n            _context4.next = 10;\n            break;\n          }\n          throw new TypeError('missing \"k\" (Key Value) Parameter value');\n        case 10:\n          octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;\n          if (!octAsKeyObject) {\n            _context4.next = 13;\n            break;\n          }\n          return _context4.abrupt(\"return\", asKeyObject(_objectSpread(_objectSpread({}, jwk), {}, {\n            alg: alg,\n            ext: (_a = jwk.ext) !== null && _a !== void 0 ? _a : false\n          })));\n        case 13:\n          return _context4.abrupt(\"return\", decodeBase64URL(jwk.k));\n        case 14:\n          if (!(jwk.oth !== undefined)) {\n            _context4.next = 16;\n            break;\n          }\n          throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n        case 16:\n          return _context4.abrupt(\"return\", asKeyObject(_objectSpread(_objectSpread({}, jwk), {}, {\n            alg: alg\n          })));\n        case 17:\n          throw new JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n        case 18:\n        case \"end\":\n          return _context4.stop();\n      }\n    }, _callee4);\n  }));\n  return _importJWK.apply(this, arguments);\n}","map":{"version":3,"names":["decode","decodeBase64URL","encodeBase64","decodeBase64","fromSPKI","importPublic","fromPKCS8","importPrivate","asKeyObject","JOSENotSupported","formatPEM","isObject","getElement","seq","result","next","length","nextPart","parseElement","subarray","push","byteLength","bytes","position","tag","TypeError","contents","raw","numberOfDigits","i","spkiFromX509","buf","tbsCertificate","getSPKI","x509","pem","replace","importSPKI","spki","alg","options","indexOf","importX509","cause","importPKCS8","pkcs8","importJWK","jwk","octAsKeyObject","kty","k","ext","_a","oth","undefined"],"sources":["E:/react-todo-app/node_modules/jose/dist/browser/key/import.js"],"sourcesContent":["import { decode as decodeBase64URL, encodeBase64, decodeBase64 } from '../runtime/base64url.js';\nimport { fromSPKI as importPublic } from '../runtime/asn1.js';\nimport { fromPKCS8 as importPrivate } from '../runtime/asn1.js';\nimport asKeyObject from '../runtime/jwk_to_key.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport formatPEM from '../lib/format_pem.js';\nimport isObject from '../lib/is_object.js';\nfunction getElement(seq) {\n    let result = [];\n    let next = 0;\n    while (next < seq.length) {\n        let nextPart = parseElement(seq.subarray(next));\n        result.push(nextPart);\n        next += nextPart.byteLength;\n    }\n    return result;\n}\nfunction parseElement(bytes) {\n    let position = 0;\n    let tag = bytes[0] & 0x1f;\n    position++;\n    if (tag === 0x1f) {\n        tag = 0;\n        while (bytes[position] >= 0x80) {\n            tag = tag * 128 + bytes[position] - 0x80;\n            position++;\n        }\n        tag = tag * 128 + bytes[position] - 0x80;\n        position++;\n    }\n    let length = 0;\n    if (bytes[position] < 0x80) {\n        length = bytes[position];\n        position++;\n    }\n    else if (length === 0x80) {\n        length = 0;\n        while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {\n            if (length > bytes.byteLength) {\n                throw new TypeError('invalid indefinite form length');\n            }\n            length++;\n        }\n        const byteLength = position + length + 2;\n        return {\n            byteLength,\n            contents: bytes.subarray(position, position + length),\n            raw: bytes.subarray(0, byteLength),\n        };\n    }\n    else {\n        let numberOfDigits = bytes[position] & 0x7f;\n        position++;\n        length = 0;\n        for (let i = 0; i < numberOfDigits; i++) {\n            length = length * 256 + bytes[position];\n            position++;\n        }\n    }\n    const byteLength = position + length;\n    return {\n        byteLength,\n        contents: bytes.subarray(position, byteLength),\n        raw: bytes.subarray(0, byteLength),\n    };\n}\nfunction spkiFromX509(buf) {\n    const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);\n    return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 0xa0 ? 6 : 5].raw);\n}\nfunction getSPKI(x509) {\n    const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\\s)/g, '');\n    const raw = decodeBase64(pem);\n    return formatPEM(spkiFromX509(raw), 'PUBLIC KEY');\n}\nexport async function importSPKI(spki, alg, options) {\n    if (typeof spki !== 'string' || spki.indexOf('-----BEGIN PUBLIC KEY-----') !== 0) {\n        throw new TypeError('\"spki\" must be SPKI formatted string');\n    }\n    return importPublic(spki, alg, options);\n}\nexport async function importX509(x509, alg, options) {\n    if (typeof x509 !== 'string' || x509.indexOf('-----BEGIN CERTIFICATE-----') !== 0) {\n        throw new TypeError('\"x509\" must be X.509 formatted string');\n    }\n    let spki;\n    try {\n        spki = getSPKI(x509);\n    }\n    catch (cause) {\n        throw new TypeError('failed to parse the X.509 certificate', { cause });\n    }\n    return importPublic(spki, alg, options);\n}\nexport async function importPKCS8(pkcs8, alg, options) {\n    if (typeof pkcs8 !== 'string' || pkcs8.indexOf('-----BEGIN PRIVATE KEY-----') !== 0) {\n        throw new TypeError('\"pkcs8\" must be PKCS#8 formatted string');\n    }\n    return importPrivate(pkcs8, alg, options);\n}\nexport async function importJWK(jwk, alg, octAsKeyObject) {\n    var _a;\n    if (!isObject(jwk)) {\n        throw new TypeError('JWK must be an object');\n    }\n    alg || (alg = jwk.alg);\n    if (typeof alg !== 'string' || !alg) {\n        throw new TypeError('\"alg\" argument is required when \"jwk.alg\" is not present');\n    }\n    switch (jwk.kty) {\n        case 'oct':\n            if (typeof jwk.k !== 'string' || !jwk.k) {\n                throw new TypeError('missing \"k\" (Key Value) Parameter value');\n            }\n            octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : (octAsKeyObject = jwk.ext !== true);\n            if (octAsKeyObject) {\n                return asKeyObject({ ...jwk, alg, ext: (_a = jwk.ext) !== null && _a !== void 0 ? _a : false });\n            }\n            return decodeBase64URL(jwk.k);\n        case 'RSA':\n            if (jwk.oth !== undefined) {\n                throw new JOSENotSupported('RSA JWK \"oth\" (Other Primes Info) Parameter value is not supported');\n            }\n        case 'EC':\n        case 'OKP':\n            return asKeyObject({ ...jwk, alg });\n        default:\n            throw new JOSENotSupported('Unsupported \"kty\" (Key Type) Parameter value');\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}