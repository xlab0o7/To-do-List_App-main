{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSimpleGraph: _isSimpleGraph,\n  isSubjectReference: _isSubjectReference\n} = require('./graphTypes');\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\nconst {\n  removeBase: _removeBase,\n  prependBase: _prependBase\n} = require('./url');\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = require('./util');\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return a promise that resolves to the compacted value.\n */\napi.compact = async _ref => {\n  let {\n    activeCtx,\n    activeProperty = null,\n    element,\n    options = {},\n    compactionMap = () => undefined\n  } = _ref;\n  // recursively compact array\n  if (_isArray(element)) {\n    let rval = [];\n    for (let i = 0; i < element.length; ++i) {\n      // compact, dropping any null values unless custom mapped\n      let compacted = await api.compact({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        compactionMap\n      });\n      if (compacted === null) {\n        compacted = await compactionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options\n        });\n        if (compacted === undefined) {\n          continue;\n        }\n      }\n      rval.push(compacted);\n    }\n    if (options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      const container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n      if (container.length === 0) {\n        rval = rval[0];\n      }\n    }\n    return rval;\n  }\n\n  // use any scoped context on activeProperty\n  const ctx = _getContextValue(activeCtx, activeProperty, '@context');\n  if (!_isUndefined(ctx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: ctx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // recursively compact object\n  if (_isObject(element)) {\n    if (options.link && '@id' in element && options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      const linked = options.link[element['@id']];\n      for (let i = 0; i < linked.length; ++i) {\n        if (linked[i].expanded === element) {\n          return linked[i].compacted;\n        }\n      }\n    }\n\n    // do value compaction on @values and subject references\n    if (_isValue(element) || _isSubjectReference(element)) {\n      const rval = api.compactValue({\n        activeCtx,\n        activeProperty,\n        value: element,\n        options\n      });\n      if (options.link && _isSubjectReference(element)) {\n        // store linked element\n        if (!options.link.hasOwnProperty(element['@id'])) {\n          options.link[element['@id']] = [];\n        }\n        options.link[element['@id']].push({\n          expanded: element,\n          compacted: rval\n        });\n      }\n      return rval;\n    }\n\n    // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n    if (_isList(element)) {\n      const container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n      if (container.includes('@list')) {\n        return api.compact({\n          activeCtx,\n          activeProperty,\n          element: element['@list'],\n          options,\n          compactionMap\n        });\n      }\n    }\n\n    // FIXME: avoid misuse of active property as an expanded property?\n    const insideReverse = activeProperty === '@reverse';\n    const rval = {};\n\n    // original context before applying property-scoped and local contexts\n    const inputCtx = activeCtx;\n\n    // revert to previous context, if there is one,\n    // and element is not a value object or a node reference\n    if (!_isValue(element) && !_isSubjectReference(element)) {\n      activeCtx = activeCtx.revertToPreviousContext();\n    }\n\n    // apply property-scoped context after reverting term-scoped context\n    const propertyScopedCtx = _getContextValue(inputCtx, activeProperty, '@context');\n    if (!_isUndefined(propertyScopedCtx)) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx: propertyScopedCtx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n    if (options.link && '@id' in element) {\n      // store linked element\n      if (!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n      options.link[element['@id']].push({\n        expanded: element,\n        compacted: rval\n      });\n    }\n\n    // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n    let types = element['@type'] || [];\n    if (types.length > 1) {\n      types = Array.from(types).sort();\n    }\n    // find all type-scoped contexts based on current context, prior to\n    // updating it\n    const typeContext = activeCtx;\n    for (const type of types) {\n      const compactedType = api.compactIri({\n        activeCtx: typeContext,\n        iri: type,\n        relativeTo: {\n          vocab: true\n        }\n      });\n\n      // Use any type-scoped context defined on this value\n      const ctx = _getContextValue(inputCtx, compactedType, '@context');\n      if (!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          options,\n          propagate: false\n        });\n      }\n    }\n\n    // process element keys in order\n    const keys = Object.keys(element).sort();\n    for (const expandedProperty of keys) {\n      const expandedValue = element[expandedProperty];\n\n      // compact @id\n      if (expandedProperty === '@id') {\n        let compactedValue = _asArray(expandedValue).map(expandedIri => api.compactIri({\n          activeCtx,\n          iri: expandedIri,\n          relativeTo: {\n            vocab: false\n          },\n          base: options.base\n        }));\n        if (compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: '@id',\n          relativeTo: {\n            vocab: true\n          }\n        });\n        rval[alias] = compactedValue;\n        continue;\n      }\n\n      // compact @type(s)\n      if (expandedProperty === '@type') {\n        // resolve type values against previous context\n        let compactedValue = _asArray(expandedValue).map(expandedIri => api.compactIri({\n          activeCtx: inputCtx,\n          iri: expandedIri,\n          relativeTo: {\n            vocab: true\n          }\n        }));\n        if (compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: '@type',\n          relativeTo: {\n            vocab: true\n          }\n        });\n        const container = _getContextValue(activeCtx, alias, '@container') || [];\n\n        // treat as array for @type if @container includes @set\n        const typeAsSet = container.includes('@set') && _processingMode(activeCtx, 1.1);\n        const isArray = typeAsSet || _isArray(compactedValue) && expandedValue.length === 0;\n        _addValue(rval, alias, compactedValue, {\n          propertyIsArray: isArray\n        });\n        continue;\n      }\n\n      // handle @reverse\n      if (expandedProperty === '@reverse') {\n        // recursively compact expanded value\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty: '@reverse',\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        // handle double-reversed properties\n        for (const compactedProperty in compactedValue) {\n          if (activeCtx.mappings.has(compactedProperty) && activeCtx.mappings.get(compactedProperty).reverse) {\n            const value = compactedValue[compactedProperty];\n            const container = _getContextValue(activeCtx, compactedProperty, '@container') || [];\n            const useArray = container.includes('@set') || !options.compactArrays;\n            _addValue(rval, compactedProperty, value, {\n              propertyIsArray: useArray\n            });\n            delete compactedValue[compactedProperty];\n          }\n        }\n        if (Object.keys(compactedValue).length > 0) {\n          // use keyword alias and add value\n          const alias = api.compactIri({\n            activeCtx,\n            iri: expandedProperty,\n            relativeTo: {\n              vocab: true\n            }\n          });\n          _addValue(rval, alias, compactedValue);\n        }\n        continue;\n      }\n      if (expandedProperty === '@preserve') {\n        // compact using activeProperty\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty,\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n        if (!(_isArray(compactedValue) && compactedValue.length === 0)) {\n          _addValue(rval, expandedProperty, compactedValue);\n        }\n        continue;\n      }\n\n      // handle @index property\n      if (expandedProperty === '@index') {\n        // drop @index if inside an @index container\n        const container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n        if (container.includes('@index')) {\n          continue;\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {\n            vocab: true\n          }\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // skip array processing for keywords that aren't\n      // @graph, @list, or @included\n      if (expandedProperty !== '@graph' && expandedProperty !== '@list' && expandedProperty !== '@included' && _isKeyword(expandedProperty)) {\n        // use keyword alias and add value as is\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {\n            vocab: true\n          }\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // Note: expanded value must be an array due to expansion algorithm.\n      if (!_isArray(expandedValue)) {\n        throw new JsonLdError('JSON-LD expansion error; expanded value must be an array.', 'jsonld.SyntaxError');\n      }\n\n      // preserve empty arrays\n      if (expandedValue.length === 0) {\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedValue,\n          relativeTo: {\n            vocab: true\n          },\n          reverse: insideReverse\n        });\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if (nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if (!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n        _addValue(nestResult, itemActiveProperty, expandedValue, {\n          propertyIsArray: true\n        });\n      }\n\n      // recusively process array values\n      for (const expandedItem of expandedValue) {\n        // compact property and get container type\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedItem,\n          relativeTo: {\n            vocab: true\n          },\n          reverse: insideReverse\n        });\n\n        // if itemActiveProperty is a @nest property, add values to nestResult,\n        // otherwise rval\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if (nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if (!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n        const container = _getContextValue(activeCtx, itemActiveProperty, '@container') || [];\n\n        // get simple @graph or @list value if appropriate\n        const isGraph = _isGraph(expandedItem);\n        const isList = _isList(expandedItem);\n        let inner;\n        if (isList) {\n          inner = expandedItem['@list'];\n        } else if (isGraph) {\n          inner = expandedItem['@graph'];\n        }\n\n        // recursively compact expanded item\n        let compactedItem = await api.compact({\n          activeCtx,\n          activeProperty: itemActiveProperty,\n          element: isList || isGraph ? inner : expandedItem,\n          options,\n          compactionMap\n        });\n\n        // handle @list\n        if (isList) {\n          // ensure @list value is an array\n          if (!_isArray(compactedItem)) {\n            compactedItem = [compactedItem];\n          }\n          if (!container.includes('@list')) {\n            // wrap using @list alias\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@list',\n                relativeTo: {\n                  vocab: true\n                }\n              })]: compactedItem\n            };\n\n            // include @index from expanded @list, if any\n            if ('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {\n                  vocab: true\n                }\n              })] = expandedItem['@index'];\n            }\n          } else {\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              valueIsArray: true,\n              allowDuplicate: true\n            });\n            continue;\n          }\n        }\n\n        // Graph object compaction cases\n        if (isGraph) {\n          if (container.includes('@graph') && (container.includes('@id') || container.includes('@index') && _isSimpleGraph(expandedItem))) {\n            // get or create the map object\n            let mapObject;\n            if (nestResult.hasOwnProperty(itemActiveProperty)) {\n              mapObject = nestResult[itemActiveProperty];\n            } else {\n              nestResult[itemActiveProperty] = mapObject = {};\n            }\n\n            // index on @id or @index or alias of @none\n            const key = (container.includes('@id') ? expandedItem['@id'] : expandedItem['@index']) || api.compactIri({\n              activeCtx,\n              iri: '@none',\n              relativeTo: {\n                vocab: true\n              }\n            });\n            // add compactedItem to map, using value of `@id` or a new blank\n            // node identifier\n\n            _addValue(mapObject, key, compactedItem, {\n              propertyIsArray: !options.compactArrays || container.includes('@set')\n            });\n          } else if (container.includes('@graph') && _isSimpleGraph(expandedItem)) {\n            // container includes @graph but not @id or @index and value is a\n            // simple graph object add compact value\n            // if compactedItem contains multiple values, it is wrapped in\n            // `@included`\n            if (_isArray(compactedItem) && compactedItem.length > 1) {\n              compactedItem = {\n                '@included': compactedItem\n              };\n            }\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              propertyIsArray: !options.compactArrays || container.includes('@set')\n            });\n          } else {\n            // wrap using @graph alias, remove array if only one item and\n            // compactArrays not set\n            if (_isArray(compactedItem) && compactedItem.length === 1 && options.compactArrays) {\n              compactedItem = compactedItem[0];\n            }\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@graph',\n                relativeTo: {\n                  vocab: true\n                }\n              })]: compactedItem\n            };\n\n            // include @id from expanded graph, if any\n            if ('@id' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@id',\n                relativeTo: {\n                  vocab: true\n                }\n              })] = expandedItem['@id'];\n            }\n\n            // include @index from expanded graph, if any\n            if ('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {\n                  vocab: true\n                }\n              })] = expandedItem['@index'];\n            }\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              propertyIsArray: !options.compactArrays || container.includes('@set')\n            });\n          }\n        } else if (container.includes('@language') || container.includes('@index') || container.includes('@id') || container.includes('@type')) {\n          // handle language and index maps\n          // get or create the map object\n          let mapObject;\n          if (nestResult.hasOwnProperty(itemActiveProperty)) {\n            mapObject = nestResult[itemActiveProperty];\n          } else {\n            nestResult[itemActiveProperty] = mapObject = {};\n          }\n          let key;\n          if (container.includes('@language')) {\n            // if container is a language map, simplify compacted value to\n            // a simple string\n            if (_isValue(compactedItem)) {\n              compactedItem = compactedItem['@value'];\n            }\n            key = expandedItem['@language'];\n          } else if (container.includes('@index')) {\n            const indexKey = _getContextValue(activeCtx, itemActiveProperty, '@index') || '@index';\n            const containerKey = api.compactIri({\n              activeCtx,\n              iri: indexKey,\n              relativeTo: {\n                vocab: true\n              }\n            });\n            if (indexKey === '@index') {\n              key = expandedItem['@index'];\n              delete compactedItem[containerKey];\n            } else {\n              let others;\n              [key, ...others] = _asArray(compactedItem[indexKey] || []);\n              if (!_isString(key)) {\n                // Will use @none if it isn't a string.\n                key = null;\n              } else {\n                switch (others.length) {\n                  case 0:\n                    delete compactedItem[indexKey];\n                    break;\n                  case 1:\n                    compactedItem[indexKey] = others[0];\n                    break;\n                  default:\n                    compactedItem[indexKey] = others;\n                    break;\n                }\n              }\n            }\n          } else if (container.includes('@id')) {\n            const idKey = api.compactIri({\n              activeCtx,\n              iri: '@id',\n              relativeTo: {\n                vocab: true\n              }\n            });\n            key = compactedItem[idKey];\n            delete compactedItem[idKey];\n          } else if (container.includes('@type')) {\n            const typeKey = api.compactIri({\n              activeCtx,\n              iri: '@type',\n              relativeTo: {\n                vocab: true\n              }\n            });\n            let types;\n            [key, ...types] = _asArray(compactedItem[typeKey] || []);\n            switch (types.length) {\n              case 0:\n                delete compactedItem[typeKey];\n                break;\n              case 1:\n                compactedItem[typeKey] = types[0];\n                break;\n              default:\n                compactedItem[typeKey] = types;\n                break;\n            }\n\n            // If compactedItem contains a single entry\n            // whose key maps to @id, recompact without @type\n            if (Object.keys(compactedItem).length === 1 && '@id' in expandedItem) {\n              compactedItem = await api.compact({\n                activeCtx,\n                activeProperty: itemActiveProperty,\n                element: {\n                  '@id': expandedItem['@id']\n                },\n                options,\n                compactionMap\n              });\n            }\n          }\n\n          // if compacting this value which has no key, index on @none\n          if (!key) {\n            key = api.compactIri({\n              activeCtx,\n              iri: '@none',\n              relativeTo: {\n                vocab: true\n              }\n            });\n          }\n          // add compact value to map object using key from expanded value\n          // based on the container type\n          _addValue(mapObject, key, compactedItem, {\n            propertyIsArray: container.includes('@set')\n          });\n        } else {\n          // use an array if: compactArrays flag is false,\n          // @container is @set or @list , value is an empty\n          // array, or key is @graph\n          const isArray = !options.compactArrays || container.includes('@set') || container.includes('@list') || _isArray(compactedItem) && compactedItem.length === 0 || expandedProperty === '@list' || expandedProperty === '@graph';\n\n          // add compact value\n          _addValue(nestResult, itemActiveProperty, compactedItem, {\n            propertyIsArray: isArray\n          });\n        }\n      }\n    }\n    return rval;\n  }\n\n  // only primitives remain which are already compact\n  return element;\n};\n\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n * @param base the absolute URL to use for compacting document-relative IRIs.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\napi.compactIri = _ref2 => {\n  let {\n    activeCtx,\n    iri,\n    value = null,\n    relativeTo = {\n      vocab: false\n    },\n    reverse = false,\n    base = null\n  } = _ref2;\n  // can't compact null\n  if (iri === null) {\n    return iri;\n  }\n\n  // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n  if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n  const inverseCtx = activeCtx.getInverse();\n\n  // if term is a keyword, it may be compacted to a simple alias\n  if (_isKeyword(iri) && iri in inverseCtx && '@none' in inverseCtx[iri] && '@type' in inverseCtx[iri]['@none'] && '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  }\n\n  // use inverse context to pick a term if iri is relative to vocab\n  if (relativeTo.vocab && iri in inverseCtx) {\n    const defaultLanguage = activeCtx['@language'] || '@none';\n\n    // prefer @index if available in value\n    const containers = [];\n    if (_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    }\n\n    // if value is a preserve object, use its value\n    if (_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    }\n\n    // prefer most specific container including @graph, prefering @set\n    // variations\n    if (_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if ('@index' in value) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // favor idmap if the graph is has an @id\n      if ('@id' in value) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n      containers.push('@graph', '@graph@set', '@set');\n      // allow indexmap if the graph is not indexed\n      if (!('@index' in value)) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // allow idmap if the graph does not have an @id\n      if (!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if (_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    }\n\n    // defaults for term selection based on type/language\n    let typeOrLanguage = '@language';\n    let typeOrLanguageValue = '@null';\n    if (reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if (_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if (!('@index' in value)) {\n        containers.push('@list');\n      }\n      const list = value['@list'];\n      if (list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        let commonLanguage = list.length === 0 ? defaultLanguage : null;\n        let commonType = null;\n        for (let i = 0; i < list.length; ++i) {\n          const item = list[i];\n          let itemLanguage = '@none';\n          let itemType = '@none';\n          if (_isValue(item)) {\n            if ('@direction' in item) {\n              const lang = (item['@language'] || '').toLowerCase();\n              const dir = item['@direction'];\n              itemLanguage = `${lang}_${dir}`;\n            } else if ('@language' in item) {\n              itemLanguage = item['@language'].toLowerCase();\n            } else if ('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n          if (commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if (itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n          if (commonType === null) {\n            commonType = itemType;\n          } else if (itemType !== commonType) {\n            commonType = '@none';\n          }\n          // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n          if (commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n        if (commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if (_isValue(value)) {\n        if ('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n          const dir = value['@direction'];\n          if (dir) {\n            typeOrLanguageValue = `${typeOrLanguageValue}_${dir}`;\n          }\n        } else if ('@direction' in value && !('@index' in value)) {\n          typeOrLanguageValue = `_${value['@direction']}`;\n        } else if ('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n      containers.push('@set');\n    }\n\n    // do term selection\n    containers.push('@none');\n\n    // an index map can be used to index values using @none, so add as a low\n    // priority\n    if (_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    }\n\n    // values without type or language can use @language map\n    if (_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n    const term = _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n    if (term !== null) {\n      return term;\n    }\n  }\n\n  // no term match, use @vocab if available\n  if (relativeTo.vocab) {\n    if ('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      const vocab = activeCtx['@vocab'];\n      if (iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        const suffix = iri.substr(vocab.length);\n        if (!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  }\n\n  // no term or @vocab match, check for possible CURIEs\n  let choice = null;\n  // TODO: make FastCurieMap a class with a method to do this lookup\n  const partialMatches = [];\n  let iriMap = activeCtx.fastCurieMap;\n  // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n  const maxPartialLength = iri.length - 1;\n  for (let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {\n    iriMap = iriMap[iri[i]];\n    if ('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  }\n  // check partial matches in reverse order to prefer longest ones first\n  for (let i = partialMatches.length - 1; i >= 0; --i) {\n    const entry = partialMatches[i];\n    const terms = entry.terms;\n    for (const term of terms) {\n      // a CURIE is usable if:\n      // 1. it has no mapping, OR\n      // 2. value is null, which means we're not compacting an @value, AND\n      //   the mapping matches the IRI\n      const curie = term + ':' + iri.substr(entry.iri.length);\n      const isUsableCurie = activeCtx.mappings.get(term)._prefix && (!activeCtx.mappings.has(curie) || value === null && activeCtx.mappings.get(curie)['@id'] === iri);\n\n      // select curie if it is shorter or the same length but lexicographically\n      // less than the current choice\n      if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {\n        choice = curie;\n      }\n    }\n  }\n\n  // return chosen curie\n  if (choice !== null) {\n    return choice;\n  }\n\n  // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n  for (const [term, td] of activeCtx.mappings) {\n    if (td && td._prefix && iri.startsWith(term + ':')) {\n      throw new JsonLdError(`Absolute IRI \"${iri}\" confused with prefix \"${term}\".`, 'jsonld.SyntaxError', {\n        code: 'IRI confused with prefix',\n        context: activeCtx\n      });\n    }\n  }\n\n  // compact IRI relative to base\n  if (!relativeTo.vocab) {\n    if ('@base' in activeCtx) {\n      if (!activeCtx['@base']) {\n        // The None case preserves rval as potentially relative\n        return iri;\n      } else {\n        return _removeBase(_prependBase(base, activeCtx['@base']), iri);\n      }\n    } else {\n      return _removeBase(base, iri);\n    }\n  }\n\n  // return IRI as is\n  return iri;\n};\n\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\napi.compactValue = _ref3 => {\n  let {\n    activeCtx,\n    activeProperty,\n    value,\n    options\n  } = _ref3;\n  // value is a @value\n  if (_isValue(value)) {\n    // get context rules\n    const type = _getContextValue(activeCtx, activeProperty, '@type');\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    const container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n    // whether or not the value has an @index that must be preserved\n    const preserveIndex = '@index' in value && !container.includes('@index');\n\n    // if there's no @index to preserve ...\n    if (!preserveIndex && type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if (value['@type'] === type) {\n        return value['@value'];\n      }\n      if ('@language' in value && value['@language'] === language && '@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n      if ('@language' in value && value['@language'] === language) {\n        return value['@value'];\n      }\n      if ('@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n    }\n\n    // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n    const keyCount = Object.keys(value).length;\n    const isValueOnlyKey = keyCount === 1 || keyCount === 2 && '@index' in value && !preserveIndex;\n    const hasDefaultLanguage = ('@language' in activeCtx);\n    const isValueString = _isString(value['@value']);\n    const hasNullMapping = activeCtx.mappings.has(activeProperty) && activeCtx.mappings.get(activeProperty)['@language'] === null;\n    if (isValueOnlyKey && type !== '@none' && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n    const rval = {};\n\n    // preserve @index\n    if (preserveIndex) {\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@index',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@index'];\n    }\n    if ('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@type',\n        relativeTo: {\n          vocab: true\n        }\n      })] = api.compactIri({\n        activeCtx,\n        iri: value['@type'],\n        relativeTo: {\n          vocab: true\n        }\n      });\n    } else if ('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@language',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@language'];\n    }\n    if ('@direction' in value) {\n      // alias @direction\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@direction',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@direction'];\n    }\n\n    // alias @value\n    rval[api.compactIri({\n      activeCtx,\n      iri: '@value',\n      relativeTo: {\n        vocab: true\n      }\n    })] = value['@value'];\n    return rval;\n  }\n\n  // value is a subject reference\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options);\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n  const compacted = api.compactIri({\n    activeCtx,\n    iri: value['@id'],\n    relativeTo: {\n      vocab: type === '@vocab'\n    },\n    base: options.base\n  });\n\n  // compact to scalar\n  if (type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n  return {\n    [api.compactIri({\n      activeCtx,\n      iri: '@id',\n      relativeTo: {\n        vocab: true\n      }\n    })]: compacted\n  };\n};\n\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\nfunction _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if (typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  }\n\n  // preferences for the value of @type or @language\n  const prefs = [];\n\n  // determine prefs for @id based on whether or not value compacts to a term\n  if ((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') && _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if (typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    }\n    // try to compact value to a term\n    const term = api.compactIri({\n      activeCtx,\n      iri: value['@id'],\n      relativeTo: {\n        vocab: true\n      }\n    });\n    if (activeCtx.mappings.has(term) && activeCtx.mappings.get(term) && activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n\n    // consider direction only\n    const langDir = prefs.find(el => el.includes('_'));\n    if (langDir) {\n      // consider _dir portion\n      prefs.push(langDir.replace(/^[^_]+_/, '_'));\n    }\n  }\n  prefs.push('@none');\n  const containerMap = activeCtx.inverse[iri];\n  for (const container of containers) {\n    // if container not available in the map, continue\n    if (!(container in containerMap)) {\n      continue;\n    }\n    const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n    for (const pref of prefs) {\n      // if type/language option not available in the map, continue\n      if (!(pref in typeOrLanguageValueMap)) {\n        continue;\n      }\n\n      // select term\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n  return null;\n}\n\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if (_expandIri(activeCtx, nestProperty, {\n    vocab: true\n  }, options) !== '@nest') {\n    throw new JsonLdError('JSON-LD compact error; nested property must have an @nest value ' + 'resolving to @nest.', 'jsonld.SyntaxError', {\n      code: 'invalid @nest value'\n    });\n  }\n}","map":{"version":3,"names":["JsonLdError","require","isArray","_isArray","isObject","_isObject","isString","_isString","isUndefined","_isUndefined","isList","_isList","isValue","_isValue","isGraph","_isGraph","isSimpleGraph","_isSimpleGraph","isSubjectReference","_isSubjectReference","expandIri","_expandIri","getContextValue","_getContextValue","isKeyword","_isKeyword","process","_processContext","processingMode","_processingMode","removeBase","_removeBase","prependBase","_prependBase","addValue","_addValue","asArray","_asArray","compareShortestLeast","_compareShortestLeast","api","module","exports","compact","activeCtx","activeProperty","element","options","compactionMap","undefined","rval","i","length","compacted","unmappedValue","parent","index","push","compactArrays","container","ctx","localCtx","propagate","overrideProtected","link","hasOwnProperty","linked","expanded","compactValue","value","includes","insideReverse","inputCtx","revertToPreviousContext","propertyScopedCtx","types","Array","from","sort","typeContext","type","compactedType","compactIri","iri","relativeTo","vocab","keys","Object","expandedProperty","expandedValue","compactedValue","map","expandedIri","base","alias","typeAsSet","propertyIsArray","compactedProperty","mappings","has","get","reverse","useArray","itemActiveProperty","nestProperty","nestResult","_checkNestProperty","expandedItem","inner","compactedItem","valueIsArray","allowDuplicate","mapObject","key","indexKey","containerKey","others","idKey","typeKey","isPropertyTermScoped","previousContext","inverseCtx","getInverse","defaultLanguage","containers","typeOrLanguage","typeOrLanguageValue","list","commonLanguage","commonType","item","itemLanguage","itemType","lang","toLowerCase","dir","term","_selectTerm","indexOf","suffix","substr","choice","partialMatches","iriMap","fastCurieMap","maxPartialLength","entry","terms","curie","isUsableCurie","_prefix","td","startsWith","code","context","language","direction","preserveIndex","keyCount","isValueOnlyKey","hasDefaultLanguage","isValueString","hasNullMapping","prefs","apply","langDir","find","el","replace","containerMap","inverse","typeOrLanguageValueMap","pref"],"sources":["G:/To-do-List_App-main/node_modules/jsonld/lib/compact.js"],"sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSimpleGraph: _isSimpleGraph,\n  isSubjectReference: _isSubjectReference\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  removeBase: _removeBase,\n  prependBase: _prependBase\n} = require('./url');\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = require('./util');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return a promise that resolves to the compacted value.\n */\napi.compact = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  compactionMap = () => undefined\n}) => {\n  // recursively compact array\n  if(_isArray(element)) {\n    let rval = [];\n    for(let i = 0; i < element.length; ++i) {\n      // compact, dropping any null values unless custom mapped\n      let compacted = await api.compact({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        compactionMap\n      });\n      if(compacted === null) {\n        compacted = await compactionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options\n        });\n        if(compacted === undefined) {\n          continue;\n        }\n      }\n      rval.push(compacted);\n    }\n    if(options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.length === 0) {\n        rval = rval[0];\n      }\n    }\n    return rval;\n  }\n\n  // use any scoped context on activeProperty\n  const ctx = _getContextValue(activeCtx, activeProperty, '@context');\n  if(!_isUndefined(ctx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: ctx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // recursively compact object\n  if(_isObject(element)) {\n    if(options.link && '@id' in element &&\n      options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      const linked = options.link[element['@id']];\n      for(let i = 0; i < linked.length; ++i) {\n        if(linked[i].expanded === element) {\n          return linked[i].compacted;\n        }\n      }\n    }\n\n    // do value compaction on @values and subject references\n    if(_isValue(element) || _isSubjectReference(element)) {\n      const rval =\n        api.compactValue({activeCtx, activeProperty, value: element, options});\n      if(options.link && _isSubjectReference(element)) {\n        // store linked element\n        if(!(options.link.hasOwnProperty(element['@id']))) {\n          options.link[element['@id']] = [];\n        }\n        options.link[element['@id']].push({expanded: element, compacted: rval});\n      }\n      return rval;\n    }\n\n    // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n    if(_isList(element)) {\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.includes('@list')) {\n        return api.compact({\n          activeCtx,\n          activeProperty,\n          element: element['@list'],\n          options,\n          compactionMap\n        });\n      }\n    }\n\n    // FIXME: avoid misuse of active property as an expanded property?\n    const insideReverse = (activeProperty === '@reverse');\n\n    const rval = {};\n\n    // original context before applying property-scoped and local contexts\n    const inputCtx = activeCtx;\n\n    // revert to previous context, if there is one,\n    // and element is not a value object or a node reference\n    if(!_isValue(element) && !_isSubjectReference(element)) {\n      activeCtx = activeCtx.revertToPreviousContext();\n    }\n\n    // apply property-scoped context after reverting term-scoped context\n    const propertyScopedCtx =\n      _getContextValue(inputCtx, activeProperty, '@context');\n    if(!_isUndefined(propertyScopedCtx)) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx: propertyScopedCtx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    if(options.link && '@id' in element) {\n      // store linked element\n      if(!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n      options.link[element['@id']].push({expanded: element, compacted: rval});\n    }\n\n    // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n    let types = element['@type'] || [];\n    if(types.length > 1) {\n      types = Array.from(types).sort();\n    }\n    // find all type-scoped contexts based on current context, prior to\n    // updating it\n    const typeContext = activeCtx;\n    for(const type of types) {\n      const compactedType = api.compactIri(\n        {activeCtx: typeContext, iri: type, relativeTo: {vocab: true}});\n\n      // Use any type-scoped context defined on this value\n      const ctx = _getContextValue(inputCtx, compactedType, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          options,\n          propagate: false\n        });\n      }\n    }\n\n    // process element keys in order\n    const keys = Object.keys(element).sort();\n    for(const expandedProperty of keys) {\n      const expandedValue = element[expandedProperty];\n\n      // compact @id\n      if(expandedProperty === '@id') {\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: false},\n            base: options.base\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@id', relativeTo: {vocab: true}});\n\n        rval[alias] = compactedValue;\n        continue;\n      }\n\n      // compact @type(s)\n      if(expandedProperty === '@type') {\n        // resolve type values against previous context\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx: inputCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: true}\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@type', relativeTo: {vocab: true}});\n        const container = _getContextValue(\n          activeCtx, alias, '@container') || [];\n\n        // treat as array for @type if @container includes @set\n        const typeAsSet =\n          container.includes('@set') &&\n          _processingMode(activeCtx, 1.1);\n        const isArray =\n          typeAsSet || (_isArray(compactedValue) && expandedValue.length === 0);\n        _addValue(rval, alias, compactedValue, {propertyIsArray: isArray});\n        continue;\n      }\n\n      // handle @reverse\n      if(expandedProperty === '@reverse') {\n        // recursively compact expanded value\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty: '@reverse',\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        // handle double-reversed properties\n        for(const compactedProperty in compactedValue) {\n          if(activeCtx.mappings.has(compactedProperty) &&\n            activeCtx.mappings.get(compactedProperty).reverse) {\n            const value = compactedValue[compactedProperty];\n            const container = _getContextValue(\n              activeCtx, compactedProperty, '@container') || [];\n            const useArray = (\n              container.includes('@set') || !options.compactArrays);\n            _addValue(\n              rval, compactedProperty, value, {propertyIsArray: useArray});\n            delete compactedValue[compactedProperty];\n          }\n        }\n\n        if(Object.keys(compactedValue).length > 0) {\n          // use keyword alias and add value\n          const alias = api.compactIri({\n            activeCtx,\n            iri: expandedProperty,\n            relativeTo: {vocab: true}\n          });\n          _addValue(rval, alias, compactedValue);\n        }\n\n        continue;\n      }\n\n      if(expandedProperty === '@preserve') {\n        // compact using activeProperty\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty,\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        if(!(_isArray(compactedValue) && compactedValue.length === 0)) {\n          _addValue(rval, expandedProperty, compactedValue);\n        }\n        continue;\n      }\n\n      // handle @index property\n      if(expandedProperty === '@index') {\n        // drop @index if inside an @index container\n        const container = _getContextValue(\n          activeCtx, activeProperty, '@container') || [];\n        if(container.includes('@index')) {\n          continue;\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // skip array processing for keywords that aren't\n      // @graph, @list, or @included\n      if(expandedProperty !== '@graph' && expandedProperty !== '@list' &&\n        expandedProperty !== '@included' &&\n        _isKeyword(expandedProperty)) {\n        // use keyword alias and add value as is\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // Note: expanded value must be an array due to expansion algorithm.\n      if(!_isArray(expandedValue)) {\n        throw new JsonLdError(\n          'JSON-LD expansion error; expanded value must be an array.',\n          'jsonld.SyntaxError');\n      }\n\n      // preserve empty arrays\n      if(expandedValue.length === 0) {\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedValue,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n        _addValue(\n          nestResult, itemActiveProperty, expandedValue, {\n            propertyIsArray: true\n          });\n      }\n\n      // recusively process array values\n      for(const expandedItem of expandedValue) {\n        // compact property and get container type\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedItem,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n\n        // if itemActiveProperty is a @nest property, add values to nestResult,\n        // otherwise rval\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n\n        const container = _getContextValue(\n          activeCtx, itemActiveProperty, '@container') || [];\n\n        // get simple @graph or @list value if appropriate\n        const isGraph = _isGraph(expandedItem);\n        const isList = _isList(expandedItem);\n        let inner;\n        if(isList) {\n          inner = expandedItem['@list'];\n        } else if(isGraph) {\n          inner = expandedItem['@graph'];\n        }\n\n        // recursively compact expanded item\n        let compactedItem = await api.compact({\n          activeCtx,\n          activeProperty: itemActiveProperty,\n          element: (isList || isGraph) ? inner : expandedItem,\n          options,\n          compactionMap\n        });\n\n        // handle @list\n        if(isList) {\n          // ensure @list value is an array\n          if(!_isArray(compactedItem)) {\n            compactedItem = [compactedItem];\n          }\n\n          if(!container.includes('@list')) {\n            // wrap using @list alias\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@list',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @index from expanded @list, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n          } else {\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              valueIsArray: true,\n              allowDuplicate: true\n            });\n            continue;\n          }\n        }\n\n        // Graph object compaction cases\n        if(isGraph) {\n          if(container.includes('@graph') && (container.includes('@id') ||\n            container.includes('@index') && _isSimpleGraph(expandedItem))) {\n            // get or create the map object\n            let mapObject;\n            if(nestResult.hasOwnProperty(itemActiveProperty)) {\n              mapObject = nestResult[itemActiveProperty];\n            } else {\n              nestResult[itemActiveProperty] = mapObject = {};\n            }\n\n            // index on @id or @index or alias of @none\n            const key = (container.includes('@id') ?\n              expandedItem['@id'] : expandedItem['@index']) ||\n              api.compactIri({activeCtx, iri: '@none',\n                relativeTo: {vocab: true}});\n            // add compactedItem to map, using value of `@id` or a new blank\n            // node identifier\n\n            _addValue(\n              mapObject, key, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else if(container.includes('@graph') &&\n            _isSimpleGraph(expandedItem)) {\n            // container includes @graph but not @id or @index and value is a\n            // simple graph object add compact value\n            // if compactedItem contains multiple values, it is wrapped in\n            // `@included`\n            if(_isArray(compactedItem) && compactedItem.length > 1) {\n              compactedItem = {'@included': compactedItem};\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else {\n            // wrap using @graph alias, remove array if only one item and\n            // compactArrays not set\n            if(_isArray(compactedItem) && compactedItem.length === 1 &&\n              options.compactArrays) {\n              compactedItem = compactedItem[0];\n            }\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@graph',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @id from expanded graph, if any\n            if('@id' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@id',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@id'];\n            }\n\n            // include @index from expanded graph, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          }\n        } else if(container.includes('@language') ||\n          container.includes('@index') || container.includes('@id') ||\n          container.includes('@type')) {\n          // handle language and index maps\n          // get or create the map object\n          let mapObject;\n          if(nestResult.hasOwnProperty(itemActiveProperty)) {\n            mapObject = nestResult[itemActiveProperty];\n          } else {\n            nestResult[itemActiveProperty] = mapObject = {};\n          }\n\n          let key;\n          if(container.includes('@language')) {\n          // if container is a language map, simplify compacted value to\n          // a simple string\n            if(_isValue(compactedItem)) {\n              compactedItem = compactedItem['@value'];\n            }\n            key = expandedItem['@language'];\n          } else if(container.includes('@index')) {\n            const indexKey = _getContextValue(\n              activeCtx, itemActiveProperty, '@index') || '@index';\n            const containerKey = api.compactIri(\n              {activeCtx, iri: indexKey, relativeTo: {vocab: true}});\n            if(indexKey === '@index') {\n              key = expandedItem['@index'];\n              delete compactedItem[containerKey];\n            } else {\n              let others;\n              [key, ...others] = _asArray(compactedItem[indexKey] || []);\n              if(!_isString(key)) {\n                // Will use @none if it isn't a string.\n                key = null;\n              } else {\n                switch(others.length) {\n                  case 0:\n                    delete compactedItem[indexKey];\n                    break;\n                  case 1:\n                    compactedItem[indexKey] = others[0];\n                    break;\n                  default:\n                    compactedItem[indexKey] = others;\n                    break;\n                }\n              }\n            }\n          } else if(container.includes('@id')) {\n            const idKey = api.compactIri({activeCtx, iri: '@id',\n              relativeTo: {vocab: true}});\n            key = compactedItem[idKey];\n            delete compactedItem[idKey];\n          } else if(container.includes('@type')) {\n            const typeKey = api.compactIri({\n              activeCtx,\n              iri: '@type',\n              relativeTo: {vocab: true}\n            });\n            let types;\n            [key, ...types] = _asArray(compactedItem[typeKey] || []);\n            switch(types.length) {\n              case 0:\n                delete compactedItem[typeKey];\n                break;\n              case 1:\n                compactedItem[typeKey] = types[0];\n                break;\n              default:\n                compactedItem[typeKey] = types;\n                break;\n            }\n\n            // If compactedItem contains a single entry\n            // whose key maps to @id, recompact without @type\n            if(Object.keys(compactedItem).length === 1 &&\n              '@id' in expandedItem) {\n              compactedItem = await api.compact({\n                activeCtx,\n                activeProperty: itemActiveProperty,\n                element: {'@id': expandedItem['@id']},\n                options,\n                compactionMap\n              });\n            }\n          }\n\n          // if compacting this value which has no key, index on @none\n          if(!key) {\n            key = api.compactIri({activeCtx, iri: '@none',\n              relativeTo: {vocab: true}});\n          }\n          // add compact value to map object using key from expanded value\n          // based on the container type\n          _addValue(\n            mapObject, key, compactedItem, {\n              propertyIsArray: container.includes('@set')\n            });\n        } else {\n          // use an array if: compactArrays flag is false,\n          // @container is @set or @list , value is an empty\n          // array, or key is @graph\n          const isArray = (!options.compactArrays ||\n            container.includes('@set') || container.includes('@list') ||\n            (_isArray(compactedItem) && compactedItem.length === 0) ||\n            expandedProperty === '@list' || expandedProperty === '@graph');\n\n          // add compact value\n          _addValue(\n            nestResult, itemActiveProperty, compactedItem,\n            {propertyIsArray: isArray});\n        }\n      }\n    }\n\n    return rval;\n  }\n\n  // only primitives remain which are already compact\n  return element;\n};\n\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n * @param base the absolute URL to use for compacting document-relative IRIs.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\napi.compactIri = ({\n  activeCtx,\n  iri,\n  value = null,\n  relativeTo = {vocab: false},\n  reverse = false,\n  base = null\n}) => {\n  // can't compact null\n  if(iri === null) {\n    return iri;\n  }\n\n  // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n  if(activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  const inverseCtx = activeCtx.getInverse();\n\n  // if term is a keyword, it may be compacted to a simple alias\n  if(_isKeyword(iri) &&\n    iri in inverseCtx &&\n    '@none' in inverseCtx[iri] &&\n    '@type' in inverseCtx[iri]['@none'] &&\n    '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  }\n\n  // use inverse context to pick a term if iri is relative to vocab\n  if(relativeTo.vocab && iri in inverseCtx) {\n    const defaultLanguage = activeCtx['@language'] || '@none';\n\n    // prefer @index if available in value\n    const containers = [];\n    if(_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    }\n\n    // if value is a preserve object, use its value\n    if(_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    }\n\n    // prefer most specific container including @graph, prefering @set\n    // variations\n    if(_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if('@index' in value) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // favor idmap if the graph is has an @id\n      if('@id' in value) {\n        containers.push(\n          '@graph@id', '@graph@id@set');\n      }\n      containers.push('@graph', '@graph@set', '@set');\n      // allow indexmap if the graph is not indexed\n      if(!('@index' in value)) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // allow idmap if the graph does not have an @id\n      if(!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if(_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    }\n\n    // defaults for term selection based on type/language\n    let typeOrLanguage = '@language';\n    let typeOrLanguageValue = '@null';\n\n    if(reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if(_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if(!('@index' in value)) {\n        containers.push('@list');\n      }\n      const list = value['@list'];\n      if(list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        let commonLanguage = (list.length === 0) ? defaultLanguage : null;\n        let commonType = null;\n        for(let i = 0; i < list.length; ++i) {\n          const item = list[i];\n          let itemLanguage = '@none';\n          let itemType = '@none';\n          if(_isValue(item)) {\n            if('@direction' in item) {\n              const lang = (item['@language'] || '').toLowerCase();\n              const dir = item['@direction'];\n              itemLanguage = `${lang}_${dir}`;\n            } else if('@language' in item) {\n              itemLanguage = item['@language'].toLowerCase();\n            } else if('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n          if(commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if(itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n          if(commonType === null) {\n            commonType = itemType;\n          } else if(itemType !== commonType) {\n            commonType = '@none';\n          }\n          // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n          if(commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n        if(commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if(_isValue(value)) {\n        if('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n          const dir = value['@direction'];\n          if(dir) {\n            typeOrLanguageValue = `${typeOrLanguageValue}_${dir}`;\n          }\n        } else if('@direction' in value && !('@index' in value)) {\n          typeOrLanguageValue = `_${value['@direction']}`;\n        } else if('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n      containers.push('@set');\n    }\n\n    // do term selection\n    containers.push('@none');\n\n    // an index map can be used to index values using @none, so add as a low\n    // priority\n    if(_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    }\n\n    // values without type or language can use @language map\n    if(_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    const term = _selectTerm(\n      activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n    if(term !== null) {\n      return term;\n    }\n  }\n\n  // no term match, use @vocab if available\n  if(relativeTo.vocab) {\n    if('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      const vocab = activeCtx['@vocab'];\n      if(iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        const suffix = iri.substr(vocab.length);\n        if(!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  }\n\n  // no term or @vocab match, check for possible CURIEs\n  let choice = null;\n  // TODO: make FastCurieMap a class with a method to do this lookup\n  const partialMatches = [];\n  let iriMap = activeCtx.fastCurieMap;\n  // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n  const maxPartialLength = iri.length - 1;\n  for(let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {\n    iriMap = iriMap[iri[i]];\n    if('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  }\n  // check partial matches in reverse order to prefer longest ones first\n  for(let i = partialMatches.length - 1; i >= 0; --i) {\n    const entry = partialMatches[i];\n    const terms = entry.terms;\n    for(const term of terms) {\n      // a CURIE is usable if:\n      // 1. it has no mapping, OR\n      // 2. value is null, which means we're not compacting an @value, AND\n      //   the mapping matches the IRI\n      const curie = term + ':' + iri.substr(entry.iri.length);\n      const isUsableCurie = (activeCtx.mappings.get(term)._prefix &&\n        (!activeCtx.mappings.has(curie) ||\n        (value === null && activeCtx.mappings.get(curie)['@id'] === iri)));\n\n      // select curie if it is shorter or the same length but lexicographically\n      // less than the current choice\n      if(isUsableCurie && (choice === null ||\n        _compareShortestLeast(curie, choice) < 0)) {\n        choice = curie;\n      }\n    }\n  }\n\n  // return chosen curie\n  if(choice !== null) {\n    return choice;\n  }\n\n  // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n  for(const [term, td] of activeCtx.mappings) {\n    if(td && td._prefix && iri.startsWith(term + ':')) {\n      throw new JsonLdError(\n        `Absolute IRI \"${iri}\" confused with prefix \"${term}\".`,\n        'jsonld.SyntaxError',\n        {code: 'IRI confused with prefix', context: activeCtx});\n    }\n  }\n\n  // compact IRI relative to base\n  if(!relativeTo.vocab) {\n    if('@base' in activeCtx) {\n      if(!activeCtx['@base']) {\n        // The None case preserves rval as potentially relative\n        return iri;\n      } else {\n        return _removeBase(_prependBase(base, activeCtx['@base']), iri);\n      }\n    } else {\n      return _removeBase(base, iri);\n    }\n  }\n\n  // return IRI as is\n  return iri;\n};\n\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\napi.compactValue = ({activeCtx, activeProperty, value, options}) => {\n  // value is a @value\n  if(_isValue(value)) {\n    // get context rules\n    const type = _getContextValue(activeCtx, activeProperty, '@type');\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    const container =\n      _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n    // whether or not the value has an @index that must be preserved\n    const preserveIndex = '@index' in value && !container.includes('@index');\n\n    // if there's no @index to preserve ...\n    if(!preserveIndex && type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if(value['@type'] === type) {\n        return value['@value'];\n      }\n      if('@language' in value && value['@language'] === language &&\n         '@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n      if('@language' in value && value['@language'] === language) {\n        return value['@value'];\n      }\n      if('@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n    }\n\n    // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n    const keyCount = Object.keys(value).length;\n    const isValueOnlyKey = (keyCount === 1 ||\n      (keyCount === 2 && '@index' in value && !preserveIndex));\n    const hasDefaultLanguage = ('@language' in activeCtx);\n    const isValueString = _isString(value['@value']);\n    const hasNullMapping = (activeCtx.mappings.has(activeProperty) &&\n      activeCtx.mappings.get(activeProperty)['@language'] === null);\n    if(isValueOnlyKey &&\n      type !== '@none' &&\n      (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    const rval = {};\n\n    // preserve @index\n    if(preserveIndex) {\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@index',\n        relativeTo: {vocab: true}\n      })] = value['@index'];\n    }\n\n    if('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@type',\n        relativeTo: {vocab: true}\n      })] = api.compactIri(\n        {activeCtx, iri: value['@type'], relativeTo: {vocab: true}});\n    } else if('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@language',\n        relativeTo: {vocab: true}\n      })] = value['@language'];\n    }\n\n    if('@direction' in value) {\n      // alias @direction\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@direction',\n        relativeTo: {vocab: true}\n      })] = value['@direction'];\n    }\n\n    // alias @value\n    rval[api.compactIri({\n      activeCtx,\n      iri: '@value',\n      relativeTo: {vocab: true}\n    })] = value['@value'];\n\n    return rval;\n  }\n\n  // value is a subject reference\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {vocab: true},\n    options);\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n  const compacted = api.compactIri({\n    activeCtx,\n    iri: value['@id'],\n    relativeTo: {vocab: type === '@vocab'},\n    base: options.base});\n\n  // compact to scalar\n  if(type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return {\n    [api.compactIri({\n      activeCtx,\n      iri: '@id',\n      relativeTo: {vocab: true}\n    })]: compacted\n  };\n};\n\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\nfunction _selectTerm(\n  activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if(typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  }\n\n  // preferences for the value of @type or @language\n  const prefs = [];\n\n  // determine prefs for @id based on whether or not value compacts to a term\n  if((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') &&\n    _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if(typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    }\n    // try to compact value to a term\n    const term = api.compactIri(\n      {activeCtx, iri: value['@id'], relativeTo: {vocab: true}});\n    if(activeCtx.mappings.has(term) &&\n      activeCtx.mappings.get(term) &&\n      activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n\n    // consider direction only\n    const langDir = prefs.find(el => el.includes('_'));\n    if(langDir) {\n      // consider _dir portion\n      prefs.push(langDir.replace(/^[^_]+_/, '_'));\n    }\n  }\n  prefs.push('@none');\n\n  const containerMap = activeCtx.inverse[iri];\n  for(const container of containers) {\n    // if container not available in the map, continue\n    if(!(container in containerMap)) {\n      continue;\n    }\n\n    const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n    for(const pref of prefs) {\n      // if type/language option not available in the map, continue\n      if(!(pref in typeOrLanguageValueMap)) {\n        continue;\n      }\n\n      // select term\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if(_expandIri(activeCtx, nestProperty, {vocab: true}, options) !== '@nest') {\n    throw new JsonLdError(\n      'JSON-LD compact error; nested property must have an @nest value ' +\n      'resolving to @nest.',\n      'jsonld.SyntaxError', {code: 'invalid @nest value'});\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}