{"ast":null,"code":"var _defineProperty = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _createForOfIteratorHelper = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nfunction isString(s) {\n  return typeof s === 'string' || s instanceof String;\n}\nvar xsdString = 'http://www.w3.org/2001/XMLSchema#string';\nfunction termToId(term) {\n  if (typeof term === 'string') {\n    return term;\n  }\n  if (!term) {\n    return '';\n  }\n  if (typeof term.id !== 'undefined' && term.termType !== 'Quad') {\n    return term.id;\n  }\n  var subject, predicate, object, graph;\n\n  // Term instantiated with another library\n  switch (term.termType) {\n    case 'NamedNode':\n      return term.value;\n    case 'BlankNode':\n      return \"_:\".concat(term.value);\n    case 'Variable':\n      return \"?\".concat(term.value);\n    case 'DefaultGraph':\n      return '';\n    case 'Literal':\n      if (term.language) {\n        return \"\\\"\".concat(term.value, \"\\\"@\").concat(term.language);\n      }\n      return \"\\\"\".concat(term.value, \"\\\"\").concat(term.datatype && term.datatype.value !== xsdString ? \"^^\".concat(term.datatype.value) : '');\n    case 'Quad':\n      // To identify RDF* quad components, we escape quotes by doubling them.\n      // This avoids the overhead of backslash parsing of Turtle-like syntaxes.\n      subject = escapeQuotes(termToId(term.subject));\n      predicate = escapeQuotes(termToId(term.predicate));\n      object = escapeQuotes(termToId(term.object));\n      graph = term.graph.termType === 'DefaultGraph' ? '' : \" \".concat(termToId(term.graph));\n      return \"<<\".concat(subject, \" \").concat(predicate, \" \").concat(object).concat(graph, \">>\");\n    default:\n      throw new Error(\"Unexpected termType: \".concat(term.termType));\n  }\n}\nvar escapedLiteral = /^\"(.*\".*)(?=\"[^\"]*$)/;\nfunction escapeQuotes(id) {\n  return id.replace(escapedLiteral, function (_, quoted) {\n    return \"\\\"\".concat(quoted.replace(/\"/g, '\"\"'));\n  });\n}\nvar DatasetCore = /*#__PURE__*/function (_Symbol$iterator) {\n  \"use strict\";\n\n  function DatasetCore(quads) {\n    _classCallCheck(this, DatasetCore);\n    // The number of quads is initially zero\n    this._size = 0;\n    // `_graphs` contains subject, predicate, and object indexes per graph\n    this._graphs = Object.create(null);\n    // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n    this._id = 0;\n    this._ids = Object.create(null);\n    this._ids['><'] = 0; // dummy entry, so the first actual key is non-zero\n    this._entities = Object.create(null); // inverse of `_ids`\n\n    this._quads = new Map();\n\n    // Add quads if passed\n    if (quads) {\n      var _iterator = _createForOfIteratorHelper(quads),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var quad = _step.value;\n          this.add(quad);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }\n  _createClass(DatasetCore, [{\n    key: \"size\",\n    get: function get() {\n      // Return the quad count if if was cached\n      var size = this._size;\n      if (size !== null) {\n        return size;\n      }\n\n      // Calculate the number of quads by counting to the deepest level\n      size = 0;\n      var graphs = this._graphs;\n      var subjects, subject;\n      for (var graphKey in graphs) {\n        for (var subjectKey in subjects = graphs[graphKey].subjects) {\n          for (var predicateKey in subject = subjects[subjectKey]) {\n            size += Object.keys(subject[predicateKey]).length;\n          }\n        }\n      }\n      this._size = size;\n      return this._size;\n    }\n  }, {\n    key: \"add\",\n    value: function add(quad) {\n      // Convert terms to internal string representation\n      var subject = termToId(quad.subject);\n      var predicate = termToId(quad.predicate);\n      var object = termToId(quad.object);\n      var graph = termToId(quad.graph);\n\n      // Find the graph that will contain the triple\n      var graphItem = this._graphs[graph];\n      // Create the graph if it doesn't exist yet\n      if (!graphItem) {\n        graphItem = this._graphs[graph] = {\n          subjects: {},\n          predicates: {},\n          objects: {}\n        };\n        // Freezing a graph helps subsequent `add` performance,\n        // and properties will never be modified anyway\n        Object.freeze(graphItem);\n      }\n\n      // Since entities can often be long IRIs, we avoid storing them in every index.\n      // Instead, we have a separate index that maps entities to numbers,\n      // which are then used as keys in the other indexes.\n      var ids = this._ids;\n      var entities = this._entities;\n      subject = ids[subject] || (ids[entities[++this._id] = subject] = this._id);\n      predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);\n      object = ids[object] || (ids[entities[++this._id] = object] = this._id);\n      this._addToIndex(graphItem.subjects, subject, predicate, object);\n      this._addToIndex(graphItem.predicates, predicate, object, subject);\n      this._addToIndex(graphItem.objects, object, subject, predicate);\n      this._setQuad(subject, predicate, object, graph, quad);\n\n      // The cached quad count is now invalid\n      this._size = null;\n      return this;\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(quad) {\n      // Convert terms to internal string representation\n      var subject = termToId(quad.subject);\n      var predicate = termToId(quad.predicate);\n      var object = termToId(quad.object);\n      var graph = termToId(quad.graph);\n\n      // Find internal identifiers for all components\n      // and verify the quad exists.\n      var ids = this._ids;\n      var graphs = this._graphs;\n      var graphItem, subjects, predicates;\n      if (!(subject = ids[subject]) || !(predicate = ids[predicate]) || !(object = ids[object]) || !(graphItem = graphs[graph]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object in predicates)) {\n        return this;\n      }\n\n      // Remove it from all indexes\n      this._removeFromIndex(graphItem.subjects, subject, predicate, object);\n      this._removeFromIndex(graphItem.predicates, predicate, object, subject);\n      this._removeFromIndex(graphItem.objects, object, subject, predicate);\n      if (this._size !== null) {\n        this._size--;\n      }\n      this._deleteQuad(subject, predicate, object, graph);\n\n      // Remove the graph if it is empty\n      for (subject in graphItem.subjects) {\n        // eslint-disable-line no-unreachable-loop\n        return this;\n      }\n      delete graphs[graph];\n      return this;\n    }\n  }, {\n    key: \"has\",\n    value: function has(quad) {\n      // Convert terms to internal string representation\n      var subject = termToId(quad.subject);\n      var predicate = termToId(quad.predicate);\n      var object = termToId(quad.object);\n      var graph = termToId(quad.graph);\n      var graphItem = this._graphs[graph];\n      if (!graphItem) {\n        return false;\n      }\n      var ids = this._ids;\n      var subjectId, predicateId, objectId;\n\n      // Translate IRIs to internal index keys.\n      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) {\n        return false;\n      }\n      return this._countInIndex(graphItem.objects, objectId, subjectId, predicateId) === 1;\n    }\n  }, {\n    key: \"match\",\n    value: function match(subject, predicate, object, graph) {\n      return this._createDataset(this._match(subject, predicate, object, graph));\n    }\n  }, {\n    key: _Symbol$iterator,\n    value: function value() {\n      return this._match()[Symbol.iterator]();\n    }\n\n    // ## Private methods\n\n    // ### `_addToIndex` adds a quad to a three-layered index.\n    // Returns if the index has changed, if the entry did not already exist.\n  }, {\n    key: \"_addToIndex\",\n    value: function _addToIndex(index0, key0, key1, key2) {\n      // Create layers as necessary\n      var index1 = index0[key0] || (index0[key0] = {});\n      var index2 = index1[key1] || (index1[key1] = {});\n      // Setting the key to _any_ value signals the presence of the quad\n      var existed = (key2 in index2);\n      if (!existed) {\n        index2[key2] = null;\n      }\n      return !existed;\n    }\n\n    // ### `_removeFromIndex` removes a quad from a three-layered index\n  }, {\n    key: \"_removeFromIndex\",\n    value: function _removeFromIndex(index0, key0, key1, key2) {\n      // Remove the quad from the index\n      var index1 = index0[key0];\n      var index2 = index1[key1];\n      delete index2[key2];\n\n      // Remove intermediary index layers if they are empty\n      for (var key in index2) {\n        // eslint-disable-line no-unreachable-loop\n        return;\n      }\n      delete index1[key1];\n      for (var _key in index1) {\n        // eslint-disable-line no-unreachable-loop\n        return;\n      }\n      delete index0[key0];\n    }\n\n    // ### `_findInIndex` finds a set of quads in a three-layered index.\n    // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n    // Any of these keys can be undefined, which is interpreted as a wildcard.\n    // `name0`, `name1`, and `name2` are the names of the keys at each level,\n    // used when reconstructing the resulting quad\n    // (for instance: _subject_, _predicate_, and _object_).\n    // Finally, `graph` will be the graph of the created quads.\n    // If `callback` is given, each result is passed through it\n    // and iteration halts when it returns truthy for any quad.\n    // If instead `array` is given, each result is added to the array.\n  }, {\n    key: \"_findInIndex\",\n    value: function _findInIndex(index0, key0, key1, key2, name0, name1, name2, graph, callback, array) {\n      var tmp, index1, index2;\n\n      // If a key is specified, use only that part of index 0.\n      if (key0) {\n        (tmp = index0, index0 = {})[key0] = tmp[key0];\n      }\n      for (var value0 in index0) {\n        index1 = index0[value0];\n        if (index1) {\n          // If a key is specified, use only that part of index 1.\n          if (key1) {\n            (tmp = index1, index1 = {})[key1] = tmp[key1];\n          }\n          for (var value1 in index1) {\n            index2 = index1[value1];\n            if (index2) {\n              // If a key is specified, use only that part of index 2, if it exists.\n              var values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2);\n              // Create quads for all items found in index 2.\n              for (var l = 0; l < values.length; l++) {\n                var _parts;\n                var parts = (_parts = {}, _defineProperty(_parts, name0, value0), _defineProperty(_parts, name1, value1), _defineProperty(_parts, name2, values[l]), _parts);\n                var quad = this._getQuad(parts.subject, parts.predicate, parts.object, graph);\n                if (array) {\n                  array.push(quad);\n                } else if (callback(quad)) {\n                  return true;\n                }\n              }\n            }\n          }\n        }\n      }\n      return array;\n    }\n\n    // ### `_countInIndex` counts matching quads in a three-layered index.\n    // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n    // Any of these keys can be undefined, which is interpreted as a wildcard.\n  }, {\n    key: \"_countInIndex\",\n    value: function _countInIndex(index0, key0, key1, key2) {\n      var count = 0;\n      var tmp, index1, index2;\n\n      // If a key is specified, count only that part of index 0\n      if (key0) {\n        (tmp = index0, index0 = {})[key0] = tmp[key0];\n      }\n      for (var value0 in index0) {\n        index1 = index0[value0];\n        if (index1) {\n          // If a key is specified, count only that part of index 1\n          if (key1) {\n            (tmp = index1, index1 = {})[key1] = tmp[key1];\n          }\n          for (var value1 in index1) {\n            index2 = index1[value1];\n            if (index2) {\n              if (key2) {\n                // If a key is specified, count the quad if it exists\n                key2 in index2 && count++;\n              } else {\n                // Otherwise, count all quads\n                count += Object.keys(index2).length;\n              }\n            }\n          }\n        }\n      }\n      return count;\n    }\n\n    // ### `_getGraphs` returns an array with the given graph,\n    // or all graphs if the argument is null or undefined.\n  }, {\n    key: \"_getGraphs\",\n    value: function _getGraphs(graph) {\n      if (!isString(graph)) {\n        return this._graphs;\n      }\n      return _defineProperty({}, graph, this._graphs[graph]);\n    }\n  }, {\n    key: \"_match\",\n    value: function _match(subject, predicate, object, graph) {\n      // Convert terms to internal string representation\n      subject = subject && termToId(subject);\n      predicate = predicate && termToId(predicate);\n      object = object && termToId(object);\n      graph = graph && termToId(graph);\n      var quads = [];\n      var graphs = this._getGraphs(graph);\n      var ids = this._ids;\n      var content, subjectId, predicateId, objectId;\n\n      // Translate IRIs to internal index keys.\n      if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) {\n        return quads;\n      }\n      for (var graphId in graphs) {\n        content = graphs[graphId];\n\n        // Only if the specified graph contains triples, there can be results\n        if (content) {\n          // Choose the optimal index, based on what fields are present\n          if (subjectId) {\n            if (objectId) {\n              // If subject and object are given, the object index will be the fastest\n              this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId, null, quads);\n            } else {\n              // If only subject and possibly predicate are given, the subject index will be the fastest\n              this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId, null, quads);\n            }\n          } else if (predicateId) {\n            // if only predicate and possibly object are given, the predicate index will be the fastest\n            this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId, null, quads);\n          } else if (objectId) {\n            // If only object is given, the object index will be the fastest\n            this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId, null, quads);\n          } else {\n            // If nothing is given, iterate subjects and predicates first\n            this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId, null, quads);\n          }\n        }\n      }\n      return quads;\n    }\n  }, {\n    key: \"_getQuad\",\n    value: function _getQuad(subjectId, predicateId, objectId, graphId) {\n      return this._quads.get(this._toId(subjectId, predicateId, objectId, graphId));\n    }\n  }, {\n    key: \"_setQuad\",\n    value: function _setQuad(subjectId, predicateId, objectId, graphId, quad) {\n      this._quads.set(this._toId(subjectId, predicateId, objectId, graphId), quad);\n    }\n  }, {\n    key: \"_deleteQuad\",\n    value: function _deleteQuad(subjectId, predicateId, objectId, graphId) {\n      this._quads.delete(this._toId(subjectId, predicateId, objectId, graphId));\n    }\n  }, {\n    key: \"_createDataset\",\n    value: function _createDataset(quads) {\n      return new this.constructor(quads);\n    }\n  }, {\n    key: \"_toId\",\n    value: function _toId(subjectId, predicateId, objectId, graphId) {\n      return \"\".concat(subjectId, \":\").concat(predicateId, \":\").concat(objectId, \":\").concat(graphId);\n    }\n  }]);\n  return DatasetCore;\n}(Symbol.iterator);\nmodule.exports = DatasetCore;","map":{"version":3,"names":["isString","s","String","xsdString","termToId","term","id","termType","subject","predicate","object","graph","value","language","datatype","escapeQuotes","Error","escapedLiteral","replace","_","quoted","DatasetCore","quads","_size","_graphs","Object","create","_id","_ids","_entities","_quads","Map","quad","add","size","graphs","subjects","graphKey","subjectKey","predicateKey","keys","length","graphItem","predicates","objects","freeze","ids","entities","_addToIndex","_setQuad","_removeFromIndex","_deleteQuad","subjectId","predicateId","objectId","_countInIndex","_createDataset","_match","Symbol","iterator","index0","key0","key1","key2","index1","index2","existed","key","name0","name1","name2","callback","array","tmp","value0","value1","values","l","parts","_getQuad","push","count","_getGraphs","content","graphId","_findInIndex","get","_toId","set","delete","constructor","module","exports"],"sources":["E:/react-todo-app/node_modules/@rdfjs/dataset/DatasetCore.js"],"sourcesContent":["function isString (s) {\n  return typeof s === 'string' || s instanceof String\n}\n\nconst xsdString = 'http://www.w3.org/2001/XMLSchema#string'\n\nfunction termToId (term) {\n  if (typeof term === 'string') {\n    return term\n  }\n\n  if (!term) {\n    return ''\n  }\n\n  if (typeof term.id !== 'undefined' && term.termType !== 'Quad') {\n    return term.id\n  }\n\n  let subject, predicate, object, graph\n\n  // Term instantiated with another library\n  switch (term.termType) {\n    case 'NamedNode':\n      return term.value\n\n    case 'BlankNode':\n      return `_:${term.value}`\n\n    case 'Variable':\n      return `?${term.value}`\n\n    case 'DefaultGraph':\n      return ''\n\n    case 'Literal':\n      if (term.language) {\n        return `\"${term.value}\"@${term.language}`\n      }\n\n      return `\"${term.value}\"${term.datatype && term.datatype.value !== xsdString ? `^^${term.datatype.value}` : ''}`\n\n    case 'Quad':\n      // To identify RDF* quad components, we escape quotes by doubling them.\n      // This avoids the overhead of backslash parsing of Turtle-like syntaxes.\n      subject = escapeQuotes(termToId(term.subject))\n      predicate = escapeQuotes(termToId(term.predicate))\n      object = escapeQuotes(termToId(term.object))\n      graph = term.graph.termType === 'DefaultGraph' ? '' : ` ${termToId(term.graph)}`\n\n      return `<<${subject} ${predicate} ${object}${graph}>>`\n\n    default:\n      throw new Error(`Unexpected termType: ${term.termType}`)\n  }\n}\n\nconst escapedLiteral = /^\"(.*\".*)(?=\"[^\"]*$)/\n\nfunction escapeQuotes (id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"/g, '\"\"')}`)\n}\n\nclass DatasetCore {\n  constructor (quads) {\n    // The number of quads is initially zero\n    this._size = 0\n    // `_graphs` contains subject, predicate, and object indexes per graph\n    this._graphs = Object.create(null)\n    // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n    this._id = 0\n    this._ids = Object.create(null)\n    this._ids['><'] = 0 // dummy entry, so the first actual key is non-zero\n    this._entities = Object.create(null) // inverse of `_ids`\n\n    this._quads = new Map()\n\n    // Add quads if passed\n    if (quads) {\n      for (const quad of quads) {\n        this.add(quad)\n      }\n    }\n  }\n\n  get size () {\n    // Return the quad count if if was cached\n    let size = this._size\n\n    if (size !== null) {\n      return size\n    }\n\n    // Calculate the number of quads by counting to the deepest level\n    size = 0\n    const graphs = this._graphs\n    let subjects, subject\n\n    for (const graphKey in graphs) {\n      for (const subjectKey in (subjects = graphs[graphKey].subjects)) {\n        for (const predicateKey in (subject = subjects[subjectKey])) {\n          size += Object.keys(subject[predicateKey]).length\n        }\n      }\n    }\n\n    this._size = size\n\n    return this._size\n  }\n\n  add (quad) {\n    // Convert terms to internal string representation\n    let subject = termToId(quad.subject)\n    let predicate = termToId(quad.predicate)\n    let object = termToId(quad.object)\n    const graph = termToId(quad.graph)\n\n    // Find the graph that will contain the triple\n    let graphItem = this._graphs[graph]\n    // Create the graph if it doesn't exist yet\n    if (!graphItem) {\n      graphItem = this._graphs[graph] = { subjects: {}, predicates: {}, objects: {} }\n      // Freezing a graph helps subsequent `add` performance,\n      // and properties will never be modified anyway\n      Object.freeze(graphItem)\n    }\n\n    // Since entities can often be long IRIs, we avoid storing them in every index.\n    // Instead, we have a separate index that maps entities to numbers,\n    // which are then used as keys in the other indexes.\n    const ids = this._ids\n    const entities = this._entities\n    subject = ids[subject] || (ids[entities[++this._id] = subject] = this._id)\n    predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id)\n    object = ids[object] || (ids[entities[++this._id] = object] = this._id)\n\n    this._addToIndex(graphItem.subjects, subject, predicate, object)\n    this._addToIndex(graphItem.predicates, predicate, object, subject)\n    this._addToIndex(graphItem.objects, object, subject, predicate)\n\n    this._setQuad(subject, predicate, object, graph, quad)\n\n    // The cached quad count is now invalid\n    this._size = null\n\n    return this\n  }\n\n  delete (quad) {\n    // Convert terms to internal string representation\n    let subject = termToId(quad.subject)\n    let predicate = termToId(quad.predicate)\n    let object = termToId(quad.object)\n    const graph = termToId(quad.graph)\n\n    // Find internal identifiers for all components\n    // and verify the quad exists.\n    const ids = this._ids\n    const graphs = this._graphs\n    let graphItem, subjects, predicates\n\n    if (!(subject = ids[subject]) || !(predicate = ids[predicate]) ||\n      !(object = ids[object]) || !(graphItem = graphs[graph]) ||\n      !(subjects = graphItem.subjects[subject]) ||\n      !(predicates = subjects[predicate]) ||\n      !(object in predicates)\n    ) {\n      return this\n    }\n\n    // Remove it from all indexes\n    this._removeFromIndex(graphItem.subjects, subject, predicate, object)\n    this._removeFromIndex(graphItem.predicates, predicate, object, subject)\n    this._removeFromIndex(graphItem.objects, object, subject, predicate)\n\n    if (this._size !== null) {\n      this._size--\n    }\n\n    this._deleteQuad(subject, predicate, object, graph)\n\n    // Remove the graph if it is empty\n    for (subject in graphItem.subjects) { // eslint-disable-line no-unreachable-loop\n      return this\n    }\n\n    delete graphs[graph]\n\n    return this\n  }\n\n  has (quad) {\n    // Convert terms to internal string representation\n    const subject = termToId(quad.subject)\n    const predicate = termToId(quad.predicate)\n    const object = termToId(quad.object)\n    const graph = termToId(quad.graph)\n\n    const graphItem = this._graphs[graph]\n\n    if (!graphItem) {\n      return false\n    }\n\n    const ids = this._ids\n    let subjectId, predicateId, objectId\n\n    // Translate IRIs to internal index keys.\n    if (\n      (isString(subject) && !(subjectId = ids[subject])) ||\n      (isString(predicate) && !(predicateId = ids[predicate])) ||\n      (isString(object) && !(objectId = ids[object]))\n    ) {\n      return false\n    }\n\n    return this._countInIndex(graphItem.objects, objectId, subjectId, predicateId) === 1\n  }\n\n  match (subject, predicate, object, graph) {\n    return this._createDataset(this._match(subject, predicate, object, graph))\n  }\n\n  [Symbol.iterator] () {\n    return this._match()[Symbol.iterator]()\n  }\n\n  // ## Private methods\n\n  // ### `_addToIndex` adds a quad to a three-layered index.\n  // Returns if the index has changed, if the entry did not already exist.\n  _addToIndex (index0, key0, key1, key2) {\n    // Create layers as necessary\n    const index1 = index0[key0] || (index0[key0] = {})\n    const index2 = index1[key1] || (index1[key1] = {})\n    // Setting the key to _any_ value signals the presence of the quad\n    const existed = key2 in index2\n\n    if (!existed) {\n      index2[key2] = null\n    }\n\n    return !existed\n  }\n\n  // ### `_removeFromIndex` removes a quad from a three-layered index\n  _removeFromIndex (index0, key0, key1, key2) {\n    // Remove the quad from the index\n    const index1 = index0[key0]\n    const index2 = index1[key1]\n    delete index2[key2]\n\n    // Remove intermediary index layers if they are empty\n    for (const key in index2) { // eslint-disable-line no-unreachable-loop\n      return\n    }\n\n    delete index1[key1]\n\n    for (const key in index1) { // eslint-disable-line no-unreachable-loop\n      return\n    }\n\n    delete index0[key0]\n  }\n\n  // ### `_findInIndex` finds a set of quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  // `name0`, `name1`, and `name2` are the names of the keys at each level,\n  // used when reconstructing the resulting quad\n  // (for instance: _subject_, _predicate_, and _object_).\n  // Finally, `graph` will be the graph of the created quads.\n  // If `callback` is given, each result is passed through it\n  // and iteration halts when it returns truthy for any quad.\n  // If instead `array` is given, each result is added to the array.\n  _findInIndex (index0, key0, key1, key2, name0, name1, name2, graph, callback, array) {\n    let tmp, index1, index2\n\n    // If a key is specified, use only that part of index 0.\n    if (key0) {\n      (tmp = index0, index0 = {})[key0] = tmp[key0]\n    }\n\n    for (const value0 in index0) {\n      index1 = index0[value0]\n\n      if (index1) {\n        // If a key is specified, use only that part of index 1.\n        if (key1) {\n          (tmp = index1, index1 = {})[key1] = tmp[key1]\n        }\n\n        for (const value1 in index1) {\n          index2 = index1[value1]\n\n          if (index2) {\n            // If a key is specified, use only that part of index 2, if it exists.\n            const values = key2 ? (key2 in index2 ? [key2] : []) : Object.keys(index2)\n            // Create quads for all items found in index 2.\n            for (let l = 0; l < values.length; l++) {\n              const parts = {\n                [name0]: value0,\n                [name1]: value1,\n                [name2]: values[l]\n              }\n\n              const quad = this._getQuad(parts.subject, parts.predicate, parts.object, graph)\n\n              if (array) {\n                array.push(quad)\n              } else if (callback(quad)) {\n                return true\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return array\n  }\n\n  // ### `_countInIndex` counts matching quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  _countInIndex (index0, key0, key1, key2) {\n    let count = 0\n    let tmp, index1, index2\n\n    // If a key is specified, count only that part of index 0\n    if (key0) {\n      (tmp = index0, index0 = {})[key0] = tmp[key0]\n    }\n\n    for (const value0 in index0) {\n      index1 = index0[value0]\n\n      if (index1) {\n        // If a key is specified, count only that part of index 1\n        if (key1) {\n          (tmp = index1, index1 = {})[key1] = tmp[key1]\n        }\n\n        for (const value1 in index1) {\n          index2 = index1[value1]\n\n          if (index2) {\n            if (key2) {\n              // If a key is specified, count the quad if it exists\n              (key2 in index2) && count++\n            } else {\n              // Otherwise, count all quads\n              count += Object.keys(index2).length\n            }\n          }\n        }\n      }\n    }\n\n    return count\n  }\n\n  // ### `_getGraphs` returns an array with the given graph,\n  // or all graphs if the argument is null or undefined.\n  _getGraphs (graph) {\n    if (!isString(graph)) {\n      return this._graphs\n    }\n\n    return {\n      [graph]: this._graphs[graph]\n    }\n  }\n\n  _match (subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject)\n    predicate = predicate && termToId(predicate)\n    object = object && termToId(object)\n    graph = graph && termToId(graph)\n\n    const quads = []\n    const graphs = this._getGraphs(graph)\n    const ids = this._ids\n    let content, subjectId, predicateId, objectId\n\n    // Translate IRIs to internal index keys.\n    if (\n      (isString(subject) && !(subjectId = ids[subject])) ||\n      (isString(predicate) && !(predicateId = ids[predicate])) ||\n      (isString(object) && !(objectId = ids[object]))\n    ) {\n      return quads\n    }\n\n    for (const graphId in graphs) {\n      content = graphs[graphId]\n\n      // Only if the specified graph contains triples, there can be results\n      if (content) {\n        // Choose the optimal index, based on what fields are present\n        if (subjectId) {\n          if (objectId) {\n            // If subject and object are given, the object index will be the fastest\n            this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId, null, quads)\n          } else {\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId, null, quads)\n          }\n        } else if (predicateId) {\n          // if only predicate and possibly object are given, the predicate index will be the fastest\n          this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId, null, quads)\n        } else if (objectId) {\n          // If only object is given, the object index will be the fastest\n          this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId, null, quads)\n        } else {\n          // If nothing is given, iterate subjects and predicates first\n          this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId, null, quads)\n        }\n      }\n    }\n\n    return quads\n  }\n\n  _getQuad (subjectId, predicateId, objectId, graphId) {\n    return this._quads.get(this._toId(subjectId, predicateId, objectId, graphId))\n  }\n\n  _setQuad (subjectId, predicateId, objectId, graphId, quad) {\n    this._quads.set(this._toId(subjectId, predicateId, objectId, graphId), quad)\n  }\n\n  _deleteQuad (subjectId, predicateId, objectId, graphId) {\n    this._quads.delete(this._toId(subjectId, predicateId, objectId, graphId))\n  }\n\n  _createDataset (quads) {\n    return new this.constructor(quads)\n  }\n\n  _toId (subjectId, predicateId, objectId, graphId) {\n    return `${subjectId}:${predicateId}:${objectId}:${graphId}`\n  }\n}\n\nmodule.exports = DatasetCore\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}