{"ast":null,"code":"// **N3Parser** parses N3 documents.\nimport N3Lexer from './N3Lexer';\nimport N3DataFactory from './N3DataFactory';\nimport namespaces from './IRIs';\nlet blankNodePrefix = 0;\n\n// ## Constructor\nexport default class N3Parser {\n  constructor(options) {\n    this._contextStack = [];\n    this._graph = null;\n\n    // Set the document IRI\n    options = options || {};\n    this._setBase(options.baseIRI);\n    options.factory && initDataFactory(this, options.factory);\n\n    // Set supported features depending on the format\n    const format = typeof options.format === 'string' ? options.format.match(/\\w*$/)[0].toLowerCase() : '',\n      isTurtle = /turtle/.test(format),\n      isTriG = /trig/.test(format),\n      isNTriples = /triple/.test(format),\n      isNQuads = /quad/.test(format),\n      isN3 = this._n3Mode = /n3/.test(format),\n      isLineMode = isNTriples || isNQuads;\n    if (!(this._supportsNamedGraphs = !(isTurtle || isN3))) this._readPredicateOrNamedGraph = this._readPredicate;\n    // Support triples in other graphs\n    this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3);\n    // Support nesting of triples\n    this._supportsRDFStar = format === '' || /star|\\*$/.test(format);\n    // Disable relative IRIs in N-Triples or N-Quads mode\n    if (isLineMode) this._resolveRelativeIRI = iri => {\n      return null;\n    };\n    this._blankNodePrefix = typeof options.blankNodePrefix !== 'string' ? '' : options.blankNodePrefix.replace(/^(?!_:)/, '_:');\n    this._lexer = options.lexer || new N3Lexer({\n      lineMode: isLineMode,\n      n3: isN3\n    });\n    // Disable explicit quantifiers by default\n    this._explicitQuantifiers = !!options.explicitQuantifiers;\n  }\n\n  // ## Static class methods\n\n  // ### `_resetBlankNodePrefix` restarts blank node prefix identification\n  static _resetBlankNodePrefix() {\n    blankNodePrefix = 0;\n  }\n\n  // ## Private methods\n\n  // ### `_setBase` sets the base IRI to resolve relative IRIs\n  _setBase(baseIRI) {\n    if (!baseIRI) {\n      this._base = '';\n      this._basePath = '';\n    } else {\n      // Remove fragment if present\n      const fragmentPos = baseIRI.indexOf('#');\n      if (fragmentPos >= 0) baseIRI = baseIRI.substr(0, fragmentPos);\n      // Set base IRI and its components\n      this._base = baseIRI;\n      this._basePath = baseIRI.indexOf('/') < 0 ? baseIRI : baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');\n      baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i);\n      this._baseRoot = baseIRI[0];\n      this._baseScheme = baseIRI[1];\n    }\n  }\n\n  // ### `_saveContext` stores the current parsing context\n  // when entering a new scope (list, blank node, formula)\n  _saveContext(type, graph, subject, predicate, object) {\n    const n3Mode = this._n3Mode;\n    this._contextStack.push({\n      type,\n      subject,\n      predicate,\n      object,\n      graph,\n      inverse: n3Mode ? this._inversePredicate : false,\n      blankPrefix: n3Mode ? this._prefixes._ : '',\n      quantified: n3Mode ? this._quantified : null\n    });\n    // The settings below only apply to N3 streams\n    if (n3Mode) {\n      // Every new scope resets the predicate direction\n      this._inversePredicate = false;\n      // In N3, blank nodes are scoped to a formula\n      // (using a dot as separator, as a blank node label cannot start with it)\n      this._prefixes._ = this._graph ? `${this._graph.id.substr(2)}.` : '.';\n      // Quantifiers are scoped to a formula\n      this._quantified = Object.create(this._quantified);\n    }\n  }\n\n  // ### `_restoreContext` restores the parent context\n  // when leaving a scope (list, blank node, formula)\n  _restoreContext(type, token) {\n    // Obtain the previous context\n    const context = this._contextStack.pop();\n    if (!context || context.type !== type) return this._error(`Unexpected ${token.type}`, token);\n\n    // Restore the quad of the previous context\n    this._subject = context.subject;\n    this._predicate = context.predicate;\n    this._object = context.object;\n    this._graph = context.graph;\n\n    // Restore N3 context settings\n    if (this._n3Mode) {\n      this._inversePredicate = context.inverse;\n      this._prefixes._ = context.blankPrefix;\n      this._quantified = context.quantified;\n    }\n  }\n\n  // ### `_readInTopContext` reads a token when in the top context\n  _readInTopContext(token) {\n    switch (token.type) {\n      // If an EOF token arrives in the top context, signal that we're done\n      case 'eof':\n        if (this._graph !== null) return this._error('Unclosed graph', token);\n        delete this._prefixes._;\n        return this._callback(null, null, this._prefixes);\n      // It could be a prefix declaration\n      case 'PREFIX':\n        this._sparqlStyle = true;\n      case '@prefix':\n        return this._readPrefix;\n      // It could be a base declaration\n      case 'BASE':\n        this._sparqlStyle = true;\n      case '@base':\n        return this._readBaseIRI;\n      // It could be a graph\n      case '{':\n        if (this._supportsNamedGraphs) {\n          this._graph = '';\n          this._subject = null;\n          return this._readSubject;\n        }\n      case 'GRAPH':\n        if (this._supportsNamedGraphs) return this._readNamedGraphLabel;\n      // Otherwise, the next token must be a subject\n      default:\n        return this._readSubject(token);\n    }\n  }\n\n  // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable\n  _readEntity(token, quantifier) {\n    let value;\n    switch (token.type) {\n      // Read a relative or absolute IRI\n      case 'IRI':\n      case 'typeIRI':\n        const iri = this._resolveIRI(token.value);\n        if (iri === null) return this._error('Invalid IRI', token);\n        value = this._namedNode(iri);\n        break;\n      // Read a prefixed name\n      case 'type':\n      case 'prefixed':\n        const prefix = this._prefixes[token.prefix];\n        if (prefix === undefined) return this._error(`Undefined prefix \"${token.prefix}:\"`, token);\n        value = this._namedNode(prefix + token.value);\n        break;\n      // Read a blank node\n      case 'blank':\n        value = this._blankNode(this._prefixes[token.prefix] + token.value);\n        break;\n      // Read a variable\n      case 'var':\n        value = this._variable(token.value.substr(1));\n        break;\n      // Everything else is not an entity\n      default:\n        return this._error(`Expected entity but got ${token.type}`, token);\n    }\n    // In N3 mode, replace the entity if it is quantified\n    if (!quantifier && this._n3Mode && value.id in this._quantified) value = this._quantified[value.id];\n    return value;\n  }\n\n  // ### `_readSubject` reads a quad's subject\n  _readSubject(token) {\n    this._predicate = null;\n    switch (token.type) {\n      case '[':\n        // Start a new quad with a new blank node as subject\n        this._saveContext('blank', this._graph, this._subject = this._blankNode(), null, null);\n        return this._readBlankNodeHead;\n      case '(':\n        // Start a new list\n        this._saveContext('list', this._graph, this.RDF_NIL, null, null);\n        this._subject = null;\n        return this._readListItem;\n      case '{':\n        // Start a new formula\n        if (!this._n3Mode) return this._error('Unexpected graph', token);\n        this._saveContext('formula', this._graph, this._graph = this._blankNode(), null, null);\n        return this._readSubject;\n      case '}':\n        // No subject; the graph in which we are reading is closed instead\n        return this._readPunctuation(token);\n      case '@forSome':\n        if (!this._n3Mode) return this._error('Unexpected \"@forSome\"', token);\n        this._subject = null;\n        this._predicate = this.N3_FORSOME;\n        this._quantifier = this._blankNode;\n        return this._readQuantifierList;\n      case '@forAll':\n        if (!this._n3Mode) return this._error('Unexpected \"@forAll\"', token);\n        this._subject = null;\n        this._predicate = this.N3_FORALL;\n        this._quantifier = this._variable;\n        return this._readQuantifierList;\n      case 'literal':\n        if (!this._n3Mode) return this._error('Unexpected literal', token);\n        if (token.prefix.length === 0) {\n          this._literalValue = token.value;\n          return this._completeSubjectLiteral;\n        } else this._subject = this._literal(token.value, this._namedNode(token.prefix));\n        break;\n      case '<<':\n        if (!this._supportsRDFStar) return this._error('Unexpected RDF* syntax', token);\n        this._saveContext('<<', this._graph, null, null, null);\n        this._graph = null;\n        return this._readSubject;\n      default:\n        // Read the subject entity\n        if ((this._subject = this._readEntity(token)) === undefined) return;\n        // In N3 mode, the subject might be a path\n        if (this._n3Mode) return this._getPathReader(this._readPredicateOrNamedGraph);\n    }\n\n    // The next token must be a predicate,\n    // or, if the subject was actually a graph IRI, a named graph\n    return this._readPredicateOrNamedGraph;\n  }\n\n  // ### `_readPredicate` reads a quad's predicate\n  _readPredicate(token) {\n    const type = token.type;\n    switch (type) {\n      case 'inverse':\n        this._inversePredicate = true;\n      case 'abbreviation':\n        this._predicate = this.ABBREVIATIONS[token.value];\n        break;\n      case '.':\n      case ']':\n      case '}':\n        // Expected predicate didn't come, must have been trailing semicolon\n        if (this._predicate === null) return this._error(`Unexpected ${type}`, token);\n        this._subject = null;\n        return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);\n      case ';':\n        // Additional semicolons can be safely ignored\n        return this._predicate !== null ? this._readPredicate : this._error('Expected predicate but got ;', token);\n      case '[':\n        if (this._n3Mode) {\n          // Start a new quad with a new blank node as subject\n          this._saveContext('blank', this._graph, this._subject, this._subject = this._blankNode(), null);\n          return this._readBlankNodeHead;\n        }\n      case 'blank':\n        if (!this._n3Mode) return this._error('Disallowed blank node as predicate', token);\n      default:\n        if ((this._predicate = this._readEntity(token)) === undefined) return;\n    }\n    // The next token must be an object\n    return this._readObject;\n  }\n\n  // ### `_readObject` reads a quad's object\n  _readObject(token) {\n    switch (token.type) {\n      case 'literal':\n        // Regular literal, can still get a datatype or language\n        if (token.prefix.length === 0) {\n          this._literalValue = token.value;\n          return this._readDataTypeOrLang;\n        }\n        // Pre-datatyped string literal (prefix stores the datatype)\n        else this._object = this._literal(token.value, this._namedNode(token.prefix));\n        break;\n      case '[':\n        // Start a new quad with a new blank node as subject\n        this._saveContext('blank', this._graph, this._subject, this._predicate, this._subject = this._blankNode());\n        return this._readBlankNodeHead;\n      case '(':\n        // Start a new list\n        this._saveContext('list', this._graph, this._subject, this._predicate, this.RDF_NIL);\n        this._subject = null;\n        return this._readListItem;\n      case '{':\n        // Start a new formula\n        if (!this._n3Mode) return this._error('Unexpected graph', token);\n        this._saveContext('formula', this._graph, this._subject, this._predicate, this._graph = this._blankNode());\n        return this._readSubject;\n      case '<<':\n        if (!this._supportsRDFStar) return this._error('Unexpected RDF* syntax', token);\n        this._saveContext('<<', this._graph, this._subject, this._predicate, null);\n        this._graph = null;\n        return this._readSubject;\n      default:\n        // Read the object entity\n        if ((this._object = this._readEntity(token)) === undefined) return;\n        // In N3 mode, the object might be a path\n        if (this._n3Mode) return this._getPathReader(this._getContextEndReader());\n    }\n    return this._getContextEndReader();\n  }\n\n  // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph\n  _readPredicateOrNamedGraph(token) {\n    return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);\n  }\n\n  // ### `_readGraph` reads a graph\n  _readGraph(token) {\n    if (token.type !== '{') return this._error(`Expected graph but got ${token.type}`, token);\n    // The \"subject\" we read is actually the GRAPH's label\n    this._graph = this._subject, this._subject = null;\n    return this._readSubject;\n  }\n\n  // ### `_readBlankNodeHead` reads the head of a blank node\n  _readBlankNodeHead(token) {\n    if (token.type === ']') {\n      this._subject = null;\n      return this._readBlankNodeTail(token);\n    } else {\n      this._predicate = null;\n      return this._readPredicate(token);\n    }\n  }\n\n  // ### `_readBlankNodeTail` reads the end of a blank node\n  _readBlankNodeTail(token) {\n    if (token.type !== ']') return this._readBlankNodePunctuation(token);\n\n    // Store blank node quad\n    if (this._subject !== null) this._emit(this._subject, this._predicate, this._object, this._graph);\n\n    // Restore the parent context containing this blank node\n    const empty = this._predicate === null;\n    this._restoreContext('blank', token);\n    // If the blank node was the object, restore previous context and read punctuation\n    if (this._object !== null) return this._getContextEndReader();\n    // If the blank node was the predicate, continue reading the object\n    else if (this._predicate !== null) return this._readObject;\n    // If the blank node was the subject, continue reading the predicate\n    else\n      // If the blank node was empty, it could be a named graph label\n      return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;\n  }\n\n  // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node\n  _readPredicateAfterBlank(token) {\n    switch (token.type) {\n      case '.':\n      case '}':\n        // No predicate is coming if the triple is terminated here\n        this._subject = null;\n        return this._readPunctuation(token);\n      default:\n        return this._readPredicate(token);\n    }\n  }\n\n  // ### `_readListItem` reads items from a list\n  _readListItem(token) {\n    let item = null,\n      // The item of the list\n      list = null,\n      // The list itself\n      next = this._readListItem; // The next function to execute\n    const previousList = this._subject,\n      // The previous list that contains this list\n      stack = this._contextStack,\n      // The stack of parent contexts\n      parent = stack[stack.length - 1]; // The parent containing the current list\n\n    switch (token.type) {\n      case '[':\n        // Stack the current list quad and start a new quad with a blank node as subject\n        this._saveContext('blank', this._graph, list = this._blankNode(), this.RDF_FIRST, this._subject = item = this._blankNode());\n        next = this._readBlankNodeHead;\n        break;\n      case '(':\n        // Stack the current list quad and start a new list\n        this._saveContext('list', this._graph, list = this._blankNode(), this.RDF_FIRST, this.RDF_NIL);\n        this._subject = null;\n        break;\n      case ')':\n        // Closing the list; restore the parent context\n        this._restoreContext('list', token);\n        // If this list is contained within a parent list, return the membership quad here.\n        // This will be `<parent list element> rdf:first <this list>.`.\n        if (stack.length !== 0 && stack[stack.length - 1].type === 'list') this._emit(this._subject, this._predicate, this._object, this._graph);\n        // Was this list the parent's subject?\n        if (this._predicate === null) {\n          // The next token is the predicate\n          next = this._readPredicate;\n          // No list tail if this was an empty list\n          if (this._subject === this.RDF_NIL) return next;\n        }\n        // The list was in the parent context's object\n        else {\n          next = this._getContextEndReader();\n          // No list tail if this was an empty list\n          if (this._object === this.RDF_NIL) return next;\n        }\n        // Close the list by making the head nil\n        list = this.RDF_NIL;\n        break;\n      case 'literal':\n        // Regular literal, can still get a datatype or language\n        if (token.prefix.length === 0) {\n          this._literalValue = token.value;\n          next = this._readListItemDataTypeOrLang;\n        }\n        // Pre-datatyped string literal (prefix stores the datatype)\n        else {\n          item = this._literal(token.value, this._namedNode(token.prefix));\n          next = this._getContextEndReader();\n        }\n        break;\n      case '{':\n        // Start a new formula\n        if (!this._n3Mode) return this._error('Unexpected graph', token);\n        this._saveContext('formula', this._graph, this._subject, this._predicate, this._graph = this._blankNode());\n        return this._readSubject;\n      default:\n        if ((item = this._readEntity(token)) === undefined) return;\n    }\n\n    // Create a new blank node if no item head was assigned yet\n    if (list === null) this._subject = list = this._blankNode();\n\n    // Is this the first element of the list?\n    if (previousList === null) {\n      // This list is either the subject or the object of its parent\n      if (parent.predicate === null) parent.subject = list;else parent.object = list;\n    } else {\n      // Continue the previous list with the current list\n      this._emit(previousList, this.RDF_REST, list, this._graph);\n    }\n    // If an item was read, add it to the list\n    if (item !== null) {\n      // In N3 mode, the item might be a path\n      if (this._n3Mode && (token.type === 'IRI' || token.type === 'prefixed')) {\n        // Create a new context to add the item's path\n        this._saveContext('item', this._graph, list, this.RDF_FIRST, item);\n        this._subject = item, this._predicate = null;\n        // _readPath will restore the context and output the item\n        return this._getPathReader(this._readListItem);\n      }\n      // Output the item\n      this._emit(list, this.RDF_FIRST, item, this._graph);\n    }\n    return next;\n  }\n\n  // ### `_readDataTypeOrLang` reads an _optional_ datatype or language\n  _readDataTypeOrLang(token) {\n    return this._completeObjectLiteral(token, false);\n  }\n\n  // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list\n  _readListItemDataTypeOrLang(token) {\n    return this._completeObjectLiteral(token, true);\n  }\n\n  // ### `_completeLiteral` completes a literal with an optional datatype or language\n  _completeLiteral(token) {\n    // Create a simple string literal by default\n    let literal = this._literal(this._literalValue);\n    switch (token.type) {\n      // Create a datatyped literal\n      case 'type':\n      case 'typeIRI':\n        const datatype = this._readEntity(token);\n        if (datatype === undefined) return; // No datatype means an error occurred\n        literal = this._literal(this._literalValue, datatype);\n        token = null;\n        break;\n      // Create a language-tagged string\n      case 'langcode':\n        literal = this._literal(this._literalValue, token.value);\n        token = null;\n        break;\n    }\n    return {\n      token,\n      literal\n    };\n  }\n\n  // Completes a literal in subject position\n  _completeSubjectLiteral(token) {\n    this._subject = this._completeLiteral(token).literal;\n    return this._readPredicateOrNamedGraph;\n  }\n\n  // Completes a literal in object position\n  _completeObjectLiteral(token, listItem) {\n    const completed = this._completeLiteral(token);\n    if (!completed) return;\n    this._object = completed.literal;\n\n    // If this literal was part of a list, write the item\n    // (we could also check the context stack, but passing in a flag is faster)\n    if (listItem) this._emit(this._subject, this.RDF_FIRST, this._object, this._graph);\n    // If the token was consumed, continue with the rest of the input\n    if (completed.token === null) return this._getContextEndReader();\n    // Otherwise, consume the token now\n    else {\n      this._readCallback = this._getContextEndReader();\n      return this._readCallback(completed.token);\n    }\n  }\n\n  // ### `_readFormulaTail` reads the end of a formula\n  _readFormulaTail(token) {\n    if (token.type !== '}') return this._readPunctuation(token);\n\n    // Store the last quad of the formula\n    if (this._subject !== null) this._emit(this._subject, this._predicate, this._object, this._graph);\n\n    // Restore the parent context containing this formula\n    this._restoreContext('formula', token);\n    // If the formula was the subject, continue reading the predicate.\n    // If the formula was the object, read punctuation.\n    return this._object === null ? this._readPredicate : this._getContextEndReader();\n  }\n\n  // ### `_readPunctuation` reads punctuation between quads or quad parts\n  _readPunctuation(token) {\n    let next,\n      graph = this._graph;\n    const subject = this._subject,\n      inversePredicate = this._inversePredicate;\n    switch (token.type) {\n      // A closing brace ends a graph\n      case '}':\n        if (this._graph === null) return this._error('Unexpected graph closing', token);\n        if (this._n3Mode) return this._readFormulaTail(token);\n        this._graph = null;\n      // A dot just ends the statement, without sharing anything with the next\n      case '.':\n        this._subject = null;\n        next = this._contextStack.length ? this._readSubject : this._readInTopContext;\n        if (inversePredicate) this._inversePredicate = false;\n        break;\n      // Semicolon means the subject is shared; predicate and object are different\n      case ';':\n        next = this._readPredicate;\n        break;\n      // Comma means both the subject and predicate are shared; the object is different\n      case ',':\n        next = this._readObject;\n        break;\n      default:\n        // An entity means this is a quad (only allowed if not already inside a graph)\n        if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== undefined) {\n          next = this._readQuadPunctuation;\n          break;\n        }\n        return this._error(`Expected punctuation to follow \"${this._object.id}\"`, token);\n    }\n    // A quad has been completed now, so return it\n    if (subject !== null) {\n      const predicate = this._predicate,\n        object = this._object;\n      if (!inversePredicate) this._emit(subject, predicate, object, graph);else this._emit(object, predicate, subject, graph);\n    }\n    return next;\n  }\n\n  // ### `_readBlankNodePunctuation` reads punctuation in a blank node\n  _readBlankNodePunctuation(token) {\n    let next;\n    switch (token.type) {\n      // Semicolon means the subject is shared; predicate and object are different\n      case ';':\n        next = this._readPredicate;\n        break;\n      // Comma means both the subject and predicate are shared; the object is different\n      case ',':\n        next = this._readObject;\n        break;\n      default:\n        return this._error(`Expected punctuation to follow \"${this._object.id}\"`, token);\n    }\n    // A quad has been completed now, so return it\n    this._emit(this._subject, this._predicate, this._object, this._graph);\n    return next;\n  }\n\n  // ### `_readQuadPunctuation` reads punctuation after a quad\n  _readQuadPunctuation(token) {\n    if (token.type !== '.') return this._error('Expected dot to follow quad', token);\n    return this._readInTopContext;\n  }\n\n  // ### `_readPrefix` reads the prefix of a prefix declaration\n  _readPrefix(token) {\n    if (token.type !== 'prefix') return this._error('Expected prefix to follow @prefix', token);\n    this._prefix = token.value;\n    return this._readPrefixIRI;\n  }\n\n  // ### `_readPrefixIRI` reads the IRI of a prefix declaration\n  _readPrefixIRI(token) {\n    if (token.type !== 'IRI') return this._error(`Expected IRI to follow prefix \"${this._prefix}:\"`, token);\n    const prefixNode = this._readEntity(token);\n    this._prefixes[this._prefix] = prefixNode.value;\n    this._prefixCallback(this._prefix, prefixNode);\n    return this._readDeclarationPunctuation;\n  }\n\n  // ### `_readBaseIRI` reads the IRI of a base declaration\n  _readBaseIRI(token) {\n    const iri = token.type === 'IRI' && this._resolveIRI(token.value);\n    if (!iri) return this._error('Expected valid IRI to follow base declaration', token);\n    this._setBase(iri);\n    return this._readDeclarationPunctuation;\n  }\n\n  // ### `_readNamedGraphLabel` reads the label of a named graph\n  _readNamedGraphLabel(token) {\n    switch (token.type) {\n      case 'IRI':\n      case 'blank':\n      case 'prefixed':\n        return this._readSubject(token), this._readGraph;\n      case '[':\n        return this._readNamedGraphBlankLabel;\n      default:\n        return this._error('Invalid graph label', token);\n    }\n  }\n\n  // ### `_readNamedGraphLabel` reads a blank node label of a named graph\n  _readNamedGraphBlankLabel(token) {\n    if (token.type !== ']') return this._error('Invalid graph label', token);\n    this._subject = this._blankNode();\n    return this._readGraph;\n  }\n\n  // ### `_readDeclarationPunctuation` reads the punctuation of a declaration\n  _readDeclarationPunctuation(token) {\n    // SPARQL-style declarations don't have punctuation\n    if (this._sparqlStyle) {\n      this._sparqlStyle = false;\n      return this._readInTopContext(token);\n    }\n    if (token.type !== '.') return this._error('Expected declaration to end with a dot', token);\n    return this._readInTopContext;\n  }\n\n  // Reads a list of quantified symbols from a @forSome or @forAll statement\n  _readQuantifierList(token) {\n    let entity;\n    switch (token.type) {\n      case 'IRI':\n      case 'prefixed':\n        if ((entity = this._readEntity(token, true)) !== undefined) break;\n      default:\n        return this._error(`Unexpected ${token.type}`, token);\n    }\n    // Without explicit quantifiers, map entities to a quantified entity\n    if (!this._explicitQuantifiers) this._quantified[entity.id] = this._quantifier(this._blankNode().value);\n    // With explicit quantifiers, output the reified quantifier\n    else {\n      // If this is the first item, start a new quantifier list\n      if (this._subject === null) this._emit(this._graph || this.DEFAULTGRAPH, this._predicate, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);\n      // Otherwise, continue the previous list\n      else this._emit(this._subject, this.RDF_REST, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);\n      // Output the list item\n      this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);\n    }\n    return this._readQuantifierPunctuation;\n  }\n\n  // Reads punctuation from a @forSome or @forAll statement\n  _readQuantifierPunctuation(token) {\n    // Read more quantifiers\n    if (token.type === ',') return this._readQuantifierList;\n    // End of the quantifier list\n    else {\n      // With explicit quantifiers, close the quantifier list\n      if (this._explicitQuantifiers) {\n        this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);\n        this._subject = null;\n      }\n      // Read a dot\n      this._readCallback = this._getContextEndReader();\n      return this._readCallback(token);\n    }\n  }\n\n  // ### `_getPathReader` reads a potential path and then resumes with the given function\n  _getPathReader(afterPath) {\n    this._afterPath = afterPath;\n    return this._readPath;\n  }\n\n  // ### `_readPath` reads a potential path\n  _readPath(token) {\n    switch (token.type) {\n      // Forward path\n      case '!':\n        return this._readForwardPath;\n      // Backward path\n      case '^':\n        return this._readBackwardPath;\n      // Not a path; resume reading where we left off\n      default:\n        const stack = this._contextStack,\n          parent = stack.length && stack[stack.length - 1];\n        // If we were reading a list item, we still need to output it\n        if (parent && parent.type === 'item') {\n          // The list item is the remaining subejct after reading the path\n          const item = this._subject;\n          // Switch back to the context of the list\n          this._restoreContext('item', token);\n          // Output the list item\n          this._emit(this._subject, this.RDF_FIRST, item, this._graph);\n        }\n        return this._afterPath(token);\n    }\n  }\n\n  // ### `_readForwardPath` reads a '!' path\n  _readForwardPath(token) {\n    let subject, predicate;\n    const object = this._blankNode();\n    // The next token is the predicate\n    if ((predicate = this._readEntity(token)) === undefined) return;\n    // If we were reading a subject, replace the subject by the path's object\n    if (this._predicate === null) subject = this._subject, this._subject = object;\n    // If we were reading an object, replace the subject by the path's object\n    else subject = this._object, this._object = object;\n    // Emit the path's current quad and read its next section\n    this._emit(subject, predicate, object, this._graph);\n    return this._readPath;\n  }\n\n  // ### `_readBackwardPath` reads a '^' path\n  _readBackwardPath(token) {\n    const subject = this._blankNode();\n    let predicate, object;\n    // The next token is the predicate\n    if ((predicate = this._readEntity(token)) === undefined) return;\n    // If we were reading a subject, replace the subject by the path's subject\n    if (this._predicate === null) object = this._subject, this._subject = subject;\n    // If we were reading an object, replace the subject by the path's subject\n    else object = this._object, this._object = subject;\n    // Emit the path's current quad and read its next section\n    this._emit(subject, predicate, object, this._graph);\n    return this._readPath;\n  }\n\n  // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF* quad or the end of a nested RDF* triple\n  _readRDFStarTailOrGraph(token) {\n    if (token.type !== '>>') {\n      // An entity means this is a quad (only allowed if not already inside a graph)\n      if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== undefined) return this._readRDFStarTail;\n      return this._error(`Expected >> to follow \"${this._object.id}\"`, token);\n    }\n    return this._readRDFStarTail(token);\n  }\n\n  // ### `_readRDFStarTail` reads the end of a nested RDF* triple\n  _readRDFStarTail(token) {\n    if (token.type !== '>>') return this._error(`Expected >> but got ${token.type}`, token);\n    // Read the quad and restore the previous context\n    const quad = this._quad(this._subject, this._predicate, this._object, this._graph || this.DEFAULTGRAPH);\n    this._restoreContext('<<', token);\n    // If the triple was the subject, continue by reading the predicate.\n    if (this._subject === null) {\n      this._subject = quad;\n      return this._readPredicate;\n    }\n    // If the triple was the object, read context end.\n    else {\n      this._object = quad;\n      return this._getContextEndReader();\n    }\n  }\n\n  // ### `_getContextEndReader` gets the next reader function at the end of a context\n  _getContextEndReader() {\n    const contextStack = this._contextStack;\n    if (!contextStack.length) return this._readPunctuation;\n    switch (contextStack[contextStack.length - 1].type) {\n      case 'blank':\n        return this._readBlankNodeTail;\n      case 'list':\n        return this._readListItem;\n      case 'formula':\n        return this._readFormulaTail;\n      case '<<':\n        return this._readRDFStarTailOrGraph;\n    }\n  }\n\n  // ### `_emit` sends a quad through the callback\n  _emit(subject, predicate, object, graph) {\n    this._callback(null, this._quad(subject, predicate, object, graph || this.DEFAULTGRAPH));\n  }\n\n  // ### `_error` emits an error message through the callback\n  _error(message, token) {\n    const err = new Error(`${message} on line ${token.line}.`);\n    err.context = {\n      token: token,\n      line: token.line,\n      previousToken: this._lexer.previousToken\n    };\n    this._callback(err);\n    this._callback = noop;\n  }\n\n  // ### `_resolveIRI` resolves an IRI against the base path\n  _resolveIRI(iri) {\n    return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);\n  }\n\n  // ### `_resolveRelativeIRI` resolves an IRI against the base path,\n  // assuming that a base path has been set and that the IRI is indeed relative\n  _resolveRelativeIRI(iri) {\n    // An empty relative IRI indicates the base IRI\n    if (!iri.length) return this._base;\n    // Decide resolving strategy based in the first character\n    switch (iri[0]) {\n      // Resolve relative fragment IRIs against the base IRI\n      case '#':\n        return this._base + iri;\n      // Resolve relative query string IRIs by replacing the query string\n      case '?':\n        return this._base.replace(/(?:\\?.*)?$/, iri);\n      // Resolve root-relative IRIs at the root of the base IRI\n      case '/':\n        // Resolve scheme-relative IRIs to the scheme\n        return (iri[1] === '/' ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);\n      // Resolve all other IRIs at the base IRI's path\n      default:\n        // Relative IRIs cannot contain a colon in the first path segment\n        return /^[^/:]*:/.test(iri) ? null : this._removeDotSegments(this._basePath + iri);\n    }\n  }\n\n  // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986\n  _removeDotSegments(iri) {\n    // Don't modify the IRI if it does not contain any dot segments\n    if (!/(^|\\/)\\.\\.?($|[/#?])/.test(iri)) return iri;\n\n    // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n    const length = iri.length;\n    let result = '',\n      i = -1,\n      pathStart = -1,\n      segmentStart = 0,\n      next = '/';\n    while (i < length) {\n      switch (next) {\n        // The path starts with the first slash after the authority\n        case ':':\n          if (pathStart < 0) {\n            // Skip two slashes before the authority\n            if (iri[++i] === '/' && iri[++i] === '/')\n              // Skip to slash after the authority\n              while ((pathStart = i + 1) < length && iri[pathStart] !== '/') i = pathStart;\n          }\n          break;\n        // Don't modify a query string or fragment\n        case '?':\n        case '#':\n          i = length;\n          break;\n        // Handle '/.' or '/..' path segments\n        case '/':\n          if (iri[i + 1] === '.') {\n            next = iri[++i + 1];\n            switch (next) {\n              // Remove a '/.' segment\n              case '/':\n                result += iri.substring(segmentStart, i - 1);\n                segmentStart = i + 1;\n                break;\n              // Remove a trailing '/.' segment\n              case undefined:\n              case '?':\n              case '#':\n                return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n              // Remove a '/..' segment\n              case '.':\n                next = iri[++i + 1];\n                if (next === undefined || next === '/' || next === '?' || next === '#') {\n                  result += iri.substring(segmentStart, i - 2);\n                  // Try to remove the parent path from result\n                  if ((segmentStart = result.lastIndexOf('/')) >= pathStart) result = result.substr(0, segmentStart);\n                  // Remove a trailing '/..' segment\n                  if (next !== '/') return `${result}/${iri.substr(i + 1)}`;\n                  segmentStart = i + 1;\n                }\n            }\n          }\n      }\n      next = iri[++i];\n    }\n    return result + iri.substring(segmentStart);\n  }\n\n  // ## Public methods\n\n  // ### `parse` parses the N3 input and emits each parsed quad through the callback\n  parse(input, quadCallback, prefixCallback) {\n    // The read callback is the next function to be executed when a token arrives.\n    // We start reading in the top context.\n    this._readCallback = this._readInTopContext;\n    this._sparqlStyle = false;\n    this._prefixes = Object.create(null);\n    this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : `b${blankNodePrefix++}_`;\n    this._prefixCallback = prefixCallback || noop;\n    this._inversePredicate = false;\n    this._quantified = Object.create(null);\n\n    // Parse synchronously if no quad callback is given\n    if (!quadCallback) {\n      const quads = [];\n      let error;\n      this._callback = (e, t) => {\n        e ? error = e : t && quads.push(t);\n      };\n      this._lexer.tokenize(input).every(token => {\n        return this._readCallback = this._readCallback(token);\n      });\n      if (error) throw error;\n      return quads;\n    }\n\n    // Parse asynchronously otherwise, executing the read callback when a token arrives\n    this._callback = quadCallback;\n    this._lexer.tokenize(input, (error, token) => {\n      if (error !== null) this._callback(error), this._callback = noop;else if (this._readCallback) this._readCallback = this._readCallback(token);\n    });\n  }\n}\n\n// The empty function\nfunction noop() {}\n\n// Initializes the parser with the given data factory\nfunction initDataFactory(parser, factory) {\n  // Set factory methods\n  const namedNode = factory.namedNode;\n  parser._namedNode = namedNode;\n  parser._blankNode = factory.blankNode;\n  parser._literal = factory.literal;\n  parser._variable = factory.variable;\n  parser._quad = factory.quad;\n  parser.DEFAULTGRAPH = factory.defaultGraph();\n\n  // Set common named nodes\n  parser.RDF_FIRST = namedNode(namespaces.rdf.first);\n  parser.RDF_REST = namedNode(namespaces.rdf.rest);\n  parser.RDF_NIL = namedNode(namespaces.rdf.nil);\n  parser.N3_FORALL = namedNode(namespaces.r.forAll);\n  parser.N3_FORSOME = namedNode(namespaces.r.forSome);\n  parser.ABBREVIATIONS = {\n    'a': namedNode(namespaces.rdf.type),\n    '=': namedNode(namespaces.owl.sameAs),\n    '>': namedNode(namespaces.log.implies)\n  };\n  parser.QUANTIFIERS_GRAPH = namedNode('urn:n3:quantifiers');\n}\ninitDataFactory(N3Parser.prototype, N3DataFactory);","map":{"version":3,"names":["N3Lexer","N3DataFactory","namespaces","blankNodePrefix","N3Parser","constructor","options","_contextStack","_graph","_setBase","baseIRI","factory","initDataFactory","format","match","toLowerCase","isTurtle","test","isTriG","isNTriples","isNQuads","isN3","_n3Mode","isLineMode","_supportsNamedGraphs","_readPredicateOrNamedGraph","_readPredicate","_supportsQuads","_supportsRDFStar","_resolveRelativeIRI","iri","_blankNodePrefix","replace","_lexer","lexer","lineMode","n3","_explicitQuantifiers","explicitQuantifiers","_resetBlankNodePrefix","_base","_basePath","fragmentPos","indexOf","substr","_baseRoot","_baseScheme","_saveContext","type","graph","subject","predicate","object","n3Mode","push","inverse","_inversePredicate","blankPrefix","_prefixes","_","quantified","_quantified","id","Object","create","_restoreContext","token","context","pop","_error","_subject","_predicate","_object","_readInTopContext","_callback","_sparqlStyle","_readPrefix","_readBaseIRI","_readSubject","_readNamedGraphLabel","_readEntity","quantifier","value","_resolveIRI","_namedNode","prefix","undefined","_blankNode","_variable","_readBlankNodeHead","RDF_NIL","_readListItem","_readPunctuation","N3_FORSOME","_quantifier","_readQuantifierList","N3_FORALL","length","_literalValue","_completeSubjectLiteral","_literal","_getPathReader","ABBREVIATIONS","_readBlankNodeTail","_readObject","_readDataTypeOrLang","_getContextEndReader","_readGraph","_readBlankNodePunctuation","_emit","empty","_readPredicateAfterBlank","item","list","next","previousList","stack","parent","RDF_FIRST","_readListItemDataTypeOrLang","RDF_REST","_completeObjectLiteral","_completeLiteral","literal","datatype","listItem","completed","_readCallback","_readFormulaTail","inversePredicate","_readQuadPunctuation","_prefix","_readPrefixIRI","prefixNode","_prefixCallback","_readDeclarationPunctuation","_readNamedGraphBlankLabel","entity","DEFAULTGRAPH","QUANTIFIERS_GRAPH","_readQuantifierPunctuation","afterPath","_afterPath","_readPath","_readForwardPath","_readBackwardPath","_readRDFStarTailOrGraph","_readRDFStarTail","quad","_quad","contextStack","message","err","Error","line","previousToken","noop","_removeDotSegments","result","i","pathStart","segmentStart","substring","lastIndexOf","parse","input","quadCallback","prefixCallback","quads","error","e","t","tokenize","every","parser","namedNode","blankNode","variable","defaultGraph","rdf","first","rest","nil","r","forAll","forSome","owl","sameAs","log","implies","prototype"],"sources":["G:/To-do-List_App-main/node_modules/n3/src/N3Parser.js"],"sourcesContent":["// **N3Parser** parses N3 documents.\nimport N3Lexer from './N3Lexer';\nimport N3DataFactory from './N3DataFactory';\nimport namespaces from './IRIs';\n\nlet blankNodePrefix = 0;\n\n// ## Constructor\nexport default class N3Parser {\n  constructor(options) {\n    this._contextStack = [];\n    this._graph = null;\n\n    // Set the document IRI\n    options = options || {};\n    this._setBase(options.baseIRI);\n    options.factory && initDataFactory(this, options.factory);\n\n    // Set supported features depending on the format\n    const format = (typeof options.format === 'string') ?\n                 options.format.match(/\\w*$/)[0].toLowerCase() : '',\n        isTurtle = /turtle/.test(format), isTriG = /trig/.test(format),\n        isNTriples = /triple/.test(format), isNQuads = /quad/.test(format),\n        isN3 = this._n3Mode = /n3/.test(format),\n        isLineMode = isNTriples || isNQuads;\n    if (!(this._supportsNamedGraphs = !(isTurtle || isN3)))\n      this._readPredicateOrNamedGraph = this._readPredicate;\n    // Support triples in other graphs\n    this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3);\n    // Support nesting of triples\n    this._supportsRDFStar = format === '' || /star|\\*$/.test(format);\n    // Disable relative IRIs in N-Triples or N-Quads mode\n    if (isLineMode)\n      this._resolveRelativeIRI = iri => { return null; };\n    this._blankNodePrefix = typeof options.blankNodePrefix !== 'string' ? '' :\n                              options.blankNodePrefix.replace(/^(?!_:)/, '_:');\n    this._lexer = options.lexer || new N3Lexer({ lineMode: isLineMode, n3: isN3 });\n    // Disable explicit quantifiers by default\n    this._explicitQuantifiers = !!options.explicitQuantifiers;\n  }\n\n  // ## Static class methods\n\n  // ### `_resetBlankNodePrefix` restarts blank node prefix identification\n  static _resetBlankNodePrefix() {\n    blankNodePrefix = 0;\n  }\n\n  // ## Private methods\n\n  // ### `_setBase` sets the base IRI to resolve relative IRIs\n  _setBase(baseIRI) {\n    if (!baseIRI) {\n      this._base = '';\n      this._basePath = '';\n    }\n    else {\n      // Remove fragment if present\n      const fragmentPos = baseIRI.indexOf('#');\n      if (fragmentPos >= 0)\n        baseIRI = baseIRI.substr(0, fragmentPos);\n      // Set base IRI and its components\n      this._base = baseIRI;\n      this._basePath   = baseIRI.indexOf('/') < 0 ? baseIRI :\n                         baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');\n      baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i);\n      this._baseRoot   = baseIRI[0];\n      this._baseScheme = baseIRI[1];\n    }\n  }\n\n  // ### `_saveContext` stores the current parsing context\n  // when entering a new scope (list, blank node, formula)\n  _saveContext(type, graph, subject, predicate, object) {\n    const n3Mode = this._n3Mode;\n    this._contextStack.push({\n      type,\n      subject, predicate, object, graph,\n      inverse: n3Mode ? this._inversePredicate : false,\n      blankPrefix: n3Mode ? this._prefixes._ : '',\n      quantified: n3Mode ? this._quantified : null,\n    });\n    // The settings below only apply to N3 streams\n    if (n3Mode) {\n      // Every new scope resets the predicate direction\n      this._inversePredicate = false;\n      // In N3, blank nodes are scoped to a formula\n      // (using a dot as separator, as a blank node label cannot start with it)\n      this._prefixes._ = (this._graph ? `${this._graph.id.substr(2)}.` : '.');\n      // Quantifiers are scoped to a formula\n      this._quantified = Object.create(this._quantified);\n    }\n  }\n\n  // ### `_restoreContext` restores the parent context\n  // when leaving a scope (list, blank node, formula)\n  _restoreContext(type, token) {\n    // Obtain the previous context\n    const context = this._contextStack.pop();\n    if (!context || context.type !== type)\n      return this._error(`Unexpected ${token.type}`, token);\n\n    // Restore the quad of the previous context\n    this._subject   = context.subject;\n    this._predicate = context.predicate;\n    this._object    = context.object;\n    this._graph     = context.graph;\n\n    // Restore N3 context settings\n    if (this._n3Mode) {\n      this._inversePredicate = context.inverse;\n      this._prefixes._ = context.blankPrefix;\n      this._quantified = context.quantified;\n    }\n  }\n\n  // ### `_readInTopContext` reads a token when in the top context\n  _readInTopContext(token) {\n    switch (token.type) {\n    // If an EOF token arrives in the top context, signal that we're done\n    case 'eof':\n      if (this._graph !== null)\n        return this._error('Unclosed graph', token);\n      delete this._prefixes._;\n      return this._callback(null, null, this._prefixes);\n    // It could be a prefix declaration\n    case 'PREFIX':\n      this._sparqlStyle = true;\n    case '@prefix':\n      return this._readPrefix;\n    // It could be a base declaration\n    case 'BASE':\n      this._sparqlStyle = true;\n    case '@base':\n      return this._readBaseIRI;\n    // It could be a graph\n    case '{':\n      if (this._supportsNamedGraphs) {\n        this._graph = '';\n        this._subject = null;\n        return this._readSubject;\n      }\n    case 'GRAPH':\n      if (this._supportsNamedGraphs)\n        return this._readNamedGraphLabel;\n    // Otherwise, the next token must be a subject\n    default:\n      return this._readSubject(token);\n    }\n  }\n\n  // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable\n  _readEntity(token, quantifier) {\n    let value;\n    switch (token.type) {\n    // Read a relative or absolute IRI\n    case 'IRI':\n    case 'typeIRI':\n      const iri = this._resolveIRI(token.value);\n      if (iri === null)\n        return this._error('Invalid IRI', token);\n      value = this._namedNode(iri);\n      break;\n    // Read a prefixed name\n    case 'type':\n    case 'prefixed':\n      const prefix = this._prefixes[token.prefix];\n      if (prefix === undefined)\n        return this._error(`Undefined prefix \"${token.prefix}:\"`, token);\n      value = this._namedNode(prefix + token.value);\n      break;\n    // Read a blank node\n    case 'blank':\n      value = this._blankNode(this._prefixes[token.prefix] + token.value);\n      break;\n    // Read a variable\n    case 'var':\n      value = this._variable(token.value.substr(1));\n      break;\n    // Everything else is not an entity\n    default:\n      return this._error(`Expected entity but got ${token.type}`, token);\n    }\n    // In N3 mode, replace the entity if it is quantified\n    if (!quantifier && this._n3Mode && (value.id in this._quantified))\n      value = this._quantified[value.id];\n    return value;\n  }\n\n  // ### `_readSubject` reads a quad's subject\n  _readSubject(token) {\n    this._predicate = null;\n    switch (token.type) {\n    case '[':\n      // Start a new quad with a new blank node as subject\n      this._saveContext('blank', this._graph,\n                        this._subject = this._blankNode(), null, null);\n      return this._readBlankNodeHead;\n    case '(':\n      // Start a new list\n      this._saveContext('list', this._graph, this.RDF_NIL, null, null);\n      this._subject = null;\n      return this._readListItem;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph,\n                        this._graph = this._blankNode(), null, null);\n      return this._readSubject;\n    case '}':\n       // No subject; the graph in which we are reading is closed instead\n      return this._readPunctuation(token);\n    case '@forSome':\n      if (!this._n3Mode)\n        return this._error('Unexpected \"@forSome\"', token);\n      this._subject = null;\n      this._predicate = this.N3_FORSOME;\n      this._quantifier = this._blankNode;\n      return this._readQuantifierList;\n    case '@forAll':\n      if (!this._n3Mode)\n        return this._error('Unexpected \"@forAll\"', token);\n      this._subject = null;\n      this._predicate = this.N3_FORALL;\n      this._quantifier = this._variable;\n      return this._readQuantifierList;\n    case 'literal':\n      if (!this._n3Mode)\n        return this._error('Unexpected literal', token);\n\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        return this._completeSubjectLiteral;\n      }\n      else\n        this._subject = this._literal(token.value, this._namedNode(token.prefix));\n\n      break;\n    case '<<':\n      if (!this._supportsRDFStar)\n        return this._error('Unexpected RDF* syntax', token);\n      this._saveContext('<<', this._graph, null, null, null);\n      this._graph = null;\n      return this._readSubject;\n    default:\n      // Read the subject entity\n      if ((this._subject = this._readEntity(token)) === undefined)\n        return;\n      // In N3 mode, the subject might be a path\n      if (this._n3Mode)\n        return this._getPathReader(this._readPredicateOrNamedGraph);\n    }\n\n    // The next token must be a predicate,\n    // or, if the subject was actually a graph IRI, a named graph\n    return this._readPredicateOrNamedGraph;\n  }\n\n  // ### `_readPredicate` reads a quad's predicate\n  _readPredicate(token) {\n    const type = token.type;\n    switch (type) {\n    case 'inverse':\n      this._inversePredicate = true;\n    case 'abbreviation':\n      this._predicate = this.ABBREVIATIONS[token.value];\n      break;\n    case '.':\n    case ']':\n    case '}':\n      // Expected predicate didn't come, must have been trailing semicolon\n      if (this._predicate === null)\n        return this._error(`Unexpected ${type}`, token);\n      this._subject = null;\n      return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);\n    case ';':\n      // Additional semicolons can be safely ignored\n      return this._predicate !== null ? this._readPredicate :\n             this._error('Expected predicate but got ;', token);\n    case '[':\n      if (this._n3Mode) {\n        // Start a new quad with a new blank node as subject\n        this._saveContext('blank', this._graph, this._subject,\n                          this._subject = this._blankNode(), null);\n        return this._readBlankNodeHead;\n      }\n    case 'blank':\n      if (!this._n3Mode)\n        return this._error('Disallowed blank node as predicate', token);\n    default:\n      if ((this._predicate = this._readEntity(token)) === undefined)\n        return;\n    }\n    // The next token must be an object\n    return this._readObject;\n  }\n\n  // ### `_readObject` reads a quad's object\n  _readObject(token) {\n    switch (token.type) {\n    case 'literal':\n      // Regular literal, can still get a datatype or language\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        return this._readDataTypeOrLang;\n      }\n      // Pre-datatyped string literal (prefix stores the datatype)\n      else\n        this._object = this._literal(token.value, this._namedNode(token.prefix));\n      break;\n    case '[':\n      // Start a new quad with a new blank node as subject\n      this._saveContext('blank', this._graph, this._subject, this._predicate,\n                        this._subject = this._blankNode());\n      return this._readBlankNodeHead;\n    case '(':\n      // Start a new list\n      this._saveContext('list', this._graph, this._subject, this._predicate, this.RDF_NIL);\n      this._subject = null;\n      return this._readListItem;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph, this._subject, this._predicate,\n                        this._graph = this._blankNode());\n      return this._readSubject;\n    case '<<':\n      if (!this._supportsRDFStar)\n        return this._error('Unexpected RDF* syntax', token);\n      this._saveContext('<<', this._graph, this._subject, this._predicate, null);\n      this._graph = null;\n      return this._readSubject;\n    default:\n      // Read the object entity\n      if ((this._object = this._readEntity(token)) === undefined)\n        return;\n      // In N3 mode, the object might be a path\n      if (this._n3Mode)\n        return this._getPathReader(this._getContextEndReader());\n    }\n    return this._getContextEndReader();\n  }\n\n  // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph\n  _readPredicateOrNamedGraph(token) {\n    return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);\n  }\n\n  // ### `_readGraph` reads a graph\n  _readGraph(token) {\n    if (token.type !== '{')\n      return this._error(`Expected graph but got ${token.type}`, token);\n    // The \"subject\" we read is actually the GRAPH's label\n    this._graph = this._subject, this._subject = null;\n    return this._readSubject;\n  }\n\n  // ### `_readBlankNodeHead` reads the head of a blank node\n  _readBlankNodeHead(token) {\n    if (token.type === ']') {\n      this._subject = null;\n      return this._readBlankNodeTail(token);\n    }\n    else {\n      this._predicate = null;\n      return this._readPredicate(token);\n    }\n  }\n\n  // ### `_readBlankNodeTail` reads the end of a blank node\n  _readBlankNodeTail(token) {\n    if (token.type !== ']')\n      return this._readBlankNodePunctuation(token);\n\n    // Store blank node quad\n    if (this._subject !== null)\n      this._emit(this._subject, this._predicate, this._object, this._graph);\n\n    // Restore the parent context containing this blank node\n    const empty = this._predicate === null;\n    this._restoreContext('blank', token);\n    // If the blank node was the object, restore previous context and read punctuation\n    if (this._object !== null)\n      return this._getContextEndReader();\n    // If the blank node was the predicate, continue reading the object\n    else if (this._predicate !== null)\n      return this._readObject;\n    // If the blank node was the subject, continue reading the predicate\n    else\n      // If the blank node was empty, it could be a named graph label\n      return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;\n  }\n\n  // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node\n  _readPredicateAfterBlank(token) {\n    switch (token.type) {\n    case '.':\n    case '}':\n      // No predicate is coming if the triple is terminated here\n      this._subject = null;\n      return this._readPunctuation(token);\n    default:\n      return this._readPredicate(token);\n    }\n  }\n\n  // ### `_readListItem` reads items from a list\n  _readListItem(token) {\n    let item = null,                      // The item of the list\n        list = null,                      // The list itself\n        next = this._readListItem;        // The next function to execute\n    const previousList = this._subject,   // The previous list that contains this list\n        stack = this._contextStack,       // The stack of parent contexts\n        parent = stack[stack.length - 1]; // The parent containing the current list\n\n    switch (token.type) {\n    case '[':\n      // Stack the current list quad and start a new quad with a blank node as subject\n      this._saveContext('blank', this._graph,\n                        list = this._blankNode(), this.RDF_FIRST,\n                        this._subject = item = this._blankNode());\n      next = this._readBlankNodeHead;\n      break;\n    case '(':\n      // Stack the current list quad and start a new list\n      this._saveContext('list', this._graph,\n                        list = this._blankNode(), this.RDF_FIRST, this.RDF_NIL);\n      this._subject = null;\n      break;\n    case ')':\n      // Closing the list; restore the parent context\n      this._restoreContext('list', token);\n      // If this list is contained within a parent list, return the membership quad here.\n      // This will be `<parent list element> rdf:first <this list>.`.\n      if (stack.length !== 0 && stack[stack.length - 1].type === 'list')\n        this._emit(this._subject, this._predicate, this._object, this._graph);\n      // Was this list the parent's subject?\n      if (this._predicate === null) {\n        // The next token is the predicate\n        next = this._readPredicate;\n        // No list tail if this was an empty list\n        if (this._subject === this.RDF_NIL)\n          return next;\n      }\n      // The list was in the parent context's object\n      else {\n        next = this._getContextEndReader();\n        // No list tail if this was an empty list\n        if (this._object === this.RDF_NIL)\n          return next;\n      }\n      // Close the list by making the head nil\n      list = this.RDF_NIL;\n      break;\n    case 'literal':\n      // Regular literal, can still get a datatype or language\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        next = this._readListItemDataTypeOrLang;\n      }\n      // Pre-datatyped string literal (prefix stores the datatype)\n      else {\n        item = this._literal(token.value, this._namedNode(token.prefix));\n        next = this._getContextEndReader();\n      }\n      break;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph, this._subject, this._predicate,\n                        this._graph = this._blankNode());\n      return this._readSubject;\n    default:\n      if ((item = this._readEntity(token)) === undefined)\n        return;\n    }\n\n     // Create a new blank node if no item head was assigned yet\n    if (list === null)\n      this._subject = list = this._blankNode();\n\n    // Is this the first element of the list?\n    if (previousList === null) {\n      // This list is either the subject or the object of its parent\n      if (parent.predicate === null)\n        parent.subject = list;\n      else\n        parent.object = list;\n    }\n    else {\n      // Continue the previous list with the current list\n      this._emit(previousList, this.RDF_REST, list, this._graph);\n    }\n    // If an item was read, add it to the list\n    if (item !== null) {\n      // In N3 mode, the item might be a path\n      if (this._n3Mode && (token.type === 'IRI' || token.type === 'prefixed')) {\n        // Create a new context to add the item's path\n        this._saveContext('item', this._graph, list, this.RDF_FIRST, item);\n        this._subject = item, this._predicate = null;\n        // _readPath will restore the context and output the item\n        return this._getPathReader(this._readListItem);\n      }\n      // Output the item\n      this._emit(list, this.RDF_FIRST, item, this._graph);\n    }\n    return next;\n  }\n\n  // ### `_readDataTypeOrLang` reads an _optional_ datatype or language\n  _readDataTypeOrLang(token) {\n    return this._completeObjectLiteral(token, false);\n  }\n\n\n  // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list\n  _readListItemDataTypeOrLang(token) {\n    return this._completeObjectLiteral(token, true);\n  }\n\n  // ### `_completeLiteral` completes a literal with an optional datatype or language\n  _completeLiteral(token) {\n    // Create a simple string literal by default\n    let literal = this._literal(this._literalValue);\n\n    switch (token.type) {\n    // Create a datatyped literal\n    case 'type':\n    case 'typeIRI':\n      const datatype = this._readEntity(token);\n      if (datatype === undefined) return; // No datatype means an error occurred\n      literal = this._literal(this._literalValue, datatype);\n      token = null;\n      break;\n    // Create a language-tagged string\n    case 'langcode':\n      literal = this._literal(this._literalValue, token.value);\n      token = null;\n      break;\n    }\n\n    return { token, literal };\n  }\n\n  // Completes a literal in subject position\n  _completeSubjectLiteral(token) {\n    this._subject = this._completeLiteral(token).literal;\n    return this._readPredicateOrNamedGraph;\n  }\n\n  // Completes a literal in object position\n  _completeObjectLiteral(token, listItem) {\n    const completed = this._completeLiteral(token);\n    if (!completed)\n      return;\n    this._object = completed.literal;\n\n    // If this literal was part of a list, write the item\n    // (we could also check the context stack, but passing in a flag is faster)\n    if (listItem)\n      this._emit(this._subject, this.RDF_FIRST, this._object, this._graph);\n    // If the token was consumed, continue with the rest of the input\n    if (completed.token === null)\n      return this._getContextEndReader();\n    // Otherwise, consume the token now\n    else {\n      this._readCallback = this._getContextEndReader();\n      return this._readCallback(completed.token);\n    }\n  }\n\n  // ### `_readFormulaTail` reads the end of a formula\n  _readFormulaTail(token) {\n    if (token.type !== '}')\n      return this._readPunctuation(token);\n\n    // Store the last quad of the formula\n    if (this._subject !== null)\n      this._emit(this._subject, this._predicate, this._object, this._graph);\n\n    // Restore the parent context containing this formula\n    this._restoreContext('formula', token);\n    // If the formula was the subject, continue reading the predicate.\n    // If the formula was the object, read punctuation.\n    return this._object === null ? this._readPredicate : this._getContextEndReader();\n  }\n\n  // ### `_readPunctuation` reads punctuation between quads or quad parts\n  _readPunctuation(token) {\n    let next, graph = this._graph;\n    const subject = this._subject, inversePredicate = this._inversePredicate;\n    switch (token.type) {\n    // A closing brace ends a graph\n    case '}':\n      if (this._graph === null)\n        return this._error('Unexpected graph closing', token);\n      if (this._n3Mode)\n        return this._readFormulaTail(token);\n      this._graph = null;\n    // A dot just ends the statement, without sharing anything with the next\n    case '.':\n      this._subject = null;\n      next = this._contextStack.length ? this._readSubject : this._readInTopContext;\n      if (inversePredicate) this._inversePredicate = false;\n      break;\n    // Semicolon means the subject is shared; predicate and object are different\n    case ';':\n      next = this._readPredicate;\n      break;\n    // Comma means both the subject and predicate are shared; the object is different\n    case ',':\n      next = this._readObject;\n      break;\n    default:\n      // An entity means this is a quad (only allowed if not already inside a graph)\n      if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== undefined) {\n        next = this._readQuadPunctuation;\n        break;\n      }\n      return this._error(`Expected punctuation to follow \"${this._object.id}\"`, token);\n    }\n    // A quad has been completed now, so return it\n    if (subject !== null) {\n      const predicate = this._predicate, object = this._object;\n      if (!inversePredicate)\n        this._emit(subject, predicate, object,  graph);\n      else\n        this._emit(object,  predicate, subject, graph);\n    }\n    return next;\n  }\n\n    // ### `_readBlankNodePunctuation` reads punctuation in a blank node\n  _readBlankNodePunctuation(token) {\n    let next;\n    switch (token.type) {\n    // Semicolon means the subject is shared; predicate and object are different\n    case ';':\n      next = this._readPredicate;\n      break;\n    // Comma means both the subject and predicate are shared; the object is different\n    case ',':\n      next = this._readObject;\n      break;\n    default:\n      return this._error(`Expected punctuation to follow \"${this._object.id}\"`, token);\n    }\n    // A quad has been completed now, so return it\n    this._emit(this._subject, this._predicate, this._object, this._graph);\n    return next;\n  }\n\n  // ### `_readQuadPunctuation` reads punctuation after a quad\n  _readQuadPunctuation(token) {\n    if (token.type !== '.')\n      return this._error('Expected dot to follow quad', token);\n    return this._readInTopContext;\n  }\n\n  // ### `_readPrefix` reads the prefix of a prefix declaration\n  _readPrefix(token) {\n    if (token.type !== 'prefix')\n      return this._error('Expected prefix to follow @prefix', token);\n    this._prefix = token.value;\n    return this._readPrefixIRI;\n  }\n\n  // ### `_readPrefixIRI` reads the IRI of a prefix declaration\n  _readPrefixIRI(token) {\n    if (token.type !== 'IRI')\n      return this._error(`Expected IRI to follow prefix \"${this._prefix}:\"`, token);\n    const prefixNode = this._readEntity(token);\n    this._prefixes[this._prefix] = prefixNode.value;\n    this._prefixCallback(this._prefix, prefixNode);\n    return this._readDeclarationPunctuation;\n  }\n\n  // ### `_readBaseIRI` reads the IRI of a base declaration\n  _readBaseIRI(token) {\n    const iri = token.type === 'IRI' && this._resolveIRI(token.value);\n    if (!iri)\n      return this._error('Expected valid IRI to follow base declaration', token);\n    this._setBase(iri);\n    return this._readDeclarationPunctuation;\n  }\n\n  // ### `_readNamedGraphLabel` reads the label of a named graph\n  _readNamedGraphLabel(token) {\n    switch (token.type) {\n    case 'IRI':\n    case 'blank':\n    case 'prefixed':\n      return this._readSubject(token), this._readGraph;\n    case '[':\n      return this._readNamedGraphBlankLabel;\n    default:\n      return this._error('Invalid graph label', token);\n    }\n  }\n\n  // ### `_readNamedGraphLabel` reads a blank node label of a named graph\n  _readNamedGraphBlankLabel(token) {\n    if (token.type !== ']')\n      return this._error('Invalid graph label', token);\n    this._subject = this._blankNode();\n    return this._readGraph;\n  }\n\n  // ### `_readDeclarationPunctuation` reads the punctuation of a declaration\n  _readDeclarationPunctuation(token) {\n    // SPARQL-style declarations don't have punctuation\n    if (this._sparqlStyle) {\n      this._sparqlStyle = false;\n      return this._readInTopContext(token);\n    }\n\n    if (token.type !== '.')\n      return this._error('Expected declaration to end with a dot', token);\n    return this._readInTopContext;\n  }\n\n  // Reads a list of quantified symbols from a @forSome or @forAll statement\n  _readQuantifierList(token) {\n    let entity;\n    switch (token.type) {\n    case 'IRI':\n    case 'prefixed':\n      if ((entity = this._readEntity(token, true)) !== undefined)\n        break;\n    default:\n      return this._error(`Unexpected ${token.type}`, token);\n    }\n    // Without explicit quantifiers, map entities to a quantified entity\n    if (!this._explicitQuantifiers)\n      this._quantified[entity.id] = this._quantifier(this._blankNode().value);\n    // With explicit quantifiers, output the reified quantifier\n    else {\n      // If this is the first item, start a new quantifier list\n      if (this._subject === null)\n        this._emit(this._graph || this.DEFAULTGRAPH, this._predicate,\n                   this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);\n      // Otherwise, continue the previous list\n      else\n        this._emit(this._subject, this.RDF_REST,\n                   this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);\n      // Output the list item\n      this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);\n    }\n    return this._readQuantifierPunctuation;\n  }\n\n  // Reads punctuation from a @forSome or @forAll statement\n  _readQuantifierPunctuation(token) {\n    // Read more quantifiers\n    if (token.type === ',')\n      return this._readQuantifierList;\n    // End of the quantifier list\n    else {\n      // With explicit quantifiers, close the quantifier list\n      if (this._explicitQuantifiers) {\n        this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);\n        this._subject = null;\n      }\n      // Read a dot\n      this._readCallback = this._getContextEndReader();\n      return this._readCallback(token);\n    }\n  }\n\n  // ### `_getPathReader` reads a potential path and then resumes with the given function\n  _getPathReader(afterPath) {\n    this._afterPath = afterPath;\n    return this._readPath;\n  }\n\n  // ### `_readPath` reads a potential path\n  _readPath(token) {\n    switch (token.type) {\n    // Forward path\n    case '!': return this._readForwardPath;\n    // Backward path\n    case '^': return this._readBackwardPath;\n    // Not a path; resume reading where we left off\n    default:\n      const stack = this._contextStack, parent = stack.length && stack[stack.length - 1];\n      // If we were reading a list item, we still need to output it\n      if (parent && parent.type === 'item') {\n        // The list item is the remaining subejct after reading the path\n        const item = this._subject;\n        // Switch back to the context of the list\n        this._restoreContext('item', token);\n        // Output the list item\n        this._emit(this._subject, this.RDF_FIRST, item, this._graph);\n      }\n      return this._afterPath(token);\n    }\n  }\n\n  // ### `_readForwardPath` reads a '!' path\n  _readForwardPath(token) {\n    let subject, predicate;\n    const object = this._blankNode();\n    // The next token is the predicate\n    if ((predicate = this._readEntity(token)) === undefined)\n      return;\n    // If we were reading a subject, replace the subject by the path's object\n    if (this._predicate === null)\n      subject = this._subject, this._subject = object;\n    // If we were reading an object, replace the subject by the path's object\n    else\n      subject = this._object,  this._object  = object;\n    // Emit the path's current quad and read its next section\n    this._emit(subject, predicate, object, this._graph);\n    return this._readPath;\n  }\n\n  // ### `_readBackwardPath` reads a '^' path\n  _readBackwardPath(token) {\n    const subject = this._blankNode();\n    let predicate, object;\n    // The next token is the predicate\n    if ((predicate = this._readEntity(token)) === undefined)\n      return;\n    // If we were reading a subject, replace the subject by the path's subject\n    if (this._predicate === null)\n      object = this._subject, this._subject = subject;\n    // If we were reading an object, replace the subject by the path's subject\n    else\n      object = this._object,  this._object  = subject;\n    // Emit the path's current quad and read its next section\n    this._emit(subject, predicate, object, this._graph);\n    return this._readPath;\n  }\n\n  // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF* quad or the end of a nested RDF* triple\n  _readRDFStarTailOrGraph(token) {\n    if (token.type !== '>>') {\n      // An entity means this is a quad (only allowed if not already inside a graph)\n      if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== undefined)\n        return this._readRDFStarTail;\n      return this._error(`Expected >> to follow \"${this._object.id}\"`, token);\n    }\n    return this._readRDFStarTail(token);\n  }\n\n  // ### `_readRDFStarTail` reads the end of a nested RDF* triple\n  _readRDFStarTail(token) {\n    if (token.type !== '>>')\n      return this._error(`Expected >> but got ${token.type}`, token);\n    // Read the quad and restore the previous context\n    const quad = this._quad(this._subject, this._predicate, this._object,\n      this._graph || this.DEFAULTGRAPH);\n    this._restoreContext('<<', token);\n    // If the triple was the subject, continue by reading the predicate.\n    if (this._subject === null) {\n      this._subject = quad;\n      return this._readPredicate;\n    }\n    // If the triple was the object, read context end.\n    else {\n      this._object = quad;\n      return this._getContextEndReader();\n    }\n  }\n\n  // ### `_getContextEndReader` gets the next reader function at the end of a context\n  _getContextEndReader() {\n    const contextStack = this._contextStack;\n    if (!contextStack.length)\n      return this._readPunctuation;\n\n    switch (contextStack[contextStack.length - 1].type) {\n    case 'blank':\n      return this._readBlankNodeTail;\n    case 'list':\n      return this._readListItem;\n    case 'formula':\n      return this._readFormulaTail;\n    case '<<':\n      return this._readRDFStarTailOrGraph;\n    }\n  }\n\n  // ### `_emit` sends a quad through the callback\n  _emit(subject, predicate, object, graph) {\n    this._callback(null, this._quad(subject, predicate, object, graph || this.DEFAULTGRAPH));\n  }\n\n  // ### `_error` emits an error message through the callback\n  _error(message, token) {\n    const err = new Error(`${message} on line ${token.line}.`);\n    err.context = {\n      token: token,\n      line: token.line,\n      previousToken: this._lexer.previousToken,\n    };\n    this._callback(err);\n    this._callback = noop;\n  }\n\n  // ### `_resolveIRI` resolves an IRI against the base path\n  _resolveIRI(iri) {\n    return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);\n  }\n\n  // ### `_resolveRelativeIRI` resolves an IRI against the base path,\n  // assuming that a base path has been set and that the IRI is indeed relative\n  _resolveRelativeIRI(iri) {\n    // An empty relative IRI indicates the base IRI\n    if (!iri.length)\n      return this._base;\n    // Decide resolving strategy based in the first character\n    switch (iri[0]) {\n    // Resolve relative fragment IRIs against the base IRI\n    case '#': return this._base + iri;\n    // Resolve relative query string IRIs by replacing the query string\n    case '?': return this._base.replace(/(?:\\?.*)?$/, iri);\n    // Resolve root-relative IRIs at the root of the base IRI\n    case '/':\n      // Resolve scheme-relative IRIs to the scheme\n      return (iri[1] === '/' ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);\n    // Resolve all other IRIs at the base IRI's path\n    default:\n      // Relative IRIs cannot contain a colon in the first path segment\n      return (/^[^/:]*:/.test(iri)) ? null : this._removeDotSegments(this._basePath + iri);\n    }\n  }\n\n  // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986\n  _removeDotSegments(iri) {\n    // Don't modify the IRI if it does not contain any dot segments\n    if (!/(^|\\/)\\.\\.?($|[/#?])/.test(iri))\n      return iri;\n\n    // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n    const length = iri.length;\n    let result = '', i = -1, pathStart = -1, segmentStart = 0, next = '/';\n\n    while (i < length) {\n      switch (next) {\n      // The path starts with the first slash after the authority\n      case ':':\n        if (pathStart < 0) {\n          // Skip two slashes before the authority\n          if (iri[++i] === '/' && iri[++i] === '/')\n            // Skip to slash after the authority\n            while ((pathStart = i + 1) < length && iri[pathStart] !== '/')\n              i = pathStart;\n        }\n        break;\n      // Don't modify a query string or fragment\n      case '?':\n      case '#':\n        i = length;\n        break;\n      // Handle '/.' or '/..' path segments\n      case '/':\n        if (iri[i + 1] === '.') {\n          next = iri[++i + 1];\n          switch (next) {\n          // Remove a '/.' segment\n          case '/':\n            result += iri.substring(segmentStart, i - 1);\n            segmentStart = i + 1;\n            break;\n          // Remove a trailing '/.' segment\n          case undefined:\n          case '?':\n          case '#':\n            return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n          // Remove a '/..' segment\n          case '.':\n            next = iri[++i + 1];\n            if (next === undefined || next === '/' || next === '?' || next === '#') {\n              result += iri.substring(segmentStart, i - 2);\n              // Try to remove the parent path from result\n              if ((segmentStart = result.lastIndexOf('/')) >= pathStart)\n                result = result.substr(0, segmentStart);\n              // Remove a trailing '/..' segment\n              if (next !== '/')\n                return `${result}/${iri.substr(i + 1)}`;\n              segmentStart = i + 1;\n            }\n          }\n        }\n      }\n      next = iri[++i];\n    }\n    return result + iri.substring(segmentStart);\n  }\n\n  // ## Public methods\n\n  // ### `parse` parses the N3 input and emits each parsed quad through the callback\n  parse(input, quadCallback, prefixCallback) {\n    // The read callback is the next function to be executed when a token arrives.\n    // We start reading in the top context.\n    this._readCallback = this._readInTopContext;\n    this._sparqlStyle = false;\n    this._prefixes = Object.create(null);\n    this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2)\n                                             : `b${blankNodePrefix++}_`;\n    this._prefixCallback = prefixCallback || noop;\n    this._inversePredicate = false;\n    this._quantified = Object.create(null);\n\n    // Parse synchronously if no quad callback is given\n    if (!quadCallback) {\n      const quads = [];\n      let error;\n      this._callback = (e, t) => { e ? (error = e) : t && quads.push(t); };\n      this._lexer.tokenize(input).every(token => {\n        return this._readCallback = this._readCallback(token);\n      });\n      if (error) throw error;\n      return quads;\n    }\n\n    // Parse asynchronously otherwise, executing the read callback when a token arrives\n    this._callback = quadCallback;\n    this._lexer.tokenize(input, (error, token) => {\n      if (error !== null)\n        this._callback(error), this._callback = noop;\n      else if (this._readCallback)\n        this._readCallback = this._readCallback(token);\n    });\n  }\n}\n\n// The empty function\nfunction noop() {}\n\n// Initializes the parser with the given data factory\nfunction initDataFactory(parser, factory) {\n  // Set factory methods\n  const namedNode = factory.namedNode;\n  parser._namedNode   = namedNode;\n  parser._blankNode   = factory.blankNode;\n  parser._literal     = factory.literal;\n  parser._variable    = factory.variable;\n  parser._quad        = factory.quad;\n  parser.DEFAULTGRAPH = factory.defaultGraph();\n\n  // Set common named nodes\n  parser.RDF_FIRST  = namedNode(namespaces.rdf.first);\n  parser.RDF_REST   = namedNode(namespaces.rdf.rest);\n  parser.RDF_NIL    = namedNode(namespaces.rdf.nil);\n  parser.N3_FORALL  = namedNode(namespaces.r.forAll);\n  parser.N3_FORSOME = namedNode(namespaces.r.forSome);\n  parser.ABBREVIATIONS = {\n    'a': namedNode(namespaces.rdf.type),\n    '=': namedNode(namespaces.owl.sameAs),\n    '>': namedNode(namespaces.log.implies),\n  };\n  parser.QUANTIFIERS_GRAPH = namedNode('urn:n3:quantifiers');\n}\ninitDataFactory(N3Parser.prototype, N3DataFactory);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}