{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _classCallCheck = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i;\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/;\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g;\nvar DELIMITER_PATTERN = /[;,\"]/;\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/;\n\n/**\n * Token character pattern\n * @type {RegExp}\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nvar TOKEN_PATTERN = /^[!#$%&'*+\\-\\.^_`|~\\da-zA-Z]+$/;\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2\n};\nfunction trim(value) {\n  return value.replace(WS_TRIM_PATTERN, '');\n}\nfunction hasWhitespace(value) {\n  return WS_CHAR_PATTERN.test(value);\n}\nfunction skipWhitespace(value, offset) {\n  while (hasWhitespace(value[offset])) {\n    offset++;\n  }\n  return offset;\n}\nfunction needsQuotes(value) {\n  return WS_DELIMITER_PATTERN.test(value) || !TOKEN_PATTERN.test(value);\n}\n\n/**\n * Shallow compares two objects to check if their properties match.\n * @param {object} object1 First object to compare.\n * @param {object} object2 Second object to compare.\n * @returns {boolean} Do the objects have matching properties.\n */\nfunction shallowCompareObjects(object1, object2) {\n  return Object.keys(object1).length === Object.keys(object2).length && Object.keys(object1).every(function (key) {\n    return key in object2 && object1[key] === object2[key];\n  });\n}\nvar Link = /*#__PURE__*/function () {\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  function Link(value) {\n    _classCallCheck(this, Link);\n    /** @type {Array} URI references */\n    this.refs = [];\n    if (value) {\n      this.parse(value);\n    }\n  }\n\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  _createClass(Link, [{\n    key: \"rel\",\n    value: function rel(value) {\n      var links = [];\n      var type = value.toLowerCase();\n      for (var i = 0; i < this.refs.length; i++) {\n        if (this.refs[i].rel.toLowerCase() === type) {\n          links.push(this.refs[i]);\n        }\n      }\n      return links;\n    }\n\n    /**\n     * Get refs where given attribute has a given value\n     * @param {String} attr\n     * @param {String} value\n     * @returns {Array<Object>}\n     */\n  }, {\n    key: \"get\",\n    value: function get(attr, value) {\n      attr = attr.toLowerCase();\n      var links = [];\n      for (var i = 0; i < this.refs.length; i++) {\n        if (this.refs[i][attr] === value) {\n          links.push(this.refs[i]);\n        }\n      }\n      return links;\n    }\n\n    /** Sets a reference. */\n  }, {\n    key: \"set\",\n    value: function set(link) {\n      this.refs.push(link);\n      return this;\n    }\n\n    /**\n     * Sets a reference if a reference with similar properties isn’t already set.\n     */\n  }, {\n    key: \"setUnique\",\n    value: function setUnique(link) {\n      if (!this.refs.some(function (ref) {\n        return shallowCompareObjects(ref, link);\n      })) {\n        this.refs.push(link);\n      }\n      return this;\n    }\n  }, {\n    key: \"has\",\n    value: function has(attr, value) {\n      attr = attr.toLowerCase();\n      for (var i = 0; i < this.refs.length; i++) {\n        if (this.refs[i][attr] === value) {\n          return true;\n        }\n      }\n      return false;\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(value, offset) {\n      offset = offset || 0;\n      value = offset ? value.slice(offset) : value;\n\n      // Trim & unfold folded lines\n      value = trim(value).replace(WS_FOLD_PATTERN, '');\n      var state = STATE.IDLE;\n      var length = value.length;\n      var offset = 0;\n      var ref = null;\n      while (offset < length) {\n        if (state === STATE.IDLE) {\n          if (hasWhitespace(value[offset])) {\n            offset++;\n            continue;\n          } else if (value[offset] === '<') {\n            if (ref != null) {\n              var _this$refs;\n              ref.rel != null ? (_this$refs = this.refs).push.apply(_this$refs, _toConsumableArray(Link.expandRelations(ref))) : this.refs.push(ref);\n            }\n            var end = value.indexOf('>', offset);\n            if (end === -1) throw new Error('Expected end of URI delimiter at offset ' + offset);\n            ref = {\n              uri: value.slice(offset + 1, end)\n            };\n            // this.refs.push( ref )\n            offset = end;\n            state = STATE.URI;\n          } else {\n            throw new Error('Unexpected character \"' + value[offset] + '\" at offset ' + offset);\n          }\n          offset++;\n        } else if (state === STATE.URI) {\n          if (hasWhitespace(value[offset])) {\n            offset++;\n            continue;\n          } else if (value[offset] === ';') {\n            state = STATE.ATTR;\n            offset++;\n          } else if (value[offset] === ',') {\n            state = STATE.IDLE;\n            offset++;\n          } else {\n            throw new Error('Unexpected character \"' + value[offset] + '\" at offset ' + offset);\n          }\n        } else if (state === STATE.ATTR) {\n          if (value[offset] === ';' || hasWhitespace(value[offset])) {\n            offset++;\n            continue;\n          }\n          var end = value.indexOf('=', offset);\n          if (end === -1) throw new Error('Expected attribute delimiter at offset ' + offset);\n          var attr = trim(value.slice(offset, end)).toLowerCase();\n          var attrValue = '';\n          offset = end + 1;\n          offset = skipWhitespace(value, offset);\n          if (value[offset] === '\"') {\n            offset++;\n            while (offset < length) {\n              if (value[offset] === '\"') {\n                offset++;\n                break;\n              }\n              if (value[offset] === '\\\\') {\n                offset++;\n              }\n              attrValue += value[offset];\n              offset++;\n            }\n          } else {\n            var end = offset + 1;\n            while (!DELIMITER_PATTERN.test(value[end]) && end < length) {\n              end++;\n            }\n            attrValue = value.slice(offset, end);\n            offset = end;\n          }\n          if (ref[attr] && Link.isSingleOccurenceAttr(attr)) {\n            // Ignore multiples of attributes which may only appear once\n          } else if (attr[attr.length - 1] === '*') {\n            ref[attr] = Link.parseExtendedValue(attrValue);\n          } else {\n            attrValue = attr === 'type' ? attrValue.toLowerCase() : attrValue;\n            if (ref[attr] != null) {\n              if (Array.isArray(ref[attr])) {\n                ref[attr].push(attrValue);\n              } else {\n                ref[attr] = [ref[attr], attrValue];\n              }\n            } else {\n              ref[attr] = attrValue;\n            }\n          }\n          switch (value[offset]) {\n            case ',':\n              state = STATE.IDLE;\n              break;\n            case ';':\n              state = STATE.ATTR;\n              break;\n          }\n          offset++;\n        } else {\n          throw new Error('Unknown parser state \"' + state + '\"');\n        }\n      }\n      if (ref != null) {\n        var _this$refs2;\n        ref.rel != null ? (_this$refs2 = this.refs).push.apply(_this$refs2, _toConsumableArray(Link.expandRelations(ref))) : this.refs.push(ref);\n      }\n      ref = null;\n      return this;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var refs = [];\n      var link = '';\n      var ref = null;\n      for (var i = 0; i < this.refs.length; i++) {\n        ref = this.refs[i];\n        link = Object.keys(this.refs[i]).reduce(function (link, attr) {\n          if (attr === 'uri') return link;\n          return link + '; ' + Link.formatAttribute(attr, ref[attr]);\n        }, '<' + ref.uri + '>');\n        refs.push(link);\n      }\n      return refs.join(', ');\n    }\n  }]);\n  return Link;\n}();\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\nLink.isCompatibleEncoding = function (value) {\n  return COMPATIBLE_ENCODING_PATTERN.test(value);\n};\nLink.parse = function (value, offset) {\n  return new Link().parse(value, offset);\n};\nLink.isSingleOccurenceAttr = function (attr) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' || attr === 'title' || attr === 'title*';\n};\nLink.isTokenAttr = function (attr) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor';\n};\nLink.escapeQuotes = function (value) {\n  return value.replace(/\"/g, '\\\\\"');\n};\nLink.expandRelations = function (ref) {\n  var rels = ref.rel.split(' ');\n  return rels.map(function (rel) {\n    var value = Object.assign({}, ref);\n    value.rel = rel;\n    return value;\n  });\n};\n\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\nLink.parseExtendedValue = function (value) {\n  var parts = /([^']+)?(?:'([^']*)')?(.+)/.exec(value);\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding(parts[1]) ? null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding(parts[1]) ? decodeURIComponent(parts[3]) : parts[3]\n  };\n};\n\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\nLink.formatExtendedAttribute = function (attr, data) {\n  var encoding = (data.encoding || 'utf-8').toUpperCase();\n  var language = data.language || 'en';\n  var encodedValue = '';\n  if (Buffer.isBuffer(data.value) && Link.isCompatibleEncoding(encoding)) {\n    encodedValue = data.value.toString(encoding);\n  } else if (Buffer.isBuffer(data.value)) {\n    encodedValue = data.value.toString('hex').replace(/[0-9a-f]{2}/gi, '%$1');\n  } else {\n    encodedValue = encodeURIComponent(data.value);\n  }\n  return attr + '=' + encoding + '\\'' + language + '\\'' + encodedValue;\n};\n\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\nLink.formatAttribute = function (attr, value) {\n  if (Array.isArray(value)) {\n    return value.map(function (item) {\n      return Link.formatAttribute(attr, item);\n    }).join('; ');\n  }\n  if (attr[attr.length - 1] === '*' || typeof value !== 'string') {\n    return Link.formatExtendedAttribute(attr, value);\n  }\n  if (Link.isTokenAttr(attr)) {\n    value = needsQuotes(value) ? '\"' + Link.escapeQuotes(value) + '\"' : Link.escapeQuotes(value);\n  } else if (needsQuotes(value)) {\n    value = encodeURIComponent(value);\n    // We don't need to escape <SP> <,> <;> within quotes\n    value = value.replace(/%20/g, ' ').replace(/%2C/g, ',').replace(/%3B/g, ';');\n    value = '\"' + value + '\"';\n  }\n  return attr + '=' + value;\n};\nmodule.exports = Link;","map":{"version":3,"names":["COMPATIBLE_ENCODING_PATTERN","WS_TRIM_PATTERN","WS_CHAR_PATTERN","WS_FOLD_PATTERN","DELIMITER_PATTERN","WS_DELIMITER_PATTERN","TOKEN_PATTERN","STATE","IDLE","URI","ATTR","trim","value","replace","hasWhitespace","test","skipWhitespace","offset","needsQuotes","shallowCompareObjects","object1","object2","Object","keys","length","every","key","Link","refs","parse","links","type","toLowerCase","i","rel","push","attr","link","some","ref","slice","state","expandRelations","end","indexOf","Error","uri","attrValue","isSingleOccurenceAttr","parseExtendedValue","Array","isArray","reduce","formatAttribute","join","isCompatibleEncoding","isTokenAttr","escapeQuotes","rels","split","map","assign","parts","exec","language","encoding","decodeURIComponent","formatExtendedAttribute","data","toUpperCase","encodedValue","Buffer","isBuffer","toString","encodeURIComponent","item","module","exports"],"sources":["E:/react-todo-app/node_modules/http-link-header/lib/link.js"],"sourcesContent":["'use strict'\n\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g\nvar DELIMITER_PATTERN = /[;,\"]/\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/\n\n/**\n * Token character pattern\n * @type {RegExp}\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nvar TOKEN_PATTERN = /^[!#$%&'*+\\-\\.^_`|~\\da-zA-Z]+$/\n\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2,\n}\n\nfunction trim( value ) {\n  return value.replace( WS_TRIM_PATTERN, '' )\n}\n\nfunction hasWhitespace( value ) {\n  return WS_CHAR_PATTERN.test( value )\n}\n\nfunction skipWhitespace( value, offset ) {\n  while( hasWhitespace( value[offset] ) ) {\n    offset++\n  }\n  return offset\n}\n\nfunction needsQuotes( value ) {\n  return WS_DELIMITER_PATTERN.test( value ) ||\n    !TOKEN_PATTERN.test( value )\n}\n\n/**\n * Shallow compares two objects to check if their properties match.\n * @param {object} object1 First object to compare.\n * @param {object} object2 Second object to compare.\n * @returns {boolean} Do the objects have matching properties.\n */\nfunction shallowCompareObjects( object1, object2 ) {\n  return (\n    Object.keys( object1 ).length === Object.keys( object2 ).length &&\n    Object.keys( object1 ).every(\n      ( key ) => key in object2 && object1[ key ] === object2[ key ]\n    )\n  );\n}\n\nclass Link {\n\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  constructor( value ) {\n\n    /** @type {Array} URI references */\n    this.refs = []\n\n    if( value ) {\n      this.parse( value )\n    }\n\n  }\n\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  rel( value ) {\n\n    var links = []\n    var type = value.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ].rel.toLowerCase() === type ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /**\n   * Get refs where given attribute has a given value\n   * @param {String} attr\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  get( attr, value ) {\n\n    attr = attr.toLowerCase()\n\n    var links = []\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ][ attr ] === value ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /** Sets a reference. */\n  set( link ) {\n    this.refs.push( link )\n    return this\n  }\n\n  /**\n   * Sets a reference if a reference with similar properties isn’t already set.\n   */\n  setUnique( link ) {\n\n    if( !this.refs.some(( ref ) => shallowCompareObjects( ref, link )) ) {\n      this.refs.push( link )\n    }\n\n    return this\n\n  }\n\n  has( attr, value ) {\n\n    attr = attr.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ][ attr ] === value ) {\n        return true\n      }\n    }\n\n    return false\n\n  }\n\n  parse( value, offset ) {\n\n    offset = offset || 0\n    value = offset ? value.slice( offset ) : value\n\n    // Trim & unfold folded lines\n    value = trim( value ).replace( WS_FOLD_PATTERN, '' )\n\n    var state = STATE.IDLE\n    var length = value.length\n    var offset = 0\n    var ref = null\n\n    while( offset < length ) {\n      if( state === STATE.IDLE ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === '<' ) {\n          if( ref != null ) {\n            ref.rel != null ?\n              this.refs.push( ...Link.expandRelations( ref ) ) :\n              this.refs.push( ref )\n          }\n          var end = value.indexOf( '>', offset )\n          if( end === -1 ) throw new Error( 'Expected end of URI delimiter at offset ' + offset )\n          ref = { uri: value.slice( offset + 1, end ) }\n          // this.refs.push( ref )\n          offset = end\n          state = STATE.URI\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n        offset++\n      } else if( state === STATE.URI ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === ';' ) {\n          state = STATE.ATTR\n          offset++\n        } else if( value[offset] === ',' ) {\n          state = STATE.IDLE\n          offset++\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n      } else if( state === STATE.ATTR ) {\n        if( value[offset] ===';' || hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        }\n        var end = value.indexOf( '=', offset )\n        if( end === -1 ) throw new Error( 'Expected attribute delimiter at offset ' + offset )\n        var attr = trim( value.slice( offset, end ) ).toLowerCase()\n        var attrValue = ''\n        offset = end + 1\n        offset = skipWhitespace( value, offset )\n        if( value[offset] === '\"' ) {\n          offset++\n          while( offset < length ) {\n            if( value[offset] === '\"' ) {\n              offset++; break\n            }\n            if( value[offset] === '\\\\' ) {\n              offset++\n            }\n            attrValue += value[offset]\n            offset++\n          }\n        } else {\n          var end = offset + 1\n          while( !DELIMITER_PATTERN.test( value[end] ) && end < length ) {\n            end++\n          }\n          attrValue = value.slice( offset, end )\n          offset = end\n        }\n        if( ref[ attr ] && Link.isSingleOccurenceAttr( attr ) ) {\n          // Ignore multiples of attributes which may only appear once\n        } else if( attr[ attr.length - 1 ] === '*' ) {\n          ref[ attr ] = Link.parseExtendedValue( attrValue )\n        } else {\n          attrValue = attr === 'type' ?\n            attrValue.toLowerCase() : attrValue\n          if( ref[ attr ] != null ) {\n            if( Array.isArray( ref[ attr ] ) ) {\n              ref[ attr ].push( attrValue )\n            } else {\n              ref[ attr ] = [ ref[ attr ], attrValue ]\n            }\n          } else {\n            ref[ attr ] = attrValue\n          }\n        }\n        switch( value[offset] ) {\n          case ',': state = STATE.IDLE; break\n          case ';': state = STATE.ATTR; break\n        }\n        offset++\n      } else {\n        throw new Error( 'Unknown parser state \"' + state + '\"' )\n      }\n    }\n\n    if( ref != null ) {\n      ref.rel != null ?\n        this.refs.push( ...Link.expandRelations( ref ) ) :\n        this.refs.push( ref )\n    }\n\n    ref = null\n\n    return this\n\n  }\n\n  toString() {\n\n    var refs = []\n    var link = ''\n    var ref = null\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      ref = this.refs[i]\n      link = Object.keys( this.refs[i] ).reduce( function( link, attr ) {\n        if( attr === 'uri' ) return link\n        return link + '; ' + Link.formatAttribute( attr, ref[ attr ] )\n      }, '<' + ref.uri + '>' )\n      refs.push( link )\n    }\n\n    return refs.join( ', ' )\n\n  }\n\n}\n\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\nLink.isCompatibleEncoding = function( value ) {\n  return COMPATIBLE_ENCODING_PATTERN.test( value )\n}\n\nLink.parse = function( value, offset ) {\n  return new Link().parse( value, offset )\n}\n\nLink.isSingleOccurenceAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' ||\n    attr === 'title' || attr === 'title*'\n}\n\nLink.isTokenAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor'\n}\n\nLink.escapeQuotes = function( value ) {\n  return value.replace( /\"/g, '\\\\\"' )\n}\n\nLink.expandRelations = function( ref ) {\n  var rels = ref.rel.split( ' ' )\n  return rels.map( function( rel ) {\n    var value = Object.assign( {}, ref )\n    value.rel = rel\n    return value\n  })\n}\n\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\nLink.parseExtendedValue = function( value ) {\n  var parts = /([^']+)?(?:'([^']*)')?(.+)/.exec( value )\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding( parts[1] ) ?\n      null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding( parts[1] ) ?\n      decodeURIComponent( parts[3] ) : parts[3]\n  }\n}\n\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\nLink.formatExtendedAttribute = function( attr, data ) {\n\n  var encoding = ( data.encoding || 'utf-8' ).toUpperCase()\n  var language = data.language || 'en'\n\n  var encodedValue = ''\n\n  if( Buffer.isBuffer( data.value ) && Link.isCompatibleEncoding( encoding ) ) {\n    encodedValue = data.value.toString( encoding )\n  } else if( Buffer.isBuffer( data.value ) ) {\n    encodedValue = data.value.toString( 'hex' )\n      .replace( /[0-9a-f]{2}/gi, '%$1' )\n  } else {\n    encodedValue = encodeURIComponent( data.value )\n  }\n\n  return attr + '=' + encoding + '\\'' +\n    language + '\\'' + encodedValue\n\n}\n\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\nLink.formatAttribute = function( attr, value ) {\n\n  if( Array.isArray( value ) ) {\n    return value.map(( item ) => {\n      return Link.formatAttribute( attr, item )\n    }).join( '; ' )\n  }\n\n  if( attr[ attr.length - 1 ] === '*' || typeof value !== 'string' ) {\n    return Link.formatExtendedAttribute( attr, value )\n  }\n\n  if( Link.isTokenAttr( attr ) ) {\n    value = needsQuotes( value ) ?\n      '\"' + Link.escapeQuotes( value ) + '\"' :\n      Link.escapeQuotes( value )\n  } else if( needsQuotes( value ) ) {\n    value = encodeURIComponent( value )\n    // We don't need to escape <SP> <,> <;> within quotes\n    value = value\n      .replace( /%20/g, ' ' )\n      .replace( /%2C/g, ',' )\n      .replace( /%3B/g, ';' )\n\n    value = '\"' + value + '\"'\n  }\n\n  return attr + '=' + value\n\n}\n\nmodule.exports = Link\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}