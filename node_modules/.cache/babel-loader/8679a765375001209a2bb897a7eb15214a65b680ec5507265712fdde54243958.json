{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _slicedToArray = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _regeneratorRuntime = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _toArray = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/toArray.js\").default;\nvar _defineProperty = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/defineProperty.js\").default;\nvar _createForOfIteratorHelper = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _asyncToGenerator = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar JsonLdError = require('./JsonLdError');\nvar _require = require('./types'),\n  _isArray = _require.isArray,\n  _isObject = _require.isObject,\n  _isString = _require.isString,\n  _isUndefined = _require.isUndefined;\nvar _require2 = require('./graphTypes'),\n  _isList = _require2.isList,\n  _isValue = _require2.isValue,\n  _isGraph = _require2.isGraph,\n  _isSimpleGraph = _require2.isSimpleGraph,\n  _isSubjectReference = _require2.isSubjectReference;\nvar _require3 = require('./context'),\n  _expandIri = _require3.expandIri,\n  _getContextValue = _require3.getContextValue,\n  _isKeyword = _require3.isKeyword,\n  _processContext = _require3.process,\n  _processingMode = _require3.processingMode;\nvar _require4 = require('./url'),\n  _removeBase = _require4.removeBase,\n  _prependBase = _require4.prependBase;\nvar _require5 = require('./util'),\n  _addValue = _require5.addValue,\n  _asArray = _require5.asArray,\n  _compareShortestLeast = _require5.compareShortestLeast;\nvar api = {};\nmodule.exports = api;\n\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return a promise that resolves to the compacted value.\n */\napi.compact = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {\n    var activeCtx, _ref$activeProperty, activeProperty, element, _ref$options, options, _ref$compactionMap, compactionMap, rval, i, compacted, container, ctx, linked, _i, _rval, _container, insideReverse, _rval2, inputCtx, propertyScopedCtx, types, typeContext, _iterator, _step, type, compactedType, _ctx, keys, _iterator2, _step2, expandedProperty, expandedValue, compactedValue, alias, _compactedValue, _alias, _container2, typeAsSet, isArray, _compactedValue2, compactedProperty, value, _container3, useArray, _alias2, _compactedValue3, _container4, _alias3, _alias4, itemActiveProperty, nestProperty, nestResult, _iterator3, _step3, expandedItem, _itemActiveProperty, _nestProperty, _nestResult, _container5, isGraph, isList, inner, compactedItem, mapObject, key, _mapObject, _key, indexKey, containerKey, others, _asArray2, _asArray3, idKey, typeKey, _types, _asArray4, _asArray5, _isArray2;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          activeCtx = _ref.activeCtx, _ref$activeProperty = _ref.activeProperty, activeProperty = _ref$activeProperty === void 0 ? null : _ref$activeProperty, element = _ref.element, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, _ref$compactionMap = _ref.compactionMap, compactionMap = _ref$compactionMap === void 0 ? function () {\n            return undefined;\n          } : _ref$compactionMap;\n          if (!_isArray(element)) {\n            _context.next = 20;\n            break;\n          }\n          rval = [];\n          i = 0;\n        case 4:\n          if (!(i < element.length)) {\n            _context.next = 18;\n            break;\n          }\n          _context.next = 7;\n          return api.compact({\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            element: element[i],\n            options: options,\n            compactionMap: compactionMap\n          });\n        case 7:\n          compacted = _context.sent;\n          if (!(compacted === null)) {\n            _context.next = 14;\n            break;\n          }\n          _context.next = 11;\n          return compactionMap({\n            unmappedValue: element[i],\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            parent: element,\n            index: i,\n            options: options\n          });\n        case 11:\n          compacted = _context.sent;\n          if (!(compacted === undefined)) {\n            _context.next = 14;\n            break;\n          }\n          return _context.abrupt(\"continue\", 15);\n        case 14:\n          rval.push(compacted);\n        case 15:\n          ++i;\n          _context.next = 4;\n          break;\n        case 18:\n          if (options.compactArrays && rval.length === 1) {\n            // use single element if no container is specified\n            container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n            if (container.length === 0) {\n              rval = rval[0];\n            }\n          }\n          return _context.abrupt(\"return\", rval);\n        case 20:\n          // use any scoped context on activeProperty\n          ctx = _getContextValue(activeCtx, activeProperty, '@context');\n          if (_isUndefined(ctx)) {\n            _context.next = 25;\n            break;\n          }\n          _context.next = 24;\n          return _processContext({\n            activeCtx: activeCtx,\n            localCtx: ctx,\n            propagate: true,\n            overrideProtected: true,\n            options: options\n          });\n        case 24:\n          activeCtx = _context.sent;\n        case 25:\n          if (!_isObject(element)) {\n            _context.next = 246;\n            break;\n          }\n          if (!(options.link && '@id' in element && options.link.hasOwnProperty(element['@id']))) {\n            _context.next = 35;\n            break;\n          }\n          // check for a linked element to reuse\n          linked = options.link[element['@id']];\n          _i = 0;\n        case 29:\n          if (!(_i < linked.length)) {\n            _context.next = 35;\n            break;\n          }\n          if (!(linked[_i].expanded === element)) {\n            _context.next = 32;\n            break;\n          }\n          return _context.abrupt(\"return\", linked[_i].compacted);\n        case 32:\n          ++_i;\n          _context.next = 29;\n          break;\n        case 35:\n          if (!(_isValue(element) || _isSubjectReference(element))) {\n            _context.next = 39;\n            break;\n          }\n          _rval = api.compactValue({\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            value: element,\n            options: options\n          });\n          if (options.link && _isSubjectReference(element)) {\n            // store linked element\n            if (!options.link.hasOwnProperty(element['@id'])) {\n              options.link[element['@id']] = [];\n            }\n            options.link[element['@id']].push({\n              expanded: element,\n              compacted: _rval\n            });\n          }\n          return _context.abrupt(\"return\", _rval);\n        case 39:\n          if (!_isList(element)) {\n            _context.next = 43;\n            break;\n          }\n          _container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n          if (!_container.includes('@list')) {\n            _context.next = 43;\n            break;\n          }\n          return _context.abrupt(\"return\", api.compact({\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            element: element['@list'],\n            options: options,\n            compactionMap: compactionMap\n          }));\n        case 43:\n          // FIXME: avoid misuse of active property as an expanded property?\n          insideReverse = activeProperty === '@reverse';\n          _rval2 = {}; // original context before applying property-scoped and local contexts\n          inputCtx = activeCtx; // revert to previous context, if there is one,\n          // and element is not a value object or a node reference\n          if (!_isValue(element) && !_isSubjectReference(element)) {\n            activeCtx = activeCtx.revertToPreviousContext();\n          }\n\n          // apply property-scoped context after reverting term-scoped context\n          propertyScopedCtx = _getContextValue(inputCtx, activeProperty, '@context');\n          if (_isUndefined(propertyScopedCtx)) {\n            _context.next = 52;\n            break;\n          }\n          _context.next = 51;\n          return _processContext({\n            activeCtx: activeCtx,\n            localCtx: propertyScopedCtx,\n            propagate: true,\n            overrideProtected: true,\n            options: options\n          });\n        case 51:\n          activeCtx = _context.sent;\n        case 52:\n          if (options.link && '@id' in element) {\n            // store linked element\n            if (!options.link.hasOwnProperty(element['@id'])) {\n              options.link[element['@id']] = [];\n            }\n            options.link[element['@id']].push({\n              expanded: element,\n              compacted: _rval2\n            });\n          }\n\n          // apply any context defined on an alias of @type\n          // if key is @type and any compacted value is a term having a local\n          // context, overlay that context\n          types = element['@type'] || [];\n          if (types.length > 1) {\n            types = Array.from(types).sort();\n          }\n          // find all type-scoped contexts based on current context, prior to\n          // updating it\n          typeContext = activeCtx;\n          _iterator = _createForOfIteratorHelper(types);\n          _context.prev = 57;\n          _iterator.s();\n        case 59:\n          if ((_step = _iterator.n()).done) {\n            _context.next = 69;\n            break;\n          }\n          type = _step.value;\n          compactedType = api.compactIri({\n            activeCtx: typeContext,\n            iri: type,\n            relativeTo: {\n              vocab: true\n            }\n          }); // Use any type-scoped context defined on this value\n          _ctx = _getContextValue(inputCtx, compactedType, '@context');\n          if (_isUndefined(_ctx)) {\n            _context.next = 67;\n            break;\n          }\n          _context.next = 66;\n          return _processContext({\n            activeCtx: activeCtx,\n            localCtx: _ctx,\n            options: options,\n            propagate: false\n          });\n        case 66:\n          activeCtx = _context.sent;\n        case 67:\n          _context.next = 59;\n          break;\n        case 69:\n          _context.next = 74;\n          break;\n        case 71:\n          _context.prev = 71;\n          _context.t0 = _context[\"catch\"](57);\n          _iterator.e(_context.t0);\n        case 74:\n          _context.prev = 74;\n          _iterator.f();\n          return _context.finish(74);\n        case 77:\n          // process element keys in order\n          keys = Object.keys(element).sort();\n          _iterator2 = _createForOfIteratorHelper(keys);\n          _context.prev = 79;\n          _iterator2.s();\n        case 81:\n          if ((_step2 = _iterator2.n()).done) {\n            _context.next = 237;\n            break;\n          }\n          expandedProperty = _step2.value;\n          expandedValue = element[expandedProperty]; // compact @id\n          if (!(expandedProperty === '@id')) {\n            _context.next = 90;\n            break;\n          }\n          compactedValue = _asArray(expandedValue).map(function (expandedIri) {\n            return api.compactIri({\n              activeCtx: activeCtx,\n              iri: expandedIri,\n              relativeTo: {\n                vocab: false\n              },\n              base: options.base\n            });\n          });\n          if (compactedValue.length === 1) {\n            compactedValue = compactedValue[0];\n          }\n\n          // use keyword alias and add value\n          alias = api.compactIri({\n            activeCtx: activeCtx,\n            iri: '@id',\n            relativeTo: {\n              vocab: true\n            }\n          });\n          _rval2[alias] = compactedValue;\n          return _context.abrupt(\"continue\", 235);\n        case 90:\n          if (!(expandedProperty === '@type')) {\n            _context.next = 99;\n            break;\n          }\n          // resolve type values against previous context\n          _compactedValue = _asArray(expandedValue).map(function (expandedIri) {\n            return api.compactIri({\n              activeCtx: inputCtx,\n              iri: expandedIri,\n              relativeTo: {\n                vocab: true\n              }\n            });\n          });\n          if (_compactedValue.length === 1) {\n            _compactedValue = _compactedValue[0];\n          }\n\n          // use keyword alias and add value\n          _alias = api.compactIri({\n            activeCtx: activeCtx,\n            iri: '@type',\n            relativeTo: {\n              vocab: true\n            }\n          });\n          _container2 = _getContextValue(activeCtx, _alias, '@container') || []; // treat as array for @type if @container includes @set\n          typeAsSet = _container2.includes('@set') && _processingMode(activeCtx, 1.1);\n          isArray = typeAsSet || _isArray(_compactedValue) && expandedValue.length === 0;\n          _addValue(_rval2, _alias, _compactedValue, {\n            propertyIsArray: isArray\n          });\n          return _context.abrupt(\"continue\", 235);\n        case 99:\n          if (!(expandedProperty === '@reverse')) {\n            _context.next = 106;\n            break;\n          }\n          _context.next = 102;\n          return api.compact({\n            activeCtx: activeCtx,\n            activeProperty: '@reverse',\n            element: expandedValue,\n            options: options,\n            compactionMap: compactionMap\n          });\n        case 102:\n          _compactedValue2 = _context.sent;\n          // handle double-reversed properties\n          for (compactedProperty in _compactedValue2) {\n            if (activeCtx.mappings.has(compactedProperty) && activeCtx.mappings.get(compactedProperty).reverse) {\n              value = _compactedValue2[compactedProperty];\n              _container3 = _getContextValue(activeCtx, compactedProperty, '@container') || [];\n              useArray = _container3.includes('@set') || !options.compactArrays;\n              _addValue(_rval2, compactedProperty, value, {\n                propertyIsArray: useArray\n              });\n              delete _compactedValue2[compactedProperty];\n            }\n          }\n          if (Object.keys(_compactedValue2).length > 0) {\n            // use keyword alias and add value\n            _alias2 = api.compactIri({\n              activeCtx: activeCtx,\n              iri: expandedProperty,\n              relativeTo: {\n                vocab: true\n              }\n            });\n            _addValue(_rval2, _alias2, _compactedValue2);\n          }\n          return _context.abrupt(\"continue\", 235);\n        case 106:\n          if (!(expandedProperty === '@preserve')) {\n            _context.next = 112;\n            break;\n          }\n          _context.next = 109;\n          return api.compact({\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            element: expandedValue,\n            options: options,\n            compactionMap: compactionMap\n          });\n        case 109:\n          _compactedValue3 = _context.sent;\n          if (!(_isArray(_compactedValue3) && _compactedValue3.length === 0)) {\n            _addValue(_rval2, expandedProperty, _compactedValue3);\n          }\n          return _context.abrupt(\"continue\", 235);\n        case 112:\n          if (!(expandedProperty === '@index')) {\n            _context.next = 119;\n            break;\n          }\n          // drop @index if inside an @index container\n          _container4 = _getContextValue(activeCtx, activeProperty, '@container') || [];\n          if (!_container4.includes('@index')) {\n            _context.next = 116;\n            break;\n          }\n          return _context.abrupt(\"continue\", 235);\n        case 116:\n          // use keyword alias and add value\n          _alias3 = api.compactIri({\n            activeCtx: activeCtx,\n            iri: expandedProperty,\n            relativeTo: {\n              vocab: true\n            }\n          });\n          _addValue(_rval2, _alias3, expandedValue);\n          return _context.abrupt(\"continue\", 235);\n        case 119:\n          if (!(expandedProperty !== '@graph' && expandedProperty !== '@list' && expandedProperty !== '@included' && _isKeyword(expandedProperty))) {\n            _context.next = 123;\n            break;\n          }\n          // use keyword alias and add value as is\n          _alias4 = api.compactIri({\n            activeCtx: activeCtx,\n            iri: expandedProperty,\n            relativeTo: {\n              vocab: true\n            }\n          });\n          _addValue(_rval2, _alias4, expandedValue);\n          return _context.abrupt(\"continue\", 235);\n        case 123:\n          if (_isArray(expandedValue)) {\n            _context.next = 125;\n            break;\n          }\n          throw new JsonLdError('JSON-LD expansion error; expanded value must be an array.', 'jsonld.SyntaxError');\n        case 125:\n          // preserve empty arrays\n          if (expandedValue.length === 0) {\n            itemActiveProperty = api.compactIri({\n              activeCtx: activeCtx,\n              iri: expandedProperty,\n              value: expandedValue,\n              relativeTo: {\n                vocab: true\n              },\n              reverse: insideReverse\n            });\n            nestProperty = activeCtx.mappings.has(itemActiveProperty) ? activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n            nestResult = _rval2;\n            if (nestProperty) {\n              _checkNestProperty(activeCtx, nestProperty, options);\n              if (!_isObject(_rval2[nestProperty])) {\n                _rval2[nestProperty] = {};\n              }\n              nestResult = _rval2[nestProperty];\n            }\n            _addValue(nestResult, itemActiveProperty, expandedValue, {\n              propertyIsArray: true\n            });\n          }\n\n          // recusively process array values\n          _iterator3 = _createForOfIteratorHelper(expandedValue);\n          _context.prev = 127;\n          _iterator3.s();\n        case 129:\n          if ((_step3 = _iterator3.n()).done) {\n            _context.next = 227;\n            break;\n          }\n          expandedItem = _step3.value;\n          // compact property and get container type\n          _itemActiveProperty = api.compactIri({\n            activeCtx: activeCtx,\n            iri: expandedProperty,\n            value: expandedItem,\n            relativeTo: {\n              vocab: true\n            },\n            reverse: insideReverse\n          }); // if itemActiveProperty is a @nest property, add values to nestResult,\n          // otherwise rval\n          _nestProperty = activeCtx.mappings.has(_itemActiveProperty) ? activeCtx.mappings.get(_itemActiveProperty)['@nest'] : null;\n          _nestResult = _rval2;\n          if (_nestProperty) {\n            _checkNestProperty(activeCtx, _nestProperty, options);\n            if (!_isObject(_rval2[_nestProperty])) {\n              _rval2[_nestProperty] = {};\n            }\n            _nestResult = _rval2[_nestProperty];\n          }\n          _container5 = _getContextValue(activeCtx, _itemActiveProperty, '@container') || []; // get simple @graph or @list value if appropriate\n          isGraph = _isGraph(expandedItem);\n          isList = _isList(expandedItem);\n          inner = void 0;\n          if (isList) {\n            inner = expandedItem['@list'];\n          } else if (isGraph) {\n            inner = expandedItem['@graph'];\n          }\n\n          // recursively compact expanded item\n          _context.next = 142;\n          return api.compact({\n            activeCtx: activeCtx,\n            activeProperty: _itemActiveProperty,\n            element: isList || isGraph ? inner : expandedItem,\n            options: options,\n            compactionMap: compactionMap\n          });\n        case 142:\n          compactedItem = _context.sent;\n          if (!isList) {\n            _context.next = 152;\n            break;\n          }\n          // ensure @list value is an array\n          if (!_isArray(compactedItem)) {\n            compactedItem = [compactedItem];\n          }\n          if (_container5.includes('@list')) {\n            _context.next = 150;\n            break;\n          }\n          // wrap using @list alias\n          compactedItem = _defineProperty({}, api.compactIri({\n            activeCtx: activeCtx,\n            iri: '@list',\n            relativeTo: {\n              vocab: true\n            }\n          }), compactedItem);\n\n          // include @index from expanded @list, if any\n          if ('@index' in expandedItem) {\n            compactedItem[api.compactIri({\n              activeCtx: activeCtx,\n              iri: '@index',\n              relativeTo: {\n                vocab: true\n              }\n            })] = expandedItem['@index'];\n          }\n          _context.next = 152;\n          break;\n        case 150:\n          _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n            valueIsArray: true,\n            allowDuplicate: true\n          });\n          return _context.abrupt(\"continue\", 225);\n        case 152:\n          if (!isGraph) {\n            _context.next = 156;\n            break;\n          }\n          if (_container5.includes('@graph') && (_container5.includes('@id') || _container5.includes('@index') && _isSimpleGraph(expandedItem))) {\n            // get or create the map object\n            mapObject = void 0;\n            if (_nestResult.hasOwnProperty(_itemActiveProperty)) {\n              mapObject = _nestResult[_itemActiveProperty];\n            } else {\n              _nestResult[_itemActiveProperty] = mapObject = {};\n            }\n\n            // index on @id or @index or alias of @none\n            key = (_container5.includes('@id') ? expandedItem['@id'] : expandedItem['@index']) || api.compactIri({\n              activeCtx: activeCtx,\n              iri: '@none',\n              relativeTo: {\n                vocab: true\n              }\n            }); // add compactedItem to map, using value of `@id` or a new blank\n            // node identifier\n            _addValue(mapObject, key, compactedItem, {\n              propertyIsArray: !options.compactArrays || _container5.includes('@set')\n            });\n          } else if (_container5.includes('@graph') && _isSimpleGraph(expandedItem)) {\n            // container includes @graph but not @id or @index and value is a\n            // simple graph object add compact value\n            // if compactedItem contains multiple values, it is wrapped in\n            // `@included`\n            if (_isArray(compactedItem) && compactedItem.length > 1) {\n              compactedItem = {\n                '@included': compactedItem\n              };\n            }\n            _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n              propertyIsArray: !options.compactArrays || _container5.includes('@set')\n            });\n          } else {\n            // wrap using @graph alias, remove array if only one item and\n            // compactArrays not set\n            if (_isArray(compactedItem) && compactedItem.length === 1 && options.compactArrays) {\n              compactedItem = compactedItem[0];\n            }\n            compactedItem = _defineProperty({}, api.compactIri({\n              activeCtx: activeCtx,\n              iri: '@graph',\n              relativeTo: {\n                vocab: true\n              }\n            }), compactedItem);\n\n            // include @id from expanded graph, if any\n            if ('@id' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx: activeCtx,\n                iri: '@id',\n                relativeTo: {\n                  vocab: true\n                }\n              })] = expandedItem['@id'];\n            }\n\n            // include @index from expanded graph, if any\n            if ('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx: activeCtx,\n                iri: '@index',\n                relativeTo: {\n                  vocab: true\n                }\n              })] = expandedItem['@index'];\n            }\n            _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n              propertyIsArray: !options.compactArrays || _container5.includes('@set')\n            });\n          }\n          _context.next = 225;\n          break;\n        case 156:\n          if (!(_container5.includes('@language') || _container5.includes('@index') || _container5.includes('@id') || _container5.includes('@type'))) {\n            _context.next = 223;\n            break;\n          }\n          // handle language and index maps\n          // get or create the map object\n          _mapObject = void 0;\n          if (_nestResult.hasOwnProperty(_itemActiveProperty)) {\n            _mapObject = _nestResult[_itemActiveProperty];\n          } else {\n            _nestResult[_itemActiveProperty] = _mapObject = {};\n          }\n          _key = void 0;\n          if (!_container5.includes('@language')) {\n            _context.next = 165;\n            break;\n          }\n          // if container is a language map, simplify compacted value to\n          // a simple string\n          if (_isValue(compactedItem)) {\n            compactedItem = compactedItem['@value'];\n          }\n          _key = expandedItem['@language'];\n          _context.next = 219;\n          break;\n        case 165:\n          if (!_container5.includes('@index')) {\n            _context.next = 193;\n            break;\n          }\n          indexKey = _getContextValue(activeCtx, _itemActiveProperty, '@index') || '@index';\n          containerKey = api.compactIri({\n            activeCtx: activeCtx,\n            iri: indexKey,\n            relativeTo: {\n              vocab: true\n            }\n          });\n          if (!(indexKey === '@index')) {\n            _context.next = 173;\n            break;\n          }\n          _key = expandedItem['@index'];\n          delete compactedItem[containerKey];\n          _context.next = 191;\n          break;\n        case 173:\n          others = void 0;\n          _asArray2 = _asArray(compactedItem[indexKey] || []);\n          _asArray3 = _toArray(_asArray2);\n          _key = _asArray3[0];\n          others = _asArray3.slice(1);\n          if (_isString(_key)) {\n            _context.next = 182;\n            break;\n          }\n          // Will use @none if it isn't a string.\n          _key = null;\n          _context.next = 191;\n          break;\n        case 182:\n          _context.t1 = others.length;\n          _context.next = _context.t1 === 0 ? 185 : _context.t1 === 1 ? 187 : 189;\n          break;\n        case 185:\n          delete compactedItem[indexKey];\n          return _context.abrupt(\"break\", 191);\n        case 187:\n          compactedItem[indexKey] = others[0];\n          return _context.abrupt(\"break\", 191);\n        case 189:\n          compactedItem[indexKey] = others;\n          return _context.abrupt(\"break\", 191);\n        case 191:\n          _context.next = 219;\n          break;\n        case 193:\n          if (!_container5.includes('@id')) {\n            _context.next = 199;\n            break;\n          }\n          idKey = api.compactIri({\n            activeCtx: activeCtx,\n            iri: '@id',\n            relativeTo: {\n              vocab: true\n            }\n          });\n          _key = compactedItem[idKey];\n          delete compactedItem[idKey];\n          _context.next = 219;\n          break;\n        case 199:\n          if (!_container5.includes('@type')) {\n            _context.next = 219;\n            break;\n          }\n          typeKey = api.compactIri({\n            activeCtx: activeCtx,\n            iri: '@type',\n            relativeTo: {\n              vocab: true\n            }\n          });\n          _types = void 0;\n          _asArray4 = _asArray(compactedItem[typeKey] || []);\n          _asArray5 = _toArray(_asArray4);\n          _key = _asArray5[0];\n          _types = _asArray5.slice(1);\n          _context.t2 = _types.length;\n          _context.next = _context.t2 === 0 ? 209 : _context.t2 === 1 ? 211 : 213;\n          break;\n        case 209:\n          delete compactedItem[typeKey];\n          return _context.abrupt(\"break\", 215);\n        case 211:\n          compactedItem[typeKey] = _types[0];\n          return _context.abrupt(\"break\", 215);\n        case 213:\n          compactedItem[typeKey] = _types;\n          return _context.abrupt(\"break\", 215);\n        case 215:\n          if (!(Object.keys(compactedItem).length === 1 && '@id' in expandedItem)) {\n            _context.next = 219;\n            break;\n          }\n          _context.next = 218;\n          return api.compact({\n            activeCtx: activeCtx,\n            activeProperty: _itemActiveProperty,\n            element: {\n              '@id': expandedItem['@id']\n            },\n            options: options,\n            compactionMap: compactionMap\n          });\n        case 218:\n          compactedItem = _context.sent;\n        case 219:\n          // if compacting this value which has no key, index on @none\n          if (!_key) {\n            _key = api.compactIri({\n              activeCtx: activeCtx,\n              iri: '@none',\n              relativeTo: {\n                vocab: true\n              }\n            });\n          }\n          // add compact value to map object using key from expanded value\n          // based on the container type\n          _addValue(_mapObject, _key, compactedItem, {\n            propertyIsArray: _container5.includes('@set')\n          });\n          _context.next = 225;\n          break;\n        case 223:\n          // use an array if: compactArrays flag is false,\n          // @container is @set or @list , value is an empty\n          // array, or key is @graph\n          _isArray2 = !options.compactArrays || _container5.includes('@set') || _container5.includes('@list') || _isArray(compactedItem) && compactedItem.length === 0 || expandedProperty === '@list' || expandedProperty === '@graph'; // add compact value\n          _addValue(_nestResult, _itemActiveProperty, compactedItem, {\n            propertyIsArray: _isArray2\n          });\n        case 225:\n          _context.next = 129;\n          break;\n        case 227:\n          _context.next = 232;\n          break;\n        case 229:\n          _context.prev = 229;\n          _context.t3 = _context[\"catch\"](127);\n          _iterator3.e(_context.t3);\n        case 232:\n          _context.prev = 232;\n          _iterator3.f();\n          return _context.finish(232);\n        case 235:\n          _context.next = 81;\n          break;\n        case 237:\n          _context.next = 242;\n          break;\n        case 239:\n          _context.prev = 239;\n          _context.t4 = _context[\"catch\"](79);\n          _iterator2.e(_context.t4);\n        case 242:\n          _context.prev = 242;\n          _iterator2.f();\n          return _context.finish(242);\n        case 245:\n          return _context.abrupt(\"return\", _rval2);\n        case 246:\n          return _context.abrupt(\"return\", element);\n        case 247:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[57, 71, 74, 77], [79, 239, 242, 245], [127, 229, 232, 235]]);\n  }));\n  return function (_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n * @param base the absolute URL to use for compacting document-relative IRIs.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\napi.compactIri = function (_ref3) {\n  var activeCtx = _ref3.activeCtx,\n    iri = _ref3.iri,\n    _ref3$value = _ref3.value,\n    value = _ref3$value === void 0 ? null : _ref3$value,\n    _ref3$relativeTo = _ref3.relativeTo,\n    relativeTo = _ref3$relativeTo === void 0 ? {\n      vocab: false\n    } : _ref3$relativeTo,\n    _ref3$reverse = _ref3.reverse,\n    reverse = _ref3$reverse === void 0 ? false : _ref3$reverse,\n    _ref3$base = _ref3.base,\n    base = _ref3$base === void 0 ? null : _ref3$base;\n  // can't compact null\n  if (iri === null) {\n    return iri;\n  }\n\n  // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n  if (activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n  var inverseCtx = activeCtx.getInverse();\n\n  // if term is a keyword, it may be compacted to a simple alias\n  if (_isKeyword(iri) && iri in inverseCtx && '@none' in inverseCtx[iri] && '@type' in inverseCtx[iri]['@none'] && '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  }\n\n  // use inverse context to pick a term if iri is relative to vocab\n  if (relativeTo.vocab && iri in inverseCtx) {\n    var defaultLanguage = activeCtx['@language'] || '@none';\n\n    // prefer @index if available in value\n    var containers = [];\n    if (_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    }\n\n    // if value is a preserve object, use its value\n    if (_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    }\n\n    // prefer most specific container including @graph, prefering @set\n    // variations\n    if (_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if ('@index' in value) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // favor idmap if the graph is has an @id\n      if ('@id' in value) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n      containers.push('@graph', '@graph@set', '@set');\n      // allow indexmap if the graph is not indexed\n      if (!('@index' in value)) {\n        containers.push('@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // allow idmap if the graph does not have an @id\n      if (!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if (_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    }\n\n    // defaults for term selection based on type/language\n    var typeOrLanguage = '@language';\n    var typeOrLanguageValue = '@null';\n    if (reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if (_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if (!('@index' in value)) {\n        containers.push('@list');\n      }\n      var list = value['@list'];\n      if (list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        var commonLanguage = list.length === 0 ? defaultLanguage : null;\n        var commonType = null;\n        for (var i = 0; i < list.length; ++i) {\n          var item = list[i];\n          var itemLanguage = '@none';\n          var itemType = '@none';\n          if (_isValue(item)) {\n            if ('@direction' in item) {\n              var lang = (item['@language'] || '').toLowerCase();\n              var dir = item['@direction'];\n              itemLanguage = \"\".concat(lang, \"_\").concat(dir);\n            } else if ('@language' in item) {\n              itemLanguage = item['@language'].toLowerCase();\n            } else if ('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n          if (commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if (itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n          if (commonType === null) {\n            commonType = itemType;\n          } else if (itemType !== commonType) {\n            commonType = '@none';\n          }\n          // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n          if (commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n        if (commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if (_isValue(value)) {\n        if ('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n          var _dir = value['@direction'];\n          if (_dir) {\n            typeOrLanguageValue = \"\".concat(typeOrLanguageValue, \"_\").concat(_dir);\n          }\n        } else if ('@direction' in value && !('@index' in value)) {\n          typeOrLanguageValue = \"_\".concat(value['@direction']);\n        } else if ('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n      containers.push('@set');\n    }\n\n    // do term selection\n    containers.push('@none');\n\n    // an index map can be used to index values using @none, so add as a low\n    // priority\n    if (_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    }\n\n    // values without type or language can use @language map\n    if (_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n    var term = _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n    if (term !== null) {\n      return term;\n    }\n  }\n\n  // no term match, use @vocab if available\n  if (relativeTo.vocab) {\n    if ('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      var vocab = activeCtx['@vocab'];\n      if (iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        var suffix = iri.substr(vocab.length);\n        if (!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  }\n\n  // no term or @vocab match, check for possible CURIEs\n  var choice = null;\n  // TODO: make FastCurieMap a class with a method to do this lookup\n  var partialMatches = [];\n  var iriMap = activeCtx.fastCurieMap;\n  // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n  var maxPartialLength = iri.length - 1;\n  for (var _i2 = 0; _i2 < maxPartialLength && iri[_i2] in iriMap; ++_i2) {\n    iriMap = iriMap[iri[_i2]];\n    if ('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  }\n  // check partial matches in reverse order to prefer longest ones first\n  for (var _i3 = partialMatches.length - 1; _i3 >= 0; --_i3) {\n    var entry = partialMatches[_i3];\n    var terms = entry.terms;\n    var _iterator4 = _createForOfIteratorHelper(terms),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _term = _step4.value;\n        // a CURIE is usable if:\n        // 1. it has no mapping, OR\n        // 2. value is null, which means we're not compacting an @value, AND\n        //   the mapping matches the IRI\n        var curie = _term + ':' + iri.substr(entry.iri.length);\n        var isUsableCurie = activeCtx.mappings.get(_term)._prefix && (!activeCtx.mappings.has(curie) || value === null && activeCtx.mappings.get(curie)['@id'] === iri);\n\n        // select curie if it is shorter or the same length but lexicographically\n        // less than the current choice\n        if (isUsableCurie && (choice === null || _compareShortestLeast(curie, choice) < 0)) {\n          choice = curie;\n        }\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  }\n\n  // return chosen curie\n  if (choice !== null) {\n    return choice;\n  }\n\n  // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n  var _iterator5 = _createForOfIteratorHelper(activeCtx.mappings),\n    _step5;\n  try {\n    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n      var _step5$value = _slicedToArray(_step5.value, 2),\n        _term2 = _step5$value[0],\n        td = _step5$value[1];\n      if (td && td._prefix && iri.startsWith(_term2 + ':')) {\n        throw new JsonLdError(\"Absolute IRI \\\"\".concat(iri, \"\\\" confused with prefix \\\"\").concat(_term2, \"\\\".\"), 'jsonld.SyntaxError', {\n          code: 'IRI confused with prefix',\n          context: activeCtx\n        });\n      }\n    }\n\n    // compact IRI relative to base\n  } catch (err) {\n    _iterator5.e(err);\n  } finally {\n    _iterator5.f();\n  }\n  if (!relativeTo.vocab) {\n    if ('@base' in activeCtx) {\n      if (!activeCtx['@base']) {\n        // The None case preserves rval as potentially relative\n        return iri;\n      } else {\n        return _removeBase(_prependBase(base, activeCtx['@base']), iri);\n      }\n    } else {\n      return _removeBase(base, iri);\n    }\n  }\n\n  // return IRI as is\n  return iri;\n};\n\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\napi.compactValue = function (_ref4) {\n  var activeCtx = _ref4.activeCtx,\n    activeProperty = _ref4.activeProperty,\n    value = _ref4.value,\n    options = _ref4.options;\n  // value is a @value\n  if (_isValue(value)) {\n    // get context rules\n    var _type = _getContextValue(activeCtx, activeProperty, '@type');\n    var language = _getContextValue(activeCtx, activeProperty, '@language');\n    var direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    var container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n    // whether or not the value has an @index that must be preserved\n    var preserveIndex = '@index' in value && !container.includes('@index');\n\n    // if there's no @index to preserve ...\n    if (!preserveIndex && _type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if (value['@type'] === _type) {\n        return value['@value'];\n      }\n      if ('@language' in value && value['@language'] === language && '@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n      if ('@language' in value && value['@language'] === language) {\n        return value['@value'];\n      }\n      if ('@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n    }\n\n    // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n    var keyCount = Object.keys(value).length;\n    var isValueOnlyKey = keyCount === 1 || keyCount === 2 && '@index' in value && !preserveIndex;\n    var hasDefaultLanguage = ('@language' in activeCtx);\n    var isValueString = _isString(value['@value']);\n    var hasNullMapping = activeCtx.mappings.has(activeProperty) && activeCtx.mappings.get(activeProperty)['@language'] === null;\n    if (isValueOnlyKey && _type !== '@none' && (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n    var rval = {};\n\n    // preserve @index\n    if (preserveIndex) {\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@index',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@index'];\n    }\n    if ('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@type',\n        relativeTo: {\n          vocab: true\n        }\n      })] = api.compactIri({\n        activeCtx: activeCtx,\n        iri: value['@type'],\n        relativeTo: {\n          vocab: true\n        }\n      });\n    } else if ('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@language',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@language'];\n    }\n    if ('@direction' in value) {\n      // alias @direction\n      rval[api.compactIri({\n        activeCtx: activeCtx,\n        iri: '@direction',\n        relativeTo: {\n          vocab: true\n        }\n      })] = value['@direction'];\n    }\n\n    // alias @value\n    rval[api.compactIri({\n      activeCtx: activeCtx,\n      iri: '@value',\n      relativeTo: {\n        vocab: true\n      }\n    })] = value['@value'];\n    return rval;\n  }\n\n  // value is a subject reference\n  var expandedProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options);\n  var type = _getContextValue(activeCtx, activeProperty, '@type');\n  var compacted = api.compactIri({\n    activeCtx: activeCtx,\n    iri: value['@id'],\n    relativeTo: {\n      vocab: type === '@vocab'\n    },\n    base: options.base\n  });\n\n  // compact to scalar\n  if (type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n  return _defineProperty({}, api.compactIri({\n    activeCtx: activeCtx,\n    iri: '@id',\n    relativeTo: {\n      vocab: true\n    }\n  }), compacted);\n};\n\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\nfunction _selectTerm(activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if (typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  }\n\n  // preferences for the value of @type or @language\n  var prefs = [];\n\n  // determine prefs for @id based on whether or not value compacts to a term\n  if ((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') && _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if (typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    }\n    // try to compact value to a term\n    var term = api.compactIri({\n      activeCtx: activeCtx,\n      iri: value['@id'],\n      relativeTo: {\n        vocab: true\n      }\n    });\n    if (activeCtx.mappings.has(term) && activeCtx.mappings.get(term) && activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n\n    // consider direction only\n    var langDir = prefs.find(function (el) {\n      return el.includes('_');\n    });\n    if (langDir) {\n      // consider _dir portion\n      prefs.push(langDir.replace(/^[^_]+_/, '_'));\n    }\n  }\n  prefs.push('@none');\n  var containerMap = activeCtx.inverse[iri];\n  var _iterator6 = _createForOfIteratorHelper(containers),\n    _step6;\n  try {\n    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n      var container = _step6.value;\n      // if container not available in the map, continue\n      if (!(container in containerMap)) {\n        continue;\n      }\n      var typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n      var _iterator7 = _createForOfIteratorHelper(prefs),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var pref = _step7.value;\n          // if type/language option not available in the map, continue\n          if (!(pref in typeOrLanguageValueMap)) {\n            continue;\n          }\n\n          // select term\n          return typeOrLanguageValueMap[pref];\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n    }\n  } catch (err) {\n    _iterator6.e(err);\n  } finally {\n    _iterator6.f();\n  }\n  return null;\n}\n\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if (_expandIri(activeCtx, nestProperty, {\n    vocab: true\n  }, options) !== '@nest') {\n    throw new JsonLdError('JSON-LD compact error; nested property must have an @nest value ' + 'resolving to @nest.', 'jsonld.SyntaxError', {\n      code: 'invalid @nest value'\n    });\n  }\n}","map":{"version":3,"names":["JsonLdError","require","_isArray","isArray","_isObject","isObject","_isString","isString","_isUndefined","isUndefined","_isList","isList","_isValue","isValue","_isGraph","isGraph","_isSimpleGraph","isSimpleGraph","_isSubjectReference","isSubjectReference","_expandIri","expandIri","_getContextValue","getContextValue","_isKeyword","isKeyword","_processContext","process","_processingMode","processingMode","_removeBase","removeBase","_prependBase","prependBase","_addValue","addValue","_asArray","asArray","_compareShortestLeast","compareShortestLeast","api","module","exports","compact","activeCtx","activeProperty","element","options","compactionMap","undefined","rval","i","length","compacted","unmappedValue","parent","index","push","compactArrays","container","ctx","localCtx","propagate","overrideProtected","link","hasOwnProperty","linked","expanded","compactValue","value","includes","insideReverse","inputCtx","revertToPreviousContext","propertyScopedCtx","types","Array","from","sort","typeContext","type","compactedType","compactIri","iri","relativeTo","vocab","keys","Object","expandedProperty","expandedValue","compactedValue","map","expandedIri","base","alias","typeAsSet","propertyIsArray","compactedProperty","mappings","has","get","reverse","useArray","itemActiveProperty","nestProperty","nestResult","_checkNestProperty","expandedItem","inner","compactedItem","valueIsArray","allowDuplicate","mapObject","key","indexKey","containerKey","others","idKey","typeKey","isPropertyTermScoped","previousContext","inverseCtx","getInverse","defaultLanguage","containers","typeOrLanguage","typeOrLanguageValue","list","commonLanguage","commonType","item","itemLanguage","itemType","lang","toLowerCase","dir","term","_selectTerm","indexOf","suffix","substr","choice","partialMatches","iriMap","fastCurieMap","maxPartialLength","entry","terms","curie","isUsableCurie","_prefix","td","startsWith","code","context","language","direction","preserveIndex","keyCount","isValueOnlyKey","hasDefaultLanguage","isValueString","hasNullMapping","prefs","apply","langDir","find","el","replace","containerMap","inverse","typeOrLanguageValueMap","pref"],"sources":["E:/react-todo-app/node_modules/jsonld/lib/compact.js"],"sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSimpleGraph: _isSimpleGraph,\n  isSubjectReference: _isSubjectReference\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  removeBase: _removeBase,\n  prependBase: _prependBase\n} = require('./url');\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  compareShortestLeast: _compareShortestLeast\n} = require('./util');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Recursively compacts an element using the given active context. All values\n * must be in expanded form before this method is called.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the compacted property associated with the element\n *          to compact, null for none.\n * @param element the element to compact.\n * @param options the compaction options.\n * @param compactionMap the compaction map to use.\n *\n * @return a promise that resolves to the compacted value.\n */\napi.compact = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  compactionMap = () => undefined\n}) => {\n  // recursively compact array\n  if(_isArray(element)) {\n    let rval = [];\n    for(let i = 0; i < element.length; ++i) {\n      // compact, dropping any null values unless custom mapped\n      let compacted = await api.compact({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        compactionMap\n      });\n      if(compacted === null) {\n        compacted = await compactionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options\n        });\n        if(compacted === undefined) {\n          continue;\n        }\n      }\n      rval.push(compacted);\n    }\n    if(options.compactArrays && rval.length === 1) {\n      // use single element if no container is specified\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.length === 0) {\n        rval = rval[0];\n      }\n    }\n    return rval;\n  }\n\n  // use any scoped context on activeProperty\n  const ctx = _getContextValue(activeCtx, activeProperty, '@context');\n  if(!_isUndefined(ctx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: ctx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // recursively compact object\n  if(_isObject(element)) {\n    if(options.link && '@id' in element &&\n      options.link.hasOwnProperty(element['@id'])) {\n      // check for a linked element to reuse\n      const linked = options.link[element['@id']];\n      for(let i = 0; i < linked.length; ++i) {\n        if(linked[i].expanded === element) {\n          return linked[i].compacted;\n        }\n      }\n    }\n\n    // do value compaction on @values and subject references\n    if(_isValue(element) || _isSubjectReference(element)) {\n      const rval =\n        api.compactValue({activeCtx, activeProperty, value: element, options});\n      if(options.link && _isSubjectReference(element)) {\n        // store linked element\n        if(!(options.link.hasOwnProperty(element['@id']))) {\n          options.link[element['@id']] = [];\n        }\n        options.link[element['@id']].push({expanded: element, compacted: rval});\n      }\n      return rval;\n    }\n\n    // if expanded property is @list and we're contained within a list\n    // container, recursively compact this item to an array\n    if(_isList(element)) {\n      const container = _getContextValue(\n        activeCtx, activeProperty, '@container') || [];\n      if(container.includes('@list')) {\n        return api.compact({\n          activeCtx,\n          activeProperty,\n          element: element['@list'],\n          options,\n          compactionMap\n        });\n      }\n    }\n\n    // FIXME: avoid misuse of active property as an expanded property?\n    const insideReverse = (activeProperty === '@reverse');\n\n    const rval = {};\n\n    // original context before applying property-scoped and local contexts\n    const inputCtx = activeCtx;\n\n    // revert to previous context, if there is one,\n    // and element is not a value object or a node reference\n    if(!_isValue(element) && !_isSubjectReference(element)) {\n      activeCtx = activeCtx.revertToPreviousContext();\n    }\n\n    // apply property-scoped context after reverting term-scoped context\n    const propertyScopedCtx =\n      _getContextValue(inputCtx, activeProperty, '@context');\n    if(!_isUndefined(propertyScopedCtx)) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx: propertyScopedCtx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    if(options.link && '@id' in element) {\n      // store linked element\n      if(!options.link.hasOwnProperty(element['@id'])) {\n        options.link[element['@id']] = [];\n      }\n      options.link[element['@id']].push({expanded: element, compacted: rval});\n    }\n\n    // apply any context defined on an alias of @type\n    // if key is @type and any compacted value is a term having a local\n    // context, overlay that context\n    let types = element['@type'] || [];\n    if(types.length > 1) {\n      types = Array.from(types).sort();\n    }\n    // find all type-scoped contexts based on current context, prior to\n    // updating it\n    const typeContext = activeCtx;\n    for(const type of types) {\n      const compactedType = api.compactIri(\n        {activeCtx: typeContext, iri: type, relativeTo: {vocab: true}});\n\n      // Use any type-scoped context defined on this value\n      const ctx = _getContextValue(inputCtx, compactedType, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          options,\n          propagate: false\n        });\n      }\n    }\n\n    // process element keys in order\n    const keys = Object.keys(element).sort();\n    for(const expandedProperty of keys) {\n      const expandedValue = element[expandedProperty];\n\n      // compact @id\n      if(expandedProperty === '@id') {\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: false},\n            base: options.base\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@id', relativeTo: {vocab: true}});\n\n        rval[alias] = compactedValue;\n        continue;\n      }\n\n      // compact @type(s)\n      if(expandedProperty === '@type') {\n        // resolve type values against previous context\n        let compactedValue = _asArray(expandedValue).map(\n          expandedIri => api.compactIri({\n            activeCtx: inputCtx,\n            iri: expandedIri,\n            relativeTo: {vocab: true}\n          }));\n        if(compactedValue.length === 1) {\n          compactedValue = compactedValue[0];\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri(\n          {activeCtx, iri: '@type', relativeTo: {vocab: true}});\n        const container = _getContextValue(\n          activeCtx, alias, '@container') || [];\n\n        // treat as array for @type if @container includes @set\n        const typeAsSet =\n          container.includes('@set') &&\n          _processingMode(activeCtx, 1.1);\n        const isArray =\n          typeAsSet || (_isArray(compactedValue) && expandedValue.length === 0);\n        _addValue(rval, alias, compactedValue, {propertyIsArray: isArray});\n        continue;\n      }\n\n      // handle @reverse\n      if(expandedProperty === '@reverse') {\n        // recursively compact expanded value\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty: '@reverse',\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        // handle double-reversed properties\n        for(const compactedProperty in compactedValue) {\n          if(activeCtx.mappings.has(compactedProperty) &&\n            activeCtx.mappings.get(compactedProperty).reverse) {\n            const value = compactedValue[compactedProperty];\n            const container = _getContextValue(\n              activeCtx, compactedProperty, '@container') || [];\n            const useArray = (\n              container.includes('@set') || !options.compactArrays);\n            _addValue(\n              rval, compactedProperty, value, {propertyIsArray: useArray});\n            delete compactedValue[compactedProperty];\n          }\n        }\n\n        if(Object.keys(compactedValue).length > 0) {\n          // use keyword alias and add value\n          const alias = api.compactIri({\n            activeCtx,\n            iri: expandedProperty,\n            relativeTo: {vocab: true}\n          });\n          _addValue(rval, alias, compactedValue);\n        }\n\n        continue;\n      }\n\n      if(expandedProperty === '@preserve') {\n        // compact using activeProperty\n        const compactedValue = await api.compact({\n          activeCtx,\n          activeProperty,\n          element: expandedValue,\n          options,\n          compactionMap\n        });\n\n        if(!(_isArray(compactedValue) && compactedValue.length === 0)) {\n          _addValue(rval, expandedProperty, compactedValue);\n        }\n        continue;\n      }\n\n      // handle @index property\n      if(expandedProperty === '@index') {\n        // drop @index if inside an @index container\n        const container = _getContextValue(\n          activeCtx, activeProperty, '@container') || [];\n        if(container.includes('@index')) {\n          continue;\n        }\n\n        // use keyword alias and add value\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // skip array processing for keywords that aren't\n      // @graph, @list, or @included\n      if(expandedProperty !== '@graph' && expandedProperty !== '@list' &&\n        expandedProperty !== '@included' &&\n        _isKeyword(expandedProperty)) {\n        // use keyword alias and add value as is\n        const alias = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          relativeTo: {vocab: true}\n        });\n        _addValue(rval, alias, expandedValue);\n        continue;\n      }\n\n      // Note: expanded value must be an array due to expansion algorithm.\n      if(!_isArray(expandedValue)) {\n        throw new JsonLdError(\n          'JSON-LD expansion error; expanded value must be an array.',\n          'jsonld.SyntaxError');\n      }\n\n      // preserve empty arrays\n      if(expandedValue.length === 0) {\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedValue,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n        _addValue(\n          nestResult, itemActiveProperty, expandedValue, {\n            propertyIsArray: true\n          });\n      }\n\n      // recusively process array values\n      for(const expandedItem of expandedValue) {\n        // compact property and get container type\n        const itemActiveProperty = api.compactIri({\n          activeCtx,\n          iri: expandedProperty,\n          value: expandedItem,\n          relativeTo: {vocab: true},\n          reverse: insideReverse\n        });\n\n        // if itemActiveProperty is a @nest property, add values to nestResult,\n        // otherwise rval\n        const nestProperty = activeCtx.mappings.has(itemActiveProperty) ?\n          activeCtx.mappings.get(itemActiveProperty)['@nest'] : null;\n        let nestResult = rval;\n        if(nestProperty) {\n          _checkNestProperty(activeCtx, nestProperty, options);\n          if(!_isObject(rval[nestProperty])) {\n            rval[nestProperty] = {};\n          }\n          nestResult = rval[nestProperty];\n        }\n\n        const container = _getContextValue(\n          activeCtx, itemActiveProperty, '@container') || [];\n\n        // get simple @graph or @list value if appropriate\n        const isGraph = _isGraph(expandedItem);\n        const isList = _isList(expandedItem);\n        let inner;\n        if(isList) {\n          inner = expandedItem['@list'];\n        } else if(isGraph) {\n          inner = expandedItem['@graph'];\n        }\n\n        // recursively compact expanded item\n        let compactedItem = await api.compact({\n          activeCtx,\n          activeProperty: itemActiveProperty,\n          element: (isList || isGraph) ? inner : expandedItem,\n          options,\n          compactionMap\n        });\n\n        // handle @list\n        if(isList) {\n          // ensure @list value is an array\n          if(!_isArray(compactedItem)) {\n            compactedItem = [compactedItem];\n          }\n\n          if(!container.includes('@list')) {\n            // wrap using @list alias\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@list',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @index from expanded @list, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n          } else {\n            _addValue(nestResult, itemActiveProperty, compactedItem, {\n              valueIsArray: true,\n              allowDuplicate: true\n            });\n            continue;\n          }\n        }\n\n        // Graph object compaction cases\n        if(isGraph) {\n          if(container.includes('@graph') && (container.includes('@id') ||\n            container.includes('@index') && _isSimpleGraph(expandedItem))) {\n            // get or create the map object\n            let mapObject;\n            if(nestResult.hasOwnProperty(itemActiveProperty)) {\n              mapObject = nestResult[itemActiveProperty];\n            } else {\n              nestResult[itemActiveProperty] = mapObject = {};\n            }\n\n            // index on @id or @index or alias of @none\n            const key = (container.includes('@id') ?\n              expandedItem['@id'] : expandedItem['@index']) ||\n              api.compactIri({activeCtx, iri: '@none',\n                relativeTo: {vocab: true}});\n            // add compactedItem to map, using value of `@id` or a new blank\n            // node identifier\n\n            _addValue(\n              mapObject, key, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else if(container.includes('@graph') &&\n            _isSimpleGraph(expandedItem)) {\n            // container includes @graph but not @id or @index and value is a\n            // simple graph object add compact value\n            // if compactedItem contains multiple values, it is wrapped in\n            // `@included`\n            if(_isArray(compactedItem) && compactedItem.length > 1) {\n              compactedItem = {'@included': compactedItem};\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          } else {\n            // wrap using @graph alias, remove array if only one item and\n            // compactArrays not set\n            if(_isArray(compactedItem) && compactedItem.length === 1 &&\n              options.compactArrays) {\n              compactedItem = compactedItem[0];\n            }\n            compactedItem = {\n              [api.compactIri({\n                activeCtx,\n                iri: '@graph',\n                relativeTo: {vocab: true}\n              })]: compactedItem\n            };\n\n            // include @id from expanded graph, if any\n            if('@id' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@id',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@id'];\n            }\n\n            // include @index from expanded graph, if any\n            if('@index' in expandedItem) {\n              compactedItem[api.compactIri({\n                activeCtx,\n                iri: '@index',\n                relativeTo: {vocab: true}\n              })] = expandedItem['@index'];\n            }\n            _addValue(\n              nestResult, itemActiveProperty, compactedItem, {\n                propertyIsArray:\n                  (!options.compactArrays || container.includes('@set'))\n              });\n          }\n        } else if(container.includes('@language') ||\n          container.includes('@index') || container.includes('@id') ||\n          container.includes('@type')) {\n          // handle language and index maps\n          // get or create the map object\n          let mapObject;\n          if(nestResult.hasOwnProperty(itemActiveProperty)) {\n            mapObject = nestResult[itemActiveProperty];\n          } else {\n            nestResult[itemActiveProperty] = mapObject = {};\n          }\n\n          let key;\n          if(container.includes('@language')) {\n          // if container is a language map, simplify compacted value to\n          // a simple string\n            if(_isValue(compactedItem)) {\n              compactedItem = compactedItem['@value'];\n            }\n            key = expandedItem['@language'];\n          } else if(container.includes('@index')) {\n            const indexKey = _getContextValue(\n              activeCtx, itemActiveProperty, '@index') || '@index';\n            const containerKey = api.compactIri(\n              {activeCtx, iri: indexKey, relativeTo: {vocab: true}});\n            if(indexKey === '@index') {\n              key = expandedItem['@index'];\n              delete compactedItem[containerKey];\n            } else {\n              let others;\n              [key, ...others] = _asArray(compactedItem[indexKey] || []);\n              if(!_isString(key)) {\n                // Will use @none if it isn't a string.\n                key = null;\n              } else {\n                switch(others.length) {\n                  case 0:\n                    delete compactedItem[indexKey];\n                    break;\n                  case 1:\n                    compactedItem[indexKey] = others[0];\n                    break;\n                  default:\n                    compactedItem[indexKey] = others;\n                    break;\n                }\n              }\n            }\n          } else if(container.includes('@id')) {\n            const idKey = api.compactIri({activeCtx, iri: '@id',\n              relativeTo: {vocab: true}});\n            key = compactedItem[idKey];\n            delete compactedItem[idKey];\n          } else if(container.includes('@type')) {\n            const typeKey = api.compactIri({\n              activeCtx,\n              iri: '@type',\n              relativeTo: {vocab: true}\n            });\n            let types;\n            [key, ...types] = _asArray(compactedItem[typeKey] || []);\n            switch(types.length) {\n              case 0:\n                delete compactedItem[typeKey];\n                break;\n              case 1:\n                compactedItem[typeKey] = types[0];\n                break;\n              default:\n                compactedItem[typeKey] = types;\n                break;\n            }\n\n            // If compactedItem contains a single entry\n            // whose key maps to @id, recompact without @type\n            if(Object.keys(compactedItem).length === 1 &&\n              '@id' in expandedItem) {\n              compactedItem = await api.compact({\n                activeCtx,\n                activeProperty: itemActiveProperty,\n                element: {'@id': expandedItem['@id']},\n                options,\n                compactionMap\n              });\n            }\n          }\n\n          // if compacting this value which has no key, index on @none\n          if(!key) {\n            key = api.compactIri({activeCtx, iri: '@none',\n              relativeTo: {vocab: true}});\n          }\n          // add compact value to map object using key from expanded value\n          // based on the container type\n          _addValue(\n            mapObject, key, compactedItem, {\n              propertyIsArray: container.includes('@set')\n            });\n        } else {\n          // use an array if: compactArrays flag is false,\n          // @container is @set or @list , value is an empty\n          // array, or key is @graph\n          const isArray = (!options.compactArrays ||\n            container.includes('@set') || container.includes('@list') ||\n            (_isArray(compactedItem) && compactedItem.length === 0) ||\n            expandedProperty === '@list' || expandedProperty === '@graph');\n\n          // add compact value\n          _addValue(\n            nestResult, itemActiveProperty, compactedItem,\n            {propertyIsArray: isArray});\n        }\n      }\n    }\n\n    return rval;\n  }\n\n  // only primitives remain which are already compact\n  return element;\n};\n\n/**\n * Compacts an IRI or keyword into a term or prefix if it can be. If the\n * IRI has an associated value it may be passed.\n *\n * @param activeCtx the active context to use.\n * @param iri the IRI to compact.\n * @param value the value to check or null.\n * @param relativeTo options for how to compact IRIs:\n *          vocab: true to split after @vocab, false not to.\n * @param reverse true if a reverse property is being compacted, false if not.\n * @param base the absolute URL to use for compacting document-relative IRIs.\n *\n * @return the compacted term, prefix, keyword alias, or the original IRI.\n */\napi.compactIri = ({\n  activeCtx,\n  iri,\n  value = null,\n  relativeTo = {vocab: false},\n  reverse = false,\n  base = null\n}) => {\n  // can't compact null\n  if(iri === null) {\n    return iri;\n  }\n\n  // if context is from a property term scoped context composed with a\n  // type-scoped context, then use the previous context instead\n  if(activeCtx.isPropertyTermScoped && activeCtx.previousContext) {\n    activeCtx = activeCtx.previousContext;\n  }\n\n  const inverseCtx = activeCtx.getInverse();\n\n  // if term is a keyword, it may be compacted to a simple alias\n  if(_isKeyword(iri) &&\n    iri in inverseCtx &&\n    '@none' in inverseCtx[iri] &&\n    '@type' in inverseCtx[iri]['@none'] &&\n    '@none' in inverseCtx[iri]['@none']['@type']) {\n    return inverseCtx[iri]['@none']['@type']['@none'];\n  }\n\n  // use inverse context to pick a term if iri is relative to vocab\n  if(relativeTo.vocab && iri in inverseCtx) {\n    const defaultLanguage = activeCtx['@language'] || '@none';\n\n    // prefer @index if available in value\n    const containers = [];\n    if(_isObject(value) && '@index' in value && !('@graph' in value)) {\n      containers.push('@index', '@index@set');\n    }\n\n    // if value is a preserve object, use its value\n    if(_isObject(value) && '@preserve' in value) {\n      value = value['@preserve'][0];\n    }\n\n    // prefer most specific container including @graph, prefering @set\n    // variations\n    if(_isGraph(value)) {\n      // favor indexmap if the graph is indexed\n      if('@index' in value) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // favor idmap if the graph is has an @id\n      if('@id' in value) {\n        containers.push(\n          '@graph@id', '@graph@id@set');\n      }\n      containers.push('@graph', '@graph@set', '@set');\n      // allow indexmap if the graph is not indexed\n      if(!('@index' in value)) {\n        containers.push(\n          '@graph@index', '@graph@index@set', '@index', '@index@set');\n      }\n      // allow idmap if the graph does not have an @id\n      if(!('@id' in value)) {\n        containers.push('@graph@id', '@graph@id@set');\n      }\n    } else if(_isObject(value) && !_isValue(value)) {\n      containers.push('@id', '@id@set', '@type', '@set@type');\n    }\n\n    // defaults for term selection based on type/language\n    let typeOrLanguage = '@language';\n    let typeOrLanguageValue = '@null';\n\n    if(reverse) {\n      typeOrLanguage = '@type';\n      typeOrLanguageValue = '@reverse';\n      containers.push('@set');\n    } else if(_isList(value)) {\n      // choose the most specific term that works for all elements in @list\n      // only select @list containers if @index is NOT in value\n      if(!('@index' in value)) {\n        containers.push('@list');\n      }\n      const list = value['@list'];\n      if(list.length === 0) {\n        // any empty list can be matched against any term that uses the\n        // @list container regardless of @type or @language\n        typeOrLanguage = '@any';\n        typeOrLanguageValue = '@none';\n      } else {\n        let commonLanguage = (list.length === 0) ? defaultLanguage : null;\n        let commonType = null;\n        for(let i = 0; i < list.length; ++i) {\n          const item = list[i];\n          let itemLanguage = '@none';\n          let itemType = '@none';\n          if(_isValue(item)) {\n            if('@direction' in item) {\n              const lang = (item['@language'] || '').toLowerCase();\n              const dir = item['@direction'];\n              itemLanguage = `${lang}_${dir}`;\n            } else if('@language' in item) {\n              itemLanguage = item['@language'].toLowerCase();\n            } else if('@type' in item) {\n              itemType = item['@type'];\n            } else {\n              // plain literal\n              itemLanguage = '@null';\n            }\n          } else {\n            itemType = '@id';\n          }\n          if(commonLanguage === null) {\n            commonLanguage = itemLanguage;\n          } else if(itemLanguage !== commonLanguage && _isValue(item)) {\n            commonLanguage = '@none';\n          }\n          if(commonType === null) {\n            commonType = itemType;\n          } else if(itemType !== commonType) {\n            commonType = '@none';\n          }\n          // there are different languages and types in the list, so choose\n          // the most generic term, no need to keep iterating the list\n          if(commonLanguage === '@none' && commonType === '@none') {\n            break;\n          }\n        }\n        commonLanguage = commonLanguage || '@none';\n        commonType = commonType || '@none';\n        if(commonType !== '@none') {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = commonType;\n        } else {\n          typeOrLanguageValue = commonLanguage;\n        }\n      }\n    } else {\n      if(_isValue(value)) {\n        if('@language' in value && !('@index' in value)) {\n          containers.push('@language', '@language@set');\n          typeOrLanguageValue = value['@language'];\n          const dir = value['@direction'];\n          if(dir) {\n            typeOrLanguageValue = `${typeOrLanguageValue}_${dir}`;\n          }\n        } else if('@direction' in value && !('@index' in value)) {\n          typeOrLanguageValue = `_${value['@direction']}`;\n        } else if('@type' in value) {\n          typeOrLanguage = '@type';\n          typeOrLanguageValue = value['@type'];\n        }\n      } else {\n        typeOrLanguage = '@type';\n        typeOrLanguageValue = '@id';\n      }\n      containers.push('@set');\n    }\n\n    // do term selection\n    containers.push('@none');\n\n    // an index map can be used to index values using @none, so add as a low\n    // priority\n    if(_isObject(value) && !('@index' in value)) {\n      // allow indexing even if no @index present\n      containers.push('@index', '@index@set');\n    }\n\n    // values without type or language can use @language map\n    if(_isValue(value) && Object.keys(value).length === 1) {\n      // allow indexing even if no @index present\n      containers.push('@language', '@language@set');\n    }\n\n    const term = _selectTerm(\n      activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue);\n    if(term !== null) {\n      return term;\n    }\n  }\n\n  // no term match, use @vocab if available\n  if(relativeTo.vocab) {\n    if('@vocab' in activeCtx) {\n      // determine if vocab is a prefix of the iri\n      const vocab = activeCtx['@vocab'];\n      if(iri.indexOf(vocab) === 0 && iri !== vocab) {\n        // use suffix as relative iri if it is not a term in the active context\n        const suffix = iri.substr(vocab.length);\n        if(!activeCtx.mappings.has(suffix)) {\n          return suffix;\n        }\n      }\n    }\n  }\n\n  // no term or @vocab match, check for possible CURIEs\n  let choice = null;\n  // TODO: make FastCurieMap a class with a method to do this lookup\n  const partialMatches = [];\n  let iriMap = activeCtx.fastCurieMap;\n  // check for partial matches of against `iri`, which means look until\n  // iri.length - 1, not full length\n  const maxPartialLength = iri.length - 1;\n  for(let i = 0; i < maxPartialLength && iri[i] in iriMap; ++i) {\n    iriMap = iriMap[iri[i]];\n    if('' in iriMap) {\n      partialMatches.push(iriMap[''][0]);\n    }\n  }\n  // check partial matches in reverse order to prefer longest ones first\n  for(let i = partialMatches.length - 1; i >= 0; --i) {\n    const entry = partialMatches[i];\n    const terms = entry.terms;\n    for(const term of terms) {\n      // a CURIE is usable if:\n      // 1. it has no mapping, OR\n      // 2. value is null, which means we're not compacting an @value, AND\n      //   the mapping matches the IRI\n      const curie = term + ':' + iri.substr(entry.iri.length);\n      const isUsableCurie = (activeCtx.mappings.get(term)._prefix &&\n        (!activeCtx.mappings.has(curie) ||\n        (value === null && activeCtx.mappings.get(curie)['@id'] === iri)));\n\n      // select curie if it is shorter or the same length but lexicographically\n      // less than the current choice\n      if(isUsableCurie && (choice === null ||\n        _compareShortestLeast(curie, choice) < 0)) {\n        choice = curie;\n      }\n    }\n  }\n\n  // return chosen curie\n  if(choice !== null) {\n    return choice;\n  }\n\n  // If iri could be confused with a compact IRI using a term in this context,\n  // signal an error\n  for(const [term, td] of activeCtx.mappings) {\n    if(td && td._prefix && iri.startsWith(term + ':')) {\n      throw new JsonLdError(\n        `Absolute IRI \"${iri}\" confused with prefix \"${term}\".`,\n        'jsonld.SyntaxError',\n        {code: 'IRI confused with prefix', context: activeCtx});\n    }\n  }\n\n  // compact IRI relative to base\n  if(!relativeTo.vocab) {\n    if('@base' in activeCtx) {\n      if(!activeCtx['@base']) {\n        // The None case preserves rval as potentially relative\n        return iri;\n      } else {\n        return _removeBase(_prependBase(base, activeCtx['@base']), iri);\n      }\n    } else {\n      return _removeBase(base, iri);\n    }\n  }\n\n  // return IRI as is\n  return iri;\n};\n\n/**\n * Performs value compaction on an object with '@value' or '@id' as the only\n * property.\n *\n * @param activeCtx the active context.\n * @param activeProperty the active property that points to the value.\n * @param value the value to compact.\n * @param {Object} [options] - processing options.\n *\n * @return the compaction result.\n */\napi.compactValue = ({activeCtx, activeProperty, value, options}) => {\n  // value is a @value\n  if(_isValue(value)) {\n    // get context rules\n    const type = _getContextValue(activeCtx, activeProperty, '@type');\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    const container =\n      _getContextValue(activeCtx, activeProperty, '@container') || [];\n\n    // whether or not the value has an @index that must be preserved\n    const preserveIndex = '@index' in value && !container.includes('@index');\n\n    // if there's no @index to preserve ...\n    if(!preserveIndex && type !== '@none') {\n      // matching @type or @language specified in context, compact value\n      if(value['@type'] === type) {\n        return value['@value'];\n      }\n      if('@language' in value && value['@language'] === language &&\n         '@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n      if('@language' in value && value['@language'] === language) {\n        return value['@value'];\n      }\n      if('@direction' in value && value['@direction'] === direction) {\n        return value['@value'];\n      }\n    }\n\n    // return just the value of @value if all are true:\n    // 1. @value is the only key or @index isn't being preserved\n    // 2. there is no default language or @value is not a string or\n    //   the key has a mapping with a null @language\n    const keyCount = Object.keys(value).length;\n    const isValueOnlyKey = (keyCount === 1 ||\n      (keyCount === 2 && '@index' in value && !preserveIndex));\n    const hasDefaultLanguage = ('@language' in activeCtx);\n    const isValueString = _isString(value['@value']);\n    const hasNullMapping = (activeCtx.mappings.has(activeProperty) &&\n      activeCtx.mappings.get(activeProperty)['@language'] === null);\n    if(isValueOnlyKey &&\n      type !== '@none' &&\n      (!hasDefaultLanguage || !isValueString || hasNullMapping)) {\n      return value['@value'];\n    }\n\n    const rval = {};\n\n    // preserve @index\n    if(preserveIndex) {\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@index',\n        relativeTo: {vocab: true}\n      })] = value['@index'];\n    }\n\n    if('@type' in value) {\n      // compact @type IRI\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@type',\n        relativeTo: {vocab: true}\n      })] = api.compactIri(\n        {activeCtx, iri: value['@type'], relativeTo: {vocab: true}});\n    } else if('@language' in value) {\n      // alias @language\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@language',\n        relativeTo: {vocab: true}\n      })] = value['@language'];\n    }\n\n    if('@direction' in value) {\n      // alias @direction\n      rval[api.compactIri({\n        activeCtx,\n        iri: '@direction',\n        relativeTo: {vocab: true}\n      })] = value['@direction'];\n    }\n\n    // alias @value\n    rval[api.compactIri({\n      activeCtx,\n      iri: '@value',\n      relativeTo: {vocab: true}\n    })] = value['@value'];\n\n    return rval;\n  }\n\n  // value is a subject reference\n  const expandedProperty = _expandIri(activeCtx, activeProperty, {vocab: true},\n    options);\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n  const compacted = api.compactIri({\n    activeCtx,\n    iri: value['@id'],\n    relativeTo: {vocab: type === '@vocab'},\n    base: options.base});\n\n  // compact to scalar\n  if(type === '@id' || type === '@vocab' || expandedProperty === '@graph') {\n    return compacted;\n  }\n\n  return {\n    [api.compactIri({\n      activeCtx,\n      iri: '@id',\n      relativeTo: {vocab: true}\n    })]: compacted\n  };\n};\n\n/**\n * Picks the preferred compaction term from the given inverse context entry.\n *\n * @param activeCtx the active context.\n * @param iri the IRI to pick the term for.\n * @param value the value to pick the term for.\n * @param containers the preferred containers.\n * @param typeOrLanguage either '@type' or '@language'.\n * @param typeOrLanguageValue the preferred value for '@type' or '@language'.\n *\n * @return the preferred term.\n */\nfunction _selectTerm(\n  activeCtx, iri, value, containers, typeOrLanguage, typeOrLanguageValue) {\n  if(typeOrLanguageValue === null) {\n    typeOrLanguageValue = '@null';\n  }\n\n  // preferences for the value of @type or @language\n  const prefs = [];\n\n  // determine prefs for @id based on whether or not value compacts to a term\n  if((typeOrLanguageValue === '@id' || typeOrLanguageValue === '@reverse') &&\n    _isObject(value) && '@id' in value) {\n    // prefer @reverse first\n    if(typeOrLanguageValue === '@reverse') {\n      prefs.push('@reverse');\n    }\n    // try to compact value to a term\n    const term = api.compactIri(\n      {activeCtx, iri: value['@id'], relativeTo: {vocab: true}});\n    if(activeCtx.mappings.has(term) &&\n      activeCtx.mappings.get(term) &&\n      activeCtx.mappings.get(term)['@id'] === value['@id']) {\n      // prefer @vocab\n      prefs.push.apply(prefs, ['@vocab', '@id']);\n    } else {\n      // prefer @id\n      prefs.push.apply(prefs, ['@id', '@vocab']);\n    }\n  } else {\n    prefs.push(typeOrLanguageValue);\n\n    // consider direction only\n    const langDir = prefs.find(el => el.includes('_'));\n    if(langDir) {\n      // consider _dir portion\n      prefs.push(langDir.replace(/^[^_]+_/, '_'));\n    }\n  }\n  prefs.push('@none');\n\n  const containerMap = activeCtx.inverse[iri];\n  for(const container of containers) {\n    // if container not available in the map, continue\n    if(!(container in containerMap)) {\n      continue;\n    }\n\n    const typeOrLanguageValueMap = containerMap[container][typeOrLanguage];\n    for(const pref of prefs) {\n      // if type/language option not available in the map, continue\n      if(!(pref in typeOrLanguageValueMap)) {\n        continue;\n      }\n\n      // select term\n      return typeOrLanguageValueMap[pref];\n    }\n  }\n\n  return null;\n}\n\n/**\n * The value of `@nest` in the term definition must either be `@nest`, or a term\n * which resolves to `@nest`.\n *\n * @param activeCtx the active context.\n * @param nestProperty a term in the active context or `@nest`.\n * @param {Object} [options] - processing options.\n */\nfunction _checkNestProperty(activeCtx, nestProperty, options) {\n  if(_expandIri(activeCtx, nestProperty, {vocab: true}, options) !== '@nest') {\n    throw new JsonLdError(\n      'JSON-LD compact error; nested property must have an @nest value ' +\n      'resolving to @nest.',\n      'jsonld.SyntaxError', {code: 'invalid @nest value'});\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}