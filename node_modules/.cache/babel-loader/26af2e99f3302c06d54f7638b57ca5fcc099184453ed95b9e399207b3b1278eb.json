{"ast":null,"code":"function isString(s) {\n  return typeof s === 'string' || s instanceof String;\n}\nconst xsdString = 'http://www.w3.org/2001/XMLSchema#string';\nfunction termToId(term) {\n  if (typeof term === 'string') {\n    return term;\n  }\n  if (!term) {\n    return '';\n  }\n  if (typeof term.id !== 'undefined' && term.termType !== 'Quad') {\n    return term.id;\n  }\n  let subject, predicate, object, graph;\n\n  // Term instantiated with another library\n  switch (term.termType) {\n    case 'NamedNode':\n      return term.value;\n    case 'BlankNode':\n      return `_:${term.value}`;\n    case 'Variable':\n      return `?${term.value}`;\n    case 'DefaultGraph':\n      return '';\n    case 'Literal':\n      if (term.language) {\n        return `\"${term.value}\"@${term.language}`;\n      }\n      return `\"${term.value}\"${term.datatype && term.datatype.value !== xsdString ? `^^${term.datatype.value}` : ''}`;\n    case 'Quad':\n      // To identify RDF* quad components, we escape quotes by doubling them.\n      // This avoids the overhead of backslash parsing of Turtle-like syntaxes.\n      subject = escapeQuotes(termToId(term.subject));\n      predicate = escapeQuotes(termToId(term.predicate));\n      object = escapeQuotes(termToId(term.object));\n      graph = term.graph.termType === 'DefaultGraph' ? '' : ` ${termToId(term.graph)}`;\n      return `<<${subject} ${predicate} ${object}${graph}>>`;\n    default:\n      throw new Error(`Unexpected termType: ${term.termType}`);\n  }\n}\nconst escapedLiteral = /^\"(.*\".*)(?=\"[^\"]*$)/;\nfunction escapeQuotes(id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"/g, '\"\"')}`);\n}\nclass DatasetCore {\n  constructor(quads) {\n    // The number of quads is initially zero\n    this._size = 0;\n    // `_graphs` contains subject, predicate, and object indexes per graph\n    this._graphs = Object.create(null);\n    // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n    this._id = 0;\n    this._ids = Object.create(null);\n    this._ids['><'] = 0; // dummy entry, so the first actual key is non-zero\n    this._entities = Object.create(null); // inverse of `_ids`\n\n    this._quads = new Map();\n\n    // Add quads if passed\n    if (quads) {\n      for (const quad of quads) {\n        this.add(quad);\n      }\n    }\n  }\n  get size() {\n    // Return the quad count if if was cached\n    let size = this._size;\n    if (size !== null) {\n      return size;\n    }\n\n    // Calculate the number of quads by counting to the deepest level\n    size = 0;\n    const graphs = this._graphs;\n    let subjects, subject;\n    for (const graphKey in graphs) {\n      for (const subjectKey in subjects = graphs[graphKey].subjects) {\n        for (const predicateKey in subject = subjects[subjectKey]) {\n          size += Object.keys(subject[predicateKey]).length;\n        }\n      }\n    }\n    this._size = size;\n    return this._size;\n  }\n  add(quad) {\n    // Convert terms to internal string representation\n    let subject = termToId(quad.subject);\n    let predicate = termToId(quad.predicate);\n    let object = termToId(quad.object);\n    const graph = termToId(quad.graph);\n\n    // Find the graph that will contain the triple\n    let graphItem = this._graphs[graph];\n    // Create the graph if it doesn't exist yet\n    if (!graphItem) {\n      graphItem = this._graphs[graph] = {\n        subjects: {},\n        predicates: {},\n        objects: {}\n      };\n      // Freezing a graph helps subsequent `add` performance,\n      // and properties will never be modified anyway\n      Object.freeze(graphItem);\n    }\n\n    // Since entities can often be long IRIs, we avoid storing them in every index.\n    // Instead, we have a separate index that maps entities to numbers,\n    // which are then used as keys in the other indexes.\n    const ids = this._ids;\n    const entities = this._entities;\n    subject = ids[subject] || (ids[entities[++this._id] = subject] = this._id);\n    predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);\n    object = ids[object] || (ids[entities[++this._id] = object] = this._id);\n    this._addToIndex(graphItem.subjects, subject, predicate, object);\n    this._addToIndex(graphItem.predicates, predicate, object, subject);\n    this._addToIndex(graphItem.objects, object, subject, predicate);\n    this._setQuad(subject, predicate, object, graph, quad);\n\n    // The cached quad count is now invalid\n    this._size = null;\n    return this;\n  }\n  delete(quad) {\n    // Convert terms to internal string representation\n    let subject = termToId(quad.subject);\n    let predicate = termToId(quad.predicate);\n    let object = termToId(quad.object);\n    const graph = termToId(quad.graph);\n\n    // Find internal identifiers for all components\n    // and verify the quad exists.\n    const ids = this._ids;\n    const graphs = this._graphs;\n    let graphItem, subjects, predicates;\n    if (!(subject = ids[subject]) || !(predicate = ids[predicate]) || !(object = ids[object]) || !(graphItem = graphs[graph]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object in predicates)) {\n      return this;\n    }\n\n    // Remove it from all indexes\n    this._removeFromIndex(graphItem.subjects, subject, predicate, object);\n    this._removeFromIndex(graphItem.predicates, predicate, object, subject);\n    this._removeFromIndex(graphItem.objects, object, subject, predicate);\n    if (this._size !== null) {\n      this._size--;\n    }\n    this._deleteQuad(subject, predicate, object, graph);\n\n    // Remove the graph if it is empty\n    for (subject in graphItem.subjects) {\n      // eslint-disable-line no-unreachable-loop\n      return this;\n    }\n    delete graphs[graph];\n    return this;\n  }\n  has(quad) {\n    // Convert terms to internal string representation\n    const subject = termToId(quad.subject);\n    const predicate = termToId(quad.predicate);\n    const object = termToId(quad.object);\n    const graph = termToId(quad.graph);\n    const graphItem = this._graphs[graph];\n    if (!graphItem) {\n      return false;\n    }\n    const ids = this._ids;\n    let subjectId, predicateId, objectId;\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) {\n      return false;\n    }\n    return this._countInIndex(graphItem.objects, objectId, subjectId, predicateId) === 1;\n  }\n  match(subject, predicate, object, graph) {\n    return this._createDataset(this._match(subject, predicate, object, graph));\n  }\n  [Symbol.iterator]() {\n    return this._match()[Symbol.iterator]();\n  }\n\n  // ## Private methods\n\n  // ### `_addToIndex` adds a quad to a three-layered index.\n  // Returns if the index has changed, if the entry did not already exist.\n  _addToIndex(index0, key0, key1, key2) {\n    // Create layers as necessary\n    const index1 = index0[key0] || (index0[key0] = {});\n    const index2 = index1[key1] || (index1[key1] = {});\n    // Setting the key to _any_ value signals the presence of the quad\n    const existed = (key2 in index2);\n    if (!existed) {\n      index2[key2] = null;\n    }\n    return !existed;\n  }\n\n  // ### `_removeFromIndex` removes a quad from a three-layered index\n  _removeFromIndex(index0, key0, key1, key2) {\n    // Remove the quad from the index\n    const index1 = index0[key0];\n    const index2 = index1[key1];\n    delete index2[key2];\n\n    // Remove intermediary index layers if they are empty\n    for (const key in index2) {\n      // eslint-disable-line no-unreachable-loop\n      return;\n    }\n    delete index1[key1];\n    for (const key in index1) {\n      // eslint-disable-line no-unreachable-loop\n      return;\n    }\n    delete index0[key0];\n  }\n\n  // ### `_findInIndex` finds a set of quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  // `name0`, `name1`, and `name2` are the names of the keys at each level,\n  // used when reconstructing the resulting quad\n  // (for instance: _subject_, _predicate_, and _object_).\n  // Finally, `graph` will be the graph of the created quads.\n  // If `callback` is given, each result is passed through it\n  // and iteration halts when it returns truthy for any quad.\n  // If instead `array` is given, each result is added to the array.\n  _findInIndex(index0, key0, key1, key2, name0, name1, name2, graph, callback, array) {\n    let tmp, index1, index2;\n\n    // If a key is specified, use only that part of index 0.\n    if (key0) {\n      (tmp = index0, index0 = {})[key0] = tmp[key0];\n    }\n    for (const value0 in index0) {\n      index1 = index0[value0];\n      if (index1) {\n        // If a key is specified, use only that part of index 1.\n        if (key1) {\n          (tmp = index1, index1 = {})[key1] = tmp[key1];\n        }\n        for (const value1 in index1) {\n          index2 = index1[value1];\n          if (index2) {\n            // If a key is specified, use only that part of index 2, if it exists.\n            const values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2);\n            // Create quads for all items found in index 2.\n            for (let l = 0; l < values.length; l++) {\n              const parts = {\n                [name0]: value0,\n                [name1]: value1,\n                [name2]: values[l]\n              };\n              const quad = this._getQuad(parts.subject, parts.predicate, parts.object, graph);\n              if (array) {\n                array.push(quad);\n              } else if (callback(quad)) {\n                return true;\n              }\n            }\n          }\n        }\n      }\n    }\n    return array;\n  }\n\n  // ### `_countInIndex` counts matching quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  _countInIndex(index0, key0, key1, key2) {\n    let count = 0;\n    let tmp, index1, index2;\n\n    // If a key is specified, count only that part of index 0\n    if (key0) {\n      (tmp = index0, index0 = {})[key0] = tmp[key0];\n    }\n    for (const value0 in index0) {\n      index1 = index0[value0];\n      if (index1) {\n        // If a key is specified, count only that part of index 1\n        if (key1) {\n          (tmp = index1, index1 = {})[key1] = tmp[key1];\n        }\n        for (const value1 in index1) {\n          index2 = index1[value1];\n          if (index2) {\n            if (key2) {\n              // If a key is specified, count the quad if it exists\n              key2 in index2 && count++;\n            } else {\n              // Otherwise, count all quads\n              count += Object.keys(index2).length;\n            }\n          }\n        }\n      }\n    }\n    return count;\n  }\n\n  // ### `_getGraphs` returns an array with the given graph,\n  // or all graphs if the argument is null or undefined.\n  _getGraphs(graph) {\n    if (!isString(graph)) {\n      return this._graphs;\n    }\n    return {\n      [graph]: this._graphs[graph]\n    };\n  }\n  _match(subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n    const quads = [];\n    const graphs = this._getGraphs(graph);\n    const ids = this._ids;\n    let content, subjectId, predicateId, objectId;\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) {\n      return quads;\n    }\n    for (const graphId in graphs) {\n      content = graphs[graphId];\n\n      // Only if the specified graph contains triples, there can be results\n      if (content) {\n        // Choose the optimal index, based on what fields are present\n        if (subjectId) {\n          if (objectId) {\n            // If subject and object are given, the object index will be the fastest\n            this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId, null, quads);\n          } else {\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId, null, quads);\n          }\n        } else if (predicateId) {\n          // if only predicate and possibly object are given, the predicate index will be the fastest\n          this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId, null, quads);\n        } else if (objectId) {\n          // If only object is given, the object index will be the fastest\n          this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId, null, quads);\n        } else {\n          // If nothing is given, iterate subjects and predicates first\n          this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId, null, quads);\n        }\n      }\n    }\n    return quads;\n  }\n  _getQuad(subjectId, predicateId, objectId, graphId) {\n    return this._quads.get(this._toId(subjectId, predicateId, objectId, graphId));\n  }\n  _setQuad(subjectId, predicateId, objectId, graphId, quad) {\n    this._quads.set(this._toId(subjectId, predicateId, objectId, graphId), quad);\n  }\n  _deleteQuad(subjectId, predicateId, objectId, graphId) {\n    this._quads.delete(this._toId(subjectId, predicateId, objectId, graphId));\n  }\n  _createDataset(quads) {\n    return new this.constructor(quads);\n  }\n  _toId(subjectId, predicateId, objectId, graphId) {\n    return `${subjectId}:${predicateId}:${objectId}:${graphId}`;\n  }\n}\nmodule.exports = DatasetCore;","map":{"version":3,"names":["isString","s","String","xsdString","termToId","term","id","termType","subject","predicate","object","graph","value","language","datatype","escapeQuotes","Error","escapedLiteral","replace","_","quoted","DatasetCore","constructor","quads","_size","_graphs","Object","create","_id","_ids","_entities","_quads","Map","quad","add","size","graphs","subjects","graphKey","subjectKey","predicateKey","keys","length","graphItem","predicates","objects","freeze","ids","entities","_addToIndex","_setQuad","delete","_removeFromIndex","_deleteQuad","has","subjectId","predicateId","objectId","_countInIndex","match","_createDataset","_match","Symbol","iterator","index0","key0","key1","key2","index1","index2","existed","key","_findInIndex","name0","name1","name2","callback","array","tmp","value0","value1","values","l","parts","_getQuad","push","count","_getGraphs","content","graphId","get","_toId","set","module","exports"],"sources":["G:/To-do-List_App-main/node_modules/@rdfjs/dataset/DatasetCore.js"],"sourcesContent":["function isString (s) {\n  return typeof s === 'string' || s instanceof String\n}\n\nconst xsdString = 'http://www.w3.org/2001/XMLSchema#string'\n\nfunction termToId (term) {\n  if (typeof term === 'string') {\n    return term\n  }\n\n  if (!term) {\n    return ''\n  }\n\n  if (typeof term.id !== 'undefined' && term.termType !== 'Quad') {\n    return term.id\n  }\n\n  let subject, predicate, object, graph\n\n  // Term instantiated with another library\n  switch (term.termType) {\n    case 'NamedNode':\n      return term.value\n\n    case 'BlankNode':\n      return `_:${term.value}`\n\n    case 'Variable':\n      return `?${term.value}`\n\n    case 'DefaultGraph':\n      return ''\n\n    case 'Literal':\n      if (term.language) {\n        return `\"${term.value}\"@${term.language}`\n      }\n\n      return `\"${term.value}\"${term.datatype && term.datatype.value !== xsdString ? `^^${term.datatype.value}` : ''}`\n\n    case 'Quad':\n      // To identify RDF* quad components, we escape quotes by doubling them.\n      // This avoids the overhead of backslash parsing of Turtle-like syntaxes.\n      subject = escapeQuotes(termToId(term.subject))\n      predicate = escapeQuotes(termToId(term.predicate))\n      object = escapeQuotes(termToId(term.object))\n      graph = term.graph.termType === 'DefaultGraph' ? '' : ` ${termToId(term.graph)}`\n\n      return `<<${subject} ${predicate} ${object}${graph}>>`\n\n    default:\n      throw new Error(`Unexpected termType: ${term.termType}`)\n  }\n}\n\nconst escapedLiteral = /^\"(.*\".*)(?=\"[^\"]*$)/\n\nfunction escapeQuotes (id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"/g, '\"\"')}`)\n}\n\nclass DatasetCore {\n  constructor (quads) {\n    // The number of quads is initially zero\n    this._size = 0\n    // `_graphs` contains subject, predicate, and object indexes per graph\n    this._graphs = Object.create(null)\n    // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n    this._id = 0\n    this._ids = Object.create(null)\n    this._ids['><'] = 0 // dummy entry, so the first actual key is non-zero\n    this._entities = Object.create(null) // inverse of `_ids`\n\n    this._quads = new Map()\n\n    // Add quads if passed\n    if (quads) {\n      for (const quad of quads) {\n        this.add(quad)\n      }\n    }\n  }\n\n  get size () {\n    // Return the quad count if if was cached\n    let size = this._size\n\n    if (size !== null) {\n      return size\n    }\n\n    // Calculate the number of quads by counting to the deepest level\n    size = 0\n    const graphs = this._graphs\n    let subjects, subject\n\n    for (const graphKey in graphs) {\n      for (const subjectKey in (subjects = graphs[graphKey].subjects)) {\n        for (const predicateKey in (subject = subjects[subjectKey])) {\n          size += Object.keys(subject[predicateKey]).length\n        }\n      }\n    }\n\n    this._size = size\n\n    return this._size\n  }\n\n  add (quad) {\n    // Convert terms to internal string representation\n    let subject = termToId(quad.subject)\n    let predicate = termToId(quad.predicate)\n    let object = termToId(quad.object)\n    const graph = termToId(quad.graph)\n\n    // Find the graph that will contain the triple\n    let graphItem = this._graphs[graph]\n    // Create the graph if it doesn't exist yet\n    if (!graphItem) {\n      graphItem = this._graphs[graph] = { subjects: {}, predicates: {}, objects: {} }\n      // Freezing a graph helps subsequent `add` performance,\n      // and properties will never be modified anyway\n      Object.freeze(graphItem)\n    }\n\n    // Since entities can often be long IRIs, we avoid storing them in every index.\n    // Instead, we have a separate index that maps entities to numbers,\n    // which are then used as keys in the other indexes.\n    const ids = this._ids\n    const entities = this._entities\n    subject = ids[subject] || (ids[entities[++this._id] = subject] = this._id)\n    predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id)\n    object = ids[object] || (ids[entities[++this._id] = object] = this._id)\n\n    this._addToIndex(graphItem.subjects, subject, predicate, object)\n    this._addToIndex(graphItem.predicates, predicate, object, subject)\n    this._addToIndex(graphItem.objects, object, subject, predicate)\n\n    this._setQuad(subject, predicate, object, graph, quad)\n\n    // The cached quad count is now invalid\n    this._size = null\n\n    return this\n  }\n\n  delete (quad) {\n    // Convert terms to internal string representation\n    let subject = termToId(quad.subject)\n    let predicate = termToId(quad.predicate)\n    let object = termToId(quad.object)\n    const graph = termToId(quad.graph)\n\n    // Find internal identifiers for all components\n    // and verify the quad exists.\n    const ids = this._ids\n    const graphs = this._graphs\n    let graphItem, subjects, predicates\n\n    if (!(subject = ids[subject]) || !(predicate = ids[predicate]) ||\n      !(object = ids[object]) || !(graphItem = graphs[graph]) ||\n      !(subjects = graphItem.subjects[subject]) ||\n      !(predicates = subjects[predicate]) ||\n      !(object in predicates)\n    ) {\n      return this\n    }\n\n    // Remove it from all indexes\n    this._removeFromIndex(graphItem.subjects, subject, predicate, object)\n    this._removeFromIndex(graphItem.predicates, predicate, object, subject)\n    this._removeFromIndex(graphItem.objects, object, subject, predicate)\n\n    if (this._size !== null) {\n      this._size--\n    }\n\n    this._deleteQuad(subject, predicate, object, graph)\n\n    // Remove the graph if it is empty\n    for (subject in graphItem.subjects) { // eslint-disable-line no-unreachable-loop\n      return this\n    }\n\n    delete graphs[graph]\n\n    return this\n  }\n\n  has (quad) {\n    // Convert terms to internal string representation\n    const subject = termToId(quad.subject)\n    const predicate = termToId(quad.predicate)\n    const object = termToId(quad.object)\n    const graph = termToId(quad.graph)\n\n    const graphItem = this._graphs[graph]\n\n    if (!graphItem) {\n      return false\n    }\n\n    const ids = this._ids\n    let subjectId, predicateId, objectId\n\n    // Translate IRIs to internal index keys.\n    if (\n      (isString(subject) && !(subjectId = ids[subject])) ||\n      (isString(predicate) && !(predicateId = ids[predicate])) ||\n      (isString(object) && !(objectId = ids[object]))\n    ) {\n      return false\n    }\n\n    return this._countInIndex(graphItem.objects, objectId, subjectId, predicateId) === 1\n  }\n\n  match (subject, predicate, object, graph) {\n    return this._createDataset(this._match(subject, predicate, object, graph))\n  }\n\n  [Symbol.iterator] () {\n    return this._match()[Symbol.iterator]()\n  }\n\n  // ## Private methods\n\n  // ### `_addToIndex` adds a quad to a three-layered index.\n  // Returns if the index has changed, if the entry did not already exist.\n  _addToIndex (index0, key0, key1, key2) {\n    // Create layers as necessary\n    const index1 = index0[key0] || (index0[key0] = {})\n    const index2 = index1[key1] || (index1[key1] = {})\n    // Setting the key to _any_ value signals the presence of the quad\n    const existed = key2 in index2\n\n    if (!existed) {\n      index2[key2] = null\n    }\n\n    return !existed\n  }\n\n  // ### `_removeFromIndex` removes a quad from a three-layered index\n  _removeFromIndex (index0, key0, key1, key2) {\n    // Remove the quad from the index\n    const index1 = index0[key0]\n    const index2 = index1[key1]\n    delete index2[key2]\n\n    // Remove intermediary index layers if they are empty\n    for (const key in index2) { // eslint-disable-line no-unreachable-loop\n      return\n    }\n\n    delete index1[key1]\n\n    for (const key in index1) { // eslint-disable-line no-unreachable-loop\n      return\n    }\n\n    delete index0[key0]\n  }\n\n  // ### `_findInIndex` finds a set of quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  // `name0`, `name1`, and `name2` are the names of the keys at each level,\n  // used when reconstructing the resulting quad\n  // (for instance: _subject_, _predicate_, and _object_).\n  // Finally, `graph` will be the graph of the created quads.\n  // If `callback` is given, each result is passed through it\n  // and iteration halts when it returns truthy for any quad.\n  // If instead `array` is given, each result is added to the array.\n  _findInIndex (index0, key0, key1, key2, name0, name1, name2, graph, callback, array) {\n    let tmp, index1, index2\n\n    // If a key is specified, use only that part of index 0.\n    if (key0) {\n      (tmp = index0, index0 = {})[key0] = tmp[key0]\n    }\n\n    for (const value0 in index0) {\n      index1 = index0[value0]\n\n      if (index1) {\n        // If a key is specified, use only that part of index 1.\n        if (key1) {\n          (tmp = index1, index1 = {})[key1] = tmp[key1]\n        }\n\n        for (const value1 in index1) {\n          index2 = index1[value1]\n\n          if (index2) {\n            // If a key is specified, use only that part of index 2, if it exists.\n            const values = key2 ? (key2 in index2 ? [key2] : []) : Object.keys(index2)\n            // Create quads for all items found in index 2.\n            for (let l = 0; l < values.length; l++) {\n              const parts = {\n                [name0]: value0,\n                [name1]: value1,\n                [name2]: values[l]\n              }\n\n              const quad = this._getQuad(parts.subject, parts.predicate, parts.object, graph)\n\n              if (array) {\n                array.push(quad)\n              } else if (callback(quad)) {\n                return true\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return array\n  }\n\n  // ### `_countInIndex` counts matching quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  _countInIndex (index0, key0, key1, key2) {\n    let count = 0\n    let tmp, index1, index2\n\n    // If a key is specified, count only that part of index 0\n    if (key0) {\n      (tmp = index0, index0 = {})[key0] = tmp[key0]\n    }\n\n    for (const value0 in index0) {\n      index1 = index0[value0]\n\n      if (index1) {\n        // If a key is specified, count only that part of index 1\n        if (key1) {\n          (tmp = index1, index1 = {})[key1] = tmp[key1]\n        }\n\n        for (const value1 in index1) {\n          index2 = index1[value1]\n\n          if (index2) {\n            if (key2) {\n              // If a key is specified, count the quad if it exists\n              (key2 in index2) && count++\n            } else {\n              // Otherwise, count all quads\n              count += Object.keys(index2).length\n            }\n          }\n        }\n      }\n    }\n\n    return count\n  }\n\n  // ### `_getGraphs` returns an array with the given graph,\n  // or all graphs if the argument is null or undefined.\n  _getGraphs (graph) {\n    if (!isString(graph)) {\n      return this._graphs\n    }\n\n    return {\n      [graph]: this._graphs[graph]\n    }\n  }\n\n  _match (subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject)\n    predicate = predicate && termToId(predicate)\n    object = object && termToId(object)\n    graph = graph && termToId(graph)\n\n    const quads = []\n    const graphs = this._getGraphs(graph)\n    const ids = this._ids\n    let content, subjectId, predicateId, objectId\n\n    // Translate IRIs to internal index keys.\n    if (\n      (isString(subject) && !(subjectId = ids[subject])) ||\n      (isString(predicate) && !(predicateId = ids[predicate])) ||\n      (isString(object) && !(objectId = ids[object]))\n    ) {\n      return quads\n    }\n\n    for (const graphId in graphs) {\n      content = graphs[graphId]\n\n      // Only if the specified graph contains triples, there can be results\n      if (content) {\n        // Choose the optimal index, based on what fields are present\n        if (subjectId) {\n          if (objectId) {\n            // If subject and object are given, the object index will be the fastest\n            this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId, null, quads)\n          } else {\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId, null, quads)\n          }\n        } else if (predicateId) {\n          // if only predicate and possibly object are given, the predicate index will be the fastest\n          this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId, null, quads)\n        } else if (objectId) {\n          // If only object is given, the object index will be the fastest\n          this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId, null, quads)\n        } else {\n          // If nothing is given, iterate subjects and predicates first\n          this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId, null, quads)\n        }\n      }\n    }\n\n    return quads\n  }\n\n  _getQuad (subjectId, predicateId, objectId, graphId) {\n    return this._quads.get(this._toId(subjectId, predicateId, objectId, graphId))\n  }\n\n  _setQuad (subjectId, predicateId, objectId, graphId, quad) {\n    this._quads.set(this._toId(subjectId, predicateId, objectId, graphId), quad)\n  }\n\n  _deleteQuad (subjectId, predicateId, objectId, graphId) {\n    this._quads.delete(this._toId(subjectId, predicateId, objectId, graphId))\n  }\n\n  _createDataset (quads) {\n    return new this.constructor(quads)\n  }\n\n  _toId (subjectId, predicateId, objectId, graphId) {\n    return `${subjectId}:${predicateId}:${objectId}:${graphId}`\n  }\n}\n\nmodule.exports = DatasetCore\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}