{"ast":null,"code":"import _regeneratorRuntime from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport digest from '../runtime/digest.js';\nexport var encoder = new TextEncoder();\nexport var decoder = new TextDecoder();\nvar MAX_INT32 = Math.pow(2, 32);\nexport function concat() {\n  for (var _len = arguments.length, buffers = new Array(_len), _key = 0; _key < _len; _key++) {\n    buffers[_key] = arguments[_key];\n  }\n  var size = buffers.reduce(function (acc, _ref) {\n    var length = _ref.length;\n    return acc + length;\n  }, 0);\n  var buf = new Uint8Array(size);\n  var i = 0;\n  buffers.forEach(function (buffer) {\n    buf.set(buffer, i);\n    i += buffer.length;\n  });\n  return buf;\n}\nexport function p2s(alg, p2sInput) {\n  return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\nfunction writeUInt32BE(buf, value, offset) {\n  if (value < 0 || value >= MAX_INT32) {\n    throw new RangeError(\"value must be >= 0 and <= \".concat(MAX_INT32 - 1, \". Received \").concat(value));\n  }\n  buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n  var high = Math.floor(value / MAX_INT32);\n  var low = value % MAX_INT32;\n  var buf = new Uint8Array(8);\n  writeUInt32BE(buf, high, 0);\n  writeUInt32BE(buf, low, 4);\n  return buf;\n}\nexport function uint32be(value) {\n  var buf = new Uint8Array(4);\n  writeUInt32BE(buf, value);\n  return buf;\n}\nexport function lengthAndInput(input) {\n  return concat(uint32be(input.length), input);\n}\nexport function concatKdf(_x, _x2, _x3) {\n  return _concatKdf.apply(this, arguments);\n}\nfunction _concatKdf() {\n  _concatKdf = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(secret, bits, value) {\n    var iterations, res, iter, buf;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          iterations = Math.ceil((bits >> 3) / 32);\n          res = new Uint8Array(iterations * 32);\n          iter = 0;\n        case 3:\n          if (!(iter < iterations)) {\n            _context.next = 17;\n            break;\n          }\n          buf = new Uint8Array(4 + secret.length + value.length);\n          buf.set(uint32be(iter + 1));\n          buf.set(secret, 4);\n          buf.set(value, 4 + secret.length);\n          _context.t0 = res;\n          _context.next = 11;\n          return digest('sha256', buf);\n        case 11:\n          _context.t1 = _context.sent;\n          _context.t2 = iter * 32;\n          _context.t0.set.call(_context.t0, _context.t1, _context.t2);\n        case 14:\n          iter++;\n          _context.next = 3;\n          break;\n        case 17:\n          return _context.abrupt(\"return\", res.slice(0, bits >> 3));\n        case 18:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _concatKdf.apply(this, arguments);\n}","map":{"version":3,"names":["digest","encoder","TextEncoder","decoder","TextDecoder","MAX_INT32","concat","buffers","size","reduce","acc","length","buf","Uint8Array","i","forEach","buffer","set","p2s","alg","p2sInput","encode","writeUInt32BE","value","offset","RangeError","uint64be","high","Math","floor","low","uint32be","lengthAndInput","input","concatKdf","secret","bits","iterations","ceil","res","iter","slice"],"sources":["E:/react-todo-app/node_modules/jose/dist/browser/lib/buffer_utils.js"],"sourcesContent":["import digest from '../runtime/digest.js';\nexport const encoder = new TextEncoder();\nexport const decoder = new TextDecoder();\nconst MAX_INT32 = 2 ** 32;\nexport function concat(...buffers) {\n    const size = buffers.reduce((acc, { length }) => acc + length, 0);\n    const buf = new Uint8Array(size);\n    let i = 0;\n    buffers.forEach((buffer) => {\n        buf.set(buffer, i);\n        i += buffer.length;\n    });\n    return buf;\n}\nexport function p2s(alg, p2sInput) {\n    return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);\n}\nfunction writeUInt32BE(buf, value, offset) {\n    if (value < 0 || value >= MAX_INT32) {\n        throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);\n    }\n    buf.set([value >>> 24, value >>> 16, value >>> 8, value & 0xff], offset);\n}\nexport function uint64be(value) {\n    const high = Math.floor(value / MAX_INT32);\n    const low = value % MAX_INT32;\n    const buf = new Uint8Array(8);\n    writeUInt32BE(buf, high, 0);\n    writeUInt32BE(buf, low, 4);\n    return buf;\n}\nexport function uint32be(value) {\n    const buf = new Uint8Array(4);\n    writeUInt32BE(buf, value);\n    return buf;\n}\nexport function lengthAndInput(input) {\n    return concat(uint32be(input.length), input);\n}\nexport async function concatKdf(secret, bits, value) {\n    const iterations = Math.ceil((bits >> 3) / 32);\n    const res = new Uint8Array(iterations * 32);\n    for (let iter = 0; iter < iterations; iter++) {\n        const buf = new Uint8Array(4 + secret.length + value.length);\n        buf.set(uint32be(iter + 1));\n        buf.set(secret, 4);\n        buf.set(value, 4 + secret.length);\n        res.set(await digest('sha256', buf), iter * 32);\n    }\n    return res.slice(0, bits >> 3);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}