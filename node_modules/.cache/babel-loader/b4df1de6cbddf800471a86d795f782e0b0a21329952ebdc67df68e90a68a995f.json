{"ast":null,"code":"import _regeneratorRuntime from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _defineProperty from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _slicedToArray from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _asyncToGenerator from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _classCallCheck from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { FlattenedEncrypt, unprotected } from '../flattened/encrypt.js';\nimport { JWEInvalid } from '../../util/errors.js';\nimport generateCek from '../../lib/cek.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { encode as base64url } from '../../runtime/base64url.js';\nimport validateCrit from '../../lib/validate_crit.js';\nvar IndividualRecipient = /*#__PURE__*/function () {\n  function IndividualRecipient(enc, key, options) {\n    _classCallCheck(this, IndividualRecipient);\n    this.parent = enc;\n    this.key = key;\n    this.options = options;\n  }\n  _createClass(IndividualRecipient, [{\n    key: \"setUnprotectedHeader\",\n    value: function setUnprotectedHeader(unprotectedHeader) {\n      if (this.unprotectedHeader) {\n        throw new TypeError('setUnprotectedHeader can only be called once');\n      }\n      this.unprotectedHeader = unprotectedHeader;\n      return this;\n    }\n  }, {\n    key: \"addRecipient\",\n    value: function addRecipient() {\n      var _this$parent;\n      return (_this$parent = this.parent).addRecipient.apply(_this$parent, arguments);\n    }\n  }, {\n    key: \"encrypt\",\n    value: function encrypt() {\n      var _this$parent2;\n      return (_this$parent2 = this.parent).encrypt.apply(_this$parent2, arguments);\n    }\n  }, {\n    key: \"done\",\n    value: function done() {\n      return this.parent;\n    }\n  }]);\n  return IndividualRecipient;\n}();\nexport var GeneralEncrypt = /*#__PURE__*/function () {\n  function GeneralEncrypt(plaintext) {\n    _classCallCheck(this, GeneralEncrypt);\n    this._recipients = [];\n    this._plaintext = plaintext;\n  }\n  _createClass(GeneralEncrypt, [{\n    key: \"addRecipient\",\n    value: function addRecipient(key, options) {\n      var recipient = new IndividualRecipient(this, key, {\n        crit: options === null || options === void 0 ? void 0 : options.crit\n      });\n      this._recipients.push(recipient);\n      return recipient;\n    }\n  }, {\n    key: \"setProtectedHeader\",\n    value: function setProtectedHeader(protectedHeader) {\n      if (this._protectedHeader) {\n        throw new TypeError('setProtectedHeader can only be called once');\n      }\n      this._protectedHeader = protectedHeader;\n      return this;\n    }\n  }, {\n    key: \"setSharedUnprotectedHeader\",\n    value: function setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n      if (this._unprotectedHeader) {\n        throw new TypeError('setSharedUnprotectedHeader can only be called once');\n      }\n      this._unprotectedHeader = sharedUnprotectedHeader;\n      return this;\n    }\n  }, {\n    key: \"setAdditionalAuthenticatedData\",\n    value: function setAdditionalAuthenticatedData(aad) {\n      this._aad = aad;\n      return this;\n    }\n  }, {\n    key: \"encrypt\",\n    value: function () {\n      var _encrypt = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options) {\n        var _a, _b, _c, _this$_recipients, recipient, flattened, _jwe, enc, i, _recipient, joseHeader, alg, cek, jwe, _i, _recipient2, target, _joseHeader, p2c, _flattened, _yield$encryptKeyMana, encryptedKey, parameters;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (this._recipients.length) {\n                _context.next = 2;\n                break;\n              }\n              throw new JWEInvalid('at least one recipient must be added');\n            case 2:\n              options = {\n                deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw\n              };\n              if (!(this._recipients.length === 1)) {\n                _context.next = 15;\n                break;\n              }\n              _this$_recipients = _slicedToArray(this._recipients, 1), recipient = _this$_recipients[0];\n              _context.next = 7;\n              return new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, _objectSpread(_objectSpread({}, recipient.options), options));\n            case 7:\n              flattened = _context.sent;\n              _jwe = {\n                ciphertext: flattened.ciphertext,\n                iv: flattened.iv,\n                recipients: [{}],\n                tag: flattened.tag\n              };\n              if (flattened.aad) _jwe.aad = flattened.aad;\n              if (flattened.protected) _jwe.protected = flattened.protected;\n              if (flattened.unprotected) _jwe.unprotected = flattened.unprotected;\n              if (flattened.encrypted_key) _jwe.recipients[0].encrypted_key = flattened.encrypted_key;\n              if (flattened.header) _jwe.recipients[0].header = flattened.header;\n              return _context.abrupt(\"return\", _jwe);\n            case 15:\n              i = 0;\n            case 16:\n              if (!(i < this._recipients.length)) {\n                _context.next = 41;\n                break;\n              }\n              _recipient = this._recipients[i];\n              if (isDisjoint(this._protectedHeader, this._unprotectedHeader, _recipient.unprotectedHeader)) {\n                _context.next = 20;\n                break;\n              }\n              throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n            case 20:\n              joseHeader = _objectSpread(_objectSpread(_objectSpread({}, this._protectedHeader), this._unprotectedHeader), _recipient.unprotectedHeader);\n              alg = joseHeader.alg;\n              if (!(typeof alg !== 'string' || !alg)) {\n                _context.next = 24;\n                break;\n              }\n              throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n            case 24:\n              if (!(alg === 'dir' || alg === 'ECDH-ES')) {\n                _context.next = 26;\n                break;\n              }\n              throw new JWEInvalid('\"dir\" and \"ECDH-ES\" alg may only be used with a single recipient');\n            case 26:\n              if (!(typeof joseHeader.enc !== 'string' || !joseHeader.enc)) {\n                _context.next = 28;\n                break;\n              }\n              throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n            case 28:\n              if (enc) {\n                _context.next = 32;\n                break;\n              }\n              enc = joseHeader.enc;\n              _context.next = 34;\n              break;\n            case 32:\n              if (!(enc !== joseHeader.enc)) {\n                _context.next = 34;\n                break;\n              }\n              throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter must be the same for all recipients');\n            case 34:\n              validateCrit(JWEInvalid, new Map(), _recipient.options.crit, this._protectedHeader, joseHeader);\n              if (!(joseHeader.zip !== undefined)) {\n                _context.next = 38;\n                break;\n              }\n              if (!(!this._protectedHeader || !this._protectedHeader.zip)) {\n                _context.next = 38;\n                break;\n              }\n              throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n            case 38:\n              i++;\n              _context.next = 16;\n              break;\n            case 41:\n              cek = generateCek(enc);\n              jwe = {\n                ciphertext: '',\n                iv: '',\n                recipients: [],\n                tag: ''\n              };\n              _i = 0;\n            case 44:\n              if (!(_i < this._recipients.length)) {\n                _context.next = 73;\n                break;\n              }\n              _recipient2 = this._recipients[_i];\n              target = {};\n              jwe.recipients.push(target);\n              _joseHeader = _objectSpread(_objectSpread(_objectSpread({}, this._protectedHeader), this._unprotectedHeader), _recipient2.unprotectedHeader);\n              p2c = _joseHeader.alg.startsWith('PBES2') ? 2048 + _i : undefined;\n              if (!(_i === 0)) {\n                _context.next = 63;\n                break;\n              }\n              _context.next = 53;\n              return new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(_recipient2.unprotectedHeader).setKeyManagementParameters({\n                p2c: p2c\n              }).encrypt(_recipient2.key, _objectSpread(_objectSpread(_objectSpread({}, _recipient2.options), options), {}, _defineProperty({}, unprotected, true)));\n            case 53:\n              _flattened = _context.sent;\n              jwe.ciphertext = _flattened.ciphertext;\n              jwe.iv = _flattened.iv;\n              jwe.tag = _flattened.tag;\n              if (_flattened.aad) jwe.aad = _flattened.aad;\n              if (_flattened.protected) jwe.protected = _flattened.protected;\n              if (_flattened.unprotected) jwe.unprotected = _flattened.unprotected;\n              target.encrypted_key = _flattened.encrypted_key;\n              if (_flattened.header) target.header = _flattened.header;\n              return _context.abrupt(\"continue\", 70);\n            case 63:\n              _context.next = 65;\n              return encryptKeyManagement(((_a = _recipient2.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) || ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) || ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, _recipient2.key, cek, {\n                p2c: p2c\n              });\n            case 65:\n              _yield$encryptKeyMana = _context.sent;\n              encryptedKey = _yield$encryptKeyMana.encryptedKey;\n              parameters = _yield$encryptKeyMana.parameters;\n              target.encrypted_key = base64url(encryptedKey);\n              if (_recipient2.unprotectedHeader || parameters) target.header = _objectSpread(_objectSpread({}, _recipient2.unprotectedHeader), parameters);\n            case 70:\n              _i++;\n              _context.next = 44;\n              break;\n            case 73:\n              return _context.abrupt(\"return\", jwe);\n            case 74:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function encrypt(_x) {\n        return _encrypt.apply(this, arguments);\n      }\n      return encrypt;\n    }()\n  }]);\n  return GeneralEncrypt;\n}();","map":{"version":3,"names":["FlattenedEncrypt","unprotected","JWEInvalid","generateCek","isDisjoint","encryptKeyManagement","encode","base64url","validateCrit","IndividualRecipient","enc","key","options","parent","unprotectedHeader","TypeError","addRecipient","encrypt","GeneralEncrypt","plaintext","_recipients","_plaintext","recipient","crit","push","protectedHeader","_protectedHeader","sharedUnprotectedHeader","_unprotectedHeader","aad","_aad","length","deflateRaw","setAdditionalAuthenticatedData","setProtectedHeader","setSharedUnprotectedHeader","setUnprotectedHeader","flattened","jwe","ciphertext","iv","recipients","tag","protected","encrypted_key","header","i","joseHeader","alg","Map","zip","undefined","cek","target","p2c","startsWith","setContentEncryptionKey","setKeyManagementParameters","_a","_b","_c","encryptedKey","parameters"],"sources":["E:/react-todo-app/node_modules/jose/dist/browser/jwe/general/encrypt.js"],"sourcesContent":["import { FlattenedEncrypt, unprotected } from '../flattened/encrypt.js';\nimport { JWEInvalid } from '../../util/errors.js';\nimport generateCek from '../../lib/cek.js';\nimport isDisjoint from '../../lib/is_disjoint.js';\nimport encryptKeyManagement from '../../lib/encrypt_key_management.js';\nimport { encode as base64url } from '../../runtime/base64url.js';\nimport validateCrit from '../../lib/validate_crit.js';\nclass IndividualRecipient {\n    constructor(enc, key, options) {\n        this.parent = enc;\n        this.key = key;\n        this.options = options;\n    }\n    setUnprotectedHeader(unprotectedHeader) {\n        if (this.unprotectedHeader) {\n            throw new TypeError('setUnprotectedHeader can only be called once');\n        }\n        this.unprotectedHeader = unprotectedHeader;\n        return this;\n    }\n    addRecipient(...args) {\n        return this.parent.addRecipient(...args);\n    }\n    encrypt(...args) {\n        return this.parent.encrypt(...args);\n    }\n    done() {\n        return this.parent;\n    }\n}\nexport class GeneralEncrypt {\n    constructor(plaintext) {\n        this._recipients = [];\n        this._plaintext = plaintext;\n    }\n    addRecipient(key, options) {\n        const recipient = new IndividualRecipient(this, key, { crit: options === null || options === void 0 ? void 0 : options.crit });\n        this._recipients.push(recipient);\n        return recipient;\n    }\n    setProtectedHeader(protectedHeader) {\n        if (this._protectedHeader) {\n            throw new TypeError('setProtectedHeader can only be called once');\n        }\n        this._protectedHeader = protectedHeader;\n        return this;\n    }\n    setSharedUnprotectedHeader(sharedUnprotectedHeader) {\n        if (this._unprotectedHeader) {\n            throw new TypeError('setSharedUnprotectedHeader can only be called once');\n        }\n        this._unprotectedHeader = sharedUnprotectedHeader;\n        return this;\n    }\n    setAdditionalAuthenticatedData(aad) {\n        this._aad = aad;\n        return this;\n    }\n    async encrypt(options) {\n        var _a, _b, _c;\n        if (!this._recipients.length) {\n            throw new JWEInvalid('at least one recipient must be added');\n        }\n        options = { deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };\n        if (this._recipients.length === 1) {\n            const [recipient] = this._recipients;\n            const flattened = await new FlattenedEncrypt(this._plaintext)\n                .setAdditionalAuthenticatedData(this._aad)\n                .setProtectedHeader(this._protectedHeader)\n                .setSharedUnprotectedHeader(this._unprotectedHeader)\n                .setUnprotectedHeader(recipient.unprotectedHeader)\n                .encrypt(recipient.key, { ...recipient.options, ...options });\n            let jwe = {\n                ciphertext: flattened.ciphertext,\n                iv: flattened.iv,\n                recipients: [{}],\n                tag: flattened.tag,\n            };\n            if (flattened.aad)\n                jwe.aad = flattened.aad;\n            if (flattened.protected)\n                jwe.protected = flattened.protected;\n            if (flattened.unprotected)\n                jwe.unprotected = flattened.unprotected;\n            if (flattened.encrypted_key)\n                jwe.recipients[0].encrypted_key = flattened.encrypted_key;\n            if (flattened.header)\n                jwe.recipients[0].header = flattened.header;\n            return jwe;\n        }\n        let enc;\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            if (!isDisjoint(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {\n                throw new JWEInvalid('JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint');\n            }\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...recipient.unprotectedHeader,\n            };\n            const { alg } = joseHeader;\n            if (typeof alg !== 'string' || !alg) {\n                throw new JWEInvalid('JWE \"alg\" (Algorithm) Header Parameter missing or invalid');\n            }\n            if (alg === 'dir' || alg === 'ECDH-ES') {\n                throw new JWEInvalid('\"dir\" and \"ECDH-ES\" alg may only be used with a single recipient');\n            }\n            if (typeof joseHeader.enc !== 'string' || !joseHeader.enc) {\n                throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter missing or invalid');\n            }\n            if (!enc) {\n                enc = joseHeader.enc;\n            }\n            else if (enc !== joseHeader.enc) {\n                throw new JWEInvalid('JWE \"enc\" (Encryption Algorithm) Header Parameter must be the same for all recipients');\n            }\n            validateCrit(JWEInvalid, new Map(), recipient.options.crit, this._protectedHeader, joseHeader);\n            if (joseHeader.zip !== undefined) {\n                if (!this._protectedHeader || !this._protectedHeader.zip) {\n                    throw new JWEInvalid('JWE \"zip\" (Compression Algorithm) Header MUST be integrity protected');\n                }\n            }\n        }\n        const cek = generateCek(enc);\n        let jwe = {\n            ciphertext: '',\n            iv: '',\n            recipients: [],\n            tag: '',\n        };\n        for (let i = 0; i < this._recipients.length; i++) {\n            const recipient = this._recipients[i];\n            const target = {};\n            jwe.recipients.push(target);\n            const joseHeader = {\n                ...this._protectedHeader,\n                ...this._unprotectedHeader,\n                ...recipient.unprotectedHeader,\n            };\n            const p2c = joseHeader.alg.startsWith('PBES2') ? 2048 + i : undefined;\n            if (i === 0) {\n                const flattened = await new FlattenedEncrypt(this._plaintext)\n                    .setAdditionalAuthenticatedData(this._aad)\n                    .setContentEncryptionKey(cek)\n                    .setProtectedHeader(this._protectedHeader)\n                    .setSharedUnprotectedHeader(this._unprotectedHeader)\n                    .setUnprotectedHeader(recipient.unprotectedHeader)\n                    .setKeyManagementParameters({ p2c })\n                    .encrypt(recipient.key, {\n                    ...recipient.options,\n                    ...options,\n                    [unprotected]: true,\n                });\n                jwe.ciphertext = flattened.ciphertext;\n                jwe.iv = flattened.iv;\n                jwe.tag = flattened.tag;\n                if (flattened.aad)\n                    jwe.aad = flattened.aad;\n                if (flattened.protected)\n                    jwe.protected = flattened.protected;\n                if (flattened.unprotected)\n                    jwe.unprotected = flattened.unprotected;\n                target.encrypted_key = flattened.encrypted_key;\n                if (flattened.header)\n                    target.header = flattened.header;\n                continue;\n            }\n            const { encryptedKey, parameters } = await encryptKeyManagement(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) ||\n                ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) ||\n                ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, { p2c });\n            target.encrypted_key = base64url(encryptedKey);\n            if (recipient.unprotectedHeader || parameters)\n                target.header = { ...recipient.unprotectedHeader, ...parameters };\n        }\n        return jwe;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}