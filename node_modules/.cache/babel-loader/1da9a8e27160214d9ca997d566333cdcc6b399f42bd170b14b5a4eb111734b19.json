{"ast":null,"code":"import { fetch, Headers } from 'cross-fetch';\nimport { jwtVerify, importJWK, exportJWK, SignJWT, generateKeyPair } from 'jose';\nimport { v4 } from 'uuid';\nconst SOLID_CLIENT_AUTHN_KEY_PREFIX = \"solidClientAuthn:\";\nconst PREFERRED_SIGNING_ALG = [\"ES256\", \"RS256\"];\nconst EVENTS = {\n  ERROR: \"error\",\n  LOGIN: \"login\",\n  LOGOUT: \"logout\",\n  NEW_REFRESH_TOKEN: \"newRefreshToken\",\n  SESSION_EXPIRED: \"sessionExpired\",\n  SESSION_EXTENDED: \"sessionExtended\",\n  SESSION_RESTORED: \"sessionRestore\",\n  TIMEOUT_SET: \"timeoutSet\"\n};\nconst REFRESH_BEFORE_EXPIRATION_SECONDS = 5;\nconst SCOPE_OPENID = \"openid\";\nconst SCOPE_OFFLINE = \"offline_access\";\nconst SCOPE_WEBID = \"webid\";\nconst DEFAULT_SCOPES = [SCOPE_OPENID, SCOPE_OFFLINE, SCOPE_WEBID].join(\" \");\nclass AggregateHandler {\n  constructor(handleables) {\n    this.handleables = handleables;\n  }\n  async getProperHandler(params) {\n    const canHandleList = await Promise.all(this.handleables.map(handleable => handleable.canHandle(...params)));\n    for (let i = 0; i < canHandleList.length; i += 1) {\n      if (canHandleList[i]) {\n        return this.handleables[i];\n      }\n    }\n    return null;\n  }\n  async canHandle() {\n    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n      params[_key] = arguments[_key];\n    }\n    return (await this.getProperHandler(params)) !== null;\n  }\n  async handle() {\n    for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      params[_key2] = arguments[_key2];\n    }\n    const handler = await this.getProperHandler(params);\n    if (handler) {\n      return handler.handle(...params);\n    }\n    throw new Error(`[${this.constructor.name}] cannot find a suitable handler for: ${params.map(param => {\n      try {\n        return JSON.stringify(param);\n      } catch (err) {\n        return param.toString();\n      }\n    }).join(\", \")}`);\n  }\n}\nasync function fetchJwks(jwksIri, issuerIri) {\n  const jwksResponse = await fetch(jwksIri);\n  if (jwksResponse.status !== 200) {\n    throw new Error(`Could not fetch JWKS for [${issuerIri}] at [${jwksIri}]: ${jwksResponse.status} ${jwksResponse.statusText}`);\n  }\n  let jwk;\n  try {\n    jwk = (await jwksResponse.json()).keys[0];\n  } catch (e) {\n    throw new Error(`Malformed JWKS for [${issuerIri}] at [${jwksIri}]: ${e.message}`);\n  }\n  return jwk;\n}\nasync function getWebidFromTokenPayload(idToken, jwksIri, issuerIri, clientId) {\n  const jwk = await fetchJwks(jwksIri, issuerIri);\n  let payload;\n  try {\n    const {\n      payload: verifiedPayload\n    } = await jwtVerify(idToken, await importJWK(jwk), {\n      issuer: issuerIri,\n      audience: clientId\n    });\n    payload = verifiedPayload;\n  } catch (e) {\n    throw new Error(`Token verification failed: ${e.stack}`);\n  }\n  if (typeof payload.webid === \"string\") {\n    return payload.webid;\n  }\n  if (typeof payload.sub !== \"string\") {\n    throw new Error(`The token ${JSON.stringify(payload)} is invalid: it has no 'webid' claim and no 'sub' claim.`);\n  }\n  try {\n    new URL(payload.sub);\n    return payload.sub;\n  } catch (e) {\n    throw new Error(`The token has no 'webid' claim, and its 'sub' claim of [${payload.sub}] is invalid as a URL - error [${e}].`);\n  }\n}\nfunction isSupportedTokenType(token) {\n  return typeof token === \"string\" && [\"DPoP\", \"Bearer\"].includes(token);\n}\nconst USER_SESSION_PREFIX = \"solidClientAuthenticationUser\";\nfunction isValidUrl(url) {\n  try {\n    new URL(url);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\nfunction determineSigningAlg(supported, preferred) {\n  var _a;\n  return (_a = preferred.find(signingAlg => {\n    return supported.includes(signingAlg);\n  })) !== null && _a !== void 0 ? _a : null;\n}\nfunction determineClientType(options, issuerConfig) {\n  if (options.clientId !== undefined && !isValidUrl(options.clientId)) {\n    return \"static\";\n  }\n  if (issuerConfig.scopesSupported.includes(\"webid\") && options.clientId !== undefined && isValidUrl(options.clientId)) {\n    return \"solid-oidc\";\n  }\n  return \"dynamic\";\n}\nasync function handleRegistration(options, issuerConfig, storageUtility, clientRegistrar) {\n  const clientType = determineClientType(options, issuerConfig);\n  if (clientType === \"dynamic\") {\n    return clientRegistrar.getClient({\n      sessionId: options.sessionId,\n      clientName: options.clientName,\n      redirectUrl: options.redirectUrl\n    }, issuerConfig);\n  }\n  await storageUtility.setForUser(options.sessionId, {\n    clientId: options.clientId\n  });\n  if (options.clientSecret) {\n    await storageUtility.setForUser(options.sessionId, {\n      clientSecret: options.clientSecret\n    });\n  }\n  if (options.clientName) {\n    await storageUtility.setForUser(options.sessionId, {\n      clientName: options.clientName\n    });\n  }\n  return {\n    clientId: options.clientId,\n    clientSecret: options.clientSecret,\n    clientName: options.clientName,\n    clientType\n  };\n}\nasync function getSessionIdFromOauthState(storageUtility, oauthState) {\n  return storageUtility.getForUser(oauthState, \"sessionId\");\n}\nasync function loadOidcContextFromStorage(sessionId, storageUtility, configFetcher) {\n  try {\n    const [issuerIri, codeVerifier, storedRedirectIri, dpop] = await Promise.all([storageUtility.getForUser(sessionId, \"issuer\", {\n      errorIfNull: true\n    }), storageUtility.getForUser(sessionId, \"codeVerifier\"), storageUtility.getForUser(sessionId, \"redirectUrl\"), storageUtility.getForUser(sessionId, \"dpop\", {\n      errorIfNull: true\n    })]);\n    await storageUtility.deleteForUser(sessionId, \"codeVerifier\");\n    const issuerConfig = await configFetcher.fetchConfig(issuerIri);\n    return {\n      codeVerifier,\n      redirectUrl: storedRedirectIri,\n      issuerConfig,\n      dpop: dpop === \"true\"\n    };\n  } catch (e) {\n    throw new Error(`Failed to retrieve OIDC context from storage associated with session [${sessionId}]: ${e}`);\n  }\n}\nasync function saveSessionInfoToStorage(storageUtility, sessionId, webId, isLoggedIn, refreshToken, secure, dpopKey) {\n  if (refreshToken !== undefined) {\n    await storageUtility.setForUser(sessionId, {\n      refreshToken\n    }, {\n      secure\n    });\n  }\n  if (webId !== undefined) {\n    await storageUtility.setForUser(sessionId, {\n      webId\n    }, {\n      secure\n    });\n  }\n  if (isLoggedIn !== undefined) {\n    await storageUtility.setForUser(sessionId, {\n      isLoggedIn\n    }, {\n      secure\n    });\n  }\n  if (dpopKey !== undefined) {\n    await storageUtility.setForUser(sessionId, {\n      publicKey: JSON.stringify(dpopKey.publicKey),\n      privateKey: JSON.stringify(await exportJWK(dpopKey.privateKey))\n    }, {\n      secure\n    });\n  }\n}\nclass StorageUtility {\n  constructor(secureStorage, insecureStorage) {\n    this.secureStorage = secureStorage;\n    this.insecureStorage = insecureStorage;\n  }\n  getKey(userId) {\n    return `solidClientAuthenticationUser:${userId}`;\n  }\n  async getUserData(userId, secure) {\n    const stored = await (secure ? this.secureStorage : this.insecureStorage).get(this.getKey(userId));\n    if (stored === undefined) {\n      return {};\n    }\n    try {\n      return JSON.parse(stored);\n    } catch (err) {\n      throw new Error(`Data for user [${userId}] in [${secure ? \"secure\" : \"unsecure\"}] storage is corrupted - expected valid JSON, but got: ${stored}`);\n    }\n  }\n  async setUserData(userId, data, secure) {\n    await (secure ? this.secureStorage : this.insecureStorage).set(this.getKey(userId), JSON.stringify(data));\n  }\n  async get(key, options) {\n    const value = await ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).get(key);\n    if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {\n      throw new Error(`[${key}] is not stored`);\n    }\n    return value;\n  }\n  async set(key, value, options) {\n    return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).set(key, value);\n  }\n  async delete(key, options) {\n    return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(key);\n  }\n  async getForUser(userId, key, options) {\n    const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\n    let value;\n    if (!userData || !userData[key]) {\n      value = undefined;\n    }\n    value = userData[key];\n    if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {\n      throw new Error(`Field [${key}] for user [${userId}] is not stored`);\n    }\n    return value || undefined;\n  }\n  async setForUser(userId, values, options) {\n    let userData;\n    try {\n      userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\n    } catch (_a) {\n      userData = {};\n    }\n    await this.setUserData(userId, {\n      ...userData,\n      ...values\n    }, options === null || options === void 0 ? void 0 : options.secure);\n  }\n  async deleteForUser(userId, key, options) {\n    const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\n    delete userData[key];\n    await this.setUserData(userId, userData, options === null || options === void 0 ? void 0 : options.secure);\n  }\n  async deleteAllUserData(userId, options) {\n    await ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(this.getKey(userId));\n  }\n}\nclass InMemoryStorage {\n  constructor() {\n    this.map = {};\n  }\n  async get(key) {\n    return this.map[key] || undefined;\n  }\n  async set(key, value) {\n    this.map[key] = value;\n  }\n  async delete(key) {\n    delete this.map[key];\n  }\n}\nclass ConfigurationError extends Error {\n  constructor(message) {\n    super(message);\n  }\n}\nclass NotImplementedError extends Error {\n  constructor(methodName) {\n    super(`[${methodName}] is not implemented`);\n  }\n}\nclass InvalidResponseError extends Error {\n  constructor(missingFields) {\n    super(`Invalid response from OIDC provider: missing fields ${missingFields}`);\n    this.missingFields = missingFields;\n  }\n}\nclass OidcProviderError extends Error {\n  constructor(message, error, errorDescription) {\n    super(message);\n    this.error = error;\n    this.errorDescription = errorDescription;\n  }\n}\nfunction normalizeHTU(audience) {\n  const audienceUrl = new URL(audience);\n  return new URL(audienceUrl.pathname, audienceUrl.origin).toString();\n}\nasync function createDpopHeader(audience, method, dpopKey) {\n  return new SignJWT({\n    htu: normalizeHTU(audience),\n    htm: method.toUpperCase(),\n    jti: v4()\n  }).setProtectedHeader({\n    alg: PREFERRED_SIGNING_ALG[0],\n    jwk: dpopKey.publicKey,\n    typ: \"dpop+jwt\"\n  }).setIssuedAt().sign(dpopKey.privateKey, {});\n}\nasync function generateDpopKeyPair() {\n  const {\n    privateKey,\n    publicKey\n  } = await generateKeyPair(PREFERRED_SIGNING_ALG[0]);\n  const dpopKeyPair = {\n    privateKey,\n    publicKey: await exportJWK(publicKey)\n  };\n  [dpopKeyPair.publicKey.alg] = PREFERRED_SIGNING_ALG;\n  return dpopKeyPair;\n}\nconst DEFAULT_EXPIRATION_TIME_SECONDS = 600;\nfunction isExpectedAuthError(statusCode) {\n  return [401, 403].includes(statusCode);\n}\nasync function buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions) {\n  var _a;\n  const headers = new Headers(defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.headers);\n  headers.set(\"Authorization\", `DPoP ${authToken}`);\n  headers.set(\"DPoP\", await createDpopHeader(targetUrl, (_a = defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.method) !== null && _a !== void 0 ? _a : \"get\", dpopKey));\n  return {\n    ...defaultOptions,\n    headers\n  };\n}\nasync function buildAuthenticatedHeaders(targetUrl, authToken, dpopKey, defaultOptions) {\n  if (dpopKey !== undefined) {\n    return buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions);\n  }\n  const headers = new Headers(defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.headers);\n  headers.set(\"Authorization\", `Bearer ${authToken}`);\n  return {\n    ...defaultOptions,\n    headers\n  };\n}\nasync function makeAuthenticatedRequest(unauthFetch, accessToken, url, defaultRequestInit, dpopKey) {\n  return unauthFetch(url, await buildAuthenticatedHeaders(url.toString(), accessToken, dpopKey, defaultRequestInit));\n}\nasync function refreshAccessToken(refreshOptions, dpopKey, eventEmitter) {\n  var _a;\n  const tokenSet = await refreshOptions.tokenRefresher.refresh(refreshOptions.sessionId, refreshOptions.refreshToken, dpopKey);\n  eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(EVENTS.SESSION_EXTENDED, (_a = tokenSet.expiresIn) !== null && _a !== void 0 ? _a : DEFAULT_EXPIRATION_TIME_SECONDS);\n  if (typeof tokenSet.refreshToken === \"string\") {\n    eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(EVENTS.NEW_REFRESH_TOKEN, tokenSet.refreshToken);\n  }\n  return {\n    accessToken: tokenSet.accessToken,\n    refreshToken: tokenSet.refreshToken,\n    expiresIn: tokenSet.expiresIn\n  };\n}\nconst computeRefreshDelay = expiresIn => {\n  if (expiresIn !== undefined) {\n    return expiresIn - REFRESH_BEFORE_EXPIRATION_SECONDS > 0 ? expiresIn - REFRESH_BEFORE_EXPIRATION_SECONDS : expiresIn;\n  }\n  return DEFAULT_EXPIRATION_TIME_SECONDS;\n};\nasync function buildAuthenticatedFetch(unauthFetch, accessToken, options) {\n  var _a;\n  let currentAccessToken = accessToken;\n  let latestTimeout;\n  const currentRefreshOptions = options === null || options === void 0 ? void 0 : options.refreshOptions;\n  if (currentRefreshOptions !== undefined) {\n    const proactivelyRefreshToken = async () => {\n      var _a, _b, _c, _d;\n      try {\n        const {\n          accessToken: refreshedAccessToken,\n          refreshToken,\n          expiresIn\n        } = await refreshAccessToken(currentRefreshOptions, options.dpopKey, options.eventEmitter);\n        currentAccessToken = refreshedAccessToken;\n        if (refreshToken !== undefined) {\n          currentRefreshOptions.refreshToken = refreshToken;\n        }\n        clearTimeout(latestTimeout);\n        latestTimeout = setTimeout(proactivelyRefreshToken, computeRefreshDelay(expiresIn) * 1000);\n        (_a = options.eventEmitter) === null || _a === void 0 ? void 0 : _a.emit(EVENTS.TIMEOUT_SET, latestTimeout);\n      } catch (e) {\n        if (e instanceof OidcProviderError) {\n          (_b = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _b === void 0 ? void 0 : _b.emit(EVENTS.ERROR, e.error, e.errorDescription);\n          (_c = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _c === void 0 ? void 0 : _c.emit(EVENTS.SESSION_EXPIRED);\n        }\n        if (e instanceof InvalidResponseError && e.missingFields.includes(\"access_token\")) {\n          (_d = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _d === void 0 ? void 0 : _d.emit(EVENTS.SESSION_EXPIRED);\n        }\n      }\n    };\n    latestTimeout = setTimeout(proactivelyRefreshToken, computeRefreshDelay(options.expiresIn) * 1000);\n    (_a = options.eventEmitter) === null || _a === void 0 ? void 0 : _a.emit(EVENTS.TIMEOUT_SET, latestTimeout);\n  } else if (options !== undefined && options.eventEmitter !== undefined) {\n    const expirationTimeout = setTimeout(() => {\n      options.eventEmitter.emit(EVENTS.SESSION_EXPIRED);\n    }, computeRefreshDelay(options.expiresIn) * 1000);\n    options.eventEmitter.emit(EVENTS.TIMEOUT_SET, expirationTimeout);\n  }\n  return async (url, requestInit) => {\n    let response = await makeAuthenticatedRequest(unauthFetch, currentAccessToken, url, requestInit, options === null || options === void 0 ? void 0 : options.dpopKey);\n    const failedButNotExpectedAuthError = !response.ok && !isExpectedAuthError(response.status);\n    if (response.ok || failedButNotExpectedAuthError) {\n      return response;\n    }\n    const hasBeenRedirected = response.url !== url;\n    if (hasBeenRedirected && (options === null || options === void 0 ? void 0 : options.dpopKey) !== undefined) {\n      response = await makeAuthenticatedRequest(unauthFetch, currentAccessToken, response.url, requestInit, options.dpopKey);\n    }\n    return response;\n  };\n}\nconst StorageUtilityGetResponse = \"getResponse\";\nconst StorageUtilityMock = {\n  get: async (key, options) => StorageUtilityGetResponse,\n  set: async (key, value) => {},\n  delete: async key => {},\n  getForUser: async (userId, key, options) => StorageUtilityGetResponse,\n  setForUser: async (userId, values, options) => {},\n  deleteForUser: async (userId, key, options) => {},\n  deleteAllUserData: async (userId, options) => {}\n};\nconst mockStorage = stored => {\n  const store = stored;\n  return {\n    get: async key => {\n      if (store[key] === undefined) {\n        return undefined;\n      }\n      if (typeof store[key] === \"string\") {\n        return store[key];\n      }\n      return JSON.stringify(store[key]);\n    },\n    set: async (key, value) => {\n      store[key] = value;\n    },\n    delete: async key => {\n      delete store[key];\n    }\n  };\n};\nconst mockStorageUtility = function (stored) {\n  let isSecure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (isSecure) {\n    return new StorageUtility(mockStorage(stored), mockStorage({}));\n  }\n  return new StorageUtility(mockStorage({}), mockStorage(stored));\n};\nexport { AggregateHandler, ConfigurationError, DEFAULT_SCOPES, EVENTS, InMemoryStorage, InvalidResponseError, NotImplementedError, OidcProviderError, PREFERRED_SIGNING_ALG, REFRESH_BEFORE_EXPIRATION_SECONDS, SOLID_CLIENT_AUTHN_KEY_PREFIX, StorageUtility, StorageUtilityGetResponse, StorageUtilityMock, USER_SESSION_PREFIX, buildAuthenticatedFetch, createDpopHeader, determineSigningAlg, fetchJwks, generateDpopKeyPair, getSessionIdFromOauthState, getWebidFromTokenPayload, handleRegistration, isSupportedTokenType, loadOidcContextFromStorage, mockStorage, mockStorageUtility, saveSessionInfoToStorage };","map":{"version":3,"names":["fetch","Headers","jwtVerify","importJWK","exportJWK","SignJWT","generateKeyPair","v4","SOLID_CLIENT_AUTHN_KEY_PREFIX","PREFERRED_SIGNING_ALG","EVENTS","ERROR","LOGIN","LOGOUT","NEW_REFRESH_TOKEN","SESSION_EXPIRED","SESSION_EXTENDED","SESSION_RESTORED","TIMEOUT_SET","REFRESH_BEFORE_EXPIRATION_SECONDS","SCOPE_OPENID","SCOPE_OFFLINE","SCOPE_WEBID","DEFAULT_SCOPES","join","AggregateHandler","constructor","handleables","getProperHandler","params","canHandleList","Promise","all","map","handleable","canHandle","i","length","handle","handler","Error","name","param","JSON","stringify","err","toString","fetchJwks","jwksIri","issuerIri","jwksResponse","status","statusText","jwk","json","keys","e","message","getWebidFromTokenPayload","idToken","clientId","payload","verifiedPayload","issuer","audience","stack","webid","sub","URL","isSupportedTokenType","token","includes","USER_SESSION_PREFIX","isValidUrl","url","_a","determineSigningAlg","supported","preferred","find","signingAlg","determineClientType","options","issuerConfig","undefined","scopesSupported","handleRegistration","storageUtility","clientRegistrar","clientType","getClient","sessionId","clientName","redirectUrl","setForUser","clientSecret","getSessionIdFromOauthState","oauthState","getForUser","loadOidcContextFromStorage","configFetcher","codeVerifier","storedRedirectIri","dpop","errorIfNull","deleteForUser","fetchConfig","saveSessionInfoToStorage","webId","isLoggedIn","refreshToken","secure","dpopKey","publicKey","privateKey","StorageUtility","secureStorage","insecureStorage","getKey","userId","getUserData","stored","get","parse","setUserData","data","set","key","value","delete","userData","values","deleteAllUserData","InMemoryStorage","ConfigurationError","NotImplementedError","methodName","InvalidResponseError","missingFields","OidcProviderError","error","errorDescription","normalizeHTU","audienceUrl","pathname","origin","createDpopHeader","method","htu","htm","toUpperCase","jti","setProtectedHeader","alg","typ","setIssuedAt","sign","generateDpopKeyPair","dpopKeyPair","DEFAULT_EXPIRATION_TIME_SECONDS","isExpectedAuthError","statusCode","buildDpopFetchOptions","targetUrl","authToken","defaultOptions","headers","buildAuthenticatedHeaders","makeAuthenticatedRequest","unauthFetch","accessToken","defaultRequestInit","refreshAccessToken","refreshOptions","eventEmitter","tokenSet","tokenRefresher","refresh","emit","expiresIn","computeRefreshDelay","buildAuthenticatedFetch","currentAccessToken","latestTimeout","currentRefreshOptions","proactivelyRefreshToken","_b","_c","_d","refreshedAccessToken","clearTimeout","setTimeout","expirationTimeout","requestInit","response","failedButNotExpectedAuthError","ok","hasBeenRedirected","StorageUtilityGetResponse","StorageUtilityMock","mockStorage","store","mockStorageUtility","isSecure"],"sources":["G:/To-do-List_App-main/node_modules/@inrupt/solid-client-authn-core/dist/index.mjs"],"sourcesContent":["import { fetch, Headers } from 'cross-fetch';\nimport { jwtVerify, importJWK, exportJWK, SignJWT, generateKeyPair } from 'jose';\nimport { v4 } from 'uuid';\n\nconst SOLID_CLIENT_AUTHN_KEY_PREFIX = \"solidClientAuthn:\";\r\nconst PREFERRED_SIGNING_ALG = [\"ES256\", \"RS256\"];\r\nconst EVENTS = {\r\n    ERROR: \"error\",\r\n    LOGIN: \"login\",\r\n    LOGOUT: \"logout\",\r\n    NEW_REFRESH_TOKEN: \"newRefreshToken\",\r\n    SESSION_EXPIRED: \"sessionExpired\",\r\n    SESSION_EXTENDED: \"sessionExtended\",\r\n    SESSION_RESTORED: \"sessionRestore\",\r\n    TIMEOUT_SET: \"timeoutSet\",\r\n};\r\nconst REFRESH_BEFORE_EXPIRATION_SECONDS = 5;\r\nconst SCOPE_OPENID = \"openid\";\r\nconst SCOPE_OFFLINE = \"offline_access\";\r\nconst SCOPE_WEBID = \"webid\";\r\nconst DEFAULT_SCOPES = [SCOPE_OPENID, SCOPE_OFFLINE, SCOPE_WEBID].join(\" \");\n\nclass AggregateHandler {\r\n    constructor(handleables) {\r\n        this.handleables = handleables;\r\n    }\r\n    async getProperHandler(params) {\r\n        const canHandleList = await Promise.all(this.handleables.map((handleable) => handleable.canHandle(...params)));\r\n        for (let i = 0; i < canHandleList.length; i += 1) {\r\n            if (canHandleList[i]) {\r\n                return this.handleables[i];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    async canHandle(...params) {\r\n        return (await this.getProperHandler(params)) !== null;\r\n    }\r\n    async handle(...params) {\r\n        const handler = await this.getProperHandler(params);\r\n        if (handler) {\r\n            return handler.handle(...params);\r\n        }\r\n        throw new Error(`[${this.constructor.name}] cannot find a suitable handler for: ${params\r\n            .map((param) => {\r\n            try {\r\n                return JSON.stringify(param);\r\n            }\r\n            catch (err) {\r\n                return param.toString();\r\n            }\r\n        })\r\n            .join(\", \")}`);\r\n    }\r\n}\n\nasync function fetchJwks(jwksIri, issuerIri) {\r\n    const jwksResponse = await fetch(jwksIri);\r\n    if (jwksResponse.status !== 200) {\r\n        throw new Error(`Could not fetch JWKS for [${issuerIri}] at [${jwksIri}]: ${jwksResponse.status} ${jwksResponse.statusText}`);\r\n    }\r\n    let jwk;\r\n    try {\r\n        jwk = (await jwksResponse.json()).keys[0];\r\n    }\r\n    catch (e) {\r\n        throw new Error(`Malformed JWKS for [${issuerIri}] at [${jwksIri}]: ${e.message}`);\r\n    }\r\n    return jwk;\r\n}\r\nasync function getWebidFromTokenPayload(idToken, jwksIri, issuerIri, clientId) {\r\n    const jwk = await fetchJwks(jwksIri, issuerIri);\r\n    let payload;\r\n    try {\r\n        const { payload: verifiedPayload } = await jwtVerify(idToken, await importJWK(jwk), {\r\n            issuer: issuerIri,\r\n            audience: clientId,\r\n        });\r\n        payload = verifiedPayload;\r\n    }\r\n    catch (e) {\r\n        throw new Error(`Token verification failed: ${e.stack}`);\r\n    }\r\n    if (typeof payload.webid === \"string\") {\r\n        return payload.webid;\r\n    }\r\n    if (typeof payload.sub !== \"string\") {\r\n        throw new Error(`The token ${JSON.stringify(payload)} is invalid: it has no 'webid' claim and no 'sub' claim.`);\r\n    }\r\n    try {\r\n        new URL(payload.sub);\r\n        return payload.sub;\r\n    }\r\n    catch (e) {\r\n        throw new Error(`The token has no 'webid' claim, and its 'sub' claim of [${payload.sub}] is invalid as a URL - error [${e}].`);\r\n    }\r\n}\n\nfunction isSupportedTokenType(token) {\r\n    return typeof token === \"string\" && [\"DPoP\", \"Bearer\"].includes(token);\r\n}\n\nconst USER_SESSION_PREFIX = \"solidClientAuthenticationUser\";\n\nfunction isValidUrl(url) {\r\n    try {\r\n        new URL(url);\r\n        return true;\r\n    }\r\n    catch (_a) {\r\n        return false;\r\n    }\r\n}\r\nfunction determineSigningAlg(supported, preferred) {\r\n    var _a;\r\n    return ((_a = preferred.find((signingAlg) => {\r\n        return supported.includes(signingAlg);\r\n    })) !== null && _a !== void 0 ? _a : null);\r\n}\r\nfunction determineClientType(options, issuerConfig) {\r\n    if (options.clientId !== undefined && !isValidUrl(options.clientId)) {\r\n        return \"static\";\r\n    }\r\n    if (issuerConfig.scopesSupported.includes(\"webid\") &&\r\n        options.clientId !== undefined &&\r\n        isValidUrl(options.clientId)) {\r\n        return \"solid-oidc\";\r\n    }\r\n    return \"dynamic\";\r\n}\r\nasync function handleRegistration(options, issuerConfig, storageUtility, clientRegistrar) {\r\n    const clientType = determineClientType(options, issuerConfig);\r\n    if (clientType === \"dynamic\") {\r\n        return clientRegistrar.getClient({\r\n            sessionId: options.sessionId,\r\n            clientName: options.clientName,\r\n            redirectUrl: options.redirectUrl,\r\n        }, issuerConfig);\r\n    }\r\n    await storageUtility.setForUser(options.sessionId, {\r\n        clientId: options.clientId,\r\n    });\r\n    if (options.clientSecret) {\r\n        await storageUtility.setForUser(options.sessionId, {\r\n            clientSecret: options.clientSecret,\r\n        });\r\n    }\r\n    if (options.clientName) {\r\n        await storageUtility.setForUser(options.sessionId, {\r\n            clientName: options.clientName,\r\n        });\r\n    }\r\n    return {\r\n        clientId: options.clientId,\r\n        clientSecret: options.clientSecret,\r\n        clientName: options.clientName,\r\n        clientType,\r\n    };\r\n}\n\nasync function getSessionIdFromOauthState(storageUtility, oauthState) {\r\n    return storageUtility.getForUser(oauthState, \"sessionId\");\r\n}\r\nasync function loadOidcContextFromStorage(sessionId, storageUtility, configFetcher) {\r\n    try {\r\n        const [issuerIri, codeVerifier, storedRedirectIri, dpop] = await Promise.all([\r\n            storageUtility.getForUser(sessionId, \"issuer\", {\r\n                errorIfNull: true,\r\n            }),\r\n            storageUtility.getForUser(sessionId, \"codeVerifier\"),\r\n            storageUtility.getForUser(sessionId, \"redirectUrl\"),\r\n            storageUtility.getForUser(sessionId, \"dpop\", { errorIfNull: true }),\r\n        ]);\r\n        await storageUtility.deleteForUser(sessionId, \"codeVerifier\");\r\n        const issuerConfig = await configFetcher.fetchConfig(issuerIri);\r\n        return {\r\n            codeVerifier,\r\n            redirectUrl: storedRedirectIri,\r\n            issuerConfig,\r\n            dpop: dpop === \"true\",\r\n        };\r\n    }\r\n    catch (e) {\r\n        throw new Error(`Failed to retrieve OIDC context from storage associated with session [${sessionId}]: ${e}`);\r\n    }\r\n}\r\nasync function saveSessionInfoToStorage(storageUtility, sessionId, webId, isLoggedIn, refreshToken, secure, dpopKey) {\r\n    if (refreshToken !== undefined) {\r\n        await storageUtility.setForUser(sessionId, { refreshToken }, { secure });\r\n    }\r\n    if (webId !== undefined) {\r\n        await storageUtility.setForUser(sessionId, { webId }, { secure });\r\n    }\r\n    if (isLoggedIn !== undefined) {\r\n        await storageUtility.setForUser(sessionId, { isLoggedIn }, { secure });\r\n    }\r\n    if (dpopKey !== undefined) {\r\n        await storageUtility.setForUser(sessionId, {\r\n            publicKey: JSON.stringify(dpopKey.publicKey),\r\n            privateKey: JSON.stringify(await exportJWK(dpopKey.privateKey)),\r\n        }, { secure });\r\n    }\r\n}\r\nclass StorageUtility {\r\n    constructor(secureStorage, insecureStorage) {\r\n        this.secureStorage = secureStorage;\r\n        this.insecureStorage = insecureStorage;\r\n    }\r\n    getKey(userId) {\r\n        return `solidClientAuthenticationUser:${userId}`;\r\n    }\r\n    async getUserData(userId, secure) {\r\n        const stored = await (secure\r\n            ? this.secureStorage\r\n            : this.insecureStorage).get(this.getKey(userId));\r\n        if (stored === undefined) {\r\n            return {};\r\n        }\r\n        try {\r\n            return JSON.parse(stored);\r\n        }\r\n        catch (err) {\r\n            throw new Error(`Data for user [${userId}] in [${secure ? \"secure\" : \"unsecure\"}] storage is corrupted - expected valid JSON, but got: ${stored}`);\r\n        }\r\n    }\r\n    async setUserData(userId, data, secure) {\r\n        await (secure ? this.secureStorage : this.insecureStorage).set(this.getKey(userId), JSON.stringify(data));\r\n    }\r\n    async get(key, options) {\r\n        const value = await ((options === null || options === void 0 ? void 0 : options.secure)\r\n            ? this.secureStorage\r\n            : this.insecureStorage).get(key);\r\n        if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {\r\n            throw new Error(`[${key}] is not stored`);\r\n        }\r\n        return value;\r\n    }\r\n    async set(key, value, options) {\r\n        return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).set(key, value);\r\n    }\r\n    async delete(key, options) {\r\n        return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(key);\r\n    }\r\n    async getForUser(userId, key, options) {\r\n        const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\r\n        let value;\r\n        if (!userData || !userData[key]) {\r\n            value = undefined;\r\n        }\r\n        value = userData[key];\r\n        if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {\r\n            throw new Error(`Field [${key}] for user [${userId}] is not stored`);\r\n        }\r\n        return value || undefined;\r\n    }\r\n    async setForUser(userId, values, options) {\r\n        let userData;\r\n        try {\r\n            userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\r\n        }\r\n        catch (_a) {\r\n            userData = {};\r\n        }\r\n        await this.setUserData(userId, { ...userData, ...values }, options === null || options === void 0 ? void 0 : options.secure);\r\n    }\r\n    async deleteForUser(userId, key, options) {\r\n        const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\r\n        delete userData[key];\r\n        await this.setUserData(userId, userData, options === null || options === void 0 ? void 0 : options.secure);\r\n    }\r\n    async deleteAllUserData(userId, options) {\r\n        await ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(this.getKey(userId));\r\n    }\r\n}\n\nclass InMemoryStorage {\r\n    constructor() {\r\n        this.map = {};\r\n    }\r\n    async get(key) {\r\n        return this.map[key] || undefined;\r\n    }\r\n    async set(key, value) {\r\n        this.map[key] = value;\r\n    }\r\n    async delete(key) {\r\n        delete this.map[key];\r\n    }\r\n}\n\nclass ConfigurationError extends Error {\r\n    constructor(message) {\r\n        super(message);\r\n    }\r\n}\n\nclass NotImplementedError extends Error {\r\n    constructor(methodName) {\r\n        super(`[${methodName}] is not implemented`);\r\n    }\r\n}\n\nclass InvalidResponseError extends Error {\r\n    constructor(missingFields) {\r\n        super(`Invalid response from OIDC provider: missing fields ${missingFields}`);\r\n        this.missingFields = missingFields;\r\n    }\r\n}\n\nclass OidcProviderError extends Error {\r\n    constructor(message, error, errorDescription) {\r\n        super(message);\r\n        this.error = error;\r\n        this.errorDescription = errorDescription;\r\n    }\r\n}\n\nfunction normalizeHTU(audience) {\r\n    const audienceUrl = new URL(audience);\r\n    return new URL(audienceUrl.pathname, audienceUrl.origin).toString();\r\n}\r\nasync function createDpopHeader(audience, method, dpopKey) {\r\n    return new SignJWT({\r\n        htu: normalizeHTU(audience),\r\n        htm: method.toUpperCase(),\r\n        jti: v4(),\r\n    })\r\n        .setProtectedHeader({\r\n        alg: PREFERRED_SIGNING_ALG[0],\r\n        jwk: dpopKey.publicKey,\r\n        typ: \"dpop+jwt\",\r\n    })\r\n        .setIssuedAt()\r\n        .sign(dpopKey.privateKey, {});\r\n}\r\nasync function generateDpopKeyPair() {\r\n    const { privateKey, publicKey } = await generateKeyPair(PREFERRED_SIGNING_ALG[0]);\r\n    const dpopKeyPair = {\r\n        privateKey,\r\n        publicKey: await exportJWK(publicKey),\r\n    };\r\n    [dpopKeyPair.publicKey.alg] = PREFERRED_SIGNING_ALG;\r\n    return dpopKeyPair;\r\n}\n\nconst DEFAULT_EXPIRATION_TIME_SECONDS = 600;\r\nfunction isExpectedAuthError(statusCode) {\r\n    return [401, 403].includes(statusCode);\r\n}\r\nasync function buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions) {\r\n    var _a;\r\n    const headers = new Headers(defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.headers);\r\n    headers.set(\"Authorization\", `DPoP ${authToken}`);\r\n    headers.set(\"DPoP\", await createDpopHeader(targetUrl, (_a = defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.method) !== null && _a !== void 0 ? _a : \"get\", dpopKey));\r\n    return {\r\n        ...defaultOptions,\r\n        headers,\r\n    };\r\n}\r\nasync function buildAuthenticatedHeaders(targetUrl, authToken, dpopKey, defaultOptions) {\r\n    if (dpopKey !== undefined) {\r\n        return buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions);\r\n    }\r\n    const headers = new Headers(defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.headers);\r\n    headers.set(\"Authorization\", `Bearer ${authToken}`);\r\n    return {\r\n        ...defaultOptions,\r\n        headers,\r\n    };\r\n}\r\nasync function makeAuthenticatedRequest(unauthFetch, accessToken, url, defaultRequestInit, dpopKey) {\r\n    return unauthFetch(url, await buildAuthenticatedHeaders(url.toString(), accessToken, dpopKey, defaultRequestInit));\r\n}\r\nasync function refreshAccessToken(refreshOptions, dpopKey, eventEmitter) {\r\n    var _a;\r\n    const tokenSet = await refreshOptions.tokenRefresher.refresh(refreshOptions.sessionId, refreshOptions.refreshToken, dpopKey);\r\n    eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(EVENTS.SESSION_EXTENDED, (_a = tokenSet.expiresIn) !== null && _a !== void 0 ? _a : DEFAULT_EXPIRATION_TIME_SECONDS);\r\n    if (typeof tokenSet.refreshToken === \"string\") {\r\n        eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(EVENTS.NEW_REFRESH_TOKEN, tokenSet.refreshToken);\r\n    }\r\n    return {\r\n        accessToken: tokenSet.accessToken,\r\n        refreshToken: tokenSet.refreshToken,\r\n        expiresIn: tokenSet.expiresIn,\r\n    };\r\n}\r\nconst computeRefreshDelay = (expiresIn) => {\r\n    if (expiresIn !== undefined) {\r\n        return expiresIn - REFRESH_BEFORE_EXPIRATION_SECONDS > 0\r\n            ?\r\n                expiresIn - REFRESH_BEFORE_EXPIRATION_SECONDS\r\n            : expiresIn;\r\n    }\r\n    return DEFAULT_EXPIRATION_TIME_SECONDS;\r\n};\r\nasync function buildAuthenticatedFetch(unauthFetch, accessToken, options) {\r\n    var _a;\r\n    let currentAccessToken = accessToken;\r\n    let latestTimeout;\r\n    const currentRefreshOptions = options === null || options === void 0 ? void 0 : options.refreshOptions;\r\n    if (currentRefreshOptions !== undefined) {\r\n        const proactivelyRefreshToken = async () => {\r\n            var _a, _b, _c, _d;\r\n            try {\r\n                const { accessToken: refreshedAccessToken, refreshToken, expiresIn, } = await refreshAccessToken(currentRefreshOptions, options.dpopKey, options.eventEmitter);\r\n                currentAccessToken = refreshedAccessToken;\r\n                if (refreshToken !== undefined) {\r\n                    currentRefreshOptions.refreshToken = refreshToken;\r\n                }\r\n                clearTimeout(latestTimeout);\r\n                latestTimeout = setTimeout(proactivelyRefreshToken, computeRefreshDelay(expiresIn) * 1000);\r\n                (_a = options.eventEmitter) === null || _a === void 0 ? void 0 : _a.emit(EVENTS.TIMEOUT_SET, latestTimeout);\r\n            }\r\n            catch (e) {\r\n                if (e instanceof OidcProviderError) {\r\n                    (_b = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _b === void 0 ? void 0 : _b.emit(EVENTS.ERROR, e.error, e.errorDescription);\r\n                    (_c = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _c === void 0 ? void 0 : _c.emit(EVENTS.SESSION_EXPIRED);\r\n                }\r\n                if (e instanceof InvalidResponseError &&\r\n                    e.missingFields.includes(\"access_token\")) {\r\n                    (_d = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _d === void 0 ? void 0 : _d.emit(EVENTS.SESSION_EXPIRED);\r\n                }\r\n            }\r\n        };\r\n        latestTimeout = setTimeout(proactivelyRefreshToken, computeRefreshDelay(options.expiresIn) * 1000);\r\n        (_a = options.eventEmitter) === null || _a === void 0 ? void 0 : _a.emit(EVENTS.TIMEOUT_SET, latestTimeout);\r\n    }\r\n    else if (options !== undefined && options.eventEmitter !== undefined) {\r\n        const expirationTimeout = setTimeout(() => {\r\n            options.eventEmitter.emit(EVENTS.SESSION_EXPIRED);\r\n        }, computeRefreshDelay(options.expiresIn) * 1000);\r\n        options.eventEmitter.emit(EVENTS.TIMEOUT_SET, expirationTimeout);\r\n    }\r\n    return async (url, requestInit) => {\r\n        let response = await makeAuthenticatedRequest(unauthFetch, currentAccessToken, url, requestInit, options === null || options === void 0 ? void 0 : options.dpopKey);\r\n        const failedButNotExpectedAuthError = !response.ok && !isExpectedAuthError(response.status);\r\n        if (response.ok || failedButNotExpectedAuthError) {\r\n            return response;\r\n        }\r\n        const hasBeenRedirected = response.url !== url;\r\n        if (hasBeenRedirected && (options === null || options === void 0 ? void 0 : options.dpopKey) !== undefined) {\r\n            response = await makeAuthenticatedRequest(unauthFetch, currentAccessToken, response.url, requestInit, options.dpopKey);\r\n        }\r\n        return response;\r\n    };\r\n}\n\nconst StorageUtilityGetResponse = \"getResponse\";\r\nconst StorageUtilityMock = {\r\n    get: async (key, options) => StorageUtilityGetResponse,\r\n    set: async (key, value) => {\r\n    },\r\n    delete: async (key) => {\r\n    },\r\n    getForUser: async (userId, key, options) => StorageUtilityGetResponse,\r\n    setForUser: async (userId, values, options) => {\r\n    },\r\n    deleteForUser: async (userId, key, options) => {\r\n    },\r\n    deleteAllUserData: async (userId, options) => {\r\n    },\r\n};\r\nconst mockStorage = (stored) => {\r\n    const store = stored;\r\n    return {\r\n        get: async (key) => {\r\n            if (store[key] === undefined) {\r\n                return undefined;\r\n            }\r\n            if (typeof store[key] === \"string\") {\r\n                return store[key];\r\n            }\r\n            return JSON.stringify(store[key]);\r\n        },\r\n        set: async (key, value) => {\r\n            store[key] = value;\r\n        },\r\n        delete: async (key) => {\r\n            delete store[key];\r\n        },\r\n    };\r\n};\r\nconst mockStorageUtility = (stored, isSecure = false) => {\r\n    if (isSecure) {\r\n        return new StorageUtility(mockStorage(stored), mockStorage({}));\r\n    }\r\n    return new StorageUtility(mockStorage({}), mockStorage(stored));\r\n};\n\nexport { AggregateHandler, ConfigurationError, DEFAULT_SCOPES, EVENTS, InMemoryStorage, InvalidResponseError, NotImplementedError, OidcProviderError, PREFERRED_SIGNING_ALG, REFRESH_BEFORE_EXPIRATION_SECONDS, SOLID_CLIENT_AUTHN_KEY_PREFIX, StorageUtility, StorageUtilityGetResponse, StorageUtilityMock, USER_SESSION_PREFIX, buildAuthenticatedFetch, createDpopHeader, determineSigningAlg, fetchJwks, generateDpopKeyPair, getSessionIdFromOauthState, getWebidFromTokenPayload, handleRegistration, isSupportedTokenType, loadOidcContextFromStorage, mockStorage, mockStorageUtility, saveSessionInfoToStorage };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}