{"ast":null,"code":"/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _slicedToArray = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _createForOfIteratorHelper = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar graphTypes = require('./graphTypes');\nvar types = require('./types');\n// TODO: move `IdentifierIssuer` to its own package\nvar IdentifierIssuer = require('rdf-canonize').IdentifierIssuer;\nvar JsonLdError = require('./JsonLdError');\n\n// constants\nvar REGEX_LINK_HEADERS = /(?:<[^>]*?>|\"[^\"]*?\"|[^,])+/g;\nvar REGEX_LINK_HEADER = /\\s*<([^>]*?)>\\s*(?:;\\s*(.*))?/;\nvar REGEX_LINK_HEADER_PARAMS = /(.*?)=(?:(?:\"([^\"]*?)\")|([^\"]*?))\\s*(?:(?:;\\s*)|$)/g;\nvar DEFAULTS = {\n  headers: {\n    accept: 'application/ld+json, application/json'\n  }\n};\nvar api = {};\nmodule.exports = api;\napi.IdentifierIssuer = IdentifierIssuer;\n\n/**\n * Clones an object, array, Map, Set, or string/number. If a typed JavaScript\n * object is given, such as a Date, it will be converted to a string.\n *\n * @param value the value to clone.\n *\n * @return the cloned value.\n */\napi.clone = function (value) {\n  if (value && typeof value === 'object') {\n    var rval;\n    if (types.isArray(value)) {\n      rval = [];\n      for (var i = 0; i < value.length; ++i) {\n        rval[i] = api.clone(value[i]);\n      }\n    } else if (value instanceof Map) {\n      rval = new Map();\n      var _iterator = _createForOfIteratorHelper(value),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            k = _step$value[0],\n            v = _step$value[1];\n          rval.set(k, api.clone(v));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } else if (value instanceof Set) {\n      rval = new Set();\n      var _iterator2 = _createForOfIteratorHelper(value),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _v = _step2.value;\n          rval.add(api.clone(_v));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    } else if (types.isObject(value)) {\n      rval = {};\n      for (var key in value) {\n        rval[key] = api.clone(value[key]);\n      }\n    } else {\n      rval = value.toString();\n    }\n    return rval;\n  }\n  return value;\n};\n\n/**\n * Ensure a value is an array. If the value is an array, it is returned.\n * Otherwise, it is wrapped in an array.\n *\n * @param value the value to return as an array.\n *\n * @return the value as an array.\n */\napi.asArray = function (value) {\n  return Array.isArray(value) ? value : [value];\n};\n\n/**\n * Builds an HTTP headers object for making a JSON-LD request from custom\n * headers and asserts the `accept` header isn't overridden.\n *\n * @param headers an object of headers with keys as header names and values\n *          as header values.\n *\n * @return an object of headers with a valid `accept` header.\n */\napi.buildHeaders = function () {\n  var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var hasAccept = Object.keys(headers).some(function (h) {\n    return h.toLowerCase() === 'accept';\n  });\n  if (hasAccept) {\n    throw new RangeError('Accept header may not be specified; only \"' + DEFAULTS.headers.accept + '\" is supported.');\n  }\n  return Object.assign({\n    Accept: DEFAULTS.headers.accept\n  }, headers);\n};\n\n/**\n * Parses a link header. The results will be key'd by the value of \"rel\".\n *\n * Link: <http://json-ld.org/contexts/person.jsonld>;\n * rel=\"http://www.w3.org/ns/json-ld#context\"; type=\"application/ld+json\"\n *\n * Parses as: {\n *   'http://www.w3.org/ns/json-ld#context': {\n *     target: http://json-ld.org/contexts/person.jsonld,\n *     type: 'application/ld+json'\n *   }\n * }\n *\n * If there is more than one \"rel\" with the same IRI, then entries in the\n * resulting map for that \"rel\" will be arrays.\n *\n * @param header the link header to parse.\n */\napi.parseLinkHeader = function (header) {\n  var rval = {};\n  // split on unbracketed/unquoted commas\n  var entries = header.match(REGEX_LINK_HEADERS);\n  for (var i = 0; i < entries.length; ++i) {\n    var match = entries[i].match(REGEX_LINK_HEADER);\n    if (!match) {\n      continue;\n    }\n    var result = {\n      target: match[1]\n    };\n    var params = match[2];\n    while (match = REGEX_LINK_HEADER_PARAMS.exec(params)) {\n      result[match[1]] = match[2] === undefined ? match[3] : match[2];\n    }\n    var rel = result['rel'] || '';\n    if (Array.isArray(rval[rel])) {\n      rval[rel].push(result);\n    } else if (rval.hasOwnProperty(rel)) {\n      rval[rel] = [rval[rel], result];\n    } else {\n      rval[rel] = result;\n    }\n  }\n  return rval;\n};\n\n/**\n * Throws an exception if the given value is not a valid @type value.\n *\n * @param v the value to check.\n */\napi.validateTypeValue = function (v, isFrame) {\n  if (types.isString(v)) {\n    return;\n  }\n  if (types.isArray(v) && v.every(function (vv) {\n    return types.isString(vv);\n  })) {\n    return;\n  }\n  if (isFrame && types.isObject(v)) {\n    switch (Object.keys(v).length) {\n      case 0:\n        // empty object is wildcard\n        return;\n      case 1:\n        // default entry is all strings\n        if ('@default' in v && api.asArray(v['@default']).every(function (vv) {\n          return types.isString(vv);\n        })) {\n          return;\n        }\n    }\n  }\n  throw new JsonLdError('Invalid JSON-LD syntax; \"@type\" value must a string, an array of ' + 'strings, an empty object, ' + 'or a default object.', 'jsonld.SyntaxError', {\n    code: 'invalid type value',\n    value: v\n  });\n};\n\n/**\n * Returns true if the given subject has the given property.\n *\n * @param subject the subject to check.\n * @param property the property to look for.\n *\n * @return true if the subject has the given property, false if not.\n */\napi.hasProperty = function (subject, property) {\n  if (subject.hasOwnProperty(property)) {\n    var value = subject[property];\n    return !types.isArray(value) || value.length > 0;\n  }\n  return false;\n};\n\n/**\n * Determines if the given value is a property of the given subject.\n *\n * @param subject the subject to check.\n * @param property the property to check.\n * @param value the value to check.\n *\n * @return true if the value exists, false if not.\n */\napi.hasValue = function (subject, property, value) {\n  if (api.hasProperty(subject, property)) {\n    var val = subject[property];\n    var isList = graphTypes.isList(val);\n    if (types.isArray(val) || isList) {\n      if (isList) {\n        val = val['@list'];\n      }\n      for (var i = 0; i < val.length; ++i) {\n        if (api.compareValues(value, val[i])) {\n          return true;\n        }\n      }\n    } else if (!types.isArray(value)) {\n      // avoid matching the set of values with an array value parameter\n      return api.compareValues(value, val);\n    }\n  }\n  return false;\n};\n\n/**\n * Adds a value to a subject. If the value is an array, all values in the\n * array will be added.\n *\n * @param subject the subject to add the value to.\n * @param property the property that relates the value to the subject.\n * @param value the value to add.\n * @param [options] the options to use:\n *        [propertyIsArray] true if the property is always an array, false\n *          if not (default: false).\n *        [valueIsArray] true if the value to be added should be preserved as\n *          an array (lists) (default: false).\n *        [allowDuplicate] true to allow duplicates, false not to (uses a\n *          simple shallow comparison of subject ID or value) (default: true).\n *        [prependValue] false to prepend value to any existing values.\n *          (default: false)\n */\napi.addValue = function (subject, property, value, options) {\n  options = options || {};\n  if (!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n  if (!('valueIsArray' in options)) {\n    options.valueIsArray = false;\n  }\n  if (!('allowDuplicate' in options)) {\n    options.allowDuplicate = true;\n  }\n  if (!('prependValue' in options)) {\n    options.prependValue = false;\n  }\n  if (options.valueIsArray) {\n    subject[property] = value;\n  } else if (types.isArray(value)) {\n    if (value.length === 0 && options.propertyIsArray && !subject.hasOwnProperty(property)) {\n      subject[property] = [];\n    }\n    if (options.prependValue) {\n      value = value.concat(subject[property]);\n      subject[property] = [];\n    }\n    for (var i = 0; i < value.length; ++i) {\n      api.addValue(subject, property, value[i], options);\n    }\n  } else if (subject.hasOwnProperty(property)) {\n    // check if subject already has value if duplicates not allowed\n    var hasValue = !options.allowDuplicate && api.hasValue(subject, property, value);\n\n    // make property an array if value not present or always an array\n    if (!types.isArray(subject[property]) && (!hasValue || options.propertyIsArray)) {\n      subject[property] = [subject[property]];\n    }\n\n    // add new value\n    if (!hasValue) {\n      if (options.prependValue) {\n        subject[property].unshift(value);\n      } else {\n        subject[property].push(value);\n      }\n    }\n  } else {\n    // add new value as set or single value\n    subject[property] = options.propertyIsArray ? [value] : value;\n  }\n};\n\n/**\n * Gets all of the values for a subject's property as an array.\n *\n * @param subject the subject.\n * @param property the property.\n *\n * @return all of the values for a subject's property as an array.\n */\napi.getValues = function (subject, property) {\n  return [].concat(subject[property] || []);\n};\n\n/**\n * Removes a property from a subject.\n *\n * @param subject the subject.\n * @param property the property.\n */\napi.removeProperty = function (subject, property) {\n  delete subject[property];\n};\n\n/**\n * Removes a value from a subject.\n *\n * @param subject the subject.\n * @param property the property that relates the value to the subject.\n * @param value the value to remove.\n * @param [options] the options to use:\n *          [propertyIsArray] true if the property is always an array, false\n *            if not (default: false).\n */\napi.removeValue = function (subject, property, value, options) {\n  options = options || {};\n  if (!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n\n  // filter out value\n  var values = api.getValues(subject, property).filter(function (e) {\n    return !api.compareValues(e, value);\n  });\n  if (values.length === 0) {\n    api.removeProperty(subject, property);\n  } else if (values.length === 1 && !options.propertyIsArray) {\n    subject[property] = values[0];\n  } else {\n    subject[property] = values;\n  }\n};\n\n/**\n * Relabels all blank nodes in the given JSON-LD input.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [issuer] an IdentifierIssuer to use to label blank nodes.\n */\napi.relabelBlankNodes = function (input, options) {\n  options = options || {};\n  var issuer = options.issuer || new IdentifierIssuer('_:b');\n  return _labelBlankNodes(issuer, input);\n};\n\n/**\n * Compares two JSON-LD values for equality. Two JSON-LD values will be\n * considered equal if:\n *\n * 1. They are both primitives of the same type and value.\n * 2. They are both @values with the same @value, @type, @language,\n *   and @index, OR\n * 3. They both have @ids they are the same.\n *\n * @param v1 the first value.\n * @param v2 the second value.\n *\n * @return true if v1 and v2 are considered equal, false if not.\n */\napi.compareValues = function (v1, v2) {\n  // 1. equal primitives\n  if (v1 === v2) {\n    return true;\n  }\n\n  // 2. equal @values\n  if (graphTypes.isValue(v1) && graphTypes.isValue(v2) && v1['@value'] === v2['@value'] && v1['@type'] === v2['@type'] && v1['@language'] === v2['@language'] && v1['@index'] === v2['@index']) {\n    return true;\n  }\n\n  // 3. equal @ids\n  if (types.isObject(v1) && '@id' in v1 && types.isObject(v2) && '@id' in v2) {\n    return v1['@id'] === v2['@id'];\n  }\n  return false;\n};\n\n/**\n * Compares two strings first based on length and then lexicographically.\n *\n * @param a the first string.\n * @param b the second string.\n *\n * @return -1 if a < b, 1 if a > b, 0 if a === b.\n */\napi.compareShortestLeast = function (a, b) {\n  if (a.length < b.length) {\n    return -1;\n  }\n  if (b.length < a.length) {\n    return 1;\n  }\n  if (a === b) {\n    return 0;\n  }\n  return a < b ? -1 : 1;\n};\n\n/**\n * Labels the blank nodes in the given value using the given IdentifierIssuer.\n *\n * @param issuer the IdentifierIssuer to use.\n * @param element the element with blank nodes to rename.\n *\n * @return the element.\n */\nfunction _labelBlankNodes(issuer, element) {\n  if (types.isArray(element)) {\n    for (var i = 0; i < element.length; ++i) {\n      element[i] = _labelBlankNodes(issuer, element[i]);\n    }\n  } else if (graphTypes.isList(element)) {\n    element['@list'] = _labelBlankNodes(issuer, element['@list']);\n  } else if (types.isObject(element)) {\n    // relabel blank node\n    if (graphTypes.isBlankNode(element)) {\n      element['@id'] = issuer.getId(element['@id']);\n    }\n\n    // recursively apply to all keys\n    var keys = Object.keys(element).sort();\n    for (var ki = 0; ki < keys.length; ++ki) {\n      var key = keys[ki];\n      if (key !== '@id') {\n        element[key] = _labelBlankNodes(issuer, element[key]);\n      }\n    }\n  }\n  return element;\n}","map":{"version":3,"names":["graphTypes","require","types","IdentifierIssuer","JsonLdError","REGEX_LINK_HEADERS","REGEX_LINK_HEADER","REGEX_LINK_HEADER_PARAMS","DEFAULTS","headers","accept","api","module","exports","clone","value","rval","isArray","i","length","Map","k","v","set","Set","add","isObject","key","toString","asArray","Array","buildHeaders","hasAccept","Object","keys","some","h","toLowerCase","RangeError","assign","Accept","parseLinkHeader","header","entries","match","result","target","params","exec","undefined","rel","push","hasOwnProperty","validateTypeValue","isFrame","isString","every","vv","code","hasProperty","subject","property","hasValue","val","isList","compareValues","addValue","options","propertyIsArray","valueIsArray","allowDuplicate","prependValue","concat","unshift","getValues","removeProperty","removeValue","values","filter","e","relabelBlankNodes","input","issuer","_labelBlankNodes","v1","v2","isValue","compareShortestLeast","a","b","element","isBlankNode","getId","sort","ki"],"sources":["E:/react-todo-app/node_modules/jsonld/lib/util.js"],"sourcesContent":["/*\n * Copyright (c) 2017-2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst graphTypes = require('./graphTypes');\nconst types = require('./types');\n// TODO: move `IdentifierIssuer` to its own package\nconst IdentifierIssuer = require('rdf-canonize').IdentifierIssuer;\nconst JsonLdError = require('./JsonLdError');\n\n// constants\nconst REGEX_LINK_HEADERS = /(?:<[^>]*?>|\"[^\"]*?\"|[^,])+/g;\nconst REGEX_LINK_HEADER = /\\s*<([^>]*?)>\\s*(?:;\\s*(.*))?/;\nconst REGEX_LINK_HEADER_PARAMS =\n  /(.*?)=(?:(?:\"([^\"]*?)\")|([^\"]*?))\\s*(?:(?:;\\s*)|$)/g;\n\nconst DEFAULTS = {\n  headers: {\n    accept: 'application/ld+json, application/json'\n  }\n};\n\nconst api = {};\nmodule.exports = api;\napi.IdentifierIssuer = IdentifierIssuer;\n\n/**\n * Clones an object, array, Map, Set, or string/number. If a typed JavaScript\n * object is given, such as a Date, it will be converted to a string.\n *\n * @param value the value to clone.\n *\n * @return the cloned value.\n */\napi.clone = function(value) {\n  if(value && typeof value === 'object') {\n    let rval;\n    if(types.isArray(value)) {\n      rval = [];\n      for(let i = 0; i < value.length; ++i) {\n        rval[i] = api.clone(value[i]);\n      }\n    } else if(value instanceof Map) {\n      rval = new Map();\n      for(const [k, v] of value) {\n        rval.set(k, api.clone(v));\n      }\n    } else if(value instanceof Set) {\n      rval = new Set();\n      for(const v of value) {\n        rval.add(api.clone(v));\n      }\n    } else if(types.isObject(value)) {\n      rval = {};\n      for(const key in value) {\n        rval[key] = api.clone(value[key]);\n      }\n    } else {\n      rval = value.toString();\n    }\n    return rval;\n  }\n  return value;\n};\n\n/**\n * Ensure a value is an array. If the value is an array, it is returned.\n * Otherwise, it is wrapped in an array.\n *\n * @param value the value to return as an array.\n *\n * @return the value as an array.\n */\napi.asArray = function(value) {\n  return Array.isArray(value) ? value : [value];\n};\n\n/**\n * Builds an HTTP headers object for making a JSON-LD request from custom\n * headers and asserts the `accept` header isn't overridden.\n *\n * @param headers an object of headers with keys as header names and values\n *          as header values.\n *\n * @return an object of headers with a valid `accept` header.\n */\napi.buildHeaders = (headers = {}) => {\n  const hasAccept = Object.keys(headers).some(\n    h => h.toLowerCase() === 'accept');\n\n  if(hasAccept) {\n    throw new RangeError(\n      'Accept header may not be specified; only \"' +\n      DEFAULTS.headers.accept + '\" is supported.');\n  }\n\n  return Object.assign({Accept: DEFAULTS.headers.accept}, headers);\n};\n\n/**\n * Parses a link header. The results will be key'd by the value of \"rel\".\n *\n * Link: <http://json-ld.org/contexts/person.jsonld>;\n * rel=\"http://www.w3.org/ns/json-ld#context\"; type=\"application/ld+json\"\n *\n * Parses as: {\n *   'http://www.w3.org/ns/json-ld#context': {\n *     target: http://json-ld.org/contexts/person.jsonld,\n *     type: 'application/ld+json'\n *   }\n * }\n *\n * If there is more than one \"rel\" with the same IRI, then entries in the\n * resulting map for that \"rel\" will be arrays.\n *\n * @param header the link header to parse.\n */\napi.parseLinkHeader = header => {\n  const rval = {};\n  // split on unbracketed/unquoted commas\n  const entries = header.match(REGEX_LINK_HEADERS);\n  for(let i = 0; i < entries.length; ++i) {\n    let match = entries[i].match(REGEX_LINK_HEADER);\n    if(!match) {\n      continue;\n    }\n    const result = {target: match[1]};\n    const params = match[2];\n    while((match = REGEX_LINK_HEADER_PARAMS.exec(params))) {\n      result[match[1]] = (match[2] === undefined) ? match[3] : match[2];\n    }\n    const rel = result['rel'] || '';\n    if(Array.isArray(rval[rel])) {\n      rval[rel].push(result);\n    } else if(rval.hasOwnProperty(rel)) {\n      rval[rel] = [rval[rel], result];\n    } else {\n      rval[rel] = result;\n    }\n  }\n  return rval;\n};\n\n/**\n * Throws an exception if the given value is not a valid @type value.\n *\n * @param v the value to check.\n */\napi.validateTypeValue = (v, isFrame) => {\n  if(types.isString(v)) {\n    return;\n  }\n\n  if(types.isArray(v) && v.every(vv => types.isString(vv))) {\n    return;\n  }\n  if(isFrame && types.isObject(v)) {\n    switch(Object.keys(v).length) {\n      case 0:\n        // empty object is wildcard\n        return;\n      case 1:\n        // default entry is all strings\n        if('@default' in v &&\n          api.asArray(v['@default']).every(vv => types.isString(vv))) {\n          return;\n        }\n    }\n  }\n\n  throw new JsonLdError(\n    'Invalid JSON-LD syntax; \"@type\" value must a string, an array of ' +\n    'strings, an empty object, ' +\n    'or a default object.', 'jsonld.SyntaxError',\n    {code: 'invalid type value', value: v});\n};\n\n/**\n * Returns true if the given subject has the given property.\n *\n * @param subject the subject to check.\n * @param property the property to look for.\n *\n * @return true if the subject has the given property, false if not.\n */\napi.hasProperty = (subject, property) => {\n  if(subject.hasOwnProperty(property)) {\n    const value = subject[property];\n    return (!types.isArray(value) || value.length > 0);\n  }\n  return false;\n};\n\n/**\n * Determines if the given value is a property of the given subject.\n *\n * @param subject the subject to check.\n * @param property the property to check.\n * @param value the value to check.\n *\n * @return true if the value exists, false if not.\n */\napi.hasValue = (subject, property, value) => {\n  if(api.hasProperty(subject, property)) {\n    let val = subject[property];\n    const isList = graphTypes.isList(val);\n    if(types.isArray(val) || isList) {\n      if(isList) {\n        val = val['@list'];\n      }\n      for(let i = 0; i < val.length; ++i) {\n        if(api.compareValues(value, val[i])) {\n          return true;\n        }\n      }\n    } else if(!types.isArray(value)) {\n      // avoid matching the set of values with an array value parameter\n      return api.compareValues(value, val);\n    }\n  }\n  return false;\n};\n\n/**\n * Adds a value to a subject. If the value is an array, all values in the\n * array will be added.\n *\n * @param subject the subject to add the value to.\n * @param property the property that relates the value to the subject.\n * @param value the value to add.\n * @param [options] the options to use:\n *        [propertyIsArray] true if the property is always an array, false\n *          if not (default: false).\n *        [valueIsArray] true if the value to be added should be preserved as\n *          an array (lists) (default: false).\n *        [allowDuplicate] true to allow duplicates, false not to (uses a\n *          simple shallow comparison of subject ID or value) (default: true).\n *        [prependValue] false to prepend value to any existing values.\n *          (default: false)\n */\napi.addValue = (subject, property, value, options) => {\n  options = options || {};\n  if(!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n  if(!('valueIsArray' in options)) {\n    options.valueIsArray = false;\n  }\n  if(!('allowDuplicate' in options)) {\n    options.allowDuplicate = true;\n  }\n  if(!('prependValue' in options)) {\n    options.prependValue = false;\n  }\n\n  if(options.valueIsArray) {\n    subject[property] = value;\n  } else if(types.isArray(value)) {\n    if(value.length === 0 && options.propertyIsArray &&\n      !subject.hasOwnProperty(property)) {\n      subject[property] = [];\n    }\n    if(options.prependValue) {\n      value = value.concat(subject[property]);\n      subject[property] = [];\n    }\n    for(let i = 0; i < value.length; ++i) {\n      api.addValue(subject, property, value[i], options);\n    }\n  } else if(subject.hasOwnProperty(property)) {\n    // check if subject already has value if duplicates not allowed\n    const hasValue = (!options.allowDuplicate &&\n      api.hasValue(subject, property, value));\n\n    // make property an array if value not present or always an array\n    if(!types.isArray(subject[property]) &&\n      (!hasValue || options.propertyIsArray)) {\n      subject[property] = [subject[property]];\n    }\n\n    // add new value\n    if(!hasValue) {\n      if(options.prependValue) {\n        subject[property].unshift(value);\n      } else {\n        subject[property].push(value);\n      }\n    }\n  } else {\n    // add new value as set or single value\n    subject[property] = options.propertyIsArray ? [value] : value;\n  }\n};\n\n/**\n * Gets all of the values for a subject's property as an array.\n *\n * @param subject the subject.\n * @param property the property.\n *\n * @return all of the values for a subject's property as an array.\n */\napi.getValues = (subject, property) => [].concat(subject[property] || []);\n\n/**\n * Removes a property from a subject.\n *\n * @param subject the subject.\n * @param property the property.\n */\napi.removeProperty = (subject, property) => {\n  delete subject[property];\n};\n\n/**\n * Removes a value from a subject.\n *\n * @param subject the subject.\n * @param property the property that relates the value to the subject.\n * @param value the value to remove.\n * @param [options] the options to use:\n *          [propertyIsArray] true if the property is always an array, false\n *            if not (default: false).\n */\napi.removeValue = (subject, property, value, options) => {\n  options = options || {};\n  if(!('propertyIsArray' in options)) {\n    options.propertyIsArray = false;\n  }\n\n  // filter out value\n  const values = api.getValues(subject, property).filter(\n    e => !api.compareValues(e, value));\n\n  if(values.length === 0) {\n    api.removeProperty(subject, property);\n  } else if(values.length === 1 && !options.propertyIsArray) {\n    subject[property] = values[0];\n  } else {\n    subject[property] = values;\n  }\n};\n\n/**\n * Relabels all blank nodes in the given JSON-LD input.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [issuer] an IdentifierIssuer to use to label blank nodes.\n */\napi.relabelBlankNodes = (input, options) => {\n  options = options || {};\n  const issuer = options.issuer || new IdentifierIssuer('_:b');\n  return _labelBlankNodes(issuer, input);\n};\n\n/**\n * Compares two JSON-LD values for equality. Two JSON-LD values will be\n * considered equal if:\n *\n * 1. They are both primitives of the same type and value.\n * 2. They are both @values with the same @value, @type, @language,\n *   and @index, OR\n * 3. They both have @ids they are the same.\n *\n * @param v1 the first value.\n * @param v2 the second value.\n *\n * @return true if v1 and v2 are considered equal, false if not.\n */\napi.compareValues = (v1, v2) => {\n  // 1. equal primitives\n  if(v1 === v2) {\n    return true;\n  }\n\n  // 2. equal @values\n  if(graphTypes.isValue(v1) && graphTypes.isValue(v2) &&\n    v1['@value'] === v2['@value'] &&\n    v1['@type'] === v2['@type'] &&\n    v1['@language'] === v2['@language'] &&\n    v1['@index'] === v2['@index']) {\n    return true;\n  }\n\n  // 3. equal @ids\n  if(types.isObject(v1) &&\n    ('@id' in v1) &&\n    types.isObject(v2) &&\n    ('@id' in v2)) {\n    return v1['@id'] === v2['@id'];\n  }\n\n  return false;\n};\n\n/**\n * Compares two strings first based on length and then lexicographically.\n *\n * @param a the first string.\n * @param b the second string.\n *\n * @return -1 if a < b, 1 if a > b, 0 if a === b.\n */\napi.compareShortestLeast = (a, b) => {\n  if(a.length < b.length) {\n    return -1;\n  }\n  if(b.length < a.length) {\n    return 1;\n  }\n  if(a === b) {\n    return 0;\n  }\n  return (a < b) ? -1 : 1;\n};\n\n/**\n * Labels the blank nodes in the given value using the given IdentifierIssuer.\n *\n * @param issuer the IdentifierIssuer to use.\n * @param element the element with blank nodes to rename.\n *\n * @return the element.\n */\nfunction _labelBlankNodes(issuer, element) {\n  if(types.isArray(element)) {\n    for(let i = 0; i < element.length; ++i) {\n      element[i] = _labelBlankNodes(issuer, element[i]);\n    }\n  } else if(graphTypes.isList(element)) {\n    element['@list'] = _labelBlankNodes(issuer, element['@list']);\n  } else if(types.isObject(element)) {\n    // relabel blank node\n    if(graphTypes.isBlankNode(element)) {\n      element['@id'] = issuer.getId(element['@id']);\n    }\n\n    // recursively apply to all keys\n    const keys = Object.keys(element).sort();\n    for(let ki = 0; ki < keys.length; ++ki) {\n      const key = keys[ki];\n      if(key !== '@id') {\n        element[key] = _labelBlankNodes(issuer, element[key]);\n      }\n    }\n  }\n\n  return element;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}