{"ast":null,"code":"// **N3Store** objects store N3 quads by graph in memory.\nimport { default as N3DataFactory, termToId, termFromId } from './N3DataFactory';\nimport { Readable } from 'readable-stream';\nimport namespaces from './IRIs';\n\n// ## Constructor\nexport default class N3Store {\n  constructor(quads, options) {\n    // The number of quads is initially zero\n    this._size = 0;\n    // `_graphs` contains subject, predicate, and object indexes per graph\n    this._graphs = Object.create(null);\n    // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n    this._id = 0;\n    this._ids = Object.create(null);\n    this._ids['><'] = 0; // dummy entry, so the first actual key is non-zero\n    this._entities = Object.create(null); // inverse of `_ids`\n    // `_blankNodeIndex` is the index of the last automatically named blank node\n    this._blankNodeIndex = 0;\n\n    // Shift parameters if `quads` is not given\n    if (!options && quads && !quads[0]) options = quads, quads = null;\n    options = options || {};\n    this._factory = options.factory || N3DataFactory;\n\n    // Add quads if passed\n    if (quads) this.addQuads(quads);\n  }\n\n  // ## Public properties\n\n  // ### `size` returns the number of quads in the store\n  get size() {\n    // Return the quad count if if was cached\n    let size = this._size;\n    if (size !== null) return size;\n\n    // Calculate the number of quads by counting to the deepest level\n    size = 0;\n    const graphs = this._graphs;\n    let subjects, subject;\n    for (const graphKey in graphs) for (const subjectKey in subjects = graphs[graphKey].subjects) for (const predicateKey in subject = subjects[subjectKey]) size += Object.keys(subject[predicateKey]).length;\n    return this._size = size;\n  }\n\n  // ## Private methods\n\n  // ### `_addToIndex` adds a quad to a three-layered index.\n  // Returns if the index has changed, if the entry did not already exist.\n  _addToIndex(index0, key0, key1, key2) {\n    // Create layers as necessary\n    const index1 = index0[key0] || (index0[key0] = {});\n    const index2 = index1[key1] || (index1[key1] = {});\n    // Setting the key to _any_ value signals the presence of the quad\n    const existed = (key2 in index2);\n    if (!existed) index2[key2] = null;\n    return !existed;\n  }\n\n  // ### `_removeFromIndex` removes a quad from a three-layered index\n  _removeFromIndex(index0, key0, key1, key2) {\n    // Remove the quad from the index\n    const index1 = index0[key0],\n      index2 = index1[key1];\n    delete index2[key2];\n\n    // Remove intermediary index layers if they are empty\n    for (const key in index2) return;\n    delete index1[key1];\n    for (const key in index1) return;\n    delete index0[key0];\n  }\n\n  // ### `_findInIndex` finds a set of quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  // `name0`, `name1`, and `name2` are the names of the keys at each level,\n  // used when reconstructing the resulting quad\n  // (for instance: _subject_, _predicate_, and _object_).\n  // Finally, `graphId` will be the graph of the created quads.\n  *_findInIndex(index0, key0, key1, key2, name0, name1, name2, graphId) {\n    let tmp, index1, index2;\n    const entityKeys = this._entities;\n    const graph = termFromId(graphId, this._factory);\n    const parts = {\n      subject: null,\n      predicate: null,\n      object: null\n    };\n\n    // If a key is specified, use only that part of index 0.\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n    for (const value0 in index0) {\n      if (index1 = index0[value0]) {\n        parts[name0] = termFromId(entityKeys[value0], this._factory);\n        // If a key is specified, use only that part of index 1.\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n        for (const value1 in index1) {\n          if (index2 = index1[value1]) {\n            parts[name1] = termFromId(entityKeys[value1], this._factory);\n            // If a key is specified, use only that part of index 2, if it exists.\n            const values = key2 ? key2 in index2 ? [key2] : [] : Object.keys(index2);\n            // Create quads for all items found in index 2.\n            for (let l = 0; l < values.length; l++) {\n              parts[name2] = termFromId(entityKeys[values[l]], this._factory);\n              yield this._factory.quad(parts.subject, parts.predicate, parts.object, graph);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // ### `_loop` executes the callback on all keys of index 0\n  _loop(index0, callback) {\n    for (const key0 in index0) callback(key0);\n  }\n\n  // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0\n  _loopByKey0(index0, key0, callback) {\n    let index1, key1;\n    if (index1 = index0[key0]) {\n      for (key1 in index1) callback(key1);\n    }\n  }\n\n  // ### `_loopByKey1` executes the callback on given keys of all entries in index 0\n  _loopByKey1(index0, key1, callback) {\n    let key0, index1;\n    for (key0 in index0) {\n      index1 = index0[key0];\n      if (index1[key1]) callback(key0);\n    }\n  }\n\n  // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2\n  _loopBy2Keys(index0, key0, key1, callback) {\n    let index1, index2, key2;\n    if ((index1 = index0[key0]) && (index2 = index1[key1])) {\n      for (key2 in index2) callback(key2);\n    }\n  }\n\n  // ### `_countInIndex` counts matching quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  _countInIndex(index0, key0, key1, key2) {\n    let count = 0,\n      tmp,\n      index1,\n      index2;\n\n    // If a key is specified, count only that part of index 0\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n    for (const value0 in index0) {\n      if (index1 = index0[value0]) {\n        // If a key is specified, count only that part of index 1\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n        for (const value1 in index1) {\n          if (index2 = index1[value1]) {\n            // If a key is specified, count the quad if it exists\n            if (key2) key2 in index2 && count++;\n            // Otherwise, count all quads\n            else count += Object.keys(index2).length;\n          }\n        }\n      }\n    }\n    return count;\n  }\n\n  // ### `_getGraphs` returns an array with the given graph,\n  // or all graphs if the argument is null or undefined.\n  _getGraphs(graph) {\n    if (!isString(graph)) return this._graphs;\n    const graphs = {};\n    graphs[graph] = this._graphs[graph];\n    return graphs;\n  }\n\n  // ### `_uniqueEntities` returns a function that accepts an entity ID\n  // and passes the corresponding entity to callback if it hasn't occurred before.\n  _uniqueEntities(callback) {\n    const uniqueIds = Object.create(null);\n    return id => {\n      if (!(id in uniqueIds)) {\n        uniqueIds[id] = true;\n        callback(termFromId(this._entities[id], this._factory));\n      }\n    };\n  }\n\n  // ## Public methods\n\n  // ### `add` adds the specified quad to the dataset.\n  // Returns the dataset instance it was called on.\n  // Existing quads, as defined in Quad.equals, will be ignored.\n  add(quad) {\n    this.addQuad(quad);\n    return this;\n  }\n\n  // ### `addQuad` adds a new quad to the store.\n  // Returns if the quad index has changed, if the quad did not already exist.\n  addQuad(subject, predicate, object, graph) {\n    // Shift arguments if a quad object is given instead of components\n    if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject;\n\n    // Convert terms to internal string representation\n    subject = termToId(subject);\n    predicate = termToId(predicate);\n    object = termToId(object);\n    graph = termToId(graph);\n\n    // Find the graph that will contain the triple\n    let graphItem = this._graphs[graph];\n    // Create the graph if it doesn't exist yet\n    if (!graphItem) {\n      graphItem = this._graphs[graph] = {\n        subjects: {},\n        predicates: {},\n        objects: {}\n      };\n      // Freezing a graph helps subsequent `add` performance,\n      // and properties will never be modified anyway\n      Object.freeze(graphItem);\n    }\n\n    // Since entities can often be long IRIs, we avoid storing them in every index.\n    // Instead, we have a separate index that maps entities to numbers,\n    // which are then used as keys in the other indexes.\n    const ids = this._ids;\n    const entities = this._entities;\n    subject = ids[subject] || (ids[entities[++this._id] = subject] = this._id);\n    predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);\n    object = ids[object] || (ids[entities[++this._id] = object] = this._id);\n    const changed = this._addToIndex(graphItem.subjects, subject, predicate, object);\n    this._addToIndex(graphItem.predicates, predicate, object, subject);\n    this._addToIndex(graphItem.objects, object, subject, predicate);\n\n    // The cached quad count is now invalid\n    this._size = null;\n    return changed;\n  }\n\n  // ### `addQuads` adds multiple quads to the store\n  addQuads(quads) {\n    for (let i = 0; i < quads.length; i++) this.addQuad(quads[i]);\n  }\n\n  // ### `delete` removes the specified quad from the dataset.\n  // Returns the dataset instance it was called on.\n  delete(quad) {\n    this.removeQuad(quad);\n    return this;\n  }\n\n  // ### `has` determines whether a dataset includes a certain quad or quad pattern.\n  has(subjectOrQuad, predicate, object, graph) {\n    if (subjectOrQuad && subjectOrQuad.subject) ({\n      subject: subjectOrQuad,\n      predicate,\n      object,\n      graph\n    } = subjectOrQuad);\n    return !this.readQuads(subjectOrQuad, predicate, object, graph).next().done;\n  }\n\n  // ### `import` adds a stream of quads to the store\n  import(stream) {\n    stream.on('data', quad => {\n      this.addQuad(quad);\n    });\n    return stream;\n  }\n\n  // ### `removeQuad` removes a quad from the store if it exists\n  removeQuad(subject, predicate, object, graph) {\n    // Shift arguments if a quad object is given instead of components\n    if (!predicate) graph = subject.graph, object = subject.object, predicate = subject.predicate, subject = subject.subject;\n\n    // Convert terms to internal string representation\n    subject = termToId(subject);\n    predicate = termToId(predicate);\n    object = termToId(object);\n    graph = termToId(graph);\n\n    // Find internal identifiers for all components\n    // and verify the quad exists.\n    const ids = this._ids,\n      graphs = this._graphs;\n    let graphItem, subjects, predicates;\n    if (!(subject = ids[subject]) || !(predicate = ids[predicate]) || !(object = ids[object]) || !(graphItem = graphs[graph]) || !(subjects = graphItem.subjects[subject]) || !(predicates = subjects[predicate]) || !(object in predicates)) return false;\n\n    // Remove it from all indexes\n    this._removeFromIndex(graphItem.subjects, subject, predicate, object);\n    this._removeFromIndex(graphItem.predicates, predicate, object, subject);\n    this._removeFromIndex(graphItem.objects, object, subject, predicate);\n    if (this._size !== null) this._size--;\n\n    // Remove the graph if it is empty\n    for (subject in graphItem.subjects) return true;\n    delete graphs[graph];\n    return true;\n  }\n\n  // ### `removeQuads` removes multiple quads from the store\n  removeQuads(quads) {\n    for (let i = 0; i < quads.length; i++) this.removeQuad(quads[i]);\n  }\n\n  // ### `remove` removes a stream of quads from the store\n  remove(stream) {\n    stream.on('data', quad => {\n      this.removeQuad(quad);\n    });\n    return stream;\n  }\n\n  // ### `removeMatches` removes all matching quads from the store\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  removeMatches(subject, predicate, object, graph) {\n    const stream = new Readable({\n      objectMode: true\n    });\n    stream._read = () => {\n      for (const quad of this.readQuads(subject, predicate, object, graph)) stream.push(quad);\n      stream.push(null);\n    };\n    return this.remove(stream);\n  }\n\n  // ### `deleteGraph` removes all triples with the given graph from the store\n  deleteGraph(graph) {\n    return this.removeMatches(null, null, null, graph);\n  }\n\n  // ### `getQuads` returns an array of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getQuads(subject, predicate, object, graph) {\n    return [...this.readQuads(subject, predicate, object, graph)];\n  }\n\n  // ### `readQuads` returns an generator of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  *readQuads(subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n    const graphs = this._getGraphs(graph),\n      ids = this._ids;\n    let content, subjectId, predicateId, objectId;\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return;\n    for (const graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subjectId) {\n          if (objectId)\n            // If subject and object are given, the object index will be the fastest\n            yield* this._findInIndex(content.objects, objectId, subjectId, predicateId, 'object', 'subject', 'predicate', graphId);else\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            yield* this._findInIndex(content.subjects, subjectId, predicateId, null, 'subject', 'predicate', 'object', graphId);\n        } else if (predicateId)\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          yield* this._findInIndex(content.predicates, predicateId, objectId, null, 'predicate', 'object', 'subject', graphId);else if (objectId)\n          // If only object is given, the object index will be the fastest\n          yield* this._findInIndex(content.objects, objectId, null, null, 'object', 'subject', 'predicate', graphId);else\n          // If nothing is given, iterate subjects and predicates first\n          yield* this._findInIndex(content.subjects, null, null, null, 'subject', 'predicate', 'object', graphId);\n      }\n    }\n  }\n\n  // ### `match` returns a new dataset that is comprised of all quads in the current instance matching the given arguments.\n  // The logic described in Quad Matching is applied for each quad in this dataset to check if it should be included in the output dataset.\n  // Note: This method always returns a new DatasetCore, even if that dataset contains no quads.\n  // Note: Since a DatasetCore is an unordered set, the order of the quads within the returned sequence is arbitrary.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  // For backwards compatibility, the object return also implements the Readable stream interface.\n  match(subject, predicate, object, graph) {\n    return new DatasetCoreAndReadableStream(this, subject, predicate, object, graph);\n  }\n\n  // ### `countQuads` returns the number of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  countQuads(subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n    const graphs = this._getGraphs(graph),\n      ids = this._ids;\n    let count = 0,\n      content,\n      subjectId,\n      predicateId,\n      objectId;\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return 0;\n    for (const graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subject) {\n          if (object)\n            // If subject and object are given, the object index will be the fastest\n            count += this._countInIndex(content.objects, objectId, subjectId, predicateId);else\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);\n        } else if (predicate) {\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);\n        } else {\n          // If only object is possibly given, the object index will be the fastest\n          count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n        }\n      }\n    }\n    return count;\n  }\n\n  // ### `forEach` executes the callback on all quads.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forEach(callback, subject, predicate, object, graph) {\n    this.some(quad => {\n      callback(quad);\n      return false;\n    }, subject, predicate, object, graph);\n  }\n\n  // ### `every` executes the callback on all quads,\n  // and returns `true` if it returns truthy for all them.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  every(callback, subject, predicate, object, graph) {\n    let some = false;\n    const every = !this.some(quad => {\n      some = true;\n      return !callback(quad);\n    }, subject, predicate, object, graph);\n    return some && every;\n  }\n\n  // ### `some` executes the callback on all quads,\n  // and returns `true` if it returns truthy for any of them.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  some(callback, subject, predicate, object, graph) {\n    for (const quad of this.readQuads(subject, predicate, object, graph)) if (callback(quad)) return true;\n    return false;\n  }\n\n  // ### `getSubjects` returns all subjects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getSubjects(predicate, object, graph) {\n    const results = [];\n    this.forSubjects(s => {\n      results.push(s);\n    }, predicate, object, graph);\n    return results;\n  }\n\n  // ### `forSubjects` executes the callback on all subjects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forSubjects(callback, predicate, object, graph) {\n    // Convert terms to internal string representation\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n    const ids = this._ids,\n      graphs = this._getGraphs(graph);\n    let content, predicateId, objectId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (isString(predicate) && !(predicateId = ids[predicate]) || isString(object) && !(objectId = ids[object])) return;\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (predicateId) {\n          if (objectId)\n            // If predicate and object are given, the POS index is best.\n            this._loopBy2Keys(content.predicates, predicateId, objectId, callback);else\n            // If only predicate is given, the SPO index is best.\n            this._loopByKey1(content.subjects, predicateId, callback);\n        } else if (objectId)\n          // If only object is given, the OSP index is best.\n          this._loopByKey0(content.objects, objectId, callback);else\n          // If no params given, iterate all the subjects\n          this._loop(content.subjects, callback);\n      }\n    }\n  }\n\n  // ### `getPredicates` returns all predicates that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getPredicates(subject, object, graph) {\n    const results = [];\n    this.forPredicates(p => {\n      results.push(p);\n    }, subject, object, graph);\n    return results;\n  }\n\n  // ### `forPredicates` executes the callback on all predicates that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forPredicates(callback, subject, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n    const ids = this._ids,\n      graphs = this._getGraphs(graph);\n    let content, subjectId, objectId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(object) && !(objectId = ids[object])) return;\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (subjectId) {\n          if (objectId)\n            // If subject and object are given, the OSP index is best.\n            this._loopBy2Keys(content.objects, objectId, subjectId, callback);else\n            // If only subject is given, the SPO index is best.\n            this._loopByKey0(content.subjects, subjectId, callback);\n        } else if (objectId)\n          // If only object is given, the POS index is best.\n          this._loopByKey1(content.predicates, objectId, callback);else\n          // If no params given, iterate all the predicates.\n          this._loop(content.predicates, callback);\n      }\n    }\n  }\n\n  // ### `getObjects` returns all objects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getObjects(subject, predicate, graph) {\n    const results = [];\n    this.forObjects(o => {\n      results.push(o);\n    }, subject, predicate, graph);\n    return results;\n  }\n\n  // ### `forObjects` executes the callback on all objects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forObjects(callback, subject, predicate, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    graph = graph && termToId(graph);\n    const ids = this._ids,\n      graphs = this._getGraphs(graph);\n    let content, subjectId, predicateId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject) && !(subjectId = ids[subject]) || isString(predicate) && !(predicateId = ids[predicate])) return;\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (subjectId) {\n          if (predicateId)\n            // If subject and predicate are given, the SPO index is best.\n            this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);else\n            // If only subject is given, the OSP index is best.\n            this._loopByKey1(content.objects, subjectId, callback);\n        } else if (predicateId)\n          // If only predicate is given, the POS index is best.\n          this._loopByKey0(content.predicates, predicateId, callback);else\n          // If no params given, iterate all the objects.\n          this._loop(content.objects, callback);\n      }\n    }\n  }\n\n  // ### `getGraphs` returns all graphs that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getGraphs(subject, predicate, object) {\n    const results = [];\n    this.forGraphs(g => {\n      results.push(g);\n    }, subject, predicate, object);\n    return results;\n  }\n\n  // ### `forGraphs` executes the callback on all graphs that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forGraphs(callback, subject, predicate, object) {\n    for (const graph in this._graphs) {\n      this.some(quad => {\n        callback(quad.graph);\n        return true; // Halt iteration of some()\n      }, subject, predicate, object, graph);\n    }\n  }\n\n  // ### `createBlankNode` creates a new blank node, returning its name\n  createBlankNode(suggestedName) {\n    let name, index;\n    // Generate a name based on the suggested name\n    if (suggestedName) {\n      name = suggestedName = `_:${suggestedName}`, index = 1;\n      while (this._ids[name]) name = suggestedName + index++;\n    }\n    // Generate a generic blank node name\n    else {\n      do {\n        name = `_:b${this._blankNodeIndex++}`;\n      } while (this._ids[name]);\n    }\n    // Add the blank node to the entities, avoiding the generation of duplicates\n    this._ids[name] = ++this._id;\n    this._entities[this._id] = name;\n    return this._factory.blankNode(name.substr(2));\n  }\n\n  // ### `extractLists` finds and removes all list triples\n  // and returns the items per list.\n  extractLists() {\n    let {\n      remove = false,\n      ignoreErrors = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const lists = {}; // has scalar keys so could be a simple Object\n    const onError = ignoreErrors ? () => true : (node, message) => {\n      throw new Error(`${node.value} ${message}`);\n    };\n\n    // Traverse each list from its tail\n    const tails = this.getQuads(null, namespaces.rdf.rest, namespaces.rdf.nil, null);\n    const toRemove = remove ? [...tails] : [];\n    tails.forEach(tailQuad => {\n      const items = []; // the members found as objects of rdf:first quads\n      let malformed = false; // signals whether the current list is malformed\n      let head; // the head of the list (_:b1 in above example)\n      let headPos; // set to subject or object when head is set\n      const graph = tailQuad.graph; // make sure list is in exactly one graph\n\n      // Traverse the list from tail to end\n      let current = tailQuad.subject;\n      while (current && !malformed) {\n        const objectQuads = this.getQuads(null, null, current, null);\n        const subjectQuads = this.getQuads(current, null, null, null);\n        let quad,\n          first = null,\n          rest = null,\n          parent = null;\n\n        // Find the first and rest of this list node\n        for (let i = 0; i < subjectQuads.length && !malformed; i++) {\n          quad = subjectQuads[i];\n          if (!quad.graph.equals(graph)) malformed = onError(current, 'not confined to single graph');else if (head) malformed = onError(current, 'has non-list arcs out');\n\n          // one rdf:first\n          else if (quad.predicate.value === namespaces.rdf.first) {\n            if (first) malformed = onError(current, 'has multiple rdf:first arcs');else toRemove.push(first = quad);\n          }\n\n          // one rdf:rest\n          else if (quad.predicate.value === namespaces.rdf.rest) {\n            if (rest) malformed = onError(current, 'has multiple rdf:rest arcs');else toRemove.push(rest = quad);\n          }\n\n          // alien triple\n          else if (objectQuads.length) malformed = onError(current, 'can\\'t be subject and object');else {\n            head = quad; // e.g. { (1 2 3) :p :o }\n            headPos = 'subject';\n          }\n        }\n\n        // { :s :p (1 2) } arrives here with no head\n        // { (1 2) :p :o } arrives here with head set to the list.\n        for (let i = 0; i < objectQuads.length && !malformed; ++i) {\n          quad = objectQuads[i];\n          if (head) malformed = onError(current, 'can\\'t have coreferences');\n          // one rdf:rest\n          else if (quad.predicate.value === namespaces.rdf.rest) {\n            if (parent) malformed = onError(current, 'has incoming rdf:rest arcs');else parent = quad;\n          } else {\n            head = quad; // e.g. { :s :p (1 2) }\n            headPos = 'object';\n          }\n        }\n\n        // Store the list item and continue with parent\n        if (!first) malformed = onError(current, 'has no list head');else items.unshift(first.object);\n        current = parent && parent.subject;\n      }\n\n      // Don't remove any quads if the list is malformed\n      if (malformed) remove = false;\n      // Store the list under the value of its head\n      else if (head) lists[head[headPos].value] = items;\n    });\n\n    // Remove list quads if requested\n    if (remove) this.removeQuads(toRemove);\n    return lists;\n  }\n\n  // ### Store is an iterable.\n  // Can be used where iterables are expected: for...of loops, array spread operator,\n  // `yield*`, and destructuring assignment (order is not guaranteed).\n  *[Symbol.iterator]() {\n    yield* this.readQuads();\n  }\n}\n\n// Determines whether the argument is a string\nfunction isString(s) {\n  return typeof s === 'string' || s instanceof String;\n}\n\n/**\n * A class that implements both DatasetCore and Readable.\n */\nclass DatasetCoreAndReadableStream extends Readable {\n  constructor(n3Store, subject, predicate, object, graph) {\n    super({\n      objectMode: true\n    });\n    Object.assign(this, {\n      n3Store,\n      subject,\n      predicate,\n      object,\n      graph\n    });\n  }\n  get filtered() {\n    if (!this._filtered) {\n      const {\n        n3Store,\n        graph,\n        object,\n        predicate,\n        subject\n      } = this;\n      const newStore = this._filtered = new N3Store({\n        factory: n3Store._factory\n      });\n      for (const quad of n3Store.readQuads(subject, predicate, object, graph)) newStore.addQuad(quad);\n    }\n    return this._filtered;\n  }\n  get size() {\n    return this.filtered.size;\n  }\n  _read() {\n    for (const quad of this) this.push(quad);\n    this.push(null);\n  }\n  add(quad) {\n    return this.filtered.add(quad);\n  }\n  delete(quad) {\n    return this.filtered.delete(quad);\n  }\n  has(quad) {\n    return this.filtered.has(quad);\n  }\n  match(subject, predicate, object, graph) {\n    return new DatasetCoreAndReadableStream(this.filtered, subject, predicate, object, graph);\n  }\n  *[Symbol.iterator]() {\n    yield* this._filtered || this.n3Store.readQuads(this.subject, this.predicate, this.object, this.graph);\n  }\n}","map":{"version":3,"names":["default","N3DataFactory","termToId","termFromId","Readable","namespaces","N3Store","constructor","quads","options","_size","_graphs","Object","create","_id","_ids","_entities","_blankNodeIndex","_factory","factory","addQuads","size","graphs","subjects","subject","graphKey","subjectKey","predicateKey","keys","length","_addToIndex","index0","key0","key1","key2","index1","index2","existed","_removeFromIndex","key","_findInIndex","name0","name1","name2","graphId","tmp","entityKeys","graph","parts","predicate","object","value0","value1","values","l","quad","_loop","callback","_loopByKey0","_loopByKey1","_loopBy2Keys","_countInIndex","count","_getGraphs","isString","_uniqueEntities","uniqueIds","id","add","addQuad","graphItem","predicates","objects","freeze","ids","entities","changed","i","delete","removeQuad","has","subjectOrQuad","readQuads","next","done","import","stream","on","removeQuads","remove","removeMatches","objectMode","_read","push","deleteGraph","getQuads","content","subjectId","predicateId","objectId","match","DatasetCoreAndReadableStream","countQuads","forEach","some","every","getSubjects","results","forSubjects","s","getPredicates","forPredicates","p","getObjects","forObjects","o","getGraphs","forGraphs","g","createBlankNode","suggestedName","name","index","blankNode","substr","extractLists","ignoreErrors","lists","onError","node","message","Error","value","tails","rdf","rest","nil","toRemove","tailQuad","items","malformed","head","headPos","current","objectQuads","subjectQuads","first","parent","equals","unshift","Symbol","iterator","String","n3Store","assign","filtered","_filtered","newStore"],"sources":["G:/To-do-List_App-main/node_modules/n3/src/N3Store.js"],"sourcesContent":["// **N3Store** objects store N3 quads by graph in memory.\nimport { default as N3DataFactory, termToId, termFromId } from './N3DataFactory';\nimport { Readable } from 'readable-stream';\nimport namespaces from './IRIs';\n\n// ## Constructor\nexport default class N3Store {\n  constructor(quads, options) {\n    // The number of quads is initially zero\n    this._size = 0;\n    // `_graphs` contains subject, predicate, and object indexes per graph\n    this._graphs = Object.create(null);\n    // `_ids` maps entities such as `http://xmlns.com/foaf/0.1/name` to numbers,\n    // saving memory by using only numbers as keys in `_graphs`\n    this._id = 0;\n    this._ids = Object.create(null);\n    this._ids['><'] = 0; // dummy entry, so the first actual key is non-zero\n    this._entities = Object.create(null); // inverse of `_ids`\n    // `_blankNodeIndex` is the index of the last automatically named blank node\n    this._blankNodeIndex = 0;\n\n    // Shift parameters if `quads` is not given\n    if (!options && quads && !quads[0])\n      options = quads, quads = null;\n    options = options || {};\n    this._factory = options.factory || N3DataFactory;\n\n    // Add quads if passed\n    if (quads)\n      this.addQuads(quads);\n  }\n\n  // ## Public properties\n\n  // ### `size` returns the number of quads in the store\n  get size() {\n    // Return the quad count if if was cached\n    let size = this._size;\n    if (size !== null)\n      return size;\n\n    // Calculate the number of quads by counting to the deepest level\n    size = 0;\n    const graphs = this._graphs;\n    let subjects, subject;\n    for (const graphKey in graphs)\n      for (const subjectKey in (subjects = graphs[graphKey].subjects))\n        for (const predicateKey in (subject = subjects[subjectKey]))\n          size += Object.keys(subject[predicateKey]).length;\n    return this._size = size;\n  }\n\n  // ## Private methods\n\n  // ### `_addToIndex` adds a quad to a three-layered index.\n  // Returns if the index has changed, if the entry did not already exist.\n  _addToIndex(index0, key0, key1, key2) {\n    // Create layers as necessary\n    const index1 = index0[key0] || (index0[key0] = {});\n    const index2 = index1[key1] || (index1[key1] = {});\n    // Setting the key to _any_ value signals the presence of the quad\n    const existed = key2 in index2;\n    if (!existed)\n      index2[key2] = null;\n    return !existed;\n  }\n\n  // ### `_removeFromIndex` removes a quad from a three-layered index\n  _removeFromIndex(index0, key0, key1, key2) {\n    // Remove the quad from the index\n    const index1 = index0[key0], index2 = index1[key1];\n    delete index2[key2];\n\n    // Remove intermediary index layers if they are empty\n    for (const key in index2) return;\n    delete index1[key1];\n    for (const key in index1) return;\n    delete index0[key0];\n  }\n\n  // ### `_findInIndex` finds a set of quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  // `name0`, `name1`, and `name2` are the names of the keys at each level,\n  // used when reconstructing the resulting quad\n  // (for instance: _subject_, _predicate_, and _object_).\n  // Finally, `graphId` will be the graph of the created quads.\n  *_findInIndex(index0, key0, key1, key2, name0, name1, name2, graphId) {\n    let tmp, index1, index2;\n    const entityKeys = this._entities;\n    const graph = termFromId(graphId, this._factory);\n    const parts = { subject: null, predicate: null, object: null };\n\n    // If a key is specified, use only that part of index 0.\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n    for (const value0 in index0) {\n      if (index1 = index0[value0]) {\n        parts[name0] = termFromId(entityKeys[value0], this._factory);\n        // If a key is specified, use only that part of index 1.\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n        for (const value1 in index1) {\n          if (index2 = index1[value1]) {\n            parts[name1] = termFromId(entityKeys[value1], this._factory);\n            // If a key is specified, use only that part of index 2, if it exists.\n            const values = key2 ? (key2 in index2 ? [key2] : []) : Object.keys(index2);\n            // Create quads for all items found in index 2.\n            for (let l = 0; l < values.length; l++) {\n              parts[name2] = termFromId(entityKeys[values[l]], this._factory);\n              yield this._factory.quad(parts.subject, parts.predicate, parts.object, graph);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // ### `_loop` executes the callback on all keys of index 0\n  _loop(index0, callback) {\n    for (const key0 in index0)\n      callback(key0);\n  }\n\n  // ### `_loopByKey0` executes the callback on all keys of a certain entry in index 0\n  _loopByKey0(index0, key0, callback) {\n    let index1, key1;\n    if (index1 = index0[key0]) {\n      for (key1 in index1)\n        callback(key1);\n    }\n  }\n\n  // ### `_loopByKey1` executes the callback on given keys of all entries in index 0\n  _loopByKey1(index0, key1, callback) {\n    let key0, index1;\n    for (key0 in index0) {\n      index1 = index0[key0];\n      if (index1[key1])\n        callback(key0);\n    }\n  }\n\n  // ### `_loopBy2Keys` executes the callback on given keys of certain entries in index 2\n  _loopBy2Keys(index0, key0, key1, callback) {\n    let index1, index2, key2;\n    if ((index1 = index0[key0]) && (index2 = index1[key1])) {\n      for (key2 in index2)\n        callback(key2);\n    }\n  }\n\n  // ### `_countInIndex` counts matching quads in a three-layered index.\n  // The index base is `index0` and the keys at each level are `key0`, `key1`, and `key2`.\n  // Any of these keys can be undefined, which is interpreted as a wildcard.\n  _countInIndex(index0, key0, key1, key2) {\n    let count = 0, tmp, index1, index2;\n\n    // If a key is specified, count only that part of index 0\n    if (key0) (tmp = index0, index0 = {})[key0] = tmp[key0];\n    for (const value0 in index0) {\n      if (index1 = index0[value0]) {\n        // If a key is specified, count only that part of index 1\n        if (key1) (tmp = index1, index1 = {})[key1] = tmp[key1];\n        for (const value1 in index1) {\n          if (index2 = index1[value1]) {\n            // If a key is specified, count the quad if it exists\n            if (key2) (key2 in index2) && count++;\n            // Otherwise, count all quads\n            else count += Object.keys(index2).length;\n          }\n        }\n      }\n    }\n    return count;\n  }\n\n  // ### `_getGraphs` returns an array with the given graph,\n  // or all graphs if the argument is null or undefined.\n  _getGraphs(graph) {\n    if (!isString(graph))\n      return this._graphs;\n    const graphs = {};\n    graphs[graph] = this._graphs[graph];\n    return graphs;\n  }\n\n  // ### `_uniqueEntities` returns a function that accepts an entity ID\n  // and passes the corresponding entity to callback if it hasn't occurred before.\n  _uniqueEntities(callback) {\n    const uniqueIds = Object.create(null);\n    return id => {\n      if (!(id in uniqueIds)) {\n        uniqueIds[id] = true;\n        callback(termFromId(this._entities[id], this._factory));\n      }\n    };\n  }\n\n  // ## Public methods\n\n  // ### `add` adds the specified quad to the dataset.\n  // Returns the dataset instance it was called on.\n  // Existing quads, as defined in Quad.equals, will be ignored.\n  add(quad) {\n    this.addQuad(quad);\n    return this;\n  }\n\n  // ### `addQuad` adds a new quad to the store.\n  // Returns if the quad index has changed, if the quad did not already exist.\n  addQuad(subject, predicate, object, graph) {\n    // Shift arguments if a quad object is given instead of components\n    if (!predicate)\n      graph = subject.graph, object = subject.object,\n        predicate = subject.predicate, subject = subject.subject;\n\n    // Convert terms to internal string representation\n    subject = termToId(subject);\n    predicate = termToId(predicate);\n    object = termToId(object);\n    graph = termToId(graph);\n\n    // Find the graph that will contain the triple\n    let graphItem = this._graphs[graph];\n    // Create the graph if it doesn't exist yet\n    if (!graphItem) {\n      graphItem = this._graphs[graph] = { subjects: {}, predicates: {}, objects: {} };\n      // Freezing a graph helps subsequent `add` performance,\n      // and properties will never be modified anyway\n      Object.freeze(graphItem);\n    }\n\n    // Since entities can often be long IRIs, we avoid storing them in every index.\n    // Instead, we have a separate index that maps entities to numbers,\n    // which are then used as keys in the other indexes.\n    const ids = this._ids;\n    const entities = this._entities;\n    subject   = ids[subject]   || (ids[entities[++this._id] = subject]   = this._id);\n    predicate = ids[predicate] || (ids[entities[++this._id] = predicate] = this._id);\n    object    = ids[object]    || (ids[entities[++this._id] = object]    = this._id);\n\n    const changed = this._addToIndex(graphItem.subjects,   subject,   predicate, object);\n    this._addToIndex(graphItem.predicates, predicate, object,    subject);\n    this._addToIndex(graphItem.objects,    object,    subject,   predicate);\n\n    // The cached quad count is now invalid\n    this._size = null;\n    return changed;\n  }\n\n  // ### `addQuads` adds multiple quads to the store\n  addQuads(quads) {\n    for (let i = 0; i < quads.length; i++)\n      this.addQuad(quads[i]);\n  }\n\n  // ### `delete` removes the specified quad from the dataset.\n  // Returns the dataset instance it was called on.\n  delete(quad) {\n    this.removeQuad(quad);\n    return this;\n  }\n\n  // ### `has` determines whether a dataset includes a certain quad or quad pattern.\n  has(subjectOrQuad, predicate, object, graph) {\n    if (subjectOrQuad && subjectOrQuad.subject)\n      ({ subject: subjectOrQuad, predicate, object, graph } = subjectOrQuad);\n    return !this.readQuads(subjectOrQuad, predicate, object, graph).next().done;\n  }\n\n  // ### `import` adds a stream of quads to the store\n  import(stream) {\n    stream.on('data', quad => { this.addQuad(quad); });\n    return stream;\n  }\n\n  // ### `removeQuad` removes a quad from the store if it exists\n  removeQuad(subject, predicate, object, graph) {\n    // Shift arguments if a quad object is given instead of components\n    if (!predicate)\n      graph = subject.graph, object = subject.object,\n        predicate = subject.predicate, subject = subject.subject;\n\n    // Convert terms to internal string representation\n    subject = termToId(subject);\n    predicate = termToId(predicate);\n    object = termToId(object);\n    graph = termToId(graph);\n\n    // Find internal identifiers for all components\n    // and verify the quad exists.\n    const ids = this._ids, graphs = this._graphs;\n    let graphItem, subjects, predicates;\n    if (!(subject    = ids[subject]) || !(predicate = ids[predicate]) ||\n        !(object     = ids[object])  || !(graphItem = graphs[graph])  ||\n        !(subjects   = graphItem.subjects[subject]) ||\n        !(predicates = subjects[predicate]) ||\n        !(object in predicates))\n      return false;\n\n    // Remove it from all indexes\n    this._removeFromIndex(graphItem.subjects,   subject,   predicate, object);\n    this._removeFromIndex(graphItem.predicates, predicate, object,    subject);\n    this._removeFromIndex(graphItem.objects,    object,    subject,   predicate);\n    if (this._size !== null) this._size--;\n\n    // Remove the graph if it is empty\n    for (subject in graphItem.subjects) return true;\n    delete graphs[graph];\n    return true;\n  }\n\n  // ### `removeQuads` removes multiple quads from the store\n  removeQuads(quads) {\n    for (let i = 0; i < quads.length; i++)\n      this.removeQuad(quads[i]);\n  }\n\n  // ### `remove` removes a stream of quads from the store\n  remove(stream) {\n    stream.on('data', quad => { this.removeQuad(quad); });\n    return stream;\n  }\n\n  // ### `removeMatches` removes all matching quads from the store\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  removeMatches(subject, predicate, object, graph) {\n    const stream = new Readable({ objectMode: true });\n\n    stream._read = () => {\n      for (const quad of this.readQuads(subject, predicate, object, graph))\n        stream.push(quad);\n      stream.push(null);\n    };\n\n    return this.remove(stream);\n  }\n\n  // ### `deleteGraph` removes all triples with the given graph from the store\n  deleteGraph(graph) {\n    return this.removeMatches(null, null, null, graph);\n  }\n\n  // ### `getQuads` returns an array of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getQuads(subject, predicate, object, graph) {\n    return [...this.readQuads(subject, predicate, object, graph)];\n  }\n\n  // ### `readQuads` returns an generator of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  *readQuads(subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const graphs = this._getGraphs(graph), ids = this._ids;\n    let content, subjectId, predicateId, objectId;\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject)   && !(subjectId   = ids[subject])   ||\n        isString(predicate) && !(predicateId = ids[predicate]) ||\n        isString(object)    && !(objectId    = ids[object]))\n      return;\n\n    for (const graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subjectId) {\n          if (objectId)\n            // If subject and object are given, the object index will be the fastest\n            yield* this._findInIndex(content.objects, objectId, subjectId, predicateId,\n                              'object', 'subject', 'predicate', graphId);\n          else\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            yield* this._findInIndex(content.subjects, subjectId, predicateId, null,\n                              'subject', 'predicate', 'object', graphId);\n        }\n        else if (predicateId)\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          yield* this._findInIndex(content.predicates, predicateId, objectId, null,\n                            'predicate', 'object', 'subject', graphId);\n        else if (objectId)\n          // If only object is given, the object index will be the fastest\n          yield* this._findInIndex(content.objects, objectId, null, null,\n                            'object', 'subject', 'predicate', graphId);\n        else\n          // If nothing is given, iterate subjects and predicates first\n          yield* this._findInIndex(content.subjects, null, null, null,\n                            'subject', 'predicate', 'object', graphId);\n      }\n    }\n  }\n\n  // ### `match` returns a new dataset that is comprised of all quads in the current instance matching the given arguments.\n  // The logic described in Quad Matching is applied for each quad in this dataset to check if it should be included in the output dataset.\n  // Note: This method always returns a new DatasetCore, even if that dataset contains no quads.\n  // Note: Since a DatasetCore is an unordered set, the order of the quads within the returned sequence is arbitrary.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  // For backwards compatibility, the object return also implements the Readable stream interface.\n  match(subject, predicate, object, graph) {\n    return new DatasetCoreAndReadableStream(this, subject, predicate, object, graph);\n  }\n\n  // ### `countQuads` returns the number of quads matching a pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  countQuads(subject, predicate, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const graphs = this._getGraphs(graph), ids = this._ids;\n    let count = 0, content, subjectId, predicateId, objectId;\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject)   && !(subjectId   = ids[subject])   ||\n        isString(predicate) && !(predicateId = ids[predicate]) ||\n        isString(object)    && !(objectId    = ids[object]))\n      return 0;\n\n    for (const graphId in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graphId]) {\n        // Choose the optimal index, based on what fields are present\n        if (subject) {\n          if (object)\n            // If subject and object are given, the object index will be the fastest\n            count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n          else\n            // If only subject and possibly predicate are given, the subject index will be the fastest\n            count += this._countInIndex(content.subjects, subjectId, predicateId, objectId);\n        }\n        else if (predicate) {\n          // If only predicate and possibly object are given, the predicate index will be the fastest\n          count += this._countInIndex(content.predicates, predicateId, objectId, subjectId);\n        }\n        else {\n          // If only object is possibly given, the object index will be the fastest\n          count += this._countInIndex(content.objects, objectId, subjectId, predicateId);\n        }\n      }\n    }\n    return count;\n  }\n\n  // ### `forEach` executes the callback on all quads.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forEach(callback, subject, predicate, object, graph) {\n    this.some(quad => {\n      callback(quad);\n      return false;\n    }, subject, predicate, object, graph);\n  }\n\n  // ### `every` executes the callback on all quads,\n  // and returns `true` if it returns truthy for all them.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  every(callback, subject, predicate, object, graph) {\n    let some = false;\n    const every = !this.some(quad => {\n      some = true;\n      return !callback(quad);\n    }, subject, predicate, object, graph);\n    return some && every;\n  }\n\n  // ### `some` executes the callback on all quads,\n  // and returns `true` if it returns truthy for any of them.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  some(callback, subject, predicate, object, graph) {\n    for (const quad of this.readQuads(subject, predicate, object, graph))\n      if (callback(quad))\n        return true;\n    return false;\n  }\n\n  // ### `getSubjects` returns all subjects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getSubjects(predicate, object, graph) {\n    const results = [];\n    this.forSubjects(s => { results.push(s); }, predicate, object, graph);\n    return results;\n  }\n\n  // ### `forSubjects` executes the callback on all subjects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forSubjects(callback, predicate, object, graph) {\n    // Convert terms to internal string representation\n    predicate = predicate && termToId(predicate);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const ids = this._ids, graphs = this._getGraphs(graph);\n    let content, predicateId, objectId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (isString(predicate) && !(predicateId = ids[predicate]) ||\n        isString(object)    && !(objectId    = ids[object]))\n      return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (predicateId) {\n          if (objectId)\n            // If predicate and object are given, the POS index is best.\n            this._loopBy2Keys(content.predicates, predicateId, objectId, callback);\n          else\n            // If only predicate is given, the SPO index is best.\n            this._loopByKey1(content.subjects, predicateId, callback);\n        }\n        else if (objectId)\n          // If only object is given, the OSP index is best.\n          this._loopByKey0(content.objects, objectId, callback);\n        else\n          // If no params given, iterate all the subjects\n          this._loop(content.subjects, callback);\n      }\n    }\n  }\n\n  // ### `getPredicates` returns all predicates that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getPredicates(subject, object, graph) {\n    const results = [];\n    this.forPredicates(p => { results.push(p); }, subject, object, graph);\n    return results;\n  }\n\n  // ### `forPredicates` executes the callback on all predicates that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forPredicates(callback, subject, object, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    object = object && termToId(object);\n    graph = graph && termToId(graph);\n\n    const ids = this._ids, graphs = this._getGraphs(graph);\n    let content, subjectId, objectId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject) && !(subjectId = ids[subject]) ||\n        isString(object)  && !(objectId  = ids[object]))\n      return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (subjectId) {\n          if (objectId)\n            // If subject and object are given, the OSP index is best.\n            this._loopBy2Keys(content.objects, objectId, subjectId, callback);\n          else\n            // If only subject is given, the SPO index is best.\n            this._loopByKey0(content.subjects, subjectId, callback);\n        }\n        else if (objectId)\n          // If only object is given, the POS index is best.\n          this._loopByKey1(content.predicates, objectId, callback);\n        else\n          // If no params given, iterate all the predicates.\n          this._loop(content.predicates, callback);\n      }\n    }\n  }\n\n  // ### `getObjects` returns all objects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getObjects(subject, predicate, graph) {\n    const results = [];\n    this.forObjects(o => { results.push(o); }, subject, predicate, graph);\n    return results;\n  }\n\n  // ### `forObjects` executes the callback on all objects that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forObjects(callback, subject, predicate, graph) {\n    // Convert terms to internal string representation\n    subject = subject && termToId(subject);\n    predicate = predicate && termToId(predicate);\n    graph = graph && termToId(graph);\n\n    const ids = this._ids, graphs = this._getGraphs(graph);\n    let content, subjectId, predicateId;\n    callback = this._uniqueEntities(callback);\n\n    // Translate IRIs to internal index keys.\n    if (isString(subject)   && !(subjectId   = ids[subject]) ||\n        isString(predicate) && !(predicateId = ids[predicate]))\n      return;\n\n    for (graph in graphs) {\n      // Only if the specified graph contains triples, there can be results\n      if (content = graphs[graph]) {\n        // Choose optimal index based on which fields are wildcards\n        if (subjectId) {\n          if (predicateId)\n            // If subject and predicate are given, the SPO index is best.\n            this._loopBy2Keys(content.subjects, subjectId, predicateId, callback);\n          else\n            // If only subject is given, the OSP index is best.\n            this._loopByKey1(content.objects, subjectId, callback);\n        }\n        else if (predicateId)\n          // If only predicate is given, the POS index is best.\n          this._loopByKey0(content.predicates, predicateId, callback);\n        else\n          // If no params given, iterate all the objects.\n          this._loop(content.objects, callback);\n      }\n    }\n  }\n\n  // ### `getGraphs` returns all graphs that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  getGraphs(subject, predicate, object) {\n    const results = [];\n    this.forGraphs(g => { results.push(g); }, subject, predicate, object);\n    return results;\n  }\n\n  // ### `forGraphs` executes the callback on all graphs that match the pattern.\n  // Setting any field to `undefined` or `null` indicates a wildcard.\n  forGraphs(callback, subject, predicate, object) {\n    for (const graph in this._graphs) {\n      this.some(quad => {\n        callback(quad.graph);\n        return true; // Halt iteration of some()\n      }, subject, predicate, object, graph);\n    }\n  }\n\n  // ### `createBlankNode` creates a new blank node, returning its name\n  createBlankNode(suggestedName) {\n    let name, index;\n    // Generate a name based on the suggested name\n    if (suggestedName) {\n      name = suggestedName = `_:${suggestedName}`, index = 1;\n      while (this._ids[name])\n        name = suggestedName + index++;\n    }\n    // Generate a generic blank node name\n    else {\n      do { name = `_:b${this._blankNodeIndex++}`; }\n      while (this._ids[name]);\n    }\n    // Add the blank node to the entities, avoiding the generation of duplicates\n    this._ids[name] = ++this._id;\n    this._entities[this._id] = name;\n    return this._factory.blankNode(name.substr(2));\n  }\n\n  // ### `extractLists` finds and removes all list triples\n  // and returns the items per list.\n  extractLists({ remove = false, ignoreErrors = false } = {}) {\n    const lists = {}; // has scalar keys so could be a simple Object\n    const onError = ignoreErrors ? (() => true) :\n                  ((node, message) => { throw new Error(`${node.value} ${message}`); });\n\n    // Traverse each list from its tail\n    const tails = this.getQuads(null, namespaces.rdf.rest, namespaces.rdf.nil, null);\n    const toRemove = remove ? [...tails] : [];\n    tails.forEach(tailQuad => {\n      const items = [];             // the members found as objects of rdf:first quads\n      let malformed = false;      // signals whether the current list is malformed\n      let head;                   // the head of the list (_:b1 in above example)\n      let headPos;                // set to subject or object when head is set\n      const graph = tailQuad.graph; // make sure list is in exactly one graph\n\n      // Traverse the list from tail to end\n      let current = tailQuad.subject;\n      while (current && !malformed) {\n        const objectQuads = this.getQuads(null, null, current, null);\n        const subjectQuads = this.getQuads(current, null, null, null);\n        let quad, first = null, rest = null, parent = null;\n\n        // Find the first and rest of this list node\n        for (let i = 0; i < subjectQuads.length && !malformed; i++) {\n          quad = subjectQuads[i];\n          if (!quad.graph.equals(graph))\n            malformed = onError(current, 'not confined to single graph');\n          else if (head)\n            malformed = onError(current, 'has non-list arcs out');\n\n          // one rdf:first\n          else if (quad.predicate.value === namespaces.rdf.first) {\n            if (first)\n              malformed = onError(current, 'has multiple rdf:first arcs');\n            else\n              toRemove.push(first = quad);\n          }\n\n          // one rdf:rest\n          else if (quad.predicate.value === namespaces.rdf.rest) {\n            if (rest)\n              malformed = onError(current, 'has multiple rdf:rest arcs');\n            else\n              toRemove.push(rest = quad);\n          }\n\n          // alien triple\n          else if (objectQuads.length)\n            malformed = onError(current, 'can\\'t be subject and object');\n          else {\n            head = quad; // e.g. { (1 2 3) :p :o }\n            headPos = 'subject';\n          }\n        }\n\n        // { :s :p (1 2) } arrives here with no head\n        // { (1 2) :p :o } arrives here with head set to the list.\n        for (let i = 0; i < objectQuads.length && !malformed; ++i) {\n          quad = objectQuads[i];\n          if (head)\n            malformed = onError(current, 'can\\'t have coreferences');\n          // one rdf:rest\n          else if (quad.predicate.value === namespaces.rdf.rest) {\n            if (parent)\n              malformed = onError(current, 'has incoming rdf:rest arcs');\n            else\n              parent = quad;\n          }\n          else {\n            head = quad; // e.g. { :s :p (1 2) }\n            headPos = 'object';\n          }\n        }\n\n        // Store the list item and continue with parent\n        if (!first)\n          malformed = onError(current, 'has no list head');\n        else\n          items.unshift(first.object);\n        current = parent && parent.subject;\n      }\n\n      // Don't remove any quads if the list is malformed\n      if (malformed)\n        remove = false;\n      // Store the list under the value of its head\n      else if (head)\n        lists[head[headPos].value] = items;\n    });\n\n    // Remove list quads if requested\n    if (remove)\n      this.removeQuads(toRemove);\n    return lists;\n  }\n\n  // ### Store is an iterable.\n  // Can be used where iterables are expected: for...of loops, array spread operator,\n  // `yield*`, and destructuring assignment (order is not guaranteed).\n  *[Symbol.iterator]() {\n    yield* this.readQuads();\n  }\n}\n\n// Determines whether the argument is a string\nfunction isString(s) {\n  return typeof s === 'string' || s instanceof String;\n}\n\n/**\n * A class that implements both DatasetCore and Readable.\n */\nclass DatasetCoreAndReadableStream extends Readable {\n  constructor(n3Store, subject, predicate, object, graph) {\n    super({ objectMode: true });\n    Object.assign(this, { n3Store, subject, predicate, object, graph });\n  }\n\n  get filtered() {\n    if (!this._filtered) {\n      const { n3Store, graph, object, predicate, subject } = this;\n      const newStore = this._filtered = new N3Store({ factory: n3Store._factory });\n      for (const quad of n3Store.readQuads(subject, predicate, object, graph))\n        newStore.addQuad(quad);\n    }\n    return this._filtered;\n  }\n\n  get size() {\n    return this.filtered.size;\n  }\n\n  _read() {\n    for (const quad of this)\n      this.push(quad);\n    this.push(null);\n  }\n\n  add(quad) {\n    return this.filtered.add(quad);\n  }\n\n  delete(quad) {\n    return this.filtered.delete(quad);\n  }\n\n  has(quad) {\n    return this.filtered.has(quad);\n  }\n\n  match(subject, predicate, object, graph) {\n    return new DatasetCoreAndReadableStream(this.filtered, subject, predicate, object, graph);\n  }\n\n  *[Symbol.iterator]() {\n    yield* this._filtered || this.n3Store.readQuads(this.subject, this.predicate, this.object, this.graph);\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}