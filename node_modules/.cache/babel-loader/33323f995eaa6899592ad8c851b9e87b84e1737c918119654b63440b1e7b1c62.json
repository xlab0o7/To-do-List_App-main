{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _slicedToArray = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _regeneratorRuntime = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _createForOfIteratorHelper = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _asyncToGenerator = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar JsonLdError = require('./JsonLdError');\nvar _require = require('./types'),\n  _isArray = _require.isArray,\n  _isObject = _require.isObject,\n  _isEmptyObject = _require.isEmptyObject,\n  _isString = _require.isString,\n  _isUndefined = _require.isUndefined;\nvar _require2 = require('./graphTypes'),\n  _isList = _require2.isList,\n  _isValue = _require2.isValue,\n  _isGraph = _require2.isGraph,\n  _isSubject = _require2.isSubject;\nvar _require3 = require('./context'),\n  _expandIri = _require3.expandIri,\n  _getContextValue = _require3.getContextValue,\n  _isKeyword = _require3.isKeyword,\n  _processContext = _require3.process,\n  _processingMode = _require3.processingMode;\nvar _require4 = require('./url'),\n  _isAbsoluteIri = _require4.isAbsolute;\nvar _require5 = require('./util'),\n  _addValue = _require5.addValue,\n  _asArray = _require5.asArray,\n  _getValues = _require5.getValues,\n  _validateTypeValue = _require5.validateTypeValue;\nvar api = {};\nmodule.exports = api;\nvar REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;\n\n/**\n * Recursively expands an element using the given context. Any context in\n * the element will be removed. All context URLs must have been retrieved\n * before calling this method.\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element, null for none.\n * @param element the element to expand.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param insideIndex true if the element is inside an index container,\n *          false if not.\n * @param typeScopedContext an optional type-scoped active context for\n *          expanding values of nodes that were expressed according to\n *          a type-scoped context.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n *\n * @return a Promise that resolves to the expanded value.\n */\napi.expand = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref) {\n    var activeCtx, _ref$activeProperty, activeProperty, element, _ref$options, options, _ref$insideList, insideList, _ref$insideIndex, insideIndex, _ref$typeScopedContex, typeScopedContext, _ref$expansionMap, expansionMap, mapped, _rval, container, i, e, expandedActiveProperty, propertyScopedCtx, keys, mustRevert, _iterator, _step, key, expandedProperty, typeKey, _iterator2, _step2, _key, _expandedProperty, value, _types, _iterator3, _step3, type, ctx, rval, count, validCount, values, types, _mapped, _mapped2, _mapped3;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          activeCtx = _ref.activeCtx, _ref$activeProperty = _ref.activeProperty, activeProperty = _ref$activeProperty === void 0 ? null : _ref$activeProperty, element = _ref.element, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, _ref$insideList = _ref.insideList, insideList = _ref$insideList === void 0 ? false : _ref$insideList, _ref$insideIndex = _ref.insideIndex, insideIndex = _ref$insideIndex === void 0 ? false : _ref$insideIndex, _ref$typeScopedContex = _ref.typeScopedContext, typeScopedContext = _ref$typeScopedContex === void 0 ? null : _ref$typeScopedContex, _ref$expansionMap = _ref.expansionMap, expansionMap = _ref$expansionMap === void 0 ? function () {\n            return undefined;\n          } : _ref$expansionMap;\n          if (!(element === null || element === undefined)) {\n            _context.next = 3;\n            break;\n          }\n          return _context.abrupt(\"return\", null);\n        case 3:\n          // disable framing if activeProperty is @default\n          if (activeProperty === '@default') {\n            options = Object.assign({}, options, {\n              isFrame: false\n            });\n          }\n          if (!(!_isArray(element) && !_isObject(element))) {\n            _context.next = 13;\n            break;\n          }\n          if (!(!insideList && (activeProperty === null || _expandIri(activeCtx, activeProperty, {\n            vocab: true\n          }, options) === '@graph'))) {\n            _context.next = 12;\n            break;\n          }\n          _context.next = 8;\n          return expansionMap({\n            unmappedValue: element,\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            options: options,\n            insideList: insideList\n          });\n        case 8:\n          mapped = _context.sent;\n          if (!(mapped === undefined)) {\n            _context.next = 11;\n            break;\n          }\n          return _context.abrupt(\"return\", null);\n        case 11:\n          return _context.abrupt(\"return\", mapped);\n        case 12:\n          return _context.abrupt(\"return\", _expandValue({\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            value: element,\n            options: options\n          }));\n        case 13:\n          if (!_isArray(element)) {\n            _context.next = 34;\n            break;\n          }\n          _rval = [];\n          container = _getContextValue(activeCtx, activeProperty, '@container') || [];\n          insideList = insideList || container.includes('@list');\n          i = 0;\n        case 18:\n          if (!(i < element.length)) {\n            _context.next = 33;\n            break;\n          }\n          _context.next = 21;\n          return api.expand({\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            element: element[i],\n            options: options,\n            expansionMap: expansionMap,\n            insideIndex: insideIndex,\n            typeScopedContext: typeScopedContext\n          });\n        case 21:\n          e = _context.sent;\n          if (insideList && _isArray(e)) {\n            e = {\n              '@list': e\n            };\n          }\n          if (!(e === null)) {\n            _context.next = 29;\n            break;\n          }\n          _context.next = 26;\n          return expansionMap({\n            unmappedValue: element[i],\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            parent: element,\n            index: i,\n            options: options,\n            expandedParent: _rval,\n            insideList: insideList\n          });\n        case 26:\n          e = _context.sent;\n          if (!(e === undefined)) {\n            _context.next = 29;\n            break;\n          }\n          return _context.abrupt(\"continue\", 30);\n        case 29:\n          if (_isArray(e)) {\n            _rval = _rval.concat(e);\n          } else {\n            _rval.push(e);\n          }\n        case 30:\n          ++i;\n          _context.next = 18;\n          break;\n        case 33:\n          return _context.abrupt(\"return\", _rval);\n        case 34:\n          // recursively expand object:\n          // first, expand the active property\n          expandedActiveProperty = _expandIri(activeCtx, activeProperty, {\n            vocab: true\n          }, options); // Get any property-scoped context for activeProperty\n          propertyScopedCtx = _getContextValue(activeCtx, activeProperty, '@context'); // second, determine if any type-scoped context should be reverted; it\n          // should only be reverted when the following are all true:\n          // 1. `element` is not a value or subject reference\n          // 2. `insideIndex` is false\n          typeScopedContext = typeScopedContext || (activeCtx.previousContext ? activeCtx : null);\n          keys = Object.keys(element).sort();\n          mustRevert = !insideIndex;\n          if (!(mustRevert && typeScopedContext && keys.length <= 2 && !keys.includes('@context'))) {\n            _context.next = 63;\n            break;\n          }\n          _iterator = _createForOfIteratorHelper(keys);\n          _context.prev = 41;\n          _iterator.s();\n        case 43:\n          if ((_step = _iterator.n()).done) {\n            _context.next = 55;\n            break;\n          }\n          key = _step.value;\n          expandedProperty = _expandIri(typeScopedContext, key, {\n            vocab: true\n          }, options);\n          if (!(expandedProperty === '@value')) {\n            _context.next = 50;\n            break;\n          }\n          // value found, ensure type-scoped context is used to expand it\n          mustRevert = false;\n          activeCtx = typeScopedContext;\n          return _context.abrupt(\"break\", 55);\n        case 50:\n          if (!(expandedProperty === '@id' && keys.length === 1)) {\n            _context.next = 53;\n            break;\n          }\n          // subject reference found, do not revert\n          mustRevert = false;\n          return _context.abrupt(\"break\", 55);\n        case 53:\n          _context.next = 43;\n          break;\n        case 55:\n          _context.next = 60;\n          break;\n        case 57:\n          _context.prev = 57;\n          _context.t0 = _context[\"catch\"](41);\n          _iterator.e(_context.t0);\n        case 60:\n          _context.prev = 60;\n          _iterator.f();\n          return _context.finish(60);\n        case 63:\n          if (mustRevert) {\n            // revert type scoped context\n            activeCtx = activeCtx.revertToPreviousContext();\n          }\n\n          // apply property-scoped context after reverting term-scoped context\n          if (_isUndefined(propertyScopedCtx)) {\n            _context.next = 68;\n            break;\n          }\n          _context.next = 67;\n          return _processContext({\n            activeCtx: activeCtx,\n            localCtx: propertyScopedCtx,\n            propagate: true,\n            overrideProtected: true,\n            options: options\n          });\n        case 67:\n          activeCtx = _context.sent;\n        case 68:\n          if (!('@context' in element)) {\n            _context.next = 72;\n            break;\n          }\n          _context.next = 71;\n          return _processContext({\n            activeCtx: activeCtx,\n            localCtx: element['@context'],\n            options: options\n          });\n        case 71:\n          activeCtx = _context.sent;\n        case 72:\n          // set the type-scoped context to the context on input, for use later\n          typeScopedContext = activeCtx;\n\n          // Remember the first key found expanding to @type\n          typeKey = null; // look for scoped contexts on `@type`\n          _iterator2 = _createForOfIteratorHelper(keys);\n          _context.prev = 75;\n          _iterator2.s();\n        case 77:\n          if ((_step2 = _iterator2.n()).done) {\n            _context.next = 106;\n            break;\n          }\n          _key = _step2.value;\n          _expandedProperty = _expandIri(activeCtx, _key, {\n            vocab: true\n          }, options);\n          if (!(_expandedProperty === '@type')) {\n            _context.next = 104;\n            break;\n          }\n          // set scoped contexts from @type\n          // avoid sorting if possible\n          typeKey = typeKey || _key;\n          value = element[_key];\n          _types = Array.isArray(value) ? value.length > 1 ? value.slice().sort() : value : [value];\n          _iterator3 = _createForOfIteratorHelper(_types);\n          _context.prev = 85;\n          _iterator3.s();\n        case 87:\n          if ((_step3 = _iterator3.n()).done) {\n            _context.next = 96;\n            break;\n          }\n          type = _step3.value;\n          ctx = _getContextValue(typeScopedContext, type, '@context');\n          if (_isUndefined(ctx)) {\n            _context.next = 94;\n            break;\n          }\n          _context.next = 93;\n          return _processContext({\n            activeCtx: activeCtx,\n            localCtx: ctx,\n            options: options,\n            propagate: false\n          });\n        case 93:\n          activeCtx = _context.sent;\n        case 94:\n          _context.next = 87;\n          break;\n        case 96:\n          _context.next = 101;\n          break;\n        case 98:\n          _context.prev = 98;\n          _context.t1 = _context[\"catch\"](85);\n          _iterator3.e(_context.t1);\n        case 101:\n          _context.prev = 101;\n          _iterator3.f();\n          return _context.finish(101);\n        case 104:\n          _context.next = 77;\n          break;\n        case 106:\n          _context.next = 111;\n          break;\n        case 108:\n          _context.prev = 108;\n          _context.t2 = _context[\"catch\"](75);\n          _iterator2.e(_context.t2);\n        case 111:\n          _context.prev = 111;\n          _iterator2.f();\n          return _context.finish(111);\n        case 114:\n          // process each key and value in element, ignoring @nest content\n          rval = {};\n          _context.next = 117;\n          return _expandObject({\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            expandedActiveProperty: expandedActiveProperty,\n            element: element,\n            expandedParent: rval,\n            options: options,\n            insideList: insideList,\n            typeKey: typeKey,\n            typeScopedContext: typeScopedContext,\n            expansionMap: expansionMap\n          });\n        case 117:\n          // get property count on expanded output\n          keys = Object.keys(rval);\n          count = keys.length;\n          if (!('@value' in rval)) {\n            _context.next = 149;\n            break;\n          }\n          if (!('@type' in rval && ('@language' in rval || '@direction' in rval))) {\n            _context.next = 122;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; an element containing \"@value\" may not ' + 'contain both \"@type\" and either \"@language\" or \"@direction\".', 'jsonld.SyntaxError', {\n            code: 'invalid value object',\n            element: rval\n          });\n        case 122:\n          validCount = count - 1;\n          if ('@type' in rval) {\n            validCount -= 1;\n          }\n          if ('@index' in rval) {\n            validCount -= 1;\n          }\n          if ('@language' in rval) {\n            validCount -= 1;\n          }\n          if ('@direction' in rval) {\n            validCount -= 1;\n          }\n          if (!(validCount !== 0)) {\n            _context.next = 129;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; an element containing \"@value\" may only ' + 'have an \"@index\" property and either \"@type\" ' + 'or either or both \"@language\" or \"@direction\".', 'jsonld.SyntaxError', {\n            code: 'invalid value object',\n            element: rval\n          });\n        case 129:\n          values = rval['@value'] === null ? [] : _asArray(rval['@value']);\n          types = _getValues(rval, '@type'); // drop null @values unless custom mapped\n          if (!(_processingMode(activeCtx, 1.1) && types.includes('@json') && types.length === 1)) {\n            _context.next = 134;\n            break;\n          }\n          _context.next = 147;\n          break;\n        case 134:\n          if (!(values.length === 0)) {\n            _context.next = 141;\n            break;\n          }\n          _context.next = 137;\n          return expansionMap({\n            unmappedValue: rval,\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            element: element,\n            options: options,\n            insideList: insideList\n          });\n        case 137:\n          _mapped = _context.sent;\n          if (_mapped !== undefined) {\n            rval = _mapped;\n          } else {\n            rval = null;\n          }\n          _context.next = 147;\n          break;\n        case 141:\n          if (!(!values.every(function (v) {\n            return _isString(v) || _isEmptyObject(v);\n          }) && '@language' in rval)) {\n            _context.next = 145;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; only strings may be language-tagged.', 'jsonld.SyntaxError', {\n            code: 'invalid language-tagged value',\n            element: rval\n          });\n        case 145:\n          if (types.every(function (t) {\n            return _isAbsoluteIri(t) && !(_isString(t) && t.indexOf('_:') === 0) || _isEmptyObject(t);\n          })) {\n            _context.next = 147;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; an element containing \"@value\" and \"@type\" ' + 'must have an absolute IRI for the value of \"@type\".', 'jsonld.SyntaxError', {\n            code: 'invalid typed value',\n            element: rval\n          });\n        case 147:\n          _context.next = 164;\n          break;\n        case 149:\n          if (!('@type' in rval && !_isArray(rval['@type']))) {\n            _context.next = 153;\n            break;\n          }\n          // convert @type to an array\n          rval['@type'] = [rval['@type']];\n          _context.next = 164;\n          break;\n        case 153:\n          if (!('@set' in rval || '@list' in rval)) {\n            _context.next = 159;\n            break;\n          }\n          if (!(count > 1 && !(count === 2 && '@index' in rval))) {\n            _context.next = 156;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; if an element has the property \"@set\" ' + 'or \"@list\", then it can have at most one other property that is ' + '\"@index\".', 'jsonld.SyntaxError', {\n            code: 'invalid set or list object',\n            element: rval\n          });\n        case 156:\n          // optimize away @set\n          if ('@set' in rval) {\n            rval = rval['@set'];\n            keys = Object.keys(rval);\n            count = keys.length;\n          }\n          _context.next = 164;\n          break;\n        case 159:\n          if (!(count === 1 && '@language' in rval)) {\n            _context.next = 164;\n            break;\n          }\n          _context.next = 162;\n          return expansionMap(rval, {\n            unmappedValue: rval,\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            element: element,\n            options: options,\n            insideList: insideList\n          });\n        case 162:\n          _mapped2 = _context.sent;\n          if (_mapped2 !== undefined) {\n            rval = _mapped2;\n          } else {\n            rval = null;\n          }\n        case 164:\n          if (!(_isObject(rval) && !options.keepFreeFloatingNodes && !insideList && (activeProperty === null || expandedActiveProperty === '@graph'))) {\n            _context.next = 170;\n            break;\n          }\n          if (!(count === 0 || '@value' in rval || '@list' in rval || count === 1 && '@id' in rval)) {\n            _context.next = 170;\n            break;\n          }\n          _context.next = 168;\n          return expansionMap({\n            unmappedValue: rval,\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            element: element,\n            options: options,\n            insideList: insideList\n          });\n        case 168:\n          _mapped3 = _context.sent;\n          if (_mapped3 !== undefined) {\n            rval = _mapped3;\n          } else {\n            rval = null;\n          }\n        case 170:\n          return _context.abrupt(\"return\", rval);\n        case 171:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee, null, [[41, 57, 60, 63], [75, 108, 111, 114], [85, 98, 101, 104]]);\n  }));\n  return function (_x) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n\n/**\n * Expand each key and value of element adding to result\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element.\n * @param expandedActiveProperty the expansion of activeProperty\n * @param element the element to expand.\n * @param expandedParent the expanded result into which to add values.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param typeKey first key found expanding to @type.\n * @param typeScopedContext the context before reverting.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n */\nfunction _expandObject(_x2) {\n  return _expandObject2.apply(this, arguments);\n}\n/**\n * Expands the given value by using the coercion and keyword rules in the\n * given context.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the active property the value is associated with.\n * @param value the value to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandObject2() {\n  _expandObject2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref3) {\n    var activeCtx, activeProperty, expandedActiveProperty, element, expandedParent, _ref3$options, options, insideList, typeKey, typeScopedContext, expansionMap, keys, nests, unexpandedValue, isJsonType, _iterator6, _step6, _key2, value, expandedValue, expandedProperty, includedResult, _iterator8, _step8, lang, _iterator9, _step9, dir, property, reverseMap, _property, items, ii, item, termCtx, ctx, container, direction, asGraph, indexKey, propertyIndex, _asGraph, isList, nextActiveProperty, _reverseMap, _ii, _item, _i, _nests, key, nestedValues, _iterator7, _step7, nv;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          activeCtx = _ref3.activeCtx, activeProperty = _ref3.activeProperty, expandedActiveProperty = _ref3.expandedActiveProperty, element = _ref3.element, expandedParent = _ref3.expandedParent, _ref3$options = _ref3.options, options = _ref3$options === void 0 ? {} : _ref3$options, insideList = _ref3.insideList, typeKey = _ref3.typeKey, typeScopedContext = _ref3.typeScopedContext, expansionMap = _ref3.expansionMap;\n          keys = Object.keys(element).sort();\n          nests = [];\n          // Figure out if this is the type for a JSON literal\n          isJsonType = element[typeKey] && _expandIri(activeCtx, _isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey], {\n            vocab: true\n          }, options) === '@json';\n          _iterator6 = _createForOfIteratorHelper(keys);\n          _context2.prev = 5;\n          _iterator6.s();\n        case 7:\n          if ((_step6 = _iterator6.n()).done) {\n            _context2.next = 202;\n            break;\n          }\n          _key2 = _step6.value;\n          value = element[_key2];\n          expandedValue = void 0; // skip @context\n          if (!(_key2 === '@context')) {\n            _context2.next = 13;\n            break;\n          }\n          return _context2.abrupt(\"continue\", 200);\n        case 13:\n          // expand property\n          expandedProperty = _expandIri(activeCtx, _key2, {\n            vocab: true\n          }, options); // drop non-absolute IRI keys that aren't keywords unless custom mapped\n          if (!(expandedProperty === null || !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty)))) {\n            _context2.next = 18;\n            break;\n          }\n          // TODO: use `await` to support async\n          expandedProperty = expansionMap({\n            unmappedProperty: _key2,\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            parent: element,\n            options: options,\n            insideList: insideList,\n            value: value,\n            expandedParent: expandedParent\n          });\n          if (!(expandedProperty === undefined)) {\n            _context2.next = 18;\n            break;\n          }\n          return _context2.abrupt(\"continue\", 200);\n        case 18:\n          if (!_isKeyword(expandedProperty)) {\n            _context2.next = 23;\n            break;\n          }\n          if (!(expandedActiveProperty === '@reverse')) {\n            _context2.next = 21;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; a keyword cannot be used as a @reverse ' + 'property.', 'jsonld.SyntaxError', {\n            code: 'invalid reverse property map',\n            value: value\n          });\n        case 21:\n          if (!(expandedProperty in expandedParent && expandedProperty !== '@included' && expandedProperty !== '@type')) {\n            _context2.next = 23;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; colliding keywords detected.', 'jsonld.SyntaxError', {\n            code: 'colliding keywords',\n            keyword: expandedProperty\n          });\n        case 23:\n          if (!(expandedProperty === '@id')) {\n            _context2.next = 40;\n            break;\n          }\n          if (_isString(value)) {\n            _context2.next = 38;\n            break;\n          }\n          if (options.isFrame) {\n            _context2.next = 27;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value must a string.', 'jsonld.SyntaxError', {\n            code: 'invalid @id value',\n            value: value\n          });\n        case 27:\n          if (!_isObject(value)) {\n            _context2.next = 32;\n            break;\n          }\n          if (_isEmptyObject(value)) {\n            _context2.next = 30;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {\n            code: 'invalid @id value',\n            value: value\n          });\n        case 30:\n          _context2.next = 38;\n          break;\n        case 32:\n          if (!_isArray(value)) {\n            _context2.next = 37;\n            break;\n          }\n          if (value.every(function (v) {\n            return _isString(v);\n          })) {\n            _context2.next = 35;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {\n            code: 'invalid @id value',\n            value: value\n          });\n        case 35:\n          _context2.next = 38;\n          break;\n        case 37:\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@id\" value an empty object or array ' + 'of strings, if framing', 'jsonld.SyntaxError', {\n            code: 'invalid @id value',\n            value: value\n          });\n        case 38:\n          _addValue(expandedParent, '@id', _asArray(value).map(function (v) {\n            return _isString(v) ? _expandIri(activeCtx, v, {\n              base: true\n            }, options) : v;\n          }), {\n            propertyIsArray: options.isFrame\n          });\n          return _context2.abrupt(\"continue\", 200);\n        case 40:\n          if (!(expandedProperty === '@type')) {\n            _context2.next = 45;\n            break;\n          }\n          // if framing, can be a default object, but need to expand\n          // key to determine that\n          if (_isObject(value)) {\n            value = Object.fromEntries(Object.entries(value).map(function (_ref6) {\n              var _ref7 = _slicedToArray(_ref6, 2),\n                k = _ref7[0],\n                v = _ref7[1];\n              return [_expandIri(typeScopedContext, k, {\n                vocab: true\n              }), _asArray(v).map(function (vv) {\n                return _expandIri(typeScopedContext, vv, {\n                  base: true,\n                  vocab: true\n                });\n              })];\n            }));\n          }\n          _validateTypeValue(value, options.isFrame);\n          _addValue(expandedParent, '@type', _asArray(value).map(function (v) {\n            return _isString(v) ? _expandIri(typeScopedContext, v, {\n              base: true,\n              vocab: true\n            }, options) : v;\n          }), {\n            propertyIsArray: options.isFrame\n          });\n          return _context2.abrupt(\"continue\", 200);\n        case 45:\n          if (!(expandedProperty === '@included' && _processingMode(activeCtx, 1.1))) {\n            _context2.next = 55;\n            break;\n          }\n          _context2.t0 = _asArray;\n          _context2.next = 49;\n          return api.expand({\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            element: value,\n            options: options,\n            expansionMap: expansionMap\n          });\n        case 49:\n          _context2.t1 = _context2.sent;\n          includedResult = (0, _context2.t0)(_context2.t1);\n          if (includedResult.every(function (v) {\n            return _isSubject(v);\n          })) {\n            _context2.next = 53;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; ' + 'values of @included must expand to node objects.', 'jsonld.SyntaxError', {\n            code: 'invalid @included value',\n            value: value\n          });\n        case 53:\n          _addValue(expandedParent, '@included', includedResult, {\n            propertyIsArray: true\n          });\n          return _context2.abrupt(\"continue\", 200);\n        case 55:\n          if (!(expandedProperty === '@graph' && !(_isObject(value) || _isArray(value)))) {\n            _context2.next = 57;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@graph\" value must not be an ' + 'object or an array.', 'jsonld.SyntaxError', {\n            code: 'invalid @graph value',\n            value: value\n          });\n        case 57:\n          if (!(expandedProperty === '@value')) {\n            _context2.next = 61;\n            break;\n          }\n          // capture value for later\n          // \"colliding keywords\" check prevents this from being set twice\n          unexpandedValue = value;\n          if (isJsonType && _processingMode(activeCtx, 1.1)) {\n            // no coercion to array, and retain all values\n            expandedParent['@value'] = value;\n          } else {\n            _addValue(expandedParent, '@value', value, {\n              propertyIsArray: options.isFrame\n            });\n          }\n          return _context2.abrupt(\"continue\", 200);\n        case 61:\n          if (!(expandedProperty === '@language')) {\n            _context2.next = 71;\n            break;\n          }\n          if (!(value === null)) {\n            _context2.next = 64;\n            break;\n          }\n          return _context2.abrupt(\"continue\", 200);\n        case 64:\n          if (!(!_isString(value) && !options.isFrame)) {\n            _context2.next = 66;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@language\" value must be a string.', 'jsonld.SyntaxError', {\n            code: 'invalid language-tagged string',\n            value: value\n          });\n        case 66:\n          // ensure language value is lowercase\n          value = _asArray(value).map(function (v) {\n            return _isString(v) ? v.toLowerCase() : v;\n          });\n\n          // ensure language tag matches BCP47\n          _iterator8 = _createForOfIteratorHelper(value);\n          try {\n            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n              lang = _step8.value;\n              if (_isString(lang) && !lang.match(REGEX_BCP47)) {\n                console.warn(\"@language must be valid BCP47: \".concat(lang));\n              }\n            }\n          } catch (err) {\n            _iterator8.e(err);\n          } finally {\n            _iterator8.f();\n          }\n          _addValue(expandedParent, '@language', value, {\n            propertyIsArray: options.isFrame\n          });\n          return _context2.abrupt(\"continue\", 200);\n        case 71:\n          if (!(expandedProperty === '@direction')) {\n            _context2.next = 94;\n            break;\n          }\n          if (!(!_isString(value) && !options.isFrame)) {\n            _context2.next = 74;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@direction\" value must be a string.', 'jsonld.SyntaxError', {\n            code: 'invalid base direction',\n            value: value\n          });\n        case 74:\n          value = _asArray(value);\n\n          // ensure direction is \"ltr\" or \"rtl\"\n          _iterator9 = _createForOfIteratorHelper(value);\n          _context2.prev = 76;\n          _iterator9.s();\n        case 78:\n          if ((_step9 = _iterator9.n()).done) {\n            _context2.next = 84;\n            break;\n          }\n          dir = _step9.value;\n          if (!(_isString(dir) && dir !== 'ltr' && dir !== 'rtl')) {\n            _context2.next = 82;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@direction\" must be \"ltr\" or \"rtl\".', 'jsonld.SyntaxError', {\n            code: 'invalid base direction',\n            value: value\n          });\n        case 82:\n          _context2.next = 78;\n          break;\n        case 84:\n          _context2.next = 89;\n          break;\n        case 86:\n          _context2.prev = 86;\n          _context2.t2 = _context2[\"catch\"](76);\n          _iterator9.e(_context2.t2);\n        case 89:\n          _context2.prev = 89;\n          _iterator9.f();\n          return _context2.finish(89);\n        case 92:\n          _addValue(expandedParent, '@direction', value, {\n            propertyIsArray: options.isFrame\n          });\n          return _context2.abrupt(\"continue\", 200);\n        case 94:\n          if (!(expandedProperty === '@index')) {\n            _context2.next = 99;\n            break;\n          }\n          if (_isString(value)) {\n            _context2.next = 97;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@index\" value must be a string.', 'jsonld.SyntaxError', {\n            code: 'invalid @index value',\n            value: value\n          });\n        case 97:\n          _addValue(expandedParent, '@index', value);\n          return _context2.abrupt(\"continue\", 200);\n        case 99:\n          if (!(expandedProperty === '@reverse')) {\n            _context2.next = 127;\n            break;\n          }\n          if (_isObject(value)) {\n            _context2.next = 102;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@reverse\" value must be an object.', 'jsonld.SyntaxError', {\n            code: 'invalid @reverse value',\n            value: value\n          });\n        case 102:\n          _context2.next = 104;\n          return api.expand({\n            activeCtx: activeCtx,\n            activeProperty: '@reverse',\n            element: value,\n            options: options,\n            expansionMap: expansionMap\n          });\n        case 104:\n          expandedValue = _context2.sent;\n          // properties double-reversed\n          if ('@reverse' in expandedValue) {\n            for (property in expandedValue['@reverse']) {\n              _addValue(expandedParent, property, expandedValue['@reverse'][property], {\n                propertyIsArray: true\n              });\n            }\n          }\n\n          // FIXME: can this be merged with code below to simplify?\n          // merge in all reversed properties\n          reverseMap = expandedParent['@reverse'] || null;\n          _context2.t3 = _regeneratorRuntime().keys(expandedValue);\n        case 108:\n          if ((_context2.t4 = _context2.t3()).done) {\n            _context2.next = 126;\n            break;\n          }\n          _property = _context2.t4.value;\n          if (!(_property === '@reverse')) {\n            _context2.next = 112;\n            break;\n          }\n          return _context2.abrupt(\"continue\", 108);\n        case 112:\n          if (reverseMap === null) {\n            reverseMap = expandedParent['@reverse'] = {};\n          }\n          _addValue(reverseMap, _property, [], {\n            propertyIsArray: true\n          });\n          items = expandedValue[_property];\n          ii = 0;\n        case 116:\n          if (!(ii < items.length)) {\n            _context2.next = 124;\n            break;\n          }\n          item = items[ii];\n          if (!(_isValue(item) || _isList(item))) {\n            _context2.next = 120;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@reverse\" value must not be a ' + '@value or an @list.', 'jsonld.SyntaxError', {\n            code: 'invalid reverse property value',\n            value: expandedValue\n          });\n        case 120:\n          _addValue(reverseMap, _property, item, {\n            propertyIsArray: true\n          });\n        case 121:\n          ++ii;\n          _context2.next = 116;\n          break;\n        case 124:\n          _context2.next = 108;\n          break;\n        case 126:\n          return _context2.abrupt(\"continue\", 200);\n        case 127:\n          if (!(expandedProperty === '@nest')) {\n            _context2.next = 130;\n            break;\n          }\n          nests.push(_key2);\n          return _context2.abrupt(\"continue\", 200);\n        case 130:\n          // use potential scoped context for key\n          termCtx = activeCtx;\n          ctx = _getContextValue(activeCtx, _key2, '@context');\n          if (_isUndefined(ctx)) {\n            _context2.next = 136;\n            break;\n          }\n          _context2.next = 135;\n          return _processContext({\n            activeCtx: activeCtx,\n            localCtx: ctx,\n            propagate: true,\n            overrideProtected: true,\n            options: options\n          });\n        case 135:\n          termCtx = _context2.sent;\n        case 136:\n          container = _getContextValue(termCtx, _key2, '@container') || [];\n          if (!(container.includes('@language') && _isObject(value))) {\n            _context2.next = 142;\n            break;\n          }\n          direction = _getContextValue(termCtx, _key2, '@direction'); // handle language map container (skip if value is not an object)\n          expandedValue = _expandLanguageMap(termCtx, value, direction, options);\n          _context2.next = 180;\n          break;\n        case 142:\n          if (!(container.includes('@index') && _isObject(value))) {\n            _context2.next = 151;\n            break;\n          }\n          // handle index container (skip if value is not an object)\n          asGraph = container.includes('@graph');\n          indexKey = _getContextValue(termCtx, _key2, '@index') || '@index';\n          propertyIndex = indexKey !== '@index' && _expandIri(activeCtx, indexKey, {\n            vocab: true\n          }, options);\n          _context2.next = 148;\n          return _expandIndexMap({\n            activeCtx: termCtx,\n            options: options,\n            activeProperty: _key2,\n            value: value,\n            expansionMap: expansionMap,\n            asGraph: asGraph,\n            indexKey: indexKey,\n            propertyIndex: propertyIndex\n          });\n        case 148:\n          expandedValue = _context2.sent;\n          _context2.next = 180;\n          break;\n        case 151:\n          if (!(container.includes('@id') && _isObject(value))) {\n            _context2.next = 158;\n            break;\n          }\n          // handle id container (skip if value is not an object)\n          _asGraph = container.includes('@graph');\n          _context2.next = 155;\n          return _expandIndexMap({\n            activeCtx: termCtx,\n            options: options,\n            activeProperty: _key2,\n            value: value,\n            expansionMap: expansionMap,\n            asGraph: _asGraph,\n            indexKey: '@id'\n          });\n        case 155:\n          expandedValue = _context2.sent;\n          _context2.next = 180;\n          break;\n        case 158:\n          if (!(container.includes('@type') && _isObject(value))) {\n            _context2.next = 164;\n            break;\n          }\n          _context2.next = 161;\n          return _expandIndexMap({\n            // since container is `@type`, revert type scoped context when expanding\n            activeCtx: termCtx.revertToPreviousContext(),\n            options: options,\n            activeProperty: _key2,\n            value: value,\n            expansionMap: expansionMap,\n            asGraph: false,\n            indexKey: '@type'\n          });\n        case 161:\n          expandedValue = _context2.sent;\n          _context2.next = 180;\n          break;\n        case 164:\n          // recurse into @list or @set\n          isList = expandedProperty === '@list';\n          if (!(isList || expandedProperty === '@set')) {\n            _context2.next = 173;\n            break;\n          }\n          nextActiveProperty = activeProperty;\n          if (isList && expandedActiveProperty === '@graph') {\n            nextActiveProperty = null;\n          }\n          _context2.next = 170;\n          return api.expand({\n            activeCtx: termCtx,\n            activeProperty: nextActiveProperty,\n            element: value,\n            options: options,\n            insideList: isList,\n            expansionMap: expansionMap\n          });\n        case 170:\n          expandedValue = _context2.sent;\n          _context2.next = 180;\n          break;\n        case 173:\n          if (!(_getContextValue(activeCtx, _key2, '@type') === '@json')) {\n            _context2.next = 177;\n            break;\n          }\n          expandedValue = {\n            '@type': '@json',\n            '@value': value\n          };\n          _context2.next = 180;\n          break;\n        case 177:\n          _context2.next = 179;\n          return api.expand({\n            activeCtx: termCtx,\n            activeProperty: _key2,\n            element: value,\n            options: options,\n            insideList: false,\n            expansionMap: expansionMap\n          });\n        case 179:\n          expandedValue = _context2.sent;\n        case 180:\n          if (!(expandedValue === null && expandedProperty !== '@value')) {\n            _context2.next = 184;\n            break;\n          }\n          // TODO: use `await` to support async\n          expandedValue = expansionMap({\n            unmappedValue: value,\n            expandedProperty: expandedProperty,\n            activeCtx: termCtx,\n            activeProperty: activeProperty,\n            parent: element,\n            options: options,\n            insideList: insideList,\n            key: _key2,\n            expandedParent: expandedParent\n          });\n          if (!(expandedValue === undefined)) {\n            _context2.next = 184;\n            break;\n          }\n          return _context2.abrupt(\"continue\", 200);\n        case 184:\n          // convert expanded value to @list if container specifies it\n          if (expandedProperty !== '@list' && !_isList(expandedValue) && container.includes('@list')) {\n            // ensure expanded value in @list is an array\n            expandedValue = {\n              '@list': _asArray(expandedValue)\n            };\n          }\n\n          // convert expanded value to @graph if container specifies it\n          // and value is not, itself, a graph\n          // index cases handled above\n          if (container.includes('@graph') && !container.some(function (key) {\n            return key === '@id' || key === '@index';\n          })) {\n            // ensure expanded values are arrays\n            expandedValue = _asArray(expandedValue).map(function (v) {\n              return {\n                '@graph': _asArray(v)\n              };\n            });\n          }\n\n          // FIXME: can this be merged with code above to simplify?\n          // merge in reverse properties\n          if (!(termCtx.mappings.has(_key2) && termCtx.mappings.get(_key2).reverse)) {\n            _context2.next = 199;\n            break;\n          }\n          _reverseMap = expandedParent['@reverse'] = expandedParent['@reverse'] || {};\n          expandedValue = _asArray(expandedValue);\n          _ii = 0;\n        case 190:\n          if (!(_ii < expandedValue.length)) {\n            _context2.next = 198;\n            break;\n          }\n          _item = expandedValue[_ii];\n          if (!(_isValue(_item) || _isList(_item))) {\n            _context2.next = 194;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@reverse\" value must not be a ' + '@value or an @list.', 'jsonld.SyntaxError', {\n            code: 'invalid reverse property value',\n            value: expandedValue\n          });\n        case 194:\n          _addValue(_reverseMap, expandedProperty, _item, {\n            propertyIsArray: true\n          });\n        case 195:\n          ++_ii;\n          _context2.next = 190;\n          break;\n        case 198:\n          return _context2.abrupt(\"continue\", 200);\n        case 199:\n          // add value for property\n          // special keywords handled above\n          _addValue(expandedParent, expandedProperty, expandedValue, {\n            propertyIsArray: true\n          });\n        case 200:\n          _context2.next = 7;\n          break;\n        case 202:\n          _context2.next = 207;\n          break;\n        case 204:\n          _context2.prev = 204;\n          _context2.t5 = _context2[\"catch\"](5);\n          _iterator6.e(_context2.t5);\n        case 207:\n          _context2.prev = 207;\n          _iterator6.f();\n          return _context2.finish(207);\n        case 210:\n          if (!('@value' in expandedParent)) {\n            _context2.next = 216;\n            break;\n          }\n          if (!(expandedParent['@type'] === '@json' && _processingMode(activeCtx, 1.1))) {\n            _context2.next = 214;\n            break;\n          }\n          _context2.next = 216;\n          break;\n        case 214:\n          if (!((_isObject(unexpandedValue) || _isArray(unexpandedValue)) && !options.isFrame)) {\n            _context2.next = 216;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; \"@value\" value must not be an ' + 'object or an array.', 'jsonld.SyntaxError', {\n            code: 'invalid value object value',\n            value: unexpandedValue\n          });\n        case 216:\n          _i = 0, _nests = nests;\n        case 217:\n          if (!(_i < _nests.length)) {\n            _context2.next = 242;\n            break;\n          }\n          key = _nests[_i];\n          nestedValues = _isArray(element[key]) ? element[key] : [element[key]];\n          _iterator7 = _createForOfIteratorHelper(nestedValues);\n          _context2.prev = 221;\n          _iterator7.s();\n        case 223:\n          if ((_step7 = _iterator7.n()).done) {\n            _context2.next = 231;\n            break;\n          }\n          nv = _step7.value;\n          if (!(!_isObject(nv) || Object.keys(nv).some(function (k) {\n            return _expandIri(activeCtx, k, {\n              vocab: true\n            }, options) === '@value';\n          }))) {\n            _context2.next = 227;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; nested value must be a node object.', 'jsonld.SyntaxError', {\n            code: 'invalid @nest value',\n            value: nv\n          });\n        case 227:\n          _context2.next = 229;\n          return _expandObject({\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            expandedActiveProperty: expandedActiveProperty,\n            element: nv,\n            expandedParent: expandedParent,\n            options: options,\n            insideList: insideList,\n            typeScopedContext: typeScopedContext,\n            typeKey: typeKey,\n            expansionMap: expansionMap\n          });\n        case 229:\n          _context2.next = 223;\n          break;\n        case 231:\n          _context2.next = 236;\n          break;\n        case 233:\n          _context2.prev = 233;\n          _context2.t6 = _context2[\"catch\"](221);\n          _iterator7.e(_context2.t6);\n        case 236:\n          _context2.prev = 236;\n          _iterator7.f();\n          return _context2.finish(236);\n        case 239:\n          _i++;\n          _context2.next = 217;\n          break;\n        case 242:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[5, 204, 207, 210], [76, 86, 89, 92], [221, 233, 236, 239]]);\n  }));\n  return _expandObject2.apply(this, arguments);\n}\nfunction _expandValue(_ref4) {\n  var activeCtx = _ref4.activeCtx,\n    activeProperty = _ref4.activeProperty,\n    value = _ref4.value,\n    options = _ref4.options;\n  // nothing to expand\n  if (value === null || value === undefined) {\n    return null;\n  }\n\n  // special-case expand @id and @type (skips '@id' expansion)\n  var expandedProperty = _expandIri(activeCtx, activeProperty, {\n    vocab: true\n  }, options);\n  if (expandedProperty === '@id') {\n    return _expandIri(activeCtx, value, {\n      base: true\n    }, options);\n  } else if (expandedProperty === '@type') {\n    return _expandIri(activeCtx, value, {\n      vocab: true,\n      base: true\n    }, options);\n  }\n\n  // get type definition from context\n  var type = _getContextValue(activeCtx, activeProperty, '@type');\n\n  // do @id expansion (automatic for @graph)\n  if ((type === '@id' || expandedProperty === '@graph') && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {\n        base: true\n      }, options)\n    };\n  }\n  // do @id expansion w/vocab\n  if (type === '@vocab' && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {\n        vocab: true,\n        base: true\n      }, options)\n    };\n  }\n\n  // do not expand keyword values\n  if (_isKeyword(expandedProperty)) {\n    return value;\n  }\n  var rval = {};\n  if (type && !['@id', '@vocab', '@none'].includes(type)) {\n    // other type\n    rval['@type'] = type;\n  } else if (_isString(value)) {\n    // check for language tagging for strings\n    var language = _getContextValue(activeCtx, activeProperty, '@language');\n    if (language !== null) {\n      rval['@language'] = language;\n    }\n    var direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    if (direction !== null) {\n      rval['@direction'] = direction;\n    }\n  }\n  // do conversion of values that aren't basic JSON types to strings\n  if (!['boolean', 'number', 'string'].includes(typeof value)) {\n    value = value.toString();\n  }\n  rval['@value'] = value;\n  return rval;\n}\n\n/**\n * Expands a language map.\n *\n * @param activeCtx the active context to use.\n * @param languageMap the language map to expand.\n * @param direction the direction to apply to values.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded language map.\n */\nfunction _expandLanguageMap(activeCtx, languageMap, direction, options) {\n  var rval = [];\n  var keys = Object.keys(languageMap).sort();\n  var _iterator4 = _createForOfIteratorHelper(keys),\n    _step4;\n  try {\n    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n      var key = _step4.value;\n      var expandedKey = _expandIri(activeCtx, key, {\n        vocab: true\n      }, options);\n      var val = languageMap[key];\n      if (!_isArray(val)) {\n        val = [val];\n      }\n      var _iterator5 = _createForOfIteratorHelper(val),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var item = _step5.value;\n          if (item === null) {\n            // null values are allowed (8.5) but ignored (3.1)\n            continue;\n          }\n          if (!_isString(item)) {\n            throw new JsonLdError('Invalid JSON-LD syntax; language map values must be strings.', 'jsonld.SyntaxError', {\n              code: 'invalid language map value',\n              languageMap: languageMap\n            });\n          }\n          var _val = {\n            '@value': item\n          };\n          if (expandedKey !== '@none') {\n            _val['@language'] = key.toLowerCase();\n          }\n          if (direction) {\n            _val['@direction'] = direction;\n          }\n          rval.push(_val);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n    }\n  } catch (err) {\n    _iterator4.e(err);\n  } finally {\n    _iterator4.f();\n  }\n  return rval;\n}\nfunction _expandIndexMap(_x3) {\n  return _expandIndexMap2.apply(this, arguments);\n}\nfunction _expandIndexMap2() {\n  _expandIndexMap2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref5) {\n    var activeCtx, options, activeProperty, value, expansionMap, asGraph, indexKey, propertyIndex, rval, keys, isTypeIndex, _iterator10, _step10, key, ctx, val, expandedKey, _iterator11, _step11, item;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          activeCtx = _ref5.activeCtx, options = _ref5.options, activeProperty = _ref5.activeProperty, value = _ref5.value, expansionMap = _ref5.expansionMap, asGraph = _ref5.asGraph, indexKey = _ref5.indexKey, propertyIndex = _ref5.propertyIndex;\n          rval = [];\n          keys = Object.keys(value).sort();\n          isTypeIndex = indexKey === '@type';\n          _iterator10 = _createForOfIteratorHelper(keys);\n          _context3.prev = 5;\n          _iterator10.s();\n        case 7:\n          if ((_step10 = _iterator10.n()).done) {\n            _context3.next = 51;\n            break;\n          }\n          key = _step10.value;\n          if (!isTypeIndex) {\n            _context3.next = 15;\n            break;\n          }\n          ctx = _getContextValue(activeCtx, key, '@context');\n          if (_isUndefined(ctx)) {\n            _context3.next = 15;\n            break;\n          }\n          _context3.next = 14;\n          return _processContext({\n            activeCtx: activeCtx,\n            localCtx: ctx,\n            propagate: false,\n            options: options\n          });\n        case 14:\n          activeCtx = _context3.sent;\n        case 15:\n          val = value[key];\n          if (!_isArray(val)) {\n            val = [val];\n          }\n          _context3.next = 19;\n          return api.expand({\n            activeCtx: activeCtx,\n            activeProperty: activeProperty,\n            element: val,\n            options: options,\n            insideList: false,\n            insideIndex: true,\n            expansionMap: expansionMap\n          });\n        case 19:\n          val = _context3.sent;\n          // expand for @type, but also for @none\n          expandedKey = void 0;\n          if (propertyIndex) {\n            if (key === '@none') {\n              expandedKey = '@none';\n            } else {\n              expandedKey = _expandValue({\n                activeCtx: activeCtx,\n                activeProperty: indexKey,\n                value: key,\n                options: options\n              });\n            }\n          } else {\n            expandedKey = _expandIri(activeCtx, key, {\n              vocab: true\n            }, options);\n          }\n          if (indexKey === '@id') {\n            // expand document relative\n            key = _expandIri(activeCtx, key, {\n              base: true\n            }, options);\n          } else if (isTypeIndex) {\n            key = expandedKey;\n          }\n          _iterator11 = _createForOfIteratorHelper(val);\n          _context3.prev = 24;\n          _iterator11.s();\n        case 26:\n          if ((_step11 = _iterator11.n()).done) {\n            _context3.next = 41;\n            break;\n          }\n          item = _step11.value;\n          // If this is also a @graph container, turn items into graphs\n          if (asGraph && !_isGraph(item)) {\n            item = {\n              '@graph': [item]\n            };\n          }\n          if (!(indexKey === '@type')) {\n            _context3.next = 33;\n            break;\n          }\n          if (expandedKey === '@none') {\n            // ignore @none\n          } else if (item['@type']) {\n            item['@type'] = [key].concat(item['@type']);\n          } else {\n            item['@type'] = [key];\n          }\n          _context3.next = 38;\n          break;\n        case 33:\n          if (!(_isValue(item) && !['@language', '@type', '@index'].includes(indexKey))) {\n            _context3.next = 37;\n            break;\n          }\n          throw new JsonLdError('Invalid JSON-LD syntax; Attempt to add illegal key to value ' + \"object: \\\"\".concat(indexKey, \"\\\".\"), 'jsonld.SyntaxError', {\n            code: 'invalid value object',\n            value: item\n          });\n        case 37:\n          if (propertyIndex) {\n            // index is a property to be expanded, and values interpreted for that\n            // property\n            if (expandedKey !== '@none') {\n              // expand key as a value\n              _addValue(item, propertyIndex, expandedKey, {\n                propertyIsArray: true,\n                prependValue: true\n              });\n            }\n          } else if (expandedKey !== '@none' && !(indexKey in item)) {\n            item[indexKey] = key;\n          }\n        case 38:\n          rval.push(item);\n        case 39:\n          _context3.next = 26;\n          break;\n        case 41:\n          _context3.next = 46;\n          break;\n        case 43:\n          _context3.prev = 43;\n          _context3.t0 = _context3[\"catch\"](24);\n          _iterator11.e(_context3.t0);\n        case 46:\n          _context3.prev = 46;\n          _iterator11.f();\n          return _context3.finish(46);\n        case 49:\n          _context3.next = 7;\n          break;\n        case 51:\n          _context3.next = 56;\n          break;\n        case 53:\n          _context3.prev = 53;\n          _context3.t1 = _context3[\"catch\"](5);\n          _iterator10.e(_context3.t1);\n        case 56:\n          _context3.prev = 56;\n          _iterator10.f();\n          return _context3.finish(56);\n        case 59:\n          return _context3.abrupt(\"return\", rval);\n        case 60:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3, null, [[5, 53, 56, 59], [24, 43, 46, 49]]);\n  }));\n  return _expandIndexMap2.apply(this, arguments);\n}","map":{"version":3,"names":["JsonLdError","require","_isArray","isArray","_isObject","isObject","_isEmptyObject","isEmptyObject","_isString","isString","_isUndefined","isUndefined","_isList","isList","_isValue","isValue","_isGraph","isGraph","_isSubject","isSubject","_expandIri","expandIri","_getContextValue","getContextValue","_isKeyword","isKeyword","_processContext","process","_processingMode","processingMode","_isAbsoluteIri","isAbsolute","_addValue","addValue","_asArray","asArray","_getValues","getValues","_validateTypeValue","validateTypeValue","api","module","exports","REGEX_BCP47","expand","activeCtx","activeProperty","element","options","insideList","insideIndex","typeScopedContext","expansionMap","undefined","Object","assign","isFrame","vocab","unmappedValue","mapped","_expandValue","value","rval","container","includes","i","length","e","parent","index","expandedParent","concat","push","expandedActiveProperty","propertyScopedCtx","previousContext","keys","sort","mustRevert","key","expandedProperty","revertToPreviousContext","localCtx","propagate","overrideProtected","typeKey","types","Array","slice","type","ctx","_expandObject","count","code","validCount","values","every","v","t","indexOf","keepFreeFloatingNodes","nests","isJsonType","expandedValue","unmappedProperty","keyword","map","base","propertyIsArray","fromEntries","entries","k","vv","includedResult","unexpandedValue","toLowerCase","lang","match","console","warn","dir","property","reverseMap","items","ii","item","termCtx","direction","_expandLanguageMap","asGraph","indexKey","propertyIndex","_expandIndexMap","nextActiveProperty","some","mappings","has","get","reverse","nestedValues","nv","language","toString","languageMap","expandedKey","val","isTypeIndex","prependValue"],"sources":["E:/react-todo-app/node_modules/jsonld/lib/expand.js"],"sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst JsonLdError = require('./JsonLdError');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isEmptyObject: _isEmptyObject,\n  isString: _isString,\n  isUndefined: _isUndefined\n} = require('./types');\n\nconst {\n  isList: _isList,\n  isValue: _isValue,\n  isGraph: _isGraph,\n  isSubject: _isSubject\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getContextValue: _getContextValue,\n  isKeyword: _isKeyword,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = require('./url');\n\nconst {\n  addValue: _addValue,\n  asArray: _asArray,\n  getValues: _getValues,\n  validateTypeValue: _validateTypeValue\n} = require('./util');\n\nconst api = {};\nmodule.exports = api;\nconst REGEX_BCP47 = /^[a-zA-Z]{1,8}(-[a-zA-Z0-9]{1,8})*$/;\n\n/**\n * Recursively expands an element using the given context. Any context in\n * the element will be removed. All context URLs must have been retrieved\n * before calling this method.\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element, null for none.\n * @param element the element to expand.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param insideIndex true if the element is inside an index container,\n *          false if not.\n * @param typeScopedContext an optional type-scoped active context for\n *          expanding values of nodes that were expressed according to\n *          a type-scoped context.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n *\n * @return a Promise that resolves to the expanded value.\n */\napi.expand = async ({\n  activeCtx,\n  activeProperty = null,\n  element,\n  options = {},\n  insideList = false,\n  insideIndex = false,\n  typeScopedContext = null,\n  expansionMap = () => undefined\n}) => {\n  // nothing to expand\n  if(element === null || element === undefined) {\n    return null;\n  }\n\n  // disable framing if activeProperty is @default\n  if(activeProperty === '@default') {\n    options = Object.assign({}, options, {isFrame: false});\n  }\n\n  if(!_isArray(element) && !_isObject(element)) {\n    // drop free-floating scalars that are not in lists unless custom mapped\n    if(!insideList && (activeProperty === null ||\n      _expandIri(activeCtx, activeProperty, {vocab: true},\n        options) === '@graph')) {\n      const mapped = await expansionMap({\n        unmappedValue: element,\n        activeCtx,\n        activeProperty,\n        options,\n        insideList\n      });\n      if(mapped === undefined) {\n        return null;\n      }\n      return mapped;\n    }\n\n    // expand element according to value expansion rules\n    return _expandValue({activeCtx, activeProperty, value: element, options});\n  }\n\n  // recursively expand array\n  if(_isArray(element)) {\n    let rval = [];\n    const container = _getContextValue(\n      activeCtx, activeProperty, '@container') || [];\n    insideList = insideList || container.includes('@list');\n    for(let i = 0; i < element.length; ++i) {\n      // expand element\n      let e = await api.expand({\n        activeCtx,\n        activeProperty,\n        element: element[i],\n        options,\n        expansionMap,\n        insideIndex,\n        typeScopedContext\n      });\n      if(insideList && _isArray(e)) {\n        e = {'@list': e};\n      }\n\n      if(e === null) {\n        e = await expansionMap({\n          unmappedValue: element[i],\n          activeCtx,\n          activeProperty,\n          parent: element,\n          index: i,\n          options,\n          expandedParent: rval,\n          insideList\n        });\n        if(e === undefined) {\n          continue;\n        }\n      }\n\n      if(_isArray(e)) {\n        rval = rval.concat(e);\n      } else {\n        rval.push(e);\n      }\n    }\n    return rval;\n  }\n\n  // recursively expand object:\n\n  // first, expand the active property\n  const expandedActiveProperty = _expandIri(\n    activeCtx, activeProperty, {vocab: true}, options);\n\n  // Get any property-scoped context for activeProperty\n  const propertyScopedCtx =\n    _getContextValue(activeCtx, activeProperty, '@context');\n\n  // second, determine if any type-scoped context should be reverted; it\n  // should only be reverted when the following are all true:\n  // 1. `element` is not a value or subject reference\n  // 2. `insideIndex` is false\n  typeScopedContext = typeScopedContext ||\n    (activeCtx.previousContext ? activeCtx : null);\n  let keys = Object.keys(element).sort();\n  let mustRevert = !insideIndex;\n  if(mustRevert && typeScopedContext && keys.length <= 2 &&\n    !keys.includes('@context')) {\n    for(const key of keys) {\n      const expandedProperty = _expandIri(\n        typeScopedContext, key, {vocab: true}, options);\n      if(expandedProperty === '@value') {\n        // value found, ensure type-scoped context is used to expand it\n        mustRevert = false;\n        activeCtx = typeScopedContext;\n        break;\n      }\n      if(expandedProperty === '@id' && keys.length === 1) {\n        // subject reference found, do not revert\n        mustRevert = false;\n        break;\n      }\n    }\n  }\n\n  if(mustRevert) {\n    // revert type scoped context\n    activeCtx = activeCtx.revertToPreviousContext();\n  }\n\n  // apply property-scoped context after reverting term-scoped context\n  if(!_isUndefined(propertyScopedCtx)) {\n    activeCtx = await _processContext({\n      activeCtx,\n      localCtx: propertyScopedCtx,\n      propagate: true,\n      overrideProtected: true,\n      options\n    });\n  }\n\n  // if element has a context, process it\n  if('@context' in element) {\n    activeCtx = await _processContext(\n      {activeCtx, localCtx: element['@context'], options});\n  }\n\n  // set the type-scoped context to the context on input, for use later\n  typeScopedContext = activeCtx;\n\n  // Remember the first key found expanding to @type\n  let typeKey = null;\n\n  // look for scoped contexts on `@type`\n  for(const key of keys) {\n    const expandedProperty = _expandIri(activeCtx, key, {vocab: true}, options);\n    if(expandedProperty === '@type') {\n      // set scoped contexts from @type\n      // avoid sorting if possible\n      typeKey = typeKey || key;\n      const value = element[key];\n      const types =\n        Array.isArray(value) ?\n          (value.length > 1 ? value.slice().sort() : value) : [value];\n      for(const type of types) {\n        const ctx = _getContextValue(typeScopedContext, type, '@context');\n        if(!_isUndefined(ctx)) {\n          activeCtx = await _processContext({\n            activeCtx,\n            localCtx: ctx,\n            options,\n            propagate: false\n          });\n        }\n      }\n    }\n  }\n\n  // process each key and value in element, ignoring @nest content\n  let rval = {};\n  await _expandObject({\n    activeCtx,\n    activeProperty,\n    expandedActiveProperty,\n    element,\n    expandedParent: rval,\n    options,\n    insideList,\n    typeKey,\n    typeScopedContext,\n    expansionMap});\n\n  // get property count on expanded output\n  keys = Object.keys(rval);\n  let count = keys.length;\n\n  if('@value' in rval) {\n    // @value must only have @language or @type\n    if('@type' in rval && ('@language' in rval || '@direction' in rval)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" may not ' +\n        'contain both \"@type\" and either \"@language\" or \"@direction\".',\n        'jsonld.SyntaxError', {code: 'invalid value object', element: rval});\n    }\n    let validCount = count - 1;\n    if('@type' in rval) {\n      validCount -= 1;\n    }\n    if('@index' in rval) {\n      validCount -= 1;\n    }\n    if('@language' in rval) {\n      validCount -= 1;\n    }\n    if('@direction' in rval) {\n      validCount -= 1;\n    }\n    if(validCount !== 0) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" may only ' +\n        'have an \"@index\" property and either \"@type\" ' +\n        'or either or both \"@language\" or \"@direction\".',\n        'jsonld.SyntaxError', {code: 'invalid value object', element: rval});\n    }\n    const values = rval['@value'] === null ? [] : _asArray(rval['@value']);\n    const types = _getValues(rval, '@type');\n\n    // drop null @values unless custom mapped\n    if(_processingMode(activeCtx, 1.1) && types.includes('@json') &&\n      types.length === 1) {\n      // Any value of @value is okay if @type: @json\n    } else if(values.length === 0) {\n      const mapped = await expansionMap({\n        unmappedValue: rval,\n        activeCtx,\n        activeProperty,\n        element,\n        options,\n        insideList\n      });\n      if(mapped !== undefined) {\n        rval = mapped;\n      } else {\n        rval = null;\n      }\n    } else if(!values.every(v => (_isString(v) || _isEmptyObject(v))) &&\n      '@language' in rval) {\n      // if @language is present, @value must be a string\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; only strings may be language-tagged.',\n        'jsonld.SyntaxError',\n        {code: 'invalid language-tagged value', element: rval});\n    } else if(!types.every(t =>\n      (_isAbsoluteIri(t) && !(_isString(t) && t.indexOf('_:') === 0) ||\n      _isEmptyObject(t)))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; an element containing \"@value\" and \"@type\" ' +\n        'must have an absolute IRI for the value of \"@type\".',\n        'jsonld.SyntaxError', {code: 'invalid typed value', element: rval});\n    }\n  } else if('@type' in rval && !_isArray(rval['@type'])) {\n    // convert @type to an array\n    rval['@type'] = [rval['@type']];\n  } else if('@set' in rval || '@list' in rval) {\n    // handle @set and @list\n    if(count > 1 && !(count === 2 && '@index' in rval)) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; if an element has the property \"@set\" ' +\n        'or \"@list\", then it can have at most one other property that is ' +\n        '\"@index\".', 'jsonld.SyntaxError',\n        {code: 'invalid set or list object', element: rval});\n    }\n    // optimize away @set\n    if('@set' in rval) {\n      rval = rval['@set'];\n      keys = Object.keys(rval);\n      count = keys.length;\n    }\n  } else if(count === 1 && '@language' in rval) {\n    // drop objects with only @language unless custom mapped\n    const mapped = await expansionMap(rval, {\n      unmappedValue: rval,\n      activeCtx,\n      activeProperty,\n      element,\n      options,\n      insideList\n    });\n    if(mapped !== undefined) {\n      rval = mapped;\n    } else {\n      rval = null;\n    }\n  }\n\n  // drop certain top-level objects that do not occur in lists, unless custom\n  // mapped\n  if(_isObject(rval) &&\n    !options.keepFreeFloatingNodes && !insideList &&\n    (activeProperty === null || expandedActiveProperty === '@graph')) {\n    // drop empty object, top-level @value/@list, or object with only @id\n    if(count === 0 || '@value' in rval || '@list' in rval ||\n      (count === 1 && '@id' in rval)) {\n      const mapped = await expansionMap({\n        unmappedValue: rval,\n        activeCtx,\n        activeProperty,\n        element,\n        options,\n        insideList\n      });\n      if(mapped !== undefined) {\n        rval = mapped;\n      } else {\n        rval = null;\n      }\n    }\n  }\n\n  return rval;\n};\n\n/**\n * Expand each key and value of element adding to result\n *\n * @param activeCtx the context to use.\n * @param activeProperty the property for the element.\n * @param expandedActiveProperty the expansion of activeProperty\n * @param element the element to expand.\n * @param expandedParent the expanded result into which to add values.\n * @param options the expansion options.\n * @param insideList true if the element is a list, false if not.\n * @param typeKey first key found expanding to @type.\n * @param typeScopedContext the context before reverting.\n * @param expansionMap(info) a function that can be used to custom map\n *          unmappable values (or to throw an error when they are detected);\n *          if this function returns `undefined` then the default behavior\n *          will be used.\n */\nasync function _expandObject({\n  activeCtx,\n  activeProperty,\n  expandedActiveProperty,\n  element,\n  expandedParent,\n  options = {},\n  insideList,\n  typeKey,\n  typeScopedContext,\n  expansionMap\n}) {\n  const keys = Object.keys(element).sort();\n  const nests = [];\n  let unexpandedValue;\n\n  // Figure out if this is the type for a JSON literal\n  const isJsonType = element[typeKey] &&\n    _expandIri(activeCtx,\n      (_isArray(element[typeKey]) ? element[typeKey][0] : element[typeKey]),\n      {vocab: true}, options) === '@json';\n\n  for(const key of keys) {\n    let value = element[key];\n    let expandedValue;\n\n    // skip @context\n    if(key === '@context') {\n      continue;\n    }\n\n    // expand property\n    let expandedProperty = _expandIri(activeCtx, key, {vocab: true}, options);\n\n    // drop non-absolute IRI keys that aren't keywords unless custom mapped\n    if(expandedProperty === null ||\n      !(_isAbsoluteIri(expandedProperty) || _isKeyword(expandedProperty))) {\n      // TODO: use `await` to support async\n      expandedProperty = expansionMap({\n        unmappedProperty: key,\n        activeCtx,\n        activeProperty,\n        parent: element,\n        options,\n        insideList,\n        value,\n        expandedParent\n      });\n      if(expandedProperty === undefined) {\n        continue;\n      }\n    }\n\n    if(_isKeyword(expandedProperty)) {\n      if(expandedActiveProperty === '@reverse') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; a keyword cannot be used as a @reverse ' +\n          'property.', 'jsonld.SyntaxError',\n          {code: 'invalid reverse property map', value});\n      }\n      if(expandedProperty in expandedParent &&\n         expandedProperty !== '@included' &&\n         expandedProperty !== '@type') {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; colliding keywords detected.',\n          'jsonld.SyntaxError',\n          {code: 'colliding keywords', keyword: expandedProperty});\n      }\n    }\n\n    // syntax error if @id is not a string\n    if(expandedProperty === '@id') {\n      if(!_isString(value)) {\n        if(!options.isFrame) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@id\" value must a string.',\n            'jsonld.SyntaxError', {code: 'invalid @id value', value});\n        }\n        if(_isObject(value)) {\n          // empty object is a wildcard\n          if(!_isEmptyObject(value)) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n              'of strings, if framing',\n              'jsonld.SyntaxError', {code: 'invalid @id value', value});\n          }\n        } else if(_isArray(value)) {\n          if(!value.every(v => _isString(v))) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n              'of strings, if framing',\n              'jsonld.SyntaxError', {code: 'invalid @id value', value});\n          }\n        } else {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@id\" value an empty object or array ' +\n            'of strings, if framing',\n            'jsonld.SyntaxError', {code: 'invalid @id value', value});\n        }\n      }\n\n      _addValue(\n        expandedParent, '@id',\n        _asArray(value).map(v =>\n          _isString(v) ? _expandIri(activeCtx, v, {base: true}, options) : v),\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    if(expandedProperty === '@type') {\n      // if framing, can be a default object, but need to expand\n      // key to determine that\n      if(_isObject(value)) {\n        value = Object.fromEntries(Object.entries(value).map(([k, v]) => [\n          _expandIri(typeScopedContext, k, {vocab: true}),\n          _asArray(v).map(vv =>\n            _expandIri(typeScopedContext, vv, {base: true, vocab: true})\n          )\n        ]));\n      }\n      _validateTypeValue(value, options.isFrame);\n      _addValue(\n        expandedParent, '@type',\n        _asArray(value).map(v =>\n          _isString(v) ?\n            _expandIri(typeScopedContext, v,\n              {base: true, vocab: true}, options) : v),\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // Included blocks are treated as an array of separate object nodes sharing\n    // the same referencing active_property.\n    // For 1.0, it is skipped as are other unknown keywords\n    if(expandedProperty === '@included' && _processingMode(activeCtx, 1.1)) {\n      const includedResult = _asArray(await api.expand({\n        activeCtx,\n        activeProperty,\n        element: value,\n        options,\n        expansionMap\n      }));\n\n      // Expanded values must be node objects\n      if(!includedResult.every(v => _isSubject(v))) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; ' +\n          'values of @included must expand to node objects.',\n          'jsonld.SyntaxError', {code: 'invalid @included value', value});\n      }\n\n      _addValue(\n        expandedParent, '@included', includedResult, {propertyIsArray: true});\n      continue;\n    }\n\n    // @graph must be an array or an object\n    if(expandedProperty === '@graph' &&\n      !(_isObject(value) || _isArray(value))) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; \"@graph\" value must not be an ' +\n        'object or an array.',\n        'jsonld.SyntaxError', {code: 'invalid @graph value', value});\n    }\n\n    if(expandedProperty === '@value') {\n      // capture value for later\n      // \"colliding keywords\" check prevents this from being set twice\n      unexpandedValue = value;\n      if(isJsonType && _processingMode(activeCtx, 1.1)) {\n        // no coercion to array, and retain all values\n        expandedParent['@value'] = value;\n      } else {\n        _addValue(\n          expandedParent, '@value', value, {propertyIsArray: options.isFrame});\n      }\n      continue;\n    }\n\n    // @language must be a string\n    // it should match BCP47\n    if(expandedProperty === '@language') {\n      if(value === null) {\n        // drop null @language values, they expand as if they didn't exist\n        continue;\n      }\n      if(!_isString(value) && !options.isFrame) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@language\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid language-tagged string', value});\n      }\n      // ensure language value is lowercase\n      value = _asArray(value).map(v => _isString(v) ? v.toLowerCase() : v);\n\n      // ensure language tag matches BCP47\n      for(const lang of value) {\n        if(_isString(lang) && !lang.match(REGEX_BCP47)) {\n          console.warn(`@language must be valid BCP47: ${lang}`);\n        }\n      }\n\n      _addValue(\n        expandedParent, '@language', value, {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @direction must be \"ltr\" or \"rtl\"\n    if(expandedProperty === '@direction') {\n      if(!_isString(value) && !options.isFrame) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@direction\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid base direction', value});\n      }\n\n      value = _asArray(value);\n\n      // ensure direction is \"ltr\" or \"rtl\"\n      for(const dir of value) {\n        if(_isString(dir) && dir !== 'ltr' && dir !== 'rtl') {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@direction\" must be \"ltr\" or \"rtl\".',\n            'jsonld.SyntaxError',\n            {code: 'invalid base direction', value});\n        }\n      }\n\n      _addValue(\n        expandedParent, '@direction', value,\n        {propertyIsArray: options.isFrame});\n      continue;\n    }\n\n    // @index must be a string\n    if(expandedProperty === '@index') {\n      if(!_isString(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@index\" value must be a string.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @index value', value});\n      }\n      _addValue(expandedParent, '@index', value);\n      continue;\n    }\n\n    // @reverse must be an object\n    if(expandedProperty === '@reverse') {\n      if(!_isObject(value)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; \"@reverse\" value must be an object.',\n          'jsonld.SyntaxError', {code: 'invalid @reverse value', value});\n      }\n\n      expandedValue = await api.expand({\n        activeCtx,\n        activeProperty:\n        '@reverse',\n        element: value,\n        options,\n        expansionMap\n      });\n      // properties double-reversed\n      if('@reverse' in expandedValue) {\n        for(const property in expandedValue['@reverse']) {\n          _addValue(\n            expandedParent, property, expandedValue['@reverse'][property],\n            {propertyIsArray: true});\n        }\n      }\n\n      // FIXME: can this be merged with code below to simplify?\n      // merge in all reversed properties\n      let reverseMap = expandedParent['@reverse'] || null;\n      for(const property in expandedValue) {\n        if(property === '@reverse') {\n          continue;\n        }\n        if(reverseMap === null) {\n          reverseMap = expandedParent['@reverse'] = {};\n        }\n        _addValue(reverseMap, property, [], {propertyIsArray: true});\n        const items = expandedValue[property];\n        for(let ii = 0; ii < items.length; ++ii) {\n          const item = items[ii];\n          if(_isValue(item) || _isList(item)) {\n            throw new JsonLdError(\n              'Invalid JSON-LD syntax; \"@reverse\" value must not be a ' +\n              '@value or an @list.', 'jsonld.SyntaxError',\n              {code: 'invalid reverse property value', value: expandedValue});\n          }\n          _addValue(reverseMap, property, item, {propertyIsArray: true});\n        }\n      }\n\n      continue;\n    }\n\n    // nested keys\n    if(expandedProperty === '@nest') {\n      nests.push(key);\n      continue;\n    }\n\n    // use potential scoped context for key\n    let termCtx = activeCtx;\n    const ctx = _getContextValue(activeCtx, key, '@context');\n    if(!_isUndefined(ctx)) {\n      termCtx = await _processContext({\n        activeCtx,\n        localCtx: ctx,\n        propagate: true,\n        overrideProtected: true,\n        options\n      });\n    }\n\n    const container = _getContextValue(termCtx, key, '@container') || [];\n\n    if(container.includes('@language') && _isObject(value)) {\n      const direction = _getContextValue(termCtx, key, '@direction');\n      // handle language map container (skip if value is not an object)\n      expandedValue = _expandLanguageMap(termCtx, value, direction, options);\n    } else if(container.includes('@index') && _isObject(value)) {\n      // handle index container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      const indexKey = _getContextValue(termCtx, key, '@index') || '@index';\n      const propertyIndex = indexKey !== '@index' &&\n        _expandIri(activeCtx, indexKey, {vocab: true}, options);\n\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph,\n        indexKey,\n        propertyIndex\n      });\n    } else if(container.includes('@id') && _isObject(value)) {\n      // handle id container (skip if value is not an object)\n      const asGraph = container.includes('@graph');\n      expandedValue = await _expandIndexMap({\n        activeCtx: termCtx,\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph,\n        indexKey: '@id'\n      });\n    } else if(container.includes('@type') && _isObject(value)) {\n      // handle type container (skip if value is not an object)\n      expandedValue = await _expandIndexMap({\n        // since container is `@type`, revert type scoped context when expanding\n        activeCtx: termCtx.revertToPreviousContext(),\n        options,\n        activeProperty: key,\n        value,\n        expansionMap,\n        asGraph: false,\n        indexKey: '@type'\n      });\n    } else {\n      // recurse into @list or @set\n      const isList = (expandedProperty === '@list');\n      if(isList || expandedProperty === '@set') {\n        let nextActiveProperty = activeProperty;\n        if(isList && expandedActiveProperty === '@graph') {\n          nextActiveProperty = null;\n        }\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: nextActiveProperty,\n          element: value,\n          options,\n          insideList: isList,\n          expansionMap\n        });\n      } else if(\n        _getContextValue(activeCtx, key, '@type') === '@json') {\n        expandedValue = {\n          '@type': '@json',\n          '@value': value\n        };\n      } else {\n        // recursively expand value with key as new active property\n        expandedValue = await api.expand({\n          activeCtx: termCtx,\n          activeProperty: key,\n          element: value,\n          options,\n          insideList: false,\n          expansionMap\n        });\n      }\n    }\n\n    // drop null values if property is not @value\n    if(expandedValue === null && expandedProperty !== '@value') {\n      // TODO: use `await` to support async\n      expandedValue = expansionMap({\n        unmappedValue: value,\n        expandedProperty,\n        activeCtx: termCtx,\n        activeProperty,\n        parent: element,\n        options,\n        insideList,\n        key,\n        expandedParent\n      });\n      if(expandedValue === undefined) {\n        continue;\n      }\n    }\n\n    // convert expanded value to @list if container specifies it\n    if(expandedProperty !== '@list' && !_isList(expandedValue) &&\n      container.includes('@list')) {\n      // ensure expanded value in @list is an array\n      expandedValue = {'@list': _asArray(expandedValue)};\n    }\n\n    // convert expanded value to @graph if container specifies it\n    // and value is not, itself, a graph\n    // index cases handled above\n    if(container.includes('@graph') &&\n      !container.some(key => key === '@id' || key === '@index')) {\n      // ensure expanded values are arrays\n      expandedValue = _asArray(expandedValue)\n        .map(v => ({'@graph': _asArray(v)}));\n    }\n\n    // FIXME: can this be merged with code above to simplify?\n    // merge in reverse properties\n    if(termCtx.mappings.has(key) && termCtx.mappings.get(key).reverse) {\n      const reverseMap =\n        expandedParent['@reverse'] = expandedParent['@reverse'] || {};\n      expandedValue = _asArray(expandedValue);\n      for(let ii = 0; ii < expandedValue.length; ++ii) {\n        const item = expandedValue[ii];\n        if(_isValue(item) || _isList(item)) {\n          throw new JsonLdError(\n            'Invalid JSON-LD syntax; \"@reverse\" value must not be a ' +\n            '@value or an @list.', 'jsonld.SyntaxError',\n            {code: 'invalid reverse property value', value: expandedValue});\n        }\n        _addValue(reverseMap, expandedProperty, item, {propertyIsArray: true});\n      }\n      continue;\n    }\n\n    // add value for property\n    // special keywords handled above\n    _addValue(expandedParent, expandedProperty, expandedValue, {\n      propertyIsArray: true\n    });\n  }\n\n  // @value must not be an object or an array (unless framing) or if @type is\n  // @json\n  if('@value' in expandedParent) {\n    if(expandedParent['@type'] === '@json' && _processingMode(activeCtx, 1.1)) {\n      // allow any value, to be verified when the object is fully expanded and\n      // the @type is @json.\n    } else if((_isObject(unexpandedValue) || _isArray(unexpandedValue)) &&\n      !options.isFrame) {\n      throw new JsonLdError(\n        'Invalid JSON-LD syntax; \"@value\" value must not be an ' +\n        'object or an array.',\n        'jsonld.SyntaxError',\n        {code: 'invalid value object value', value: unexpandedValue});\n    }\n  }\n\n  // expand each nested key\n  for(const key of nests) {\n    const nestedValues = _isArray(element[key]) ? element[key] : [element[key]];\n    for(const nv of nestedValues) {\n      if(!_isObject(nv) || Object.keys(nv).some(k =>\n        _expandIri(activeCtx, k, {vocab: true}, options) === '@value')) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; nested value must be a node object.',\n          'jsonld.SyntaxError',\n          {code: 'invalid @nest value', value: nv});\n      }\n      await _expandObject({\n        activeCtx,\n        activeProperty,\n        expandedActiveProperty,\n        element: nv,\n        expandedParent,\n        options,\n        insideList,\n        typeScopedContext,\n        typeKey,\n        expansionMap});\n    }\n  }\n}\n\n/**\n * Expands the given value by using the coercion and keyword rules in the\n * given context.\n *\n * @param activeCtx the active context to use.\n * @param activeProperty the active property the value is associated with.\n * @param value the value to expand.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded value.\n */\nfunction _expandValue({activeCtx, activeProperty, value, options}) {\n  // nothing to expand\n  if(value === null || value === undefined) {\n    return null;\n  }\n\n  // special-case expand @id and @type (skips '@id' expansion)\n  const expandedProperty = _expandIri(\n    activeCtx, activeProperty, {vocab: true}, options);\n  if(expandedProperty === '@id') {\n    return _expandIri(activeCtx, value, {base: true}, options);\n  } else if(expandedProperty === '@type') {\n    return _expandIri(activeCtx, value, {vocab: true, base: true}, options);\n  }\n\n  // get type definition from context\n  const type = _getContextValue(activeCtx, activeProperty, '@type');\n\n  // do @id expansion (automatic for @graph)\n  if((type === '@id' || expandedProperty === '@graph') && _isString(value)) {\n    return {'@id': _expandIri(activeCtx, value, {base: true}, options)};\n  }\n  // do @id expansion w/vocab\n  if(type === '@vocab' && _isString(value)) {\n    return {\n      '@id': _expandIri(activeCtx, value, {vocab: true, base: true}, options)\n    };\n  }\n\n  // do not expand keyword values\n  if(_isKeyword(expandedProperty)) {\n    return value;\n  }\n\n  const rval = {};\n\n  if(type && !['@id', '@vocab', '@none'].includes(type)) {\n    // other type\n    rval['@type'] = type;\n  } else if(_isString(value)) {\n    // check for language tagging for strings\n    const language = _getContextValue(activeCtx, activeProperty, '@language');\n    if(language !== null) {\n      rval['@language'] = language;\n    }\n    const direction = _getContextValue(activeCtx, activeProperty, '@direction');\n    if(direction !== null) {\n      rval['@direction'] = direction;\n    }\n  }\n  // do conversion of values that aren't basic JSON types to strings\n  if(!['boolean', 'number', 'string'].includes(typeof value)) {\n    value = value.toString();\n  }\n  rval['@value'] = value;\n\n  return rval;\n}\n\n/**\n * Expands a language map.\n *\n * @param activeCtx the active context to use.\n * @param languageMap the language map to expand.\n * @param direction the direction to apply to values.\n * @param {Object} [options] - processing options.\n *\n * @return the expanded language map.\n */\nfunction _expandLanguageMap(activeCtx, languageMap, direction, options) {\n  const rval = [];\n  const keys = Object.keys(languageMap).sort();\n  for(const key of keys) {\n    const expandedKey = _expandIri(activeCtx, key, {vocab: true}, options);\n    let val = languageMap[key];\n    if(!_isArray(val)) {\n      val = [val];\n    }\n    for(const item of val) {\n      if(item === null) {\n        // null values are allowed (8.5) but ignored (3.1)\n        continue;\n      }\n      if(!_isString(item)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; language map values must be strings.',\n          'jsonld.SyntaxError',\n          {code: 'invalid language map value', languageMap});\n      }\n      const val = {'@value': item};\n      if(expandedKey !== '@none') {\n        val['@language'] = key.toLowerCase();\n      }\n      if(direction) {\n        val['@direction'] = direction;\n      }\n      rval.push(val);\n    }\n  }\n  return rval;\n}\n\nasync function _expandIndexMap(\n  {activeCtx, options, activeProperty, value, expansionMap, asGraph,\n    indexKey, propertyIndex}) {\n  const rval = [];\n  const keys = Object.keys(value).sort();\n  const isTypeIndex = indexKey === '@type';\n  for(let key of keys) {\n    // if indexKey is @type, there may be a context defined for it\n    if(isTypeIndex) {\n      const ctx = _getContextValue(activeCtx, key, '@context');\n      if(!_isUndefined(ctx)) {\n        activeCtx = await _processContext({\n          activeCtx,\n          localCtx: ctx,\n          propagate: false,\n          options\n        });\n      }\n    }\n\n    let val = value[key];\n    if(!_isArray(val)) {\n      val = [val];\n    }\n\n    val = await api.expand({\n      activeCtx,\n      activeProperty,\n      element: val,\n      options,\n      insideList: false,\n      insideIndex: true,\n      expansionMap\n    });\n\n    // expand for @type, but also for @none\n    let expandedKey;\n    if(propertyIndex) {\n      if(key === '@none') {\n        expandedKey = '@none';\n      } else {\n        expandedKey = _expandValue(\n          {activeCtx, activeProperty: indexKey, value: key, options});\n      }\n    } else {\n      expandedKey = _expandIri(activeCtx, key, {vocab: true}, options);\n    }\n\n    if(indexKey === '@id') {\n      // expand document relative\n      key = _expandIri(activeCtx, key, {base: true}, options);\n    } else if(isTypeIndex) {\n      key = expandedKey;\n    }\n\n    for(let item of val) {\n      // If this is also a @graph container, turn items into graphs\n      if(asGraph && !_isGraph(item)) {\n        item = {'@graph': [item]};\n      }\n      if(indexKey === '@type') {\n        if(expandedKey === '@none') {\n          // ignore @none\n        } else if(item['@type']) {\n          item['@type'] = [key].concat(item['@type']);\n        } else {\n          item['@type'] = [key];\n        }\n      } else if(_isValue(item) &&\n        !['@language', '@type', '@index'].includes(indexKey)) {\n        throw new JsonLdError(\n          'Invalid JSON-LD syntax; Attempt to add illegal key to value ' +\n          `object: \"${indexKey}\".`,\n          'jsonld.SyntaxError',\n          {code: 'invalid value object', value: item});\n      } else if(propertyIndex) {\n        // index is a property to be expanded, and values interpreted for that\n        // property\n        if(expandedKey !== '@none') {\n          // expand key as a value\n          _addValue(item, propertyIndex, expandedKey, {\n            propertyIsArray: true,\n            prependValue: true\n          });\n        }\n      } else if(expandedKey !== '@none' && !(indexKey in item)) {\n        item[indexKey] = key;\n      }\n      rval.push(item);\n    }\n  }\n  return rval;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}