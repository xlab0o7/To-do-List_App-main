{"ast":null,"code":"/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n;\n\n'use strict';\nconst {\n  ArrayIsArray,\n  Promise,\n  SymbolAsyncIterator\n} = require('../../ours/primordials');\nconst eos = require('./end-of-stream');\nconst {\n  once\n} = require('../../ours/util');\nconst destroyImpl = require('./destroy');\nconst Duplex = require('./duplex');\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED,\n    ERR_STREAM_PREMATURE_CLOSE\n  },\n  AbortError\n} = require('../../ours/errors');\nconst {\n  validateFunction,\n  validateAbortSignal\n} = require('../validators');\nconst {\n  isIterable,\n  isReadable,\n  isReadableNodeStream,\n  isNodeStream\n} = require('./utils');\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController;\nlet PassThrough;\nlet Readable;\nfunction destroyer(stream, reading, writing) {\n  let finished = false;\n  stream.on('close', () => {\n    finished = true;\n  });\n  const cleanup = eos(stream, {\n    readable: reading,\n    writable: writing\n  }, err => {\n    finished = !err;\n  });\n  return {\n    destroy: err => {\n      if (finished) return;\n      finished = true;\n      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'));\n    },\n    cleanup\n  };\n}\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]');\n  return streams.pop();\n}\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val;\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val);\n  }\n  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val);\n}\nasync function* fromReadable(val) {\n  if (!Readable) {\n    Readable = require('./readable');\n  }\n  yield* Readable.prototype[SymbolAsyncIterator].call(val);\n}\nasync function pump(iterable, writable, finish, _ref) {\n  let {\n    end\n  } = _ref;\n  let error;\n  let onresolve = null;\n  const resume = err => {\n    if (err) {\n      error = err;\n    }\n    if (onresolve) {\n      const callback = onresolve;\n      onresolve = null;\n      callback();\n    }\n  };\n  const wait = () => new Promise((resolve, reject) => {\n    if (error) {\n      reject(error);\n    } else {\n      onresolve = () => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      };\n    }\n  });\n  writable.on('drain', resume);\n  const cleanup = eos(writable, {\n    readable: false\n  }, resume);\n  try {\n    if (writable.writableNeedDrain) {\n      await wait();\n    }\n    for await (const chunk of iterable) {\n      if (!writable.write(chunk)) {\n        await wait();\n      }\n    }\n    if (end) {\n      writable.end();\n    }\n    await wait();\n    finish();\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error, err) : err);\n  } finally {\n    cleanup();\n    writable.off('drain', resume);\n  }\n}\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  return pipelineImpl(streams, once(popCallback(streams)));\n}\nfunction pipelineImpl(streams, callback, opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0];\n  }\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  const ac = new AbortController();\n  const signal = ac.signal;\n  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal;\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  const lastStreamCleanup = [];\n  validateAbortSignal(outerSignal, 'options.signal');\n  function abort() {\n    finishImpl(new AbortError());\n  }\n  outerSignal === null || outerSignal === undefined ? undefined : outerSignal.addEventListener('abort', abort);\n  let error;\n  let value;\n  const destroys = [];\n  let finishCount = 0;\n  function finish(err) {\n    finishImpl(err, --finishCount === 0);\n  }\n  function finishImpl(err, final) {\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err;\n    }\n    if (!error && !final) {\n      return;\n    }\n    while (destroys.length) {\n      destroys.shift()(error);\n    }\n    outerSignal === null || outerSignal === undefined ? undefined : outerSignal.removeEventListener('abort', abort);\n    ac.abort();\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach(fn => fn());\n      }\n      process.nextTick(callback, error, value);\n    }\n  }\n  let ret;\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i];\n    const reading = i < streams.length - 1;\n    const writing = i > 0;\n    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false;\n    const isLastStream = i === streams.length - 1;\n    if (isNodeStream(stream)) {\n      if (end) {\n        const {\n          destroy,\n          cleanup\n        } = destroyer(stream, reading, writing);\n        destroys.push(destroy);\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      }\n\n      // Catch stream errors that occur after pipe/pump has completed.\n      function onError(err) {\n        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n          finish(err);\n        }\n      }\n      stream.on('error', onError);\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(() => {\n          stream.removeListener('error', onError);\n        });\n      }\n    }\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({\n          signal\n        });\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret);\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream)) {\n        ret = stream;\n      } else {\n        ret = Duplex.from(stream);\n      }\n    } else if (typeof stream === 'function') {\n      ret = makeAsyncIterable(ret);\n      ret = stream(ret, {\n        signal\n      });\n      if (reading) {\n        if (!isIterable(ret, true)) {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret);\n        }\n      } else {\n        var _ret;\n        if (!PassThrough) {\n          PassThrough = require('./passthrough');\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        const pt = new PassThrough({\n          objectMode: true\n        });\n\n        // Handle Promises/A+ spec, `then` could be a getter that throws on\n        // second use.\n        const then = (_ret = ret) === null || _ret === undefined ? undefined : _ret.then;\n        if (typeof then === 'function') {\n          finishCount++;\n          then.call(ret, val => {\n            value = val;\n            if (val != null) {\n              pt.write(val);\n            }\n            if (end) {\n              pt.end();\n            }\n            process.nextTick(finish);\n          }, err => {\n            pt.destroy(err);\n            process.nextTick(finish, err);\n          });\n        } else if (isIterable(ret, true)) {\n          finishCount++;\n          pump(ret, pt, finish, {\n            end\n          });\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret);\n        }\n        ret = pt;\n        const {\n          destroy,\n          cleanup\n        } = destroyer(ret, false, true);\n        destroys.push(destroy);\n        if (isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2;\n        const cleanup = pipe(ret, stream, finish, {\n          end\n        });\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      } else if (isIterable(ret)) {\n        finishCount++;\n        pump(ret, stream, finish, {\n          end\n        });\n      } else {\n        throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], ret);\n      }\n      ret = stream;\n    } else {\n      ret = Duplex.from(stream);\n    }\n  }\n  if (signal !== null && signal !== undefined && signal.aborted || outerSignal !== null && outerSignal !== undefined && outerSignal.aborted) {\n    process.nextTick(abort);\n  }\n  return ret;\n}\nfunction pipe(src, dst, finish, _ref2) {\n  let {\n    end\n  } = _ref2;\n  let ended = false;\n  dst.on('close', () => {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE());\n    }\n  });\n  src.pipe(dst, {\n    end\n  });\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but \"secretly\" don't close the underlying fd.\n    src.once('end', () => {\n      ended = true;\n      dst.end();\n    });\n  } else {\n    finish();\n  }\n  eos(src, {\n    readable: true,\n    writable: false\n  }, err => {\n    const rState = src._readableState;\n    if (err && err.code === 'ERR_STREAM_PREMATURE_CLOSE' && rState && rState.ended && !rState.errored && !rState.errorEmitted) {\n      // Some readable streams will emit 'close' before 'end'. However, since\n      // this is on the readable side 'end' should still be emitted if the\n      // stream has been ended and no error emitted. This should be allowed in\n      // favor of backwards compatibility. Since the stream is piped to a\n      // destination this should not result in any observable difference.\n      // We don't need to check if this is a writable premature close since\n      // eos will only fail with premature close on the reading side for\n      // duplex streams.\n      src.once('end', finish).once('error', finish);\n    } else {\n      finish(err);\n    }\n  });\n  return eos(dst, {\n    readable: false,\n    writable: true\n  }, finish);\n}\nmodule.exports = {\n  pipelineImpl,\n  pipeline\n};","map":{"version":3,"names":["process","require","ArrayIsArray","Promise","SymbolAsyncIterator","eos","once","destroyImpl","Duplex","aggregateTwoErrors","codes","ERR_INVALID_ARG_TYPE","ERR_INVALID_RETURN_VALUE","ERR_MISSING_ARGS","ERR_STREAM_DESTROYED","ERR_STREAM_PREMATURE_CLOSE","AbortError","validateFunction","validateAbortSignal","isIterable","isReadable","isReadableNodeStream","isNodeStream","AbortController","globalThis","PassThrough","Readable","destroyer","stream","reading","writing","finished","on","cleanup","readable","writable","err","destroy","popCallback","streams","length","pop","makeAsyncIterable","val","fromReadable","prototype","call","pump","iterable","finish","end","error","onresolve","resume","callback","wait","resolve","reject","writableNeedDrain","chunk","write","off","pipeline","pipelineImpl","opts","ac","signal","outerSignal","undefined","lastStreamCleanup","abort","finishImpl","addEventListener","value","destroys","finishCount","final","code","shift","removeEventListener","forEach","fn","nextTick","ret","i","isLastStream","push","onError","name","removeListener","from","_ret","pt","objectMode","then","pipe","aborted","src","dst","ended","rState","_readableState","errored","errorEmitted","module","exports"],"sources":["G:/To-do-List_App-main/node_modules/n3/node_modules/readable-stream/lib/internal/streams/pipeline.js"],"sourcesContent":["/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n;('use strict')\nconst { ArrayIsArray, Promise, SymbolAsyncIterator } = require('../../ours/primordials')\nconst eos = require('./end-of-stream')\nconst { once } = require('../../ours/util')\nconst destroyImpl = require('./destroy')\nconst Duplex = require('./duplex')\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED,\n    ERR_STREAM_PREMATURE_CLOSE\n  },\n  AbortError\n} = require('../../ours/errors')\nconst { validateFunction, validateAbortSignal } = require('../validators')\nconst { isIterable, isReadable, isReadableNodeStream, isNodeStream } = require('./utils')\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nlet PassThrough\nlet Readable\nfunction destroyer(stream, reading, writing) {\n  let finished = false\n  stream.on('close', () => {\n    finished = true\n  })\n  const cleanup = eos(\n    stream,\n    {\n      readable: reading,\n      writable: writing\n    },\n    (err) => {\n      finished = !err\n    }\n  )\n  return {\n    destroy: (err) => {\n      if (finished) return\n      finished = true\n      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'))\n    },\n    cleanup\n  }\n}\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]')\n  return streams.pop()\n}\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val)\n  }\n  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val)\n}\nasync function* fromReadable(val) {\n  if (!Readable) {\n    Readable = require('./readable')\n  }\n  yield* Readable.prototype[SymbolAsyncIterator].call(val)\n}\nasync function pump(iterable, writable, finish, { end }) {\n  let error\n  let onresolve = null\n  const resume = (err) => {\n    if (err) {\n      error = err\n    }\n    if (onresolve) {\n      const callback = onresolve\n      onresolve = null\n      callback()\n    }\n  }\n  const wait = () =>\n    new Promise((resolve, reject) => {\n      if (error) {\n        reject(error)\n      } else {\n        onresolve = () => {\n          if (error) {\n            reject(error)\n          } else {\n            resolve()\n          }\n        }\n      }\n    })\n  writable.on('drain', resume)\n  const cleanup = eos(\n    writable,\n    {\n      readable: false\n    },\n    resume\n  )\n  try {\n    if (writable.writableNeedDrain) {\n      await wait()\n    }\n    for await (const chunk of iterable) {\n      if (!writable.write(chunk)) {\n        await wait()\n      }\n    }\n    if (end) {\n      writable.end()\n    }\n    await wait()\n    finish()\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error, err) : err)\n  } finally {\n    cleanup()\n    writable.off('drain', resume)\n  }\n}\nfunction pipeline(...streams) {\n  return pipelineImpl(streams, once(popCallback(streams)))\n}\nfunction pipelineImpl(streams, callback, opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0]\n  }\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams')\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  const lastStreamCleanup = []\n  validateAbortSignal(outerSignal, 'options.signal')\n  function abort() {\n    finishImpl(new AbortError())\n  }\n  outerSignal === null || outerSignal === undefined ? undefined : outerSignal.addEventListener('abort', abort)\n  let error\n  let value\n  const destroys = []\n  let finishCount = 0\n  function finish(err) {\n    finishImpl(err, --finishCount === 0)\n  }\n  function finishImpl(err, final) {\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err\n    }\n    if (!error && !final) {\n      return\n    }\n    while (destroys.length) {\n      destroys.shift()(error)\n    }\n    outerSignal === null || outerSignal === undefined ? undefined : outerSignal.removeEventListener('abort', abort)\n    ac.abort()\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach((fn) => fn())\n      }\n      process.nextTick(callback, error, value)\n    }\n  }\n  let ret\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i]\n    const reading = i < streams.length - 1\n    const writing = i > 0\n    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false\n    const isLastStream = i === streams.length - 1\n    if (isNodeStream(stream)) {\n      if (end) {\n        const { destroy, cleanup } = destroyer(stream, reading, writing)\n        destroys.push(destroy)\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n\n      // Catch stream errors that occur after pipe/pump has completed.\n      function onError(err) {\n        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n          finish(err)\n        }\n      }\n      stream.on('error', onError)\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(() => {\n          stream.removeListener('error', onError)\n        })\n      }\n    }\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({\n          signal\n        })\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret)\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream)) {\n        ret = stream\n      } else {\n        ret = Duplex.from(stream)\n      }\n    } else if (typeof stream === 'function') {\n      ret = makeAsyncIterable(ret)\n      ret = stream(ret, {\n        signal\n      })\n      if (reading) {\n        if (!isIterable(ret, true)) {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret)\n        }\n      } else {\n        var _ret\n        if (!PassThrough) {\n          PassThrough = require('./passthrough')\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        const pt = new PassThrough({\n          objectMode: true\n        })\n\n        // Handle Promises/A+ spec, `then` could be a getter that throws on\n        // second use.\n        const then = (_ret = ret) === null || _ret === undefined ? undefined : _ret.then\n        if (typeof then === 'function') {\n          finishCount++\n          then.call(\n            ret,\n            (val) => {\n              value = val\n              if (val != null) {\n                pt.write(val)\n              }\n              if (end) {\n                pt.end()\n              }\n              process.nextTick(finish)\n            },\n            (err) => {\n              pt.destroy(err)\n              process.nextTick(finish, err)\n            }\n          )\n        } else if (isIterable(ret, true)) {\n          finishCount++\n          pump(ret, pt, finish, {\n            end\n          })\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret)\n        }\n        ret = pt\n        const { destroy, cleanup } = destroyer(ret, false, true)\n        destroys.push(destroy)\n        if (isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2\n        const cleanup = pipe(ret, stream, finish, {\n          end\n        })\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      } else if (isIterable(ret)) {\n        finishCount++\n        pump(ret, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], ret)\n      }\n      ret = stream\n    } else {\n      ret = Duplex.from(stream)\n    }\n  }\n  if (\n    (signal !== null && signal !== undefined && signal.aborted) ||\n    (outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)\n  ) {\n    process.nextTick(abort)\n  }\n  return ret\n}\nfunction pipe(src, dst, finish, { end }) {\n  let ended = false\n  dst.on('close', () => {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE())\n    }\n  })\n  src.pipe(dst, {\n    end\n  })\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but \"secretly\" don't close the underlying fd.\n    src.once('end', () => {\n      ended = true\n      dst.end()\n    })\n  } else {\n    finish()\n  }\n  eos(\n    src,\n    {\n      readable: true,\n      writable: false\n    },\n    (err) => {\n      const rState = src._readableState\n      if (\n        err &&\n        err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&\n        rState &&\n        rState.ended &&\n        !rState.errored &&\n        !rState.errorEmitted\n      ) {\n        // Some readable streams will emit 'close' before 'end'. However, since\n        // this is on the readable side 'end' should still be emitted if the\n        // stream has been ended and no error emitted. This should be allowed in\n        // favor of backwards compatibility. Since the stream is piped to a\n        // destination this should not result in any observable difference.\n        // We don't need to check if this is a writable premature close since\n        // eos will only fail with premature close on the reading side for\n        // duplex streams.\n        src.once('end', finish).once('error', finish)\n      } else {\n        finish(err)\n      }\n    }\n  )\n  return eos(\n    dst,\n    {\n      readable: false,\n      writable: true\n    },\n    finish\n  )\n}\nmodule.exports = {\n  pipelineImpl,\n  pipeline\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}