{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {\n  createNodeMap\n} = require('./nodeMap');\nconst {\n  isKeyword\n} = require('./context');\nconst graphTypes = require('./graphTypes');\nconst jsonCanonicalize = require('canonicalize');\nconst types = require('./types');\nconst util = require('./util');\nconst {\n  // RDF,\n  // RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  RDF_LANGSTRING,\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING\n} = require('./constants');\nconst {\n  isAbsolute: _isAbsoluteIri\n} = require('./url');\nconst api = {};\nmodule.exports = api;\n\n/**\n * Outputs an RDF dataset for the expanded JSON-LD input.\n *\n * @param input the expanded JSON-LD input.\n * @param options the RDF serialization options.\n *\n * @return the RDF dataset.\n */\napi.toRDF = (input, options) => {\n  // create node map for default graph (and any named graphs)\n  const issuer = new util.IdentifierIssuer('_:b');\n  const nodeMap = {\n    '@default': {}\n  };\n  createNodeMap(input, nodeMap, '@default', issuer);\n  const dataset = [];\n  const graphNames = Object.keys(nodeMap).sort();\n  for (const graphName of graphNames) {\n    let graphTerm;\n    if (graphName === '@default') {\n      graphTerm = {\n        termType: 'DefaultGraph',\n        value: ''\n      };\n    } else if (_isAbsoluteIri(graphName)) {\n      if (graphName.startsWith('_:')) {\n        graphTerm = {\n          termType: 'BlankNode'\n        };\n      } else {\n        graphTerm = {\n          termType: 'NamedNode'\n        };\n      }\n      graphTerm.value = graphName;\n    } else {\n      // skip relative IRIs (not valid RDF)\n      continue;\n    }\n    _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);\n  }\n  return dataset;\n};\n\n/**\n * Adds RDF quads for a particular graph to the given dataset.\n *\n * @param dataset the dataset to append RDF quads to.\n * @param graph the graph to create RDF quads for.\n * @param graphTerm the graph term for each quad.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param options the RDF serialization options.\n *\n * @return the array of RDF triples for the given graph.\n */\nfunction _graphToRDF(dataset, graph, graphTerm, issuer, options) {\n  const ids = Object.keys(graph).sort();\n  for (const id of ids) {\n    const node = graph[id];\n    const properties = Object.keys(node).sort();\n    for (let property of properties) {\n      const items = node[property];\n      if (property === '@type') {\n        property = RDF_TYPE;\n      } else if (isKeyword(property)) {\n        continue;\n      }\n      for (const item of items) {\n        // RDF subject\n        const subject = {\n          termType: id.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: id\n        };\n\n        // skip relative IRI subjects (not valid RDF)\n        if (!_isAbsoluteIri(id)) {\n          continue;\n        }\n\n        // RDF predicate\n        const predicate = {\n          termType: property.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: property\n        };\n\n        // skip relative IRI predicates (not valid RDF)\n        if (!_isAbsoluteIri(property)) {\n          continue;\n        }\n\n        // skip blank node predicates unless producing generalized RDF\n        if (predicate.termType === 'BlankNode' && !options.produceGeneralizedRdf) {\n          continue;\n        }\n\n        // convert list, value or node object to triple\n        const object = _objectToRDF(item, issuer, dataset, graphTerm, options.rdfDirection);\n        // skip null objects (they are relative IRIs)\n        if (object) {\n          dataset.push({\n            subject,\n            predicate,\n            object,\n            graph: graphTerm\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * Converts a @list value into linked list of blank node RDF quads\n * (an RDF collection).\n *\n * @param list the @list value.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the array of quads to append to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the head of the list.\n */\nfunction _listToRDF(list, issuer, dataset, graphTerm, rdfDirection) {\n  const first = {\n    termType: 'NamedNode',\n    value: RDF_FIRST\n  };\n  const rest = {\n    termType: 'NamedNode',\n    value: RDF_REST\n  };\n  const nil = {\n    termType: 'NamedNode',\n    value: RDF_NIL\n  };\n  const last = list.pop();\n  // Result is the head of the list\n  const result = last ? {\n    termType: 'BlankNode',\n    value: issuer.getId()\n  } : nil;\n  let subject = result;\n  for (const item of list) {\n    const object = _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection);\n    const next = {\n      termType: 'BlankNode',\n      value: issuer.getId()\n    };\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: next,\n      graph: graphTerm\n    });\n    subject = next;\n  }\n\n  // Tail of list\n  if (last) {\n    const object = _objectToRDF(last, issuer, dataset, graphTerm, rdfDirection);\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: nil,\n      graph: graphTerm\n    });\n  }\n  return result;\n}\n\n/**\n * Converts a JSON-LD value object to an RDF literal or a JSON-LD string,\n * node object to an RDF resource, or adds a list.\n *\n * @param item the JSON-LD value or node object.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the dataset to append RDF quads to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the RDF literal or RDF resource.\n */\nfunction _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection) {\n  const object = {};\n\n  // convert value object to RDF\n  if (graphTypes.isValue(item)) {\n    object.termType = 'Literal';\n    object.value = undefined;\n    object.datatype = {\n      termType: 'NamedNode'\n    };\n    let value = item['@value'];\n    const datatype = item['@type'] || null;\n\n    // convert to XSD/JSON datatypes as appropriate\n    if (datatype === '@json') {\n      object.value = jsonCanonicalize(value);\n      object.datatype.value = RDF_JSON_LITERAL;\n    } else if (types.isBoolean(value)) {\n      object.value = value.toString();\n      object.datatype.value = datatype || XSD_BOOLEAN;\n    } else if (types.isDouble(value) || datatype === XSD_DOUBLE) {\n      if (!types.isDouble(value)) {\n        value = parseFloat(value);\n      }\n      // canonical double representation\n      object.value = value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n      object.datatype.value = datatype || XSD_DOUBLE;\n    } else if (types.isNumber(value)) {\n      object.value = value.toFixed(0);\n      object.datatype.value = datatype || XSD_INTEGER;\n    } else if (rdfDirection === 'i18n-datatype' && '@direction' in item) {\n      const datatype = 'https://www.w3.org/ns/i18n#' + (item['@language'] || '') + `_${item['@direction']}`;\n      object.datatype.value = datatype;\n      object.value = value;\n    } else if ('@language' in item) {\n      object.value = value;\n      object.datatype.value = datatype || RDF_LANGSTRING;\n      object.language = item['@language'];\n    } else {\n      object.value = value;\n      object.datatype.value = datatype || XSD_STRING;\n    }\n  } else if (graphTypes.isList(item)) {\n    const _list = _listToRDF(item['@list'], issuer, dataset, graphTerm, rdfDirection);\n    object.termType = _list.termType;\n    object.value = _list.value;\n  } else {\n    // convert string/node object to RDF\n    const id = types.isObject(item) ? item['@id'] : item;\n    object.termType = id.startsWith('_:') ? 'BlankNode' : 'NamedNode';\n    object.value = id;\n  }\n\n  // skip relative IRIs, not valid RDF\n  if (object.termType === 'NamedNode' && !_isAbsoluteIri(object.value)) {\n    return null;\n  }\n  return object;\n}","map":{"version":3,"names":["createNodeMap","require","isKeyword","graphTypes","jsonCanonicalize","types","util","RDF_FIRST","RDF_REST","RDF_NIL","RDF_TYPE","RDF_JSON_LITERAL","RDF_LANGSTRING","XSD_BOOLEAN","XSD_DOUBLE","XSD_INTEGER","XSD_STRING","isAbsolute","_isAbsoluteIri","api","module","exports","toRDF","input","options","issuer","IdentifierIssuer","nodeMap","dataset","graphNames","Object","keys","sort","graphName","graphTerm","termType","value","startsWith","_graphToRDF","graph","ids","id","node","properties","property","items","item","subject","predicate","produceGeneralizedRdf","object","_objectToRDF","rdfDirection","push","_listToRDF","list","first","rest","nil","last","pop","result","getId","next","isValue","undefined","datatype","isBoolean","toString","isDouble","parseFloat","toExponential","replace","isNumber","toFixed","language","isList","_list","isObject"],"sources":["E:/react-todo-app/node_modules/jsonld/lib/toRdf.js"],"sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {createNodeMap} = require('./nodeMap');\nconst {isKeyword} = require('./context');\nconst graphTypes = require('./graphTypes');\nconst jsonCanonicalize = require('canonicalize');\nconst types = require('./types');\nconst util = require('./util');\n\nconst {\n  // RDF,\n  // RDF_LIST,\n  RDF_FIRST,\n  RDF_REST,\n  RDF_NIL,\n  RDF_TYPE,\n  // RDF_PLAIN_LITERAL,\n  // RDF_XML_LITERAL,\n  RDF_JSON_LITERAL,\n  // RDF_OBJECT,\n  RDF_LANGSTRING,\n\n  // XSD,\n  XSD_BOOLEAN,\n  XSD_DOUBLE,\n  XSD_INTEGER,\n  XSD_STRING,\n} = require('./constants');\n\nconst {\n  isAbsolute: _isAbsoluteIri\n} = require('./url');\n\nconst api = {};\nmodule.exports = api;\n\n/**\n * Outputs an RDF dataset for the expanded JSON-LD input.\n *\n * @param input the expanded JSON-LD input.\n * @param options the RDF serialization options.\n *\n * @return the RDF dataset.\n */\napi.toRDF = (input, options) => {\n  // create node map for default graph (and any named graphs)\n  const issuer = new util.IdentifierIssuer('_:b');\n  const nodeMap = {'@default': {}};\n  createNodeMap(input, nodeMap, '@default', issuer);\n\n  const dataset = [];\n  const graphNames = Object.keys(nodeMap).sort();\n  for(const graphName of graphNames) {\n    let graphTerm;\n    if(graphName === '@default') {\n      graphTerm = {termType: 'DefaultGraph', value: ''};\n    } else if(_isAbsoluteIri(graphName)) {\n      if(graphName.startsWith('_:')) {\n        graphTerm = {termType: 'BlankNode'};\n      } else {\n        graphTerm = {termType: 'NamedNode'};\n      }\n      graphTerm.value = graphName;\n    } else {\n      // skip relative IRIs (not valid RDF)\n      continue;\n    }\n    _graphToRDF(dataset, nodeMap[graphName], graphTerm, issuer, options);\n  }\n\n  return dataset;\n};\n\n/**\n * Adds RDF quads for a particular graph to the given dataset.\n *\n * @param dataset the dataset to append RDF quads to.\n * @param graph the graph to create RDF quads for.\n * @param graphTerm the graph term for each quad.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param options the RDF serialization options.\n *\n * @return the array of RDF triples for the given graph.\n */\nfunction _graphToRDF(dataset, graph, graphTerm, issuer, options) {\n  const ids = Object.keys(graph).sort();\n  for(const id of ids) {\n    const node = graph[id];\n    const properties = Object.keys(node).sort();\n    for(let property of properties) {\n      const items = node[property];\n      if(property === '@type') {\n        property = RDF_TYPE;\n      } else if(isKeyword(property)) {\n        continue;\n      }\n\n      for(const item of items) {\n        // RDF subject\n        const subject = {\n          termType: id.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: id\n        };\n\n        // skip relative IRI subjects (not valid RDF)\n        if(!_isAbsoluteIri(id)) {\n          continue;\n        }\n\n        // RDF predicate\n        const predicate = {\n          termType: property.startsWith('_:') ? 'BlankNode' : 'NamedNode',\n          value: property\n        };\n\n        // skip relative IRI predicates (not valid RDF)\n        if(!_isAbsoluteIri(property)) {\n          continue;\n        }\n\n        // skip blank node predicates unless producing generalized RDF\n        if(predicate.termType === 'BlankNode' &&\n          !options.produceGeneralizedRdf) {\n          continue;\n        }\n\n        // convert list, value or node object to triple\n        const object =\n          _objectToRDF(item, issuer, dataset, graphTerm, options.rdfDirection);\n        // skip null objects (they are relative IRIs)\n        if(object) {\n          dataset.push({\n            subject,\n            predicate,\n            object,\n            graph: graphTerm\n          });\n        }\n      }\n    }\n  }\n}\n\n/**\n * Converts a @list value into linked list of blank node RDF quads\n * (an RDF collection).\n *\n * @param list the @list value.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the array of quads to append to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the head of the list.\n */\nfunction _listToRDF(list, issuer, dataset, graphTerm, rdfDirection) {\n  const first = {termType: 'NamedNode', value: RDF_FIRST};\n  const rest = {termType: 'NamedNode', value: RDF_REST};\n  const nil = {termType: 'NamedNode', value: RDF_NIL};\n\n  const last = list.pop();\n  // Result is the head of the list\n  const result = last ? {termType: 'BlankNode', value: issuer.getId()} : nil;\n  let subject = result;\n\n  for(const item of list) {\n    const object = _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection);\n    const next = {termType: 'BlankNode', value: issuer.getId()};\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: next,\n      graph: graphTerm\n    });\n    subject = next;\n  }\n\n  // Tail of list\n  if(last) {\n    const object = _objectToRDF(last, issuer, dataset, graphTerm, rdfDirection);\n    dataset.push({\n      subject,\n      predicate: first,\n      object,\n      graph: graphTerm\n    });\n    dataset.push({\n      subject,\n      predicate: rest,\n      object: nil,\n      graph: graphTerm\n    });\n  }\n\n  return result;\n}\n\n/**\n * Converts a JSON-LD value object to an RDF literal or a JSON-LD string,\n * node object to an RDF resource, or adds a list.\n *\n * @param item the JSON-LD value or node object.\n * @param issuer a IdentifierIssuer for assigning blank node names.\n * @param dataset the dataset to append RDF quads to.\n * @param graphTerm the graph term for each quad.\n *\n * @return the RDF literal or RDF resource.\n */\nfunction _objectToRDF(item, issuer, dataset, graphTerm, rdfDirection) {\n  const object = {};\n\n  // convert value object to RDF\n  if(graphTypes.isValue(item)) {\n    object.termType = 'Literal';\n    object.value = undefined;\n    object.datatype = {\n      termType: 'NamedNode'\n    };\n    let value = item['@value'];\n    const datatype = item['@type'] || null;\n\n    // convert to XSD/JSON datatypes as appropriate\n    if(datatype === '@json') {\n      object.value = jsonCanonicalize(value);\n      object.datatype.value = RDF_JSON_LITERAL;\n    } else if(types.isBoolean(value)) {\n      object.value = value.toString();\n      object.datatype.value = datatype || XSD_BOOLEAN;\n    } else if(types.isDouble(value) || datatype === XSD_DOUBLE) {\n      if(!types.isDouble(value)) {\n        value = parseFloat(value);\n      }\n      // canonical double representation\n      object.value = value.toExponential(15).replace(/(\\d)0*e\\+?/, '$1E');\n      object.datatype.value = datatype || XSD_DOUBLE;\n    } else if(types.isNumber(value)) {\n      object.value = value.toFixed(0);\n      object.datatype.value = datatype || XSD_INTEGER;\n    } else if(rdfDirection === 'i18n-datatype' &&\n      '@direction' in item) {\n      const datatype = 'https://www.w3.org/ns/i18n#' +\n        (item['@language'] || '') +\n        `_${item['@direction']}`;\n      object.datatype.value = datatype;\n      object.value = value;\n    } else if('@language' in item) {\n      object.value = value;\n      object.datatype.value = datatype || RDF_LANGSTRING;\n      object.language = item['@language'];\n    } else {\n      object.value = value;\n      object.datatype.value = datatype || XSD_STRING;\n    }\n  } else if(graphTypes.isList(item)) {\n    const _list =\n      _listToRDF(item['@list'], issuer, dataset, graphTerm, rdfDirection);\n    object.termType = _list.termType;\n    object.value = _list.value;\n  } else {\n    // convert string/node object to RDF\n    const id = types.isObject(item) ? item['@id'] : item;\n    object.termType = id.startsWith('_:') ? 'BlankNode' : 'NamedNode';\n    object.value = id;\n  }\n\n  // skip relative IRIs, not valid RDF\n  if(object.termType === 'NamedNode' && !_isAbsoluteIri(object.value)) {\n    return null;\n  }\n\n  return object;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}