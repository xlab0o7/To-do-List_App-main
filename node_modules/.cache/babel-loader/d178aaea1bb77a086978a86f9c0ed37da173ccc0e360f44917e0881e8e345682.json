{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _slicedToArray = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/slicedToArray.js\").default;\nvar _asyncToGenerator = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\nvar ClientRegistrar = /*#__PURE__*/function () {\n  function ClientRegistrar(storageUtility) {\n    _classCallCheck(this, ClientRegistrar);\n    this.storageUtility = storageUtility;\n  }\n  _createClass(ClientRegistrar, [{\n    key: \"getClient\",\n    value: function () {\n      var _getClient = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options, issuerConfig) {\n        var _yield$Promise$all, _yield$Promise$all2, storedClientId, storedClientSecret, registeredClient, infoToSave;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return Promise.all([this.storageUtility.getForUser(options.sessionId, \"clientId\", {\n                secure: false\n              }), this.storageUtility.getForUser(options.sessionId, \"clientSecret\", {\n                secure: false\n              })]);\n            case 2:\n              _yield$Promise$all = _context.sent;\n              _yield$Promise$all2 = _slicedToArray(_yield$Promise$all, 2);\n              storedClientId = _yield$Promise$all2[0];\n              storedClientSecret = _yield$Promise$all2[1];\n              if (!storedClientId) {\n                _context.next = 8;\n                break;\n              }\n              return _context.abrupt(\"return\", {\n                clientId: storedClientId,\n                clientSecret: storedClientSecret,\n                clientType: \"dynamic\"\n              });\n            case 8:\n              _context.prev = 8;\n              _context.next = 11;\n              return (0, oidc_client_ext_1.registerClient)(options, issuerConfig);\n            case 11:\n              registeredClient = _context.sent;\n              infoToSave = {\n                clientId: registeredClient.clientId\n              };\n              if (registeredClient.clientSecret) {\n                infoToSave.clientSecret = registeredClient.clientSecret;\n              }\n              if (registeredClient.idTokenSignedResponseAlg) {\n                infoToSave.idTokenSignedResponseAlg = registeredClient.idTokenSignedResponseAlg;\n              }\n              _context.next = 17;\n              return this.storageUtility.setForUser(options.sessionId, infoToSave, {\n                secure: false\n              });\n            case 17:\n              return _context.abrupt(\"return\", registeredClient);\n            case 20:\n              _context.prev = 20;\n              _context.t0 = _context[\"catch\"](8);\n              throw new Error(\"Client registration failed: [\".concat(_context.t0, \"]\"));\n            case 23:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[8, 20]]);\n      }));\n      function getClient(_x, _x2) {\n        return _getClient.apply(this, arguments);\n      }\n      return getClient;\n    }()\n  }]);\n  return ClientRegistrar;\n}();\nexports.default = ClientRegistrar;","map":{"version":3,"mappings":";;;;;;;;;;AAiCA;AAAyD,IAKpCA,eAAe;EAClC,yBAAoBC,cAA+B;IAAA;IAA/B,mBAAc,GAAdA,cAAc;EAAoB;EAAC;IAAA;IAAA;MAAA,4EAEvD,iBACEC,OAAgC,EAChCC,YAA2B;QAAA;QAAA;UAAA;YAAA;cAAA;cAAA,OAOjBC,OAAO,CAACC,GAAG,CAAC,CACpB,IAAI,CAACJ,cAAc,CAACK,UAAU,CAACJ,OAAO,CAACK,SAAS,EAAE,UAAU,EAAE;gBAC5DC,MAAM,EAAE;eACT,CAAC,EACF,IAAI,CAACP,cAAc,CAACK,UAAU,CAACJ,OAAO,CAACK,SAAS,EAAE,cAAc,EAAE;gBAChEC,MAAM,EAAE;eACT,CAAC,CAKH,CAAC;YAAA;cAAA;cAAA;cAdAC,cAAc;cACdC,kBAAkB;cAAA,KAchBD,cAAc;gBAAA;gBAAA;cAAA;cAAA,iCACT;gBACLE,QAAQ,EAAEF,cAAc;gBACxBG,YAAY,EAAEF,kBAAkB;gBAChCG,UAAU,EAAE;eACb;YAAA;cAAA;cAAA;cAAA,OAI8B,oCAAc,EAACX,OAAO,EAAEC,YAAY,CAAC;YAAA;cAA9DW,gBAAgB;cAEhBC,UAAU,GAA2B;gBACzCJ,QAAQ,EAAEG,gBAAgB,CAACH;eAC5B;cACD,IAAIG,gBAAgB,CAACF,YAAY,EAAE;gBACjCG,UAAU,CAACH,YAAY,GAAGE,gBAAgB,CAACF,YAAY;;cAEzD,IAAIE,gBAAgB,CAACE,wBAAwB,EAAE;gBAC7CD,UAAU,CAACC,wBAAwB,GACjCF,gBAAgB,CAACE,wBAAwB;;cAC5C;cAAA,OACK,IAAI,CAACf,cAAc,CAACgB,UAAU,CAACf,OAAO,CAACK,SAAS,EAAEQ,UAAU,EAAE;gBAIlEP,MAAM,EAAE;eACT,CAAC;YAAA;cAAA,iCACKM,gBAAgB;YAAA;cAAA;cAAA;cAAA,MAEjB,IAAII,KAAK,0DAA0C;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CAE5D;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA;AAvDHC","names":["ClientRegistrar","storageUtility","options","issuerConfig","Promise","all","getForUser","sessionId","secure","storedClientId","storedClientSecret","clientId","clientSecret","clientType","registeredClient","infoToSave","idTokenSignedResponseAlg","setForUser","Error","exports"],"sources":["E:\\react-todo-app\\node_modules\\@inrupt\\solid-client-authn-browser\\src\\login\\oidc\\ClientRegistrar.ts"],"sourcesContent":["//\n// Copyright 2022 Inrupt Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n// Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n/**\n * @hidden\n * @packageDocumentation\n */\n\nimport {\n  IStorageUtility,\n  IClientRegistrar,\n  IIssuerConfig,\n  IClient,\n  IClientRegistrarOptions,\n} from \"@inrupt/solid-client-authn-core\";\nimport { registerClient } from \"@inrupt/oidc-client-ext\";\n\n/**\n * @hidden\n */\nexport default class ClientRegistrar implements IClientRegistrar {\n  constructor(private storageUtility: IStorageUtility) {}\n\n  async getClient(\n    options: IClientRegistrarOptions,\n    issuerConfig: IIssuerConfig\n  ): Promise<IClient> {\n    // If client secret and/or client id are stored in storage, use those.\n    const [\n      storedClientId,\n      storedClientSecret,\n      // storedClientName,\n    ] = await Promise.all([\n      this.storageUtility.getForUser(options.sessionId, \"clientId\", {\n        secure: false,\n      }),\n      this.storageUtility.getForUser(options.sessionId, \"clientSecret\", {\n        secure: false,\n      }),\n      // this.storageUtility.getForUser(options.sessionId, \"clientName\", {\n      //   // FIXME: figure out how to persist secure storage at reload\n      //   secure: false,\n      // }),\n    ]);\n    if (storedClientId) {\n      return {\n        clientId: storedClientId,\n        clientSecret: storedClientSecret,\n        clientType: \"dynamic\",\n      };\n    }\n\n    try {\n      const registeredClient = await registerClient(options, issuerConfig);\n      // Save info\n      const infoToSave: Record<string, string> = {\n        clientId: registeredClient.clientId,\n      };\n      if (registeredClient.clientSecret) {\n        infoToSave.clientSecret = registeredClient.clientSecret;\n      }\n      if (registeredClient.idTokenSignedResponseAlg) {\n        infoToSave.idTokenSignedResponseAlg =\n          registeredClient.idTokenSignedResponseAlg;\n      }\n      await this.storageUtility.setForUser(options.sessionId, infoToSave, {\n        // FIXME: figure out how to persist secure storage at reload\n        // Otherwise, the client info cannot be retrieved from storage, and\n        // the lib tries to re-register the client on each fetch\n        secure: false,\n      });\n      return registeredClient;\n    } catch (error) {\n      throw new Error(`Client registration failed: [${error}]`);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}