{"ast":null,"code":"/*!\n * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\n// eslint-disable-next-line no-unused-vars\nvar _createForOfIteratorHelper = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _classCallCheck = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar TERMS = ['subject', 'predicate', 'object', 'graph'];\nvar RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nvar RDF_LANGSTRING = RDF + 'langString';\nvar XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string';\nvar TYPE_NAMED_NODE = 'NamedNode';\nvar TYPE_BLANK_NODE = 'BlankNode';\nvar TYPE_LITERAL = 'Literal';\nvar TYPE_DEFAULT_GRAPH = 'DefaultGraph';\n\n// build regexes\nvar REGEX = {};\n(function () {\n  var iri = '(?:<([^:]+:[^>]*)>)';\n  // https://www.w3.org/TR/turtle/#grammar-production-BLANK_NODE_LABEL\n  var PN_CHARS_BASE = 'A-Z' + 'a-z' + \"\\xC0-\\xD6\" + \"\\xD8-\\xF6\" + \"\\xF8-\\u02FF\" + \"\\u0370-\\u037D\" + \"\\u037F-\\u1FFF\" + \"\\u200C-\\u200D\" + \"\\u2070-\\u218F\" + \"\\u2C00-\\u2FEF\" + \"\\u3001-\\uD7FF\" + \"\\uF900-\\uFDCF\" + \"\\uFDF0-\\uFFFD\";\n  // TODO:\n  //'\\u10000-\\uEFFFF';\n  var PN_CHARS_U = PN_CHARS_BASE + '_';\n  var PN_CHARS = PN_CHARS_U + '0-9' + '-' + \"\\xB7\" + \"\\u0300-\\u036F\" + \"\\u203F-\\u2040\";\n  var BLANK_NODE_LABEL = '(_:' + '(?:[' + PN_CHARS_U + '0-9])' + '(?:(?:[' + PN_CHARS + '.])*(?:[' + PN_CHARS + ']))?' + ')';\n  var bnode = BLANK_NODE_LABEL;\n  var plain = '\"([^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*)\"';\n  var datatype = '(?:\\\\^\\\\^' + iri + ')';\n  var language = '(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))';\n  var literal = '(?:' + plain + '(?:' + datatype + '|' + language + ')?)';\n  var ws = '[ \\\\t]+';\n  var wso = '[ \\\\t]*';\n\n  // define quad part regexes\n  var subject = '(?:' + iri + '|' + bnode + ')' + ws;\n  var property = iri + ws;\n  var object = '(?:' + iri + '|' + bnode + '|' + literal + ')' + wso;\n  var graphName = '(?:\\\\.|(?:(?:' + iri + '|' + bnode + ')' + wso + '\\\\.))';\n\n  // end of line and empty regexes\n  REGEX.eoln = /(?:\\r\\n)|(?:\\n)|(?:\\r)/g;\n  REGEX.empty = new RegExp('^' + wso + '$');\n\n  // full quad regex\n  REGEX.quad = new RegExp('^' + wso + subject + property + object + graphName + wso + '$');\n})();\nmodule.exports = /*#__PURE__*/function () {\n  function NQuads() {\n    _classCallCheck(this, NQuads);\n  }\n  _createClass(NQuads, null, [{\n    key: \"parse\",\n    value:\n    /**\n     * Parses RDF in the form of N-Quads.\n     *\n     * @param input the N-Quads input to parse.\n     *\n     * @return an RDF dataset (an array of quads per http://rdf.js.org/).\n     */\n    function parse(input) {\n      // build RDF dataset\n      var dataset = [];\n      var graphs = {};\n\n      // split N-Quad input into lines\n      var lines = input.split(REGEX.eoln);\n      var lineNumber = 0;\n      var _iterator = _createForOfIteratorHelper(lines),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var line = _step.value;\n          lineNumber++;\n\n          // skip empty lines\n          if (REGEX.empty.test(line)) {\n            continue;\n          }\n\n          // parse quad\n          var match = line.match(REGEX.quad);\n          if (match === null) {\n            throw new Error('N-Quads parse error on line ' + lineNumber + '.');\n          }\n\n          // create RDF quad\n          var quad = {\n            subject: null,\n            predicate: null,\n            object: null,\n            graph: null\n          };\n\n          // get subject\n          if (match[1] !== undefined) {\n            quad.subject = {\n              termType: TYPE_NAMED_NODE,\n              value: match[1]\n            };\n          } else {\n            quad.subject = {\n              termType: TYPE_BLANK_NODE,\n              value: match[2]\n            };\n          }\n\n          // get predicate\n          quad.predicate = {\n            termType: TYPE_NAMED_NODE,\n            value: match[3]\n          };\n\n          // get object\n          if (match[4] !== undefined) {\n            quad.object = {\n              termType: TYPE_NAMED_NODE,\n              value: match[4]\n            };\n          } else if (match[5] !== undefined) {\n            quad.object = {\n              termType: TYPE_BLANK_NODE,\n              value: match[5]\n            };\n          } else {\n            quad.object = {\n              termType: TYPE_LITERAL,\n              value: undefined,\n              datatype: {\n                termType: TYPE_NAMED_NODE\n              }\n            };\n            if (match[7] !== undefined) {\n              quad.object.datatype.value = match[7];\n            } else if (match[8] !== undefined) {\n              quad.object.datatype.value = RDF_LANGSTRING;\n              quad.object.language = match[8];\n            } else {\n              quad.object.datatype.value = XSD_STRING;\n            }\n            quad.object.value = _unescape(match[6]);\n          }\n\n          // get graph\n          if (match[9] !== undefined) {\n            quad.graph = {\n              termType: TYPE_NAMED_NODE,\n              value: match[9]\n            };\n          } else if (match[10] !== undefined) {\n            quad.graph = {\n              termType: TYPE_BLANK_NODE,\n              value: match[10]\n            };\n          } else {\n            quad.graph = {\n              termType: TYPE_DEFAULT_GRAPH,\n              value: ''\n            };\n          }\n\n          // only add quad if it is unique in its graph\n          if (!(quad.graph.value in graphs)) {\n            graphs[quad.graph.value] = [quad];\n            dataset.push(quad);\n          } else {\n            var unique = true;\n            var quads = graphs[quad.graph.value];\n            var _iterator2 = _createForOfIteratorHelper(quads),\n              _step2;\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var q = _step2.value;\n                if (_compareTriples(q, quad)) {\n                  unique = false;\n                  break;\n                }\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n            if (unique) {\n              quads.push(quad);\n              dataset.push(quad);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return dataset;\n    }\n\n    /**\n     * Converts an RDF dataset to N-Quads.\n     *\n     * @param dataset (array of quads) the RDF dataset to convert.\n     *\n     * @return the N-Quads string.\n     */\n  }, {\n    key: \"serialize\",\n    value: function serialize(dataset) {\n      if (!Array.isArray(dataset)) {\n        dataset = NQuads.legacyDatasetToQuads(dataset);\n      }\n      var quads = [];\n      var _iterator3 = _createForOfIteratorHelper(dataset),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var quad = _step3.value;\n          quads.push(NQuads.serializeQuad(quad));\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      return quads.sort().join('');\n    }\n\n    /**\n     * Converts RDF quad components to an N-Quad string (a single quad).\n     *\n     * @param {Object} s - N-Quad subject component.\n     * @param {Object} p - N-Quad predicate component.\n     * @param {Object} o - N-Quad object component.\n     * @param {Object} g - N-Quad graph component.\n     *\n     * @return {string} the N-Quad.\n     */\n  }, {\n    key: \"serializeQuadComponents\",\n    value: function serializeQuadComponents(s, p, o, g) {\n      var nquad = '';\n\n      // subject can only be NamedNode or BlankNode\n      if (s.termType === TYPE_NAMED_NODE) {\n        nquad += \"<\".concat(s.value, \">\");\n      } else {\n        nquad += \"\".concat(s.value);\n      }\n\n      // predicate can only be NamedNode\n      nquad += \" <\".concat(p.value, \"> \");\n\n      // object is NamedNode, BlankNode, or Literal\n      if (o.termType === TYPE_NAMED_NODE) {\n        nquad += \"<\".concat(o.value, \">\");\n      } else if (o.termType === TYPE_BLANK_NODE) {\n        nquad += o.value;\n      } else {\n        nquad += \"\\\"\".concat(_escape(o.value), \"\\\"\");\n        if (o.datatype.value === RDF_LANGSTRING) {\n          if (o.language) {\n            nquad += \"@\".concat(o.language);\n          }\n        } else if (o.datatype.value !== XSD_STRING) {\n          nquad += \"^^<\".concat(o.datatype.value, \">\");\n        }\n      }\n\n      // graph can only be NamedNode or BlankNode (or DefaultGraph, but that\n      // does not add to `nquad`)\n      if (g.termType === TYPE_NAMED_NODE) {\n        nquad += \" <\".concat(g.value, \">\");\n      } else if (g.termType === TYPE_BLANK_NODE) {\n        nquad += \" \".concat(g.value);\n      }\n      nquad += ' .\\n';\n      return nquad;\n    }\n\n    /**\n     * Converts an RDF quad to an N-Quad string (a single quad).\n     *\n     * @param quad the RDF quad convert.\n     *\n     * @return the N-Quad string.\n     */\n  }, {\n    key: \"serializeQuad\",\n    value: function serializeQuad(quad) {\n      return NQuads.serializeQuadComponents(quad.subject, quad.predicate, quad.object, quad.graph);\n    }\n\n    /**\n     * Converts a legacy-formatted dataset to an array of quads dataset per\n     * http://rdf.js.org/.\n     *\n     * @param dataset the legacy dataset to convert.\n     *\n     * @return the array of quads dataset.\n     */\n  }, {\n    key: \"legacyDatasetToQuads\",\n    value: function legacyDatasetToQuads(dataset) {\n      var quads = [];\n      var termTypeMap = {\n        'blank node': TYPE_BLANK_NODE,\n        IRI: TYPE_NAMED_NODE,\n        literal: TYPE_LITERAL\n      };\n      var _loop = function _loop(graphName) {\n        var triples = dataset[graphName];\n        triples.forEach(function (triple) {\n          var quad = {};\n          for (var componentName in triple) {\n            var oldComponent = triple[componentName];\n            var newComponent = {\n              termType: termTypeMap[oldComponent.type],\n              value: oldComponent.value\n            };\n            if (newComponent.termType === TYPE_LITERAL) {\n              newComponent.datatype = {\n                termType: TYPE_NAMED_NODE\n              };\n              if ('datatype' in oldComponent) {\n                newComponent.datatype.value = oldComponent.datatype;\n              }\n              if ('language' in oldComponent) {\n                if (!('datatype' in oldComponent)) {\n                  newComponent.datatype.value = RDF_LANGSTRING;\n                }\n                newComponent.language = oldComponent.language;\n              } else if (!('datatype' in oldComponent)) {\n                newComponent.datatype.value = XSD_STRING;\n              }\n            }\n            quad[componentName] = newComponent;\n          }\n          if (graphName === '@default') {\n            quad.graph = {\n              termType: TYPE_DEFAULT_GRAPH,\n              value: ''\n            };\n          } else {\n            quad.graph = {\n              termType: graphName.startsWith('_:') ? TYPE_BLANK_NODE : TYPE_NAMED_NODE,\n              value: graphName\n            };\n          }\n          quads.push(quad);\n        });\n      };\n      for (var graphName in dataset) {\n        _loop(graphName);\n      }\n      return quads;\n    }\n  }]);\n  return NQuads;\n}();\n\n/**\n * Compares two RDF triples for equality.\n *\n * @param t1 the first triple.\n * @param t2 the second triple.\n *\n * @return true if the triples are the same, false if not.\n */\nfunction _compareTriples(t1, t2) {\n  // compare subject and object types first as it is the quickest check\n  if (!(t1.subject.termType === t2.subject.termType && t1.object.termType === t2.object.termType)) {\n    return false;\n  }\n  // compare values\n  if (!(t1.subject.value === t2.subject.value && t1.predicate.value === t2.predicate.value && t1.object.value === t2.object.value)) {\n    return false;\n  }\n  if (t1.object.termType !== TYPE_LITERAL) {\n    // no `datatype` or `language` to check\n    return true;\n  }\n  return t1.object.datatype.termType === t2.object.datatype.termType && t1.object.language === t2.object.language && t1.object.datatype.value === t2.object.datatype.value;\n}\nvar _escapeRegex = /[\"\\\\\\n\\r]/g;\n/**\n * Escape string to N-Quads literal\n */\nfunction _escape(s) {\n  return s.replace(_escapeRegex, function (match) {\n    switch (match) {\n      case '\"':\n        return '\\\\\"';\n      case '\\\\':\n        return '\\\\\\\\';\n      case '\\n':\n        return '\\\\n';\n      case '\\r':\n        return '\\\\r';\n    }\n  });\n}\nvar _unescapeRegex = /(?:\\\\([tbnrf\"'\\\\]))|(?:\\\\u([0-9A-Fa-f]{4}))|(?:\\\\U([0-9A-Fa-f]{8}))/g;\n/**\n * Unescape N-Quads literal to string\n */\nfunction _unescape(s) {\n  return s.replace(_unescapeRegex, function (match, code, u, U) {\n    if (code) {\n      switch (code) {\n        case 't':\n          return '\\t';\n        case 'b':\n          return '\\b';\n        case 'n':\n          return '\\n';\n        case 'r':\n          return '\\r';\n        case 'f':\n          return '\\f';\n        case '\"':\n          return '\"';\n        case '\\'':\n          return '\\'';\n        case '\\\\':\n          return '\\\\';\n      }\n    }\n    if (u) {\n      return String.fromCharCode(parseInt(u, 16));\n    }\n    if (U) {\n      // FIXME: support larger values\n      throw new Error('Unsupported U escape');\n    }\n  });\n}","map":{"version":3,"names":["TERMS","RDF","RDF_LANGSTRING","XSD_STRING","TYPE_NAMED_NODE","TYPE_BLANK_NODE","TYPE_LITERAL","TYPE_DEFAULT_GRAPH","REGEX","iri","PN_CHARS_BASE","PN_CHARS_U","PN_CHARS","BLANK_NODE_LABEL","bnode","plain","datatype","language","literal","ws","wso","subject","property","object","graphName","eoln","empty","RegExp","quad","module","exports","input","dataset","graphs","lines","split","lineNumber","line","test","match","Error","predicate","graph","undefined","termType","value","_unescape","push","unique","quads","q","_compareTriples","Array","isArray","NQuads","legacyDatasetToQuads","serializeQuad","sort","join","s","p","o","g","nquad","_escape","serializeQuadComponents","termTypeMap","IRI","triples","forEach","triple","componentName","oldComponent","newComponent","type","startsWith","t1","t2","_escapeRegex","replace","_unescapeRegex","code","u","U","String","fromCharCode","parseInt"],"sources":["E:/react-todo-app/node_modules/rdf-canonize/lib/NQuads.js"],"sourcesContent":["/*!\n * Copyright (c) 2016-2022 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\n// eslint-disable-next-line no-unused-vars\nconst TERMS = ['subject', 'predicate', 'object', 'graph'];\nconst RDF = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';\nconst RDF_LANGSTRING = RDF + 'langString';\nconst XSD_STRING = 'http://www.w3.org/2001/XMLSchema#string';\n\nconst TYPE_NAMED_NODE = 'NamedNode';\nconst TYPE_BLANK_NODE = 'BlankNode';\nconst TYPE_LITERAL = 'Literal';\nconst TYPE_DEFAULT_GRAPH = 'DefaultGraph';\n\n// build regexes\nconst REGEX = {};\n(() => {\n  const iri = '(?:<([^:]+:[^>]*)>)';\n  // https://www.w3.org/TR/turtle/#grammar-production-BLANK_NODE_LABEL\n  const PN_CHARS_BASE =\n    'A-Z' + 'a-z' +\n    '\\u00C0-\\u00D6' +\n    '\\u00D8-\\u00F6' +\n    '\\u00F8-\\u02FF' +\n    '\\u0370-\\u037D' +\n    '\\u037F-\\u1FFF' +\n    '\\u200C-\\u200D' +\n    '\\u2070-\\u218F' +\n    '\\u2C00-\\u2FEF' +\n    '\\u3001-\\uD7FF' +\n    '\\uF900-\\uFDCF' +\n    '\\uFDF0-\\uFFFD';\n    // TODO:\n    //'\\u10000-\\uEFFFF';\n  const PN_CHARS_U =\n    PN_CHARS_BASE +\n    '_';\n  const PN_CHARS =\n    PN_CHARS_U +\n    '0-9' +\n    '-' +\n    '\\u00B7' +\n    '\\u0300-\\u036F' +\n    '\\u203F-\\u2040';\n  const BLANK_NODE_LABEL =\n    '(_:' +\n      '(?:[' + PN_CHARS_U + '0-9])' +\n      '(?:(?:[' + PN_CHARS + '.])*(?:[' + PN_CHARS + ']))?' +\n    ')';\n  const bnode = BLANK_NODE_LABEL;\n  const plain = '\"([^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*)\"';\n  const datatype = '(?:\\\\^\\\\^' + iri + ')';\n  const language = '(?:@([a-zA-Z]+(?:-[a-zA-Z0-9]+)*))';\n  const literal = '(?:' + plain + '(?:' + datatype + '|' + language + ')?)';\n  const ws = '[ \\\\t]+';\n  const wso = '[ \\\\t]*';\n\n  // define quad part regexes\n  const subject = '(?:' + iri + '|' + bnode + ')' + ws;\n  const property = iri + ws;\n  const object = '(?:' + iri + '|' + bnode + '|' + literal + ')' + wso;\n  const graphName = '(?:\\\\.|(?:(?:' + iri + '|' + bnode + ')' + wso + '\\\\.))';\n\n  // end of line and empty regexes\n  REGEX.eoln = /(?:\\r\\n)|(?:\\n)|(?:\\r)/g;\n  REGEX.empty = new RegExp('^' + wso + '$');\n\n  // full quad regex\n  REGEX.quad = new RegExp(\n    '^' + wso + subject + property + object + graphName + wso + '$');\n})();\n\nmodule.exports = class NQuads {\n  /**\n   * Parses RDF in the form of N-Quads.\n   *\n   * @param input the N-Quads input to parse.\n   *\n   * @return an RDF dataset (an array of quads per http://rdf.js.org/).\n   */\n  static parse(input) {\n    // build RDF dataset\n    const dataset = [];\n\n    const graphs = {};\n\n    // split N-Quad input into lines\n    const lines = input.split(REGEX.eoln);\n    let lineNumber = 0;\n    for(const line of lines) {\n      lineNumber++;\n\n      // skip empty lines\n      if(REGEX.empty.test(line)) {\n        continue;\n      }\n\n      // parse quad\n      const match = line.match(REGEX.quad);\n      if(match === null) {\n        throw new Error('N-Quads parse error on line ' + lineNumber + '.');\n      }\n\n      // create RDF quad\n      const quad = {subject: null, predicate: null, object: null, graph: null};\n\n      // get subject\n      if(match[1] !== undefined) {\n        quad.subject = {termType: TYPE_NAMED_NODE, value: match[1]};\n      } else {\n        quad.subject = {termType: TYPE_BLANK_NODE, value: match[2]};\n      }\n\n      // get predicate\n      quad.predicate = {termType: TYPE_NAMED_NODE, value: match[3]};\n\n      // get object\n      if(match[4] !== undefined) {\n        quad.object = {termType: TYPE_NAMED_NODE, value: match[4]};\n      } else if(match[5] !== undefined) {\n        quad.object = {termType: TYPE_BLANK_NODE, value: match[5]};\n      } else {\n        quad.object = {\n          termType: TYPE_LITERAL,\n          value: undefined,\n          datatype: {\n            termType: TYPE_NAMED_NODE\n          }\n        };\n        if(match[7] !== undefined) {\n          quad.object.datatype.value = match[7];\n        } else if(match[8] !== undefined) {\n          quad.object.datatype.value = RDF_LANGSTRING;\n          quad.object.language = match[8];\n        } else {\n          quad.object.datatype.value = XSD_STRING;\n        }\n        quad.object.value = _unescape(match[6]);\n      }\n\n      // get graph\n      if(match[9] !== undefined) {\n        quad.graph = {\n          termType: TYPE_NAMED_NODE,\n          value: match[9]\n        };\n      } else if(match[10] !== undefined) {\n        quad.graph = {\n          termType: TYPE_BLANK_NODE,\n          value: match[10]\n        };\n      } else {\n        quad.graph = {\n          termType: TYPE_DEFAULT_GRAPH,\n          value: ''\n        };\n      }\n\n      // only add quad if it is unique in its graph\n      if(!(quad.graph.value in graphs)) {\n        graphs[quad.graph.value] = [quad];\n        dataset.push(quad);\n      } else {\n        let unique = true;\n        const quads = graphs[quad.graph.value];\n        for(const q of quads) {\n          if(_compareTriples(q, quad)) {\n            unique = false;\n            break;\n          }\n        }\n        if(unique) {\n          quads.push(quad);\n          dataset.push(quad);\n        }\n      }\n    }\n\n    return dataset;\n  }\n\n  /**\n   * Converts an RDF dataset to N-Quads.\n   *\n   * @param dataset (array of quads) the RDF dataset to convert.\n   *\n   * @return the N-Quads string.\n   */\n  static serialize(dataset) {\n    if(!Array.isArray(dataset)) {\n      dataset = NQuads.legacyDatasetToQuads(dataset);\n    }\n    const quads = [];\n    for(const quad of dataset) {\n      quads.push(NQuads.serializeQuad(quad));\n    }\n    return quads.sort().join('');\n  }\n\n  /**\n   * Converts RDF quad components to an N-Quad string (a single quad).\n   *\n   * @param {Object} s - N-Quad subject component.\n   * @param {Object} p - N-Quad predicate component.\n   * @param {Object} o - N-Quad object component.\n   * @param {Object} g - N-Quad graph component.\n   *\n   * @return {string} the N-Quad.\n   */\n  static serializeQuadComponents(s, p, o, g) {\n    let nquad = '';\n\n    // subject can only be NamedNode or BlankNode\n    if(s.termType === TYPE_NAMED_NODE) {\n      nquad += `<${s.value}>`;\n    } else {\n      nquad += `${s.value}`;\n    }\n\n    // predicate can only be NamedNode\n    nquad += ` <${p.value}> `;\n\n    // object is NamedNode, BlankNode, or Literal\n    if(o.termType === TYPE_NAMED_NODE) {\n      nquad += `<${o.value}>`;\n    } else if(o.termType === TYPE_BLANK_NODE) {\n      nquad += o.value;\n    } else {\n      nquad += `\"${_escape(o.value)}\"`;\n      if(o.datatype.value === RDF_LANGSTRING) {\n        if(o.language) {\n          nquad += `@${o.language}`;\n        }\n      } else if(o.datatype.value !== XSD_STRING) {\n        nquad += `^^<${o.datatype.value}>`;\n      }\n    }\n\n    // graph can only be NamedNode or BlankNode (or DefaultGraph, but that\n    // does not add to `nquad`)\n    if(g.termType === TYPE_NAMED_NODE) {\n      nquad += ` <${g.value}>`;\n    } else if(g.termType === TYPE_BLANK_NODE) {\n      nquad += ` ${g.value}`;\n    }\n\n    nquad += ' .\\n';\n    return nquad;\n  }\n\n  /**\n   * Converts an RDF quad to an N-Quad string (a single quad).\n   *\n   * @param quad the RDF quad convert.\n   *\n   * @return the N-Quad string.\n   */\n  static serializeQuad(quad) {\n    return NQuads.serializeQuadComponents(\n      quad.subject, quad.predicate, quad.object, quad.graph);\n  }\n\n  /**\n   * Converts a legacy-formatted dataset to an array of quads dataset per\n   * http://rdf.js.org/.\n   *\n   * @param dataset the legacy dataset to convert.\n   *\n   * @return the array of quads dataset.\n   */\n  static legacyDatasetToQuads(dataset) {\n    const quads = [];\n\n    const termTypeMap = {\n      'blank node': TYPE_BLANK_NODE,\n      IRI: TYPE_NAMED_NODE,\n      literal: TYPE_LITERAL\n    };\n\n    for(const graphName in dataset) {\n      const triples = dataset[graphName];\n      triples.forEach(triple => {\n        const quad = {};\n        for(const componentName in triple) {\n          const oldComponent = triple[componentName];\n          const newComponent = {\n            termType: termTypeMap[oldComponent.type],\n            value: oldComponent.value\n          };\n          if(newComponent.termType === TYPE_LITERAL) {\n            newComponent.datatype = {\n              termType: TYPE_NAMED_NODE\n            };\n            if('datatype' in oldComponent) {\n              newComponent.datatype.value = oldComponent.datatype;\n            }\n            if('language' in oldComponent) {\n              if(!('datatype' in oldComponent)) {\n                newComponent.datatype.value = RDF_LANGSTRING;\n              }\n              newComponent.language = oldComponent.language;\n            } else if(!('datatype' in oldComponent)) {\n              newComponent.datatype.value = XSD_STRING;\n            }\n          }\n          quad[componentName] = newComponent;\n        }\n        if(graphName === '@default') {\n          quad.graph = {\n            termType: TYPE_DEFAULT_GRAPH,\n            value: ''\n          };\n        } else {\n          quad.graph = {\n            termType: graphName.startsWith('_:') ?\n              TYPE_BLANK_NODE : TYPE_NAMED_NODE,\n            value: graphName\n          };\n        }\n        quads.push(quad);\n      });\n    }\n\n    return quads;\n  }\n};\n\n/**\n * Compares two RDF triples for equality.\n *\n * @param t1 the first triple.\n * @param t2 the second triple.\n *\n * @return true if the triples are the same, false if not.\n */\nfunction _compareTriples(t1, t2) {\n  // compare subject and object types first as it is the quickest check\n  if(!(t1.subject.termType === t2.subject.termType &&\n    t1.object.termType === t2.object.termType)) {\n    return false;\n  }\n  // compare values\n  if(!(t1.subject.value === t2.subject.value &&\n    t1.predicate.value === t2.predicate.value &&\n    t1.object.value === t2.object.value)) {\n    return false;\n  }\n  if(t1.object.termType !== TYPE_LITERAL) {\n    // no `datatype` or `language` to check\n    return true;\n  }\n  return (\n    (t1.object.datatype.termType === t2.object.datatype.termType) &&\n    (t1.object.language === t2.object.language) &&\n    (t1.object.datatype.value === t2.object.datatype.value)\n  );\n}\n\nconst _escapeRegex = /[\"\\\\\\n\\r]/g;\n/**\n * Escape string to N-Quads literal\n */\nfunction _escape(s) {\n  return s.replace(_escapeRegex, function(match) {\n    switch(match) {\n      case '\"': return '\\\\\"';\n      case '\\\\': return '\\\\\\\\';\n      case '\\n': return '\\\\n';\n      case '\\r': return '\\\\r';\n    }\n  });\n}\n\nconst _unescapeRegex =\n  /(?:\\\\([tbnrf\"'\\\\]))|(?:\\\\u([0-9A-Fa-f]{4}))|(?:\\\\U([0-9A-Fa-f]{8}))/g;\n/**\n * Unescape N-Quads literal to string\n */\nfunction _unescape(s) {\n  return s.replace(_unescapeRegex, function(match, code, u, U) {\n    if(code) {\n      switch(code) {\n        case 't': return '\\t';\n        case 'b': return '\\b';\n        case 'n': return '\\n';\n        case 'r': return '\\r';\n        case 'f': return '\\f';\n        case '\"': return '\"';\n        case '\\'': return '\\'';\n        case '\\\\': return '\\\\';\n      }\n    }\n    if(u) {\n      return String.fromCharCode(parseInt(u, 16));\n    }\n    if(U) {\n      // FIXME: support larger values\n      throw new Error('Unsupported U escape');\n    }\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}