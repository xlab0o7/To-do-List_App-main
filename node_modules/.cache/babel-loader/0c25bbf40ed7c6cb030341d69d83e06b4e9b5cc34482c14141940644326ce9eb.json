{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _objectSpread = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _asyncToGenerator = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\nvar oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\nvar globalFetch = function globalFetch(request, init) {\n  return window.fetch(request, init);\n};\nvar ClientAuthentication = /*#__PURE__*/function () {\n  function ClientAuthentication(loginHandler, redirectHandler, logoutHandler, sessionInfoManager, issuerConfigFetcher) {\n    var _this = this;\n    _classCallCheck(this, ClientAuthentication);\n    this.loginHandler = loginHandler;\n    this.redirectHandler = redirectHandler;\n    this.logoutHandler = logoutHandler;\n    this.sessionInfoManager = sessionInfoManager;\n    this.issuerConfigFetcher = issuerConfigFetcher;\n    this.login = /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options, eventEmitter) {\n        var _a, _b, redirectUrl;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return _this.sessionInfoManager.clear(options.sessionId);\n            case 2:\n              redirectUrl = (0, oidc_client_ext_1.removeOidcQueryParam)((_a = options.redirectUrl) !== null && _a !== void 0 ? _a : window.location.href);\n              _context.next = 5;\n              return _this.loginHandler.handle(_objectSpread(_objectSpread({}, options), {}, {\n                redirectUrl: redirectUrl,\n                clientName: (_b = options.clientName) !== null && _b !== void 0 ? _b : options.clientId,\n                eventEmitter: eventEmitter\n              }));\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function (_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n    this.fetch = globalFetch;\n    this.logout = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(sessionId) {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return _this.logoutHandler.handle(sessionId);\n            case 2:\n              _this.fetch = globalFetch;\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n      return function (_x3) {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    this.getSessionInfo = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(sessionId) {\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", _this.sessionInfoManager.get(sessionId));\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3);\n      }));\n      return function (_x4) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n    this.getAllSessionInfo = /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n      return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n        while (1) switch (_context4.prev = _context4.next) {\n          case 0:\n            return _context4.abrupt(\"return\", _this.sessionInfoManager.getAll());\n          case 1:\n          case \"end\":\n            return _context4.stop();\n        }\n      }, _callee4);\n    }));\n    this.validateCurrentSession = /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(currentSessionId) {\n        var sessionInfo;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return _this.sessionInfoManager.get(currentSessionId);\n            case 2:\n              sessionInfo = _context5.sent;\n              if (!(sessionInfo === undefined || sessionInfo.clientAppId === undefined || sessionInfo.issuer === undefined)) {\n                _context5.next = 5;\n                break;\n              }\n              return _context5.abrupt(\"return\", null);\n            case 5:\n              return _context5.abrupt(\"return\", sessionInfo);\n            case 6:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5);\n      }));\n      return function (_x5) {\n        return _ref5.apply(this, arguments);\n      };\n    }();\n    this.handleIncomingRedirect = /*#__PURE__*/function () {\n      var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(url, eventEmitter) {\n        var redirectInfo;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.prev = 0;\n              _context6.next = 3;\n              return _this.redirectHandler.handle(url, eventEmitter);\n            case 3:\n              redirectInfo = _context6.sent;\n              _this.fetch = redirectInfo.fetch.bind(window);\n              _this.cleanUrlAfterRedirect(url);\n              return _context6.abrupt(\"return\", {\n                isLoggedIn: redirectInfo.isLoggedIn,\n                webId: redirectInfo.webId,\n                sessionId: redirectInfo.sessionId,\n                expirationDate: redirectInfo.expirationDate\n              });\n            case 9:\n              _context6.prev = 9;\n              _context6.t0 = _context6[\"catch\"](0);\n              _this.cleanUrlAfterRedirect(url);\n              eventEmitter.emit(solid_client_authn_core_1.EVENTS.ERROR, \"redirect\", _context6.t0);\n              return _context6.abrupt(\"return\", undefined);\n            case 14:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, null, [[0, 9]]);\n      }));\n      return function (_x6, _x7) {\n        return _ref6.apply(this, arguments);\n      };\n    }();\n  }\n  _createClass(ClientAuthentication, [{\n    key: \"cleanUrlAfterRedirect\",\n    value: function cleanUrlAfterRedirect(url) {\n      var cleanedUpUrl = new URL(url);\n      cleanedUpUrl.searchParams.delete(\"state\");\n      cleanedUpUrl.searchParams.delete(\"code\");\n      cleanedUpUrl.searchParams.delete(\"id_token\");\n      cleanedUpUrl.searchParams.delete(\"access_token\");\n      cleanedUpUrl.searchParams.delete(\"error\");\n      cleanedUpUrl.searchParams.delete(\"error_description\");\n      cleanedUpUrl.searchParams.delete(\"iss\");\n      window.history.replaceState(null, \"\", cleanedUpUrl.toString());\n    }\n  }]);\n  return ClientAuthentication;\n}();\nexports.default = ClientAuthentication;","map":{"version":3,"mappings":"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","names":["globalFetch","request","init","window","fetch","ClientAuthentication","loginHandler","redirectHandler","logoutHandler","sessionInfoManager","issuerConfigFetcher","options","eventEmitter","clear","sessionId","redirectUrl","location","href","handle","clientName","clientId","get","getAll","currentSessionId","sessionInfo","undefined","clientAppId","issuer","url","redirectInfo","bind","cleanUrlAfterRedirect","isLoggedIn","webId","expirationDate","emit","solid_client_authn_core_1","ERROR","cleanedUpUrl","URL","searchParams","delete","history","replaceState","toString","exports"],"sources":["E:\\react-todo-app\\node_modules\\@inrupt\\solid-client-authn-browser\\src\\ClientAuthentication.ts"],"sourcesContent":["//\n// Copyright 2022 Inrupt Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n// Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n/**\n * @hidden\n * @packageDocumentation\n */\n\nimport {\n  ILoginHandler,\n  ILogoutHandler,\n  IIncomingRedirectHandler,\n  ISessionInfo,\n  ISessionInfoManager,\n  IIssuerConfigFetcher,\n  ISessionInternalInfo,\n  ILoginOptions,\n  EVENTS,\n} from \"@inrupt/solid-client-authn-core\";\nimport { removeOidcQueryParam } from \"@inrupt/oidc-client-ext\";\nimport { EventEmitter } from \"events\";\n\n// By only referring to `window` at runtime, apps that do server-side rendering\n// won't run into errors when rendering code that instantiates a\n// ClientAuthentication:\nconst globalFetch: typeof window.fetch = (request, init) =>\n  window.fetch(request, init);\n\n/**\n * @hidden\n */\nexport default class ClientAuthentication {\n  constructor(\n    private loginHandler: ILoginHandler,\n    private redirectHandler: IIncomingRedirectHandler,\n    private logoutHandler: ILogoutHandler,\n    private sessionInfoManager: ISessionInfoManager,\n    private issuerConfigFetcher: IIssuerConfigFetcher\n  ) {}\n\n  // Define these functions as properties so that they don't get accidentally re-bound.\n  // Isn't Javascript fun?\n  login = async (\n    options: ILoginOptions,\n    eventEmitter: EventEmitter\n  ): Promise<void> => {\n    // In order to get a clean start, make sure that the session is logged out\n    // on login.\n    // But we may want to preserve our client application info, particularly if\n    // we used Dynamic Client Registration to register (since we don't\n    // necessarily want the user to have to register this app each time they\n    // login).\n    await this.sessionInfoManager.clear(options.sessionId);\n\n    // In the case of the user hitting the 'back' button in their browser, they\n    // could return to a previous redirect URL that contains OIDC params that\n    // are now longer valid - so just to be safe, strip relevant params now.\n    const redirectUrl = removeOidcQueryParam(\n      options.redirectUrl ?? window.location.href\n    );\n\n    await this.loginHandler.handle({\n      ...options,\n      redirectUrl,\n      // If no clientName is provided, the clientId may be used instead.\n      clientName: options.clientName ?? options.clientId,\n      eventEmitter,\n    });\n  };\n\n  // By default, our fetch() resolves to the environment fetch() function.\n  fetch = globalFetch;\n\n  logout = async (sessionId: string): Promise<void> => {\n    await this.logoutHandler.handle(sessionId);\n\n    // Restore our fetch() function back to the environment fetch(), effectively\n    // leaving us with un-authenticated fetches from now on.\n    this.fetch = globalFetch;\n  };\n\n  getSessionInfo = async (\n    sessionId: string\n  ): Promise<(ISessionInfo & ISessionInternalInfo) | undefined> => {\n    // TODO complete\n    return this.sessionInfoManager.get(sessionId);\n  };\n\n  getAllSessionInfo = async (): Promise<ISessionInfo[]> => {\n    return this.sessionInfoManager.getAll();\n  };\n\n  // Collects session information from storage, and returns them. Returns null\n  // if the expected information cannot be found.\n  // Note that the ID token is not stored, which means the session information\n  // cannot be validated at this point.\n  validateCurrentSession = async (\n    currentSessionId: string\n  ): Promise<(ISessionInfo & ISessionInternalInfo) | null> => {\n    const sessionInfo = await this.sessionInfoManager.get(currentSessionId);\n    if (\n      sessionInfo === undefined ||\n      sessionInfo.clientAppId === undefined ||\n      sessionInfo.issuer === undefined\n    ) {\n      return null;\n    }\n    return sessionInfo;\n  };\n\n  handleIncomingRedirect = async (\n    url: string,\n    eventEmitter: EventEmitter\n  ): Promise<ISessionInfo | undefined> => {\n    try {\n      const redirectInfo = await this.redirectHandler.handle(url, eventEmitter);\n      // The `FallbackRedirectHandler` directly returns the global `fetch` for\n      // his value, so we should ensure it's bound to `window` rather than to\n      // ClientAuthentication, to avoid the following error:\n      // > 'fetch' called on an object that does not implement interface Window.\n      this.fetch = redirectInfo.fetch.bind(window);\n\n      // Strip the oauth params:\n      this.cleanUrlAfterRedirect(url);\n\n      return {\n        isLoggedIn: redirectInfo.isLoggedIn,\n        webId: redirectInfo.webId,\n        sessionId: redirectInfo.sessionId,\n        expirationDate: redirectInfo.expirationDate,\n      };\n    } catch (err) {\n      // Strip the oauth params:\n      this.cleanUrlAfterRedirect(url);\n\n      // FIXME: EVENTS.ERROR should be errorCode, errorDescription\n      //\n      // I'm not sure if \"redirect\" is a good error code, and in theory `err`\n      // maybe an Error object and not a string; Maybe we want to just hardcode\n      // a description instead?\n      eventEmitter.emit(EVENTS.ERROR, \"redirect\", err);\n\n      return undefined;\n    }\n  };\n\n  private cleanUrlAfterRedirect(url: string): void {\n    const cleanedUpUrl = new URL(url);\n    cleanedUpUrl.searchParams.delete(\"state\");\n    // For auth code flow\n    cleanedUpUrl.searchParams.delete(\"code\");\n    // For implicit flow\n    cleanedUpUrl.searchParams.delete(\"id_token\");\n    cleanedUpUrl.searchParams.delete(\"access_token\");\n    // For login error\n    cleanedUpUrl.searchParams.delete(\"error\");\n    cleanedUpUrl.searchParams.delete(\"error_description\");\n    cleanedUpUrl.searchParams.delete(\"iss\");\n\n    // Remove OAuth-specific query params (since the login flow finishes with\n    // the browser being redirected back with OAuth2 query params (e.g. for\n    // 'code' and 'state'), and so if the user simply refreshes this page our\n    // authentication library will be called again with what are now invalid\n    // query parameters!).\n    window.history.replaceState(null, \"\", cleanedUpUrl.toString());\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}