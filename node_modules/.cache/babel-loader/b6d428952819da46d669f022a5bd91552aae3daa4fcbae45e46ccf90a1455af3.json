{"ast":null,"code":"/*\n * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nvar _regeneratorRuntime = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _toConsumableArray = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/toConsumableArray.js\").default;\nvar _createForOfIteratorHelper = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper.js\").default;\nvar _asyncToGenerator = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _require = require('./types'),\n  _isArray = _require.isArray,\n  _isObject = _require.isObject,\n  _isString = _require.isString;\nvar _require2 = require('./util'),\n  _asArray = _require2.asArray;\nvar _require3 = require('./url'),\n  prependBase = _require3.prependBase;\nvar JsonLdError = require('./JsonLdError');\nvar ResolvedContext = require('./ResolvedContext');\nvar MAX_CONTEXT_URLS = 10;\nmodule.exports = /*#__PURE__*/function () {\n  /**\n   * Creates a ContextResolver.\n   *\n   * @param sharedCache a shared LRU cache with `get` and `set` APIs.\n   */\n  function ContextResolver(_ref) {\n    var sharedCache = _ref.sharedCache;\n    _classCallCheck(this, ContextResolver);\n    this.perOpCache = new Map();\n    this.sharedCache = sharedCache;\n  }\n  _createClass(ContextResolver, [{\n    key: \"resolve\",\n    value: function () {\n      var _resolve = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref2) {\n        var activeCtx, context, documentLoader, base, _ref2$cycles, cycles, allResolved, _iterator, _step, ctx, _resolved, key, resolved;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              activeCtx = _ref2.activeCtx, context = _ref2.context, documentLoader = _ref2.documentLoader, base = _ref2.base, _ref2$cycles = _ref2.cycles, cycles = _ref2$cycles === void 0 ? new Set() : _ref2$cycles;\n              // process `@context`\n              if (context && _isObject(context) && context['@context']) {\n                context = context['@context'];\n              }\n\n              // context is one or more contexts\n              context = _asArray(context);\n\n              // resolve each context in the array\n              allResolved = [];\n              _iterator = _createForOfIteratorHelper(context);\n              _context.prev = 5;\n              _iterator.s();\n            case 7:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 27;\n                break;\n              }\n              ctx = _step.value;\n              if (!_isString(ctx)) {\n                _context.next = 17;\n                break;\n              }\n              // see if `ctx` has been resolved before...\n              _resolved = this._get(ctx);\n              if (_resolved) {\n                _context.next = 15;\n                break;\n              }\n              _context.next = 14;\n              return this._resolveRemoteContext({\n                activeCtx: activeCtx,\n                url: ctx,\n                documentLoader: documentLoader,\n                base: base,\n                cycles: cycles\n              });\n            case 14:\n              _resolved = _context.sent;\n            case 15:\n              // add to output and continue\n              if (_isArray(_resolved)) {\n                allResolved.push.apply(allResolved, _toConsumableArray(_resolved));\n              } else {\n                allResolved.push(_resolved);\n              }\n              return _context.abrupt(\"continue\", 25);\n            case 17:\n              if (!(ctx === null)) {\n                _context.next = 20;\n                break;\n              }\n              // handle `null` context, nothing to cache\n              allResolved.push(new ResolvedContext({\n                document: null\n              }));\n              return _context.abrupt(\"continue\", 25);\n            case 20:\n              if (!_isObject(ctx)) {\n                _throwInvalidLocalContext(context);\n              }\n              // context is an object, get/create `ResolvedContext` for it\n              key = JSON.stringify(ctx);\n              resolved = this._get(key);\n              if (!resolved) {\n                // create a new static `ResolvedContext` and cache it\n                resolved = new ResolvedContext({\n                  document: ctx\n                });\n                this._cacheResolvedContext({\n                  key: key,\n                  resolved: resolved,\n                  tag: 'static'\n                });\n              }\n              allResolved.push(resolved);\n            case 25:\n              _context.next = 7;\n              break;\n            case 27:\n              _context.next = 32;\n              break;\n            case 29:\n              _context.prev = 29;\n              _context.t0 = _context[\"catch\"](5);\n              _iterator.e(_context.t0);\n            case 32:\n              _context.prev = 32;\n              _iterator.f();\n              return _context.finish(32);\n            case 35:\n              return _context.abrupt(\"return\", allResolved);\n            case 36:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[5, 29, 32, 35]]);\n      }));\n      function resolve(_x) {\n        return _resolve.apply(this, arguments);\n      }\n      return resolve;\n    }()\n  }, {\n    key: \"_get\",\n    value: function _get(key) {\n      // get key from per operation cache; no `tag` is used with this cache so\n      // any retrieved context will always be the same during a single operation\n      var resolved = this.perOpCache.get(key);\n      if (!resolved) {\n        // see if the shared cache has a `static` entry for this URL\n        var tagMap = this.sharedCache.get(key);\n        if (tagMap) {\n          resolved = tagMap.get('static');\n          if (resolved) {\n            this.perOpCache.set(key, resolved);\n          }\n        }\n      }\n      return resolved;\n    }\n  }, {\n    key: \"_cacheResolvedContext\",\n    value: function _cacheResolvedContext(_ref3) {\n      var key = _ref3.key,\n        resolved = _ref3.resolved,\n        tag = _ref3.tag;\n      this.perOpCache.set(key, resolved);\n      if (tag !== undefined) {\n        var tagMap = this.sharedCache.get(key);\n        if (!tagMap) {\n          tagMap = new Map();\n          this.sharedCache.set(key, tagMap);\n        }\n        tagMap.set(tag, resolved);\n      }\n      return resolved;\n    }\n  }, {\n    key: \"_resolveRemoteContext\",\n    value: function () {\n      var _resolveRemoteContext2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(_ref4) {\n        var activeCtx, url, documentLoader, base, cycles, _yield$this$_fetchCon, context, remoteDoc, resolved;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              activeCtx = _ref4.activeCtx, url = _ref4.url, documentLoader = _ref4.documentLoader, base = _ref4.base, cycles = _ref4.cycles;\n              // resolve relative URL and fetch context\n              url = prependBase(base, url);\n              _context2.next = 4;\n              return this._fetchContext({\n                activeCtx: activeCtx,\n                url: url,\n                documentLoader: documentLoader,\n                cycles: cycles\n              });\n            case 4:\n              _yield$this$_fetchCon = _context2.sent;\n              context = _yield$this$_fetchCon.context;\n              remoteDoc = _yield$this$_fetchCon.remoteDoc;\n              // update base according to remote document and resolve any relative URLs\n              base = remoteDoc.documentUrl || url;\n              _resolveContextUrls({\n                context: context,\n                base: base\n              });\n\n              // resolve, cache, and return context\n              _context2.next = 11;\n              return this.resolve({\n                activeCtx: activeCtx,\n                context: context,\n                documentLoader: documentLoader,\n                base: base,\n                cycles: cycles\n              });\n            case 11:\n              resolved = _context2.sent;\n              this._cacheResolvedContext({\n                key: url,\n                resolved: resolved,\n                tag: remoteDoc.tag\n              });\n              return _context2.abrupt(\"return\", resolved);\n            case 14:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function _resolveRemoteContext(_x2) {\n        return _resolveRemoteContext2.apply(this, arguments);\n      }\n      return _resolveRemoteContext;\n    }()\n  }, {\n    key: \"_fetchContext\",\n    value: function () {\n      var _fetchContext2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(_ref5) {\n        var activeCtx, url, documentLoader, cycles, context, remoteDoc;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              activeCtx = _ref5.activeCtx, url = _ref5.url, documentLoader = _ref5.documentLoader, cycles = _ref5.cycles;\n              if (!(cycles.size > MAX_CONTEXT_URLS)) {\n                _context3.next = 3;\n                break;\n              }\n              throw new JsonLdError('Maximum number of @context URLs exceeded.', 'jsonld.ContextUrlError', {\n                code: activeCtx.processingMode === 'json-ld-1.0' ? 'loading remote context failed' : 'context overflow',\n                max: MAX_CONTEXT_URLS\n              });\n            case 3:\n              if (!cycles.has(url)) {\n                _context3.next = 5;\n                break;\n              }\n              throw new JsonLdError('Cyclical @context URLs detected.', 'jsonld.ContextUrlError', {\n                code: activeCtx.processingMode === 'json-ld-1.0' ? 'recursive context inclusion' : 'context overflow',\n                url: url\n              });\n            case 5:\n              // track cycles\n              cycles.add(url);\n              _context3.prev = 6;\n              _context3.next = 9;\n              return documentLoader(url);\n            case 9:\n              remoteDoc = _context3.sent;\n              context = remoteDoc.document || null;\n              // parse string context as JSON\n              if (_isString(context)) {\n                context = JSON.parse(context);\n              }\n              _context3.next = 17;\n              break;\n            case 14:\n              _context3.prev = 14;\n              _context3.t0 = _context3[\"catch\"](6);\n              throw new JsonLdError('Dereferencing a URL did not result in a valid JSON-LD object. ' + 'Possible causes are an inaccessible URL perhaps due to ' + 'a same-origin policy (ensure the server uses CORS if you are ' + 'using client-side JavaScript), too many redirects, a ' + 'non-JSON response, or more than one HTTP Link Header was ' + 'provided for a remote context.', 'jsonld.InvalidUrl', {\n                code: 'loading remote context failed',\n                url: url,\n                cause: _context3.t0\n              });\n            case 17:\n              if (_isObject(context)) {\n                _context3.next = 19;\n                break;\n              }\n              throw new JsonLdError('Dereferencing a URL did not result in a JSON object. The ' + 'response was valid JSON, but it was not a JSON object.', 'jsonld.InvalidUrl', {\n                code: 'invalid remote context',\n                url: url\n              });\n            case 19:\n              // use empty context if no @context key is present\n              if (!('@context' in context)) {\n                context = {\n                  '@context': {}\n                };\n              } else {\n                context = {\n                  '@context': context['@context']\n                };\n              }\n\n              // append @context URL to context if given\n              if (remoteDoc.contextUrl) {\n                if (!_isArray(context['@context'])) {\n                  context['@context'] = [context['@context']];\n                }\n                context['@context'].push(remoteDoc.contextUrl);\n              }\n              return _context3.abrupt(\"return\", {\n                context: context,\n                remoteDoc: remoteDoc\n              });\n            case 22:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, null, [[6, 14]]);\n      }));\n      function _fetchContext(_x3) {\n        return _fetchContext2.apply(this, arguments);\n      }\n      return _fetchContext;\n    }()\n  }]);\n  return ContextResolver;\n}();\nfunction _throwInvalidLocalContext(ctx) {\n  throw new JsonLdError('Invalid JSON-LD syntax; @context must be an object.', 'jsonld.SyntaxError', {\n    code: 'invalid local context',\n    context: ctx\n  });\n}\n\n/**\n * Resolve all relative `@context` URLs in the given context by inline\n * replacing them with absolute URLs.\n *\n * @param context the context.\n * @param base the base IRI to use to resolve relative IRIs.\n */\nfunction _resolveContextUrls(_ref6) {\n  var context = _ref6.context,\n    base = _ref6.base;\n  if (!context) {\n    return;\n  }\n  var ctx = context['@context'];\n  if (_isString(ctx)) {\n    context['@context'] = prependBase(base, ctx);\n    return;\n  }\n  if (_isArray(ctx)) {\n    for (var i = 0; i < ctx.length; ++i) {\n      var element = ctx[i];\n      if (_isString(element)) {\n        ctx[i] = prependBase(base, element);\n        continue;\n      }\n      if (_isObject(element)) {\n        _resolveContextUrls({\n          context: {\n            '@context': element\n          },\n          base: base\n        });\n      }\n    }\n    return;\n  }\n  if (!_isObject(ctx)) {\n    // no @context URLs can be found in non-object\n    return;\n  }\n\n  // ctx is an object, resolve any context URLs in terms\n  for (var term in ctx) {\n    _resolveContextUrls({\n      context: ctx[term],\n      base: base\n    });\n  }\n}","map":{"version":3,"names":["require","_isArray","isArray","_isObject","isObject","_isString","isString","_asArray","asArray","prependBase","JsonLdError","ResolvedContext","MAX_CONTEXT_URLS","module","exports","sharedCache","perOpCache","Map","activeCtx","context","documentLoader","base","cycles","Set","allResolved","ctx","resolved","_get","_resolveRemoteContext","url","push","document","_throwInvalidLocalContext","key","JSON","stringify","_cacheResolvedContext","tag","get","tagMap","set","undefined","_fetchContext","remoteDoc","documentUrl","_resolveContextUrls","resolve","size","code","processingMode","max","has","add","parse","cause","contextUrl","i","length","element","term"],"sources":["E:/react-todo-app/node_modules/jsonld/lib/ContextResolver.js"],"sourcesContent":["/*\n * Copyright (c) 2019 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString,\n} = require('./types');\nconst {\n  asArray: _asArray\n} = require('./util');\nconst {prependBase} = require('./url');\nconst JsonLdError = require('./JsonLdError');\nconst ResolvedContext = require('./ResolvedContext');\n\nconst MAX_CONTEXT_URLS = 10;\n\nmodule.exports = class ContextResolver {\n  /**\n   * Creates a ContextResolver.\n   *\n   * @param sharedCache a shared LRU cache with `get` and `set` APIs.\n   */\n  constructor({sharedCache}) {\n    this.perOpCache = new Map();\n    this.sharedCache = sharedCache;\n  }\n\n  async resolve({\n    activeCtx, context, documentLoader, base, cycles = new Set()\n  }) {\n    // process `@context`\n    if(context && _isObject(context) && context['@context']) {\n      context = context['@context'];\n    }\n\n    // context is one or more contexts\n    context = _asArray(context);\n\n    // resolve each context in the array\n    const allResolved = [];\n    for(const ctx of context) {\n      if(_isString(ctx)) {\n        // see if `ctx` has been resolved before...\n        let resolved = this._get(ctx);\n        if(!resolved) {\n          // not resolved yet, resolve\n          resolved = await this._resolveRemoteContext(\n            {activeCtx, url: ctx, documentLoader, base, cycles});\n        }\n\n        // add to output and continue\n        if(_isArray(resolved)) {\n          allResolved.push(...resolved);\n        } else {\n          allResolved.push(resolved);\n        }\n        continue;\n      }\n      if(ctx === null) {\n        // handle `null` context, nothing to cache\n        allResolved.push(new ResolvedContext({document: null}));\n        continue;\n      }\n      if(!_isObject(ctx)) {\n        _throwInvalidLocalContext(context);\n      }\n      // context is an object, get/create `ResolvedContext` for it\n      const key = JSON.stringify(ctx);\n      let resolved = this._get(key);\n      if(!resolved) {\n        // create a new static `ResolvedContext` and cache it\n        resolved = new ResolvedContext({document: ctx});\n        this._cacheResolvedContext({key, resolved, tag: 'static'});\n      }\n      allResolved.push(resolved);\n    }\n\n    return allResolved;\n  }\n\n  _get(key) {\n    // get key from per operation cache; no `tag` is used with this cache so\n    // any retrieved context will always be the same during a single operation\n    let resolved = this.perOpCache.get(key);\n    if(!resolved) {\n      // see if the shared cache has a `static` entry for this URL\n      const tagMap = this.sharedCache.get(key);\n      if(tagMap) {\n        resolved = tagMap.get('static');\n        if(resolved) {\n          this.perOpCache.set(key, resolved);\n        }\n      }\n    }\n    return resolved;\n  }\n\n  _cacheResolvedContext({key, resolved, tag}) {\n    this.perOpCache.set(key, resolved);\n    if(tag !== undefined) {\n      let tagMap = this.sharedCache.get(key);\n      if(!tagMap) {\n        tagMap = new Map();\n        this.sharedCache.set(key, tagMap);\n      }\n      tagMap.set(tag, resolved);\n    }\n    return resolved;\n  }\n\n  async _resolveRemoteContext({activeCtx, url, documentLoader, base, cycles}) {\n    // resolve relative URL and fetch context\n    url = prependBase(base, url);\n    const {context, remoteDoc} = await this._fetchContext(\n      {activeCtx, url, documentLoader, cycles});\n\n    // update base according to remote document and resolve any relative URLs\n    base = remoteDoc.documentUrl || url;\n    _resolveContextUrls({context, base});\n\n    // resolve, cache, and return context\n    const resolved = await this.resolve(\n      {activeCtx, context, documentLoader, base, cycles});\n    this._cacheResolvedContext({key: url, resolved, tag: remoteDoc.tag});\n    return resolved;\n  }\n\n  async _fetchContext({activeCtx, url, documentLoader, cycles}) {\n    // check for max context URLs fetched during a resolve operation\n    if(cycles.size > MAX_CONTEXT_URLS) {\n      throw new JsonLdError(\n        'Maximum number of @context URLs exceeded.',\n        'jsonld.ContextUrlError',\n        {\n          code: activeCtx.processingMode === 'json-ld-1.0' ?\n            'loading remote context failed' :\n            'context overflow',\n          max: MAX_CONTEXT_URLS\n        });\n    }\n\n    // check for context URL cycle\n    // shortcut to avoid extra work that would eventually hit the max above\n    if(cycles.has(url)) {\n      throw new JsonLdError(\n        'Cyclical @context URLs detected.',\n        'jsonld.ContextUrlError',\n        {\n          code: activeCtx.processingMode === 'json-ld-1.0' ?\n            'recursive context inclusion' :\n            'context overflow',\n          url\n        });\n    }\n\n    // track cycles\n    cycles.add(url);\n\n    let context;\n    let remoteDoc;\n\n    try {\n      remoteDoc = await documentLoader(url);\n      context = remoteDoc.document || null;\n      // parse string context as JSON\n      if(_isString(context)) {\n        context = JSON.parse(context);\n      }\n    } catch(e) {\n      throw new JsonLdError(\n        'Dereferencing a URL did not result in a valid JSON-LD object. ' +\n        'Possible causes are an inaccessible URL perhaps due to ' +\n        'a same-origin policy (ensure the server uses CORS if you are ' +\n        'using client-side JavaScript), too many redirects, a ' +\n        'non-JSON response, or more than one HTTP Link Header was ' +\n        'provided for a remote context.',\n        'jsonld.InvalidUrl',\n        {code: 'loading remote context failed', url, cause: e});\n    }\n\n    // ensure ctx is an object\n    if(!_isObject(context)) {\n      throw new JsonLdError(\n        'Dereferencing a URL did not result in a JSON object. The ' +\n        'response was valid JSON, but it was not a JSON object.',\n        'jsonld.InvalidUrl', {code: 'invalid remote context', url});\n    }\n\n    // use empty context if no @context key is present\n    if(!('@context' in context)) {\n      context = {'@context': {}};\n    } else {\n      context = {'@context': context['@context']};\n    }\n\n    // append @context URL to context if given\n    if(remoteDoc.contextUrl) {\n      if(!_isArray(context['@context'])) {\n        context['@context'] = [context['@context']];\n      }\n      context['@context'].push(remoteDoc.contextUrl);\n    }\n\n    return {context, remoteDoc};\n  }\n};\n\nfunction _throwInvalidLocalContext(ctx) {\n  throw new JsonLdError(\n    'Invalid JSON-LD syntax; @context must be an object.',\n    'jsonld.SyntaxError', {\n      code: 'invalid local context', context: ctx\n    });\n}\n\n/**\n * Resolve all relative `@context` URLs in the given context by inline\n * replacing them with absolute URLs.\n *\n * @param context the context.\n * @param base the base IRI to use to resolve relative IRIs.\n */\nfunction _resolveContextUrls({context, base}) {\n  if(!context) {\n    return;\n  }\n\n  const ctx = context['@context'];\n\n  if(_isString(ctx)) {\n    context['@context'] = prependBase(base, ctx);\n    return;\n  }\n\n  if(_isArray(ctx)) {\n    for(let i = 0; i < ctx.length; ++i) {\n      const element = ctx[i];\n      if(_isString(element)) {\n        ctx[i] = prependBase(base, element);\n        continue;\n      }\n      if(_isObject(element)) {\n        _resolveContextUrls({context: {'@context': element}, base});\n      }\n    }\n    return;\n  }\n\n  if(!_isObject(ctx)) {\n    // no @context URLs can be found in non-object\n    return;\n  }\n\n  // ctx is an object, resolve any context URLs in terms\n  for(const term in ctx) {\n    _resolveContextUrls({context: ctx[term], base});\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}