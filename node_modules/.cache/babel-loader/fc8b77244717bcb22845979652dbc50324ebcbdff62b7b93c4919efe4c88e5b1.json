{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AuthCodeRedirectHandler = void 0;\nconst solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\nconst oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\nclass AuthCodeRedirectHandler {\n  constructor(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar, tokerRefresher) {\n    this.storageUtility = storageUtility;\n    this.sessionInfoManager = sessionInfoManager;\n    this.issuerConfigFetcher = issuerConfigFetcher;\n    this.clientRegistrar = clientRegistrar;\n    this.tokerRefresher = tokerRefresher;\n  }\n  async canHandle(redirectUrl) {\n    try {\n      const myUrl = new URL(redirectUrl);\n      return myUrl.searchParams.get(\"code\") !== null && myUrl.searchParams.get(\"state\") !== null;\n    } catch (e) {\n      throw new Error(`[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e}`);\n    }\n  }\n  async handle(redirectUrl, eventEmitter) {\n    if (!(await this.canHandle(redirectUrl))) {\n      throw new Error(`AuthCodeRedirectHandler cannot handle [${redirectUrl}]: it is missing one of [code, state].`);\n    }\n    const url = new URL(redirectUrl);\n    const oauthState = url.searchParams.get(\"state\");\n    const storedSessionId = await this.storageUtility.getForUser(oauthState, \"sessionId\", {\n      errorIfNull: true\n    });\n    const {\n      issuerConfig,\n      codeVerifier,\n      redirectUrl: storedRedirectIri,\n      dpop: isDpop\n    } = await (0, solid_client_authn_core_1.loadOidcContextFromStorage)(storedSessionId, this.storageUtility, this.issuerConfigFetcher);\n    const iss = url.searchParams.get(\"iss\");\n    if (typeof iss === \"string\" && iss !== issuerConfig.issuer) {\n      throw new Error(`The value of the iss parameter (${iss}) does not match the issuer identifier of the authorization server (${issuerConfig.issuer}). See [rfc9207](https://www.rfc-editor.org/rfc/rfc9207.html#section-2.3-3.1.1)`);\n    }\n    if (codeVerifier === undefined) {\n      throw new Error(`The code verifier for session ${storedSessionId} is missing from storage.`);\n    }\n    if (storedRedirectIri === undefined) {\n      throw new Error(`The redirect URL for session ${storedSessionId} is missing from storage.`);\n    }\n    const client = await this.clientRegistrar.getClient({\n      sessionId: storedSessionId\n    }, issuerConfig);\n    let tokens;\n    const tokenCreatedAt = Date.now();\n    if (isDpop) {\n      tokens = await (0, oidc_client_ext_1.getDpopToken)(issuerConfig, client, {\n        grantType: \"authorization_code\",\n        code: url.searchParams.get(\"code\"),\n        codeVerifier,\n        redirectUrl: storedRedirectIri\n      });\n      window.localStorage.removeItem(`oidc.${oauthState}`);\n    } else {\n      tokens = await (0, oidc_client_ext_1.getBearerToken)(url.toString());\n    }\n    let refreshOptions;\n    if (tokens.refreshToken !== undefined) {\n      refreshOptions = {\n        sessionId: storedSessionId,\n        refreshToken: tokens.refreshToken,\n        tokenRefresher: this.tokerRefresher\n      };\n    }\n    const authFetch = await (0, solid_client_authn_core_1.buildAuthenticatedFetch)(fetch, tokens.accessToken, {\n      dpopKey: tokens.dpopKey,\n      refreshOptions,\n      eventEmitter,\n      expiresIn: tokens.expiresIn\n    });\n    await this.storageUtility.setForUser(storedSessionId, {\n      webId: tokens.webId,\n      isLoggedIn: \"true\"\n    }, {\n      secure: true\n    });\n    url.searchParams.delete(\"code\");\n    await this.storageUtility.setForUser(storedSessionId, {\n      redirectUrl: url.toString()\n    }, {\n      secure: false\n    });\n    const sessionInfo = await this.sessionInfoManager.get(storedSessionId);\n    if (!sessionInfo) {\n      throw new Error(`Could not retrieve session: [${storedSessionId}].`);\n    }\n    return Object.assign(sessionInfo, {\n      fetch: authFetch,\n      expirationDate: typeof tokens.expiresIn === \"number\" ? tokenCreatedAt + tokens.expiresIn * 1000 : null\n    });\n  }\n}\nexports.AuthCodeRedirectHandler = AuthCodeRedirectHandler;","map":{"version":3,"mappings":"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","names":["AuthCodeRedirectHandler","constructor","storageUtility","sessionInfoManager","issuerConfigFetcher","clientRegistrar","tokerRefresher","canHandle","redirectUrl","myUrl","URL","searchParams","get","e","Error","handle","eventEmitter","url","oauthState","storedSessionId","getForUser","errorIfNull","issuerConfig","codeVerifier","storedRedirectIri","dpop","isDpop","iss","issuer","undefined","client","getClient","sessionId","tokens","tokenCreatedAt","Date","now","grantType","code","window","localStorage","removeItem","toString","refreshOptions","refreshToken","tokenRefresher","authFetch","fetch","accessToken","dpopKey","expiresIn","setForUser","webId","isLoggedIn","secure","delete","sessionInfo","Object","assign","expirationDate","exports"],"sources":["G:\\To-do-List_App-main\\node_modules\\@inrupt\\solid-client-authn-browser\\src\\login\\oidc\\incomingRedirectHandler\\AuthCodeRedirectHandler.ts"],"sourcesContent":["//\n// Copyright 2022 Inrupt Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n// Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n/**\n * @hidden\n * @packageDocumentation\n */\n// FIXME: The following doesn't work in the browser, it results in all the fetches\n// being unauthenticated. This should be looked into when migrating to universal-fetch.\n// import { fetch } from \"cross-fetch\";\n\nimport {\n  buildAuthenticatedFetch,\n  IClient,\n  IClientRegistrar,\n  IIssuerConfigFetcher,\n  IIncomingRedirectHandler,\n  ISessionInfo,\n  ISessionInfoManager,\n  IStorageUtility,\n  ITokenRefresher,\n  loadOidcContextFromStorage,\n  RefreshOptions,\n} from \"@inrupt/solid-client-authn-core\";\nimport {\n  getDpopToken,\n  getBearerToken,\n  CodeExchangeResult,\n} from \"@inrupt/oidc-client-ext\";\nimport { EventEmitter } from \"events\";\n\n/**\n * @hidden\n */\nexport class AuthCodeRedirectHandler implements IIncomingRedirectHandler {\n  constructor(\n    private storageUtility: IStorageUtility,\n    private sessionInfoManager: ISessionInfoManager,\n    private issuerConfigFetcher: IIssuerConfigFetcher,\n    private clientRegistrar: IClientRegistrar,\n    private tokerRefresher: ITokenRefresher\n  ) {}\n\n  async canHandle(redirectUrl: string): Promise<boolean> {\n    try {\n      const myUrl = new URL(redirectUrl);\n      return (\n        myUrl.searchParams.get(\"code\") !== null &&\n        myUrl.searchParams.get(\"state\") !== null\n      );\n    } catch (e) {\n      throw new Error(\n        `[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e}`\n      );\n    }\n  }\n\n  async handle(\n    redirectUrl: string,\n    eventEmitter?: EventEmitter\n  ): Promise<ISessionInfo & { fetch: typeof fetch }> {\n    if (!(await this.canHandle(redirectUrl))) {\n      throw new Error(\n        `AuthCodeRedirectHandler cannot handle [${redirectUrl}]: it is missing one of [code, state].`\n      );\n    }\n\n    const url = new URL(redirectUrl);\n    const oauthState = url.searchParams.get(\"state\") as string;\n\n    const storedSessionId = (await this.storageUtility.getForUser(\n      oauthState,\n      \"sessionId\",\n      {\n        errorIfNull: true,\n      }\n    )) as string;\n\n    const {\n      issuerConfig,\n      codeVerifier,\n      redirectUrl: storedRedirectIri,\n      dpop: isDpop,\n    } = await loadOidcContextFromStorage(\n      storedSessionId,\n      this.storageUtility,\n      this.issuerConfigFetcher\n    );\n\n    const iss = url.searchParams.get(\"iss\");\n\n    if (typeof iss === \"string\" && iss !== issuerConfig.issuer) {\n      throw new Error(\n        `The value of the iss parameter (${iss}) does not match the issuer identifier of the authorization server (${issuerConfig.issuer}). See [rfc9207](https://www.rfc-editor.org/rfc/rfc9207.html#section-2.3-3.1.1)`\n      );\n    }\n\n    if (codeVerifier === undefined) {\n      throw new Error(\n        `The code verifier for session ${storedSessionId} is missing from storage.`\n      );\n    }\n\n    if (storedRedirectIri === undefined) {\n      throw new Error(\n        `The redirect URL for session ${storedSessionId} is missing from storage.`\n      );\n    }\n\n    const client: IClient = await this.clientRegistrar.getClient(\n      { sessionId: storedSessionId },\n      issuerConfig\n    );\n\n    let tokens: CodeExchangeResult;\n    const tokenCreatedAt = Date.now();\n\n    if (isDpop) {\n      tokens = await getDpopToken(issuerConfig, client, {\n        grantType: \"authorization_code\",\n        // We rely on our 'canHandle' function checking that the OAuth 'code'\n        // parameter is present in our query string.\n        code: url.searchParams.get(\"code\") as string,\n        codeVerifier,\n        redirectUrl: storedRedirectIri,\n      });\n\n      // Delete oidc-client-specific session information from storage. This is\n      // done automatically when retrieving a bearer token, but since the DPoP\n      // binding uses our custom code, this needs to be done manually.\n      window.localStorage.removeItem(`oidc.${oauthState}`);\n    } else {\n      tokens = await getBearerToken(url.toString());\n    }\n\n    let refreshOptions: RefreshOptions | undefined;\n    if (tokens.refreshToken !== undefined) {\n      refreshOptions = {\n        sessionId: storedSessionId,\n        refreshToken: tokens.refreshToken,\n        tokenRefresher: this.tokerRefresher,\n      };\n    }\n\n    const authFetch = await buildAuthenticatedFetch(fetch, tokens.accessToken, {\n      dpopKey: tokens.dpopKey,\n      refreshOptions,\n      eventEmitter,\n      expiresIn: tokens.expiresIn,\n    });\n\n    await this.storageUtility.setForUser(\n      storedSessionId,\n      {\n        webId: tokens.webId,\n        isLoggedIn: \"true\",\n      },\n      { secure: true }\n    );\n    // Clear the code query param from the redirect URL before storing it, but\n    // preserve any state that my have been provided by the client and returned\n    // by the IdP.\n    url.searchParams.delete(\"code\");\n    await this.storageUtility.setForUser(\n      storedSessionId,\n      {\n        redirectUrl: url.toString(),\n      },\n      {\n        secure: false,\n      }\n    );\n\n    const sessionInfo = await this.sessionInfoManager.get(storedSessionId);\n    if (!sessionInfo) {\n      throw new Error(`Could not retrieve session: [${storedSessionId}].`);\n    }\n\n    return Object.assign(sessionInfo, {\n      fetch: authFetch,\n      expirationDate:\n        typeof tokens.expiresIn === \"number\"\n          ? tokenCreatedAt + tokens.expiresIn * 1000\n          : null,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}