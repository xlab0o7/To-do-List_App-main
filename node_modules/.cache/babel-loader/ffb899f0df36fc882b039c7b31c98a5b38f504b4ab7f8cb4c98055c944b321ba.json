{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\nconst oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\nconst globalFetch = (request, init) => window.fetch(request, init);\nclass ClientAuthentication {\n  constructor(loginHandler, redirectHandler, logoutHandler, sessionInfoManager, issuerConfigFetcher) {\n    this.loginHandler = loginHandler;\n    this.redirectHandler = redirectHandler;\n    this.logoutHandler = logoutHandler;\n    this.sessionInfoManager = sessionInfoManager;\n    this.issuerConfigFetcher = issuerConfigFetcher;\n    this.login = async (options, eventEmitter) => {\n      var _a, _b;\n      await this.sessionInfoManager.clear(options.sessionId);\n      const redirectUrl = (0, oidc_client_ext_1.removeOidcQueryParam)((_a = options.redirectUrl) !== null && _a !== void 0 ? _a : window.location.href);\n      await this.loginHandler.handle({\n        ...options,\n        redirectUrl,\n        clientName: (_b = options.clientName) !== null && _b !== void 0 ? _b : options.clientId,\n        eventEmitter\n      });\n    };\n    this.fetch = globalFetch;\n    this.logout = async sessionId => {\n      await this.logoutHandler.handle(sessionId);\n      this.fetch = globalFetch;\n    };\n    this.getSessionInfo = async sessionId => {\n      return this.sessionInfoManager.get(sessionId);\n    };\n    this.getAllSessionInfo = async () => {\n      return this.sessionInfoManager.getAll();\n    };\n    this.validateCurrentSession = async currentSessionId => {\n      const sessionInfo = await this.sessionInfoManager.get(currentSessionId);\n      if (sessionInfo === undefined || sessionInfo.clientAppId === undefined || sessionInfo.issuer === undefined) {\n        return null;\n      }\n      return sessionInfo;\n    };\n    this.handleIncomingRedirect = async (url, eventEmitter) => {\n      try {\n        const redirectInfo = await this.redirectHandler.handle(url, eventEmitter);\n        this.fetch = redirectInfo.fetch.bind(window);\n        this.cleanUrlAfterRedirect(url);\n        return {\n          isLoggedIn: redirectInfo.isLoggedIn,\n          webId: redirectInfo.webId,\n          sessionId: redirectInfo.sessionId,\n          expirationDate: redirectInfo.expirationDate\n        };\n      } catch (err) {\n        this.cleanUrlAfterRedirect(url);\n        eventEmitter.emit(solid_client_authn_core_1.EVENTS.ERROR, \"redirect\", err);\n        return undefined;\n      }\n    };\n  }\n  cleanUrlAfterRedirect(url) {\n    const cleanedUpUrl = new URL(url);\n    cleanedUpUrl.searchParams.delete(\"state\");\n    cleanedUpUrl.searchParams.delete(\"code\");\n    cleanedUpUrl.searchParams.delete(\"id_token\");\n    cleanedUpUrl.searchParams.delete(\"access_token\");\n    cleanedUpUrl.searchParams.delete(\"error\");\n    cleanedUpUrl.searchParams.delete(\"error_description\");\n    cleanedUpUrl.searchParams.delete(\"iss\");\n    window.history.replaceState(null, \"\", cleanedUpUrl.toString());\n  }\n}\nexports.default = ClientAuthentication;","map":{"version":3,"mappings":"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","names":["globalFetch","request","init","window","fetch","ClientAuthentication","constructor","loginHandler","redirectHandler","logoutHandler","sessionInfoManager","issuerConfigFetcher","options","eventEmitter","clear","sessionId","redirectUrl","location","href","handle","clientName","clientId","get","getAll","currentSessionId","sessionInfo","undefined","clientAppId","issuer","url","redirectInfo","bind","cleanUrlAfterRedirect","isLoggedIn","webId","expirationDate","err","emit","solid_client_authn_core_1","ERROR","cleanedUpUrl","URL","searchParams","delete","history","replaceState","toString","exports"],"sources":["G:\\To-do-List_App-main\\node_modules\\@inrupt\\solid-client-authn-browser\\src\\ClientAuthentication.ts"],"sourcesContent":["//\n// Copyright 2022 Inrupt Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n// Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n/**\n * @hidden\n * @packageDocumentation\n */\n\nimport {\n  ILoginHandler,\n  ILogoutHandler,\n  IIncomingRedirectHandler,\n  ISessionInfo,\n  ISessionInfoManager,\n  IIssuerConfigFetcher,\n  ISessionInternalInfo,\n  ILoginOptions,\n  EVENTS,\n} from \"@inrupt/solid-client-authn-core\";\nimport { removeOidcQueryParam } from \"@inrupt/oidc-client-ext\";\nimport { EventEmitter } from \"events\";\n\n// By only referring to `window` at runtime, apps that do server-side rendering\n// won't run into errors when rendering code that instantiates a\n// ClientAuthentication:\nconst globalFetch: typeof window.fetch = (request, init) =>\n  window.fetch(request, init);\n\n/**\n * @hidden\n */\nexport default class ClientAuthentication {\n  constructor(\n    private loginHandler: ILoginHandler,\n    private redirectHandler: IIncomingRedirectHandler,\n    private logoutHandler: ILogoutHandler,\n    private sessionInfoManager: ISessionInfoManager,\n    private issuerConfigFetcher: IIssuerConfigFetcher\n  ) {}\n\n  // Define these functions as properties so that they don't get accidentally re-bound.\n  // Isn't Javascript fun?\n  login = async (\n    options: ILoginOptions,\n    eventEmitter: EventEmitter\n  ): Promise<void> => {\n    // In order to get a clean start, make sure that the session is logged out\n    // on login.\n    // But we may want to preserve our client application info, particularly if\n    // we used Dynamic Client Registration to register (since we don't\n    // necessarily want the user to have to register this app each time they\n    // login).\n    await this.sessionInfoManager.clear(options.sessionId);\n\n    // In the case of the user hitting the 'back' button in their browser, they\n    // could return to a previous redirect URL that contains OIDC params that\n    // are now longer valid - so just to be safe, strip relevant params now.\n    const redirectUrl = removeOidcQueryParam(\n      options.redirectUrl ?? window.location.href\n    );\n\n    await this.loginHandler.handle({\n      ...options,\n      redirectUrl,\n      // If no clientName is provided, the clientId may be used instead.\n      clientName: options.clientName ?? options.clientId,\n      eventEmitter,\n    });\n  };\n\n  // By default, our fetch() resolves to the environment fetch() function.\n  fetch = globalFetch;\n\n  logout = async (sessionId: string): Promise<void> => {\n    await this.logoutHandler.handle(sessionId);\n\n    // Restore our fetch() function back to the environment fetch(), effectively\n    // leaving us with un-authenticated fetches from now on.\n    this.fetch = globalFetch;\n  };\n\n  getSessionInfo = async (\n    sessionId: string\n  ): Promise<(ISessionInfo & ISessionInternalInfo) | undefined> => {\n    // TODO complete\n    return this.sessionInfoManager.get(sessionId);\n  };\n\n  getAllSessionInfo = async (): Promise<ISessionInfo[]> => {\n    return this.sessionInfoManager.getAll();\n  };\n\n  // Collects session information from storage, and returns them. Returns null\n  // if the expected information cannot be found.\n  // Note that the ID token is not stored, which means the session information\n  // cannot be validated at this point.\n  validateCurrentSession = async (\n    currentSessionId: string\n  ): Promise<(ISessionInfo & ISessionInternalInfo) | null> => {\n    const sessionInfo = await this.sessionInfoManager.get(currentSessionId);\n    if (\n      sessionInfo === undefined ||\n      sessionInfo.clientAppId === undefined ||\n      sessionInfo.issuer === undefined\n    ) {\n      return null;\n    }\n    return sessionInfo;\n  };\n\n  handleIncomingRedirect = async (\n    url: string,\n    eventEmitter: EventEmitter\n  ): Promise<ISessionInfo | undefined> => {\n    try {\n      const redirectInfo = await this.redirectHandler.handle(url, eventEmitter);\n      // The `FallbackRedirectHandler` directly returns the global `fetch` for\n      // his value, so we should ensure it's bound to `window` rather than to\n      // ClientAuthentication, to avoid the following error:\n      // > 'fetch' called on an object that does not implement interface Window.\n      this.fetch = redirectInfo.fetch.bind(window);\n\n      // Strip the oauth params:\n      this.cleanUrlAfterRedirect(url);\n\n      return {\n        isLoggedIn: redirectInfo.isLoggedIn,\n        webId: redirectInfo.webId,\n        sessionId: redirectInfo.sessionId,\n        expirationDate: redirectInfo.expirationDate,\n      };\n    } catch (err) {\n      // Strip the oauth params:\n      this.cleanUrlAfterRedirect(url);\n\n      // FIXME: EVENTS.ERROR should be errorCode, errorDescription\n      //\n      // I'm not sure if \"redirect\" is a good error code, and in theory `err`\n      // maybe an Error object and not a string; Maybe we want to just hardcode\n      // a description instead?\n      eventEmitter.emit(EVENTS.ERROR, \"redirect\", err);\n\n      return undefined;\n    }\n  };\n\n  private cleanUrlAfterRedirect(url: string): void {\n    const cleanedUpUrl = new URL(url);\n    cleanedUpUrl.searchParams.delete(\"state\");\n    // For auth code flow\n    cleanedUpUrl.searchParams.delete(\"code\");\n    // For implicit flow\n    cleanedUpUrl.searchParams.delete(\"id_token\");\n    cleanedUpUrl.searchParams.delete(\"access_token\");\n    // For login error\n    cleanedUpUrl.searchParams.delete(\"error\");\n    cleanedUpUrl.searchParams.delete(\"error_description\");\n    cleanedUpUrl.searchParams.delete(\"iss\");\n\n    // Remove OAuth-specific query params (since the login flow finishes with\n    // the browser being redirected back with OAuth2 query params (e.g. for\n    // 'code' and 'state'), and so if the user simply refreshes this page our\n    // authentication library will be called again with what are now invalid\n    // query parameters!).\n    window.history.replaceState(null, \"\", cleanedUpUrl.toString());\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}