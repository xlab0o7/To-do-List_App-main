{"ast":null,"code":"import _possibleConstructorReturn from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\";\nimport _assertThisInitialized from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _classCallCheck from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// N3.js implementations of the RDF/JS core data types\n// See https://github.com/rdfjs/representation-task-force/blob/master/interface-spec.md\n\nimport namespaces from './IRIs';\nimport { isDefaultGraph } from './N3Util';\nvar rdf = namespaces.rdf,\n  xsd = namespaces.xsd;\n\n// eslint-disable-next-line prefer-const\nvar DEFAULTGRAPH;\nvar _blankNodeCounter = 0;\nvar escapedLiteral = /^\"(.*\".*)(?=\"[^\"]*$)/;\nvar quadId = /^<<(\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) (\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) (\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) ?(\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+)?>>$/;\n\n// ## DataFactory singleton\nvar DataFactory = {\n  namedNode: namedNode,\n  blankNode: blankNode,\n  variable: variable,\n  literal: literal,\n  defaultGraph: defaultGraph,\n  quad: quad,\n  triple: quad\n};\nexport default DataFactory;\n\n// ## Term constructor\nexport var Term = /*#__PURE__*/function () {\n  function Term(id) {\n    _classCallCheck(this, Term);\n    this.id = id;\n  }\n\n  // ### The value of this term\n  _createClass(Term, [{\n    key: \"value\",\n    get: function get() {\n      return this.id;\n    }\n\n    // ### Returns whether this object represents the same term as the other\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      // If both terms were created by this library,\n      // equality can be computed through ids\n      if (other instanceof Term) return this.id === other.id;\n      // Otherwise, compare term type and value\n      return !!other && this.termType === other.termType && this.value === other.value;\n    }\n\n    // ### Implement hashCode for Immutable.js, since we implement `equals`\n    // https://immutable-js.com/docs/v4.0.0/ValueObject/#hashCode()\n  }, {\n    key: \"hashCode\",\n    value: function hashCode() {\n      return 0;\n    }\n\n    // ### Returns a plain object representation of this term\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        termType: this.termType,\n        value: this.value\n      };\n    }\n  }]);\n  return Term;\n}();\n\n// ## NamedNode constructor\nexport var NamedNode = /*#__PURE__*/function (_Term) {\n  _inherits(NamedNode, _Term);\n  var _super = _createSuper(NamedNode);\n  function NamedNode() {\n    _classCallCheck(this, NamedNode);\n    return _super.apply(this, arguments);\n  }\n  _createClass(NamedNode, [{\n    key: \"termType\",\n    get:\n    // ### The term type of this term\n    function get() {\n      return 'NamedNode';\n    }\n  }]);\n  return NamedNode;\n}(Term);\n\n// ## Literal constructor\nexport var Literal = /*#__PURE__*/function (_Term2) {\n  _inherits(Literal, _Term2);\n  var _super2 = _createSuper(Literal);\n  function Literal() {\n    _classCallCheck(this, Literal);\n    return _super2.apply(this, arguments);\n  }\n  _createClass(Literal, [{\n    key: \"termType\",\n    get:\n    // ### The term type of this term\n    function get() {\n      return 'Literal';\n    }\n\n    // ### The text value of this literal\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.id.substring(1, this.id.lastIndexOf('\"'));\n    }\n\n    // ### The language of this literal\n  }, {\n    key: \"language\",\n    get: function get() {\n      // Find the last quotation mark (e.g., '\"abc\"@en-us')\n      var id = this.id;\n      var atPos = id.lastIndexOf('\"') + 1;\n      // If \"@\" it follows, return the remaining substring; empty otherwise\n      return atPos < id.length && id[atPos++] === '@' ? id.substr(atPos).toLowerCase() : '';\n    }\n\n    // ### The datatype IRI of this literal\n  }, {\n    key: \"datatype\",\n    get: function get() {\n      return new NamedNode(this.datatypeString);\n    }\n\n    // ### The datatype string of this literal\n  }, {\n    key: \"datatypeString\",\n    get: function get() {\n      // Find the last quotation mark (e.g., '\"abc\"^^http://ex.org/types#t')\n      var id = this.id,\n        dtPos = id.lastIndexOf('\"') + 1;\n      var char = dtPos < id.length ? id[dtPos] : '';\n      // If \"^\" it follows, return the remaining substring\n      return char === '^' ? id.substr(dtPos + 2) :\n      // If \"@\" follows, return rdf:langString; xsd:string otherwise\n      char !== '@' ? xsd.string : rdf.langString;\n    }\n\n    // ### Returns whether this object represents the same term as the other\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      // If both literals were created by this library,\n      // equality can be computed through ids\n      if (other instanceof Literal) return this.id === other.id;\n      // Otherwise, compare term type, value, language, and datatype\n      return !!other && !!other.datatype && this.termType === other.termType && this.value === other.value && this.language === other.language && this.datatype.value === other.datatype.value;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        termType: this.termType,\n        value: this.value,\n        language: this.language,\n        datatype: {\n          termType: 'NamedNode',\n          value: this.datatypeString\n        }\n      };\n    }\n  }]);\n  return Literal;\n}(Term);\n\n// ## BlankNode constructor\nexport var BlankNode = /*#__PURE__*/function (_Term3) {\n  _inherits(BlankNode, _Term3);\n  var _super3 = _createSuper(BlankNode);\n  function BlankNode(name) {\n    _classCallCheck(this, BlankNode);\n    return _super3.call(this, \"_:\".concat(name));\n  }\n\n  // ### The term type of this term\n  _createClass(BlankNode, [{\n    key: \"termType\",\n    get: function get() {\n      return 'BlankNode';\n    }\n\n    // ### The name of this blank node\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.id.substr(2);\n    }\n  }]);\n  return BlankNode;\n}(Term);\nexport var Variable = /*#__PURE__*/function (_Term4) {\n  _inherits(Variable, _Term4);\n  var _super4 = _createSuper(Variable);\n  function Variable(name) {\n    _classCallCheck(this, Variable);\n    return _super4.call(this, \"?\".concat(name));\n  }\n\n  // ### The term type of this term\n  _createClass(Variable, [{\n    key: \"termType\",\n    get: function get() {\n      return 'Variable';\n    }\n\n    // ### The name of this variable\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this.id.substr(1);\n    }\n  }]);\n  return Variable;\n}(Term);\n\n// ## DefaultGraph constructor\nexport var DefaultGraph = /*#__PURE__*/function (_Term5) {\n  _inherits(DefaultGraph, _Term5);\n  var _super5 = _createSuper(DefaultGraph);\n  function DefaultGraph() {\n    var _this;\n    _classCallCheck(this, DefaultGraph);\n    _this = _super5.call(this, '');\n    return _possibleConstructorReturn(_this, DEFAULTGRAPH || _assertThisInitialized(_this));\n  }\n\n  // ### The term type of this term\n  _createClass(DefaultGraph, [{\n    key: \"termType\",\n    get: function get() {\n      return 'DefaultGraph';\n    }\n\n    // ### Returns whether this object represents the same term as the other\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      // If both terms were created by this library,\n      // equality can be computed through strict equality;\n      // otherwise, compare term types.\n      return this === other || !!other && this.termType === other.termType;\n    }\n  }]);\n  return DefaultGraph;\n}(Term);\n\n// ## DefaultGraph singleton\nDEFAULTGRAPH = new DefaultGraph();\n\n// ### Constructs a term from the given internal string ID\nexport function termFromId(id, factory) {\n  factory = factory || DataFactory;\n\n  // Falsy value or empty string indicate the default graph\n  if (!id) return factory.defaultGraph();\n\n  // Identify the term type based on the first character\n  switch (id[0]) {\n    case '?':\n      return factory.variable(id.substr(1));\n    case '_':\n      return factory.blankNode(id.substr(2));\n    case '\"':\n      // Shortcut for internal literals\n      if (factory === DataFactory) return new Literal(id);\n      // Literal without datatype or language\n      if (id[id.length - 1] === '\"') return factory.literal(id.substr(1, id.length - 2));\n      // Literal with datatype or language\n      var endPos = id.lastIndexOf('\"', id.length - 1);\n      return factory.literal(id.substr(1, endPos - 1), id[endPos + 1] === '@' ? id.substr(endPos + 2) : factory.namedNode(id.substr(endPos + 3)));\n    case '<':\n      var components = quadId.exec(id);\n      return factory.quad(termFromId(unescapeQuotes(components[1]), factory), termFromId(unescapeQuotes(components[2]), factory), termFromId(unescapeQuotes(components[3]), factory), components[4] && termFromId(unescapeQuotes(components[4]), factory));\n    default:\n      return factory.namedNode(id);\n  }\n}\n\n// ### Constructs an internal string ID from the given term or ID string\nexport function termToId(term) {\n  if (typeof term === 'string') return term;\n  if (term instanceof Term && term.termType !== 'Quad') return term.id;\n  if (!term) return DEFAULTGRAPH.id;\n\n  // Term instantiated with another library\n  switch (term.termType) {\n    case 'NamedNode':\n      return term.value;\n    case 'BlankNode':\n      return \"_:\".concat(term.value);\n    case 'Variable':\n      return \"?\".concat(term.value);\n    case 'DefaultGraph':\n      return '';\n    case 'Literal':\n      return \"\\\"\".concat(term.value, \"\\\"\").concat(term.language ? \"@\".concat(term.language) : term.datatype && term.datatype.value !== xsd.string ? \"^^\".concat(term.datatype.value) : '');\n    case 'Quad':\n      // To identify RDF* quad components, we escape quotes by doubling them.\n      // This avoids the overhead of backslash parsing of Turtle-like syntaxes.\n      return \"<<\".concat(escapeQuotes(termToId(term.subject)), \" \").concat(escapeQuotes(termToId(term.predicate)), \" \").concat(escapeQuotes(termToId(term.object))).concat(isDefaultGraph(term.graph) ? '' : \" \".concat(termToId(term.graph)), \">>\");\n    default:\n      throw new Error(\"Unexpected termType: \".concat(term.termType));\n  }\n}\n\n// ## Quad constructor\nexport var Quad = /*#__PURE__*/function (_Term6) {\n  _inherits(Quad, _Term6);\n  var _super6 = _createSuper(Quad);\n  function Quad(subject, predicate, object, graph) {\n    var _this2;\n    _classCallCheck(this, Quad);\n    _this2 = _super6.call(this, '');\n    _this2._subject = subject;\n    _this2._predicate = predicate;\n    _this2._object = object;\n    _this2._graph = graph || DEFAULTGRAPH;\n    return _this2;\n  }\n\n  // ### The term type of this term\n  _createClass(Quad, [{\n    key: \"termType\",\n    get: function get() {\n      return 'Quad';\n    }\n  }, {\n    key: \"subject\",\n    get: function get() {\n      return this._subject;\n    }\n  }, {\n    key: \"predicate\",\n    get: function get() {\n      return this._predicate;\n    }\n  }, {\n    key: \"object\",\n    get: function get() {\n      return this._object;\n    }\n  }, {\n    key: \"graph\",\n    get: function get() {\n      return this._graph;\n    }\n\n    // ### Returns a plain object representation of this quad\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        termType: this.termType,\n        subject: this._subject.toJSON(),\n        predicate: this._predicate.toJSON(),\n        object: this._object.toJSON(),\n        graph: this._graph.toJSON()\n      };\n    }\n\n    // ### Returns whether this object represents the same quad as the other\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return !!other && this._subject.equals(other.subject) && this._predicate.equals(other.predicate) && this._object.equals(other.object) && this._graph.equals(other.graph);\n    }\n  }]);\n  return Quad;\n}(Term);\nexport { Quad as Triple };\n\n// ### Escapes the quotes within the given literal\nexport function escapeQuotes(id) {\n  return id.replace(escapedLiteral, function (_, quoted) {\n    return \"\\\"\".concat(quoted.replace(/\"/g, '\"\"'));\n  });\n}\n\n// ### Unescapes the quotes within the given literal\nexport function unescapeQuotes(id) {\n  return id.replace(escapedLiteral, function (_, quoted) {\n    return \"\\\"\".concat(quoted.replace(/\"\"/g, '\"'));\n  });\n}\n\n// ### Creates an IRI\nfunction namedNode(iri) {\n  return new NamedNode(iri);\n}\n\n// ### Creates a blank node\nfunction blankNode(name) {\n  return new BlankNode(name || \"n3-\".concat(_blankNodeCounter++));\n}\n\n// ### Creates a literal\nfunction literal(value, languageOrDataType) {\n  // Create a language-tagged string\n  if (typeof languageOrDataType === 'string') return new Literal(\"\\\"\".concat(value, \"\\\"@\").concat(languageOrDataType.toLowerCase()));\n\n  // Automatically determine datatype for booleans and numbers\n  var datatype = languageOrDataType ? languageOrDataType.value : '';\n  if (datatype === '') {\n    // Convert a boolean\n    if (typeof value === 'boolean') datatype = xsd.boolean;\n    // Convert an integer or double\n    else if (typeof value === 'number') {\n      if (Number.isFinite(value)) datatype = Number.isInteger(value) ? xsd.integer : xsd.double;else {\n        datatype = xsd.double;\n        if (!Number.isNaN(value)) value = value > 0 ? 'INF' : '-INF';\n      }\n    }\n  }\n\n  // Create a datatyped literal\n  return datatype === '' || datatype === xsd.string ? new Literal(\"\\\"\".concat(value, \"\\\"\")) : new Literal(\"\\\"\".concat(value, \"\\\"^^\").concat(datatype));\n}\n\n// ### Creates a variable\nfunction variable(name) {\n  return new Variable(name);\n}\n\n// ### Returns the default graph\nfunction defaultGraph() {\n  return DEFAULTGRAPH;\n}\n\n// ### Creates a quad\nfunction quad(subject, predicate, object, graph) {\n  return new Quad(subject, predicate, object, graph);\n}","map":{"version":3,"names":["namespaces","isDefaultGraph","rdf","xsd","DEFAULTGRAPH","_blankNodeCounter","escapedLiteral","quadId","DataFactory","namedNode","blankNode","variable","literal","defaultGraph","quad","triple","Term","id","other","termType","value","NamedNode","Literal","substring","lastIndexOf","atPos","length","substr","toLowerCase","datatypeString","dtPos","char","string","langString","datatype","language","BlankNode","name","Variable","DefaultGraph","termFromId","factory","endPos","components","exec","unescapeQuotes","termToId","term","escapeQuotes","subject","predicate","object","graph","Error","Quad","_subject","_predicate","_object","_graph","toJSON","equals","Triple","replace","_","quoted","iri","languageOrDataType","boolean","Number","isFinite","isInteger","integer","double","isNaN"],"sources":["E:/react-todo-app/node_modules/n3/src/N3DataFactory.js"],"sourcesContent":["// N3.js implementations of the RDF/JS core data types\n// See https://github.com/rdfjs/representation-task-force/blob/master/interface-spec.md\n\nimport namespaces from './IRIs';\nimport { isDefaultGraph } from './N3Util';\nconst { rdf, xsd } = namespaces;\n\n// eslint-disable-next-line prefer-const\nlet DEFAULTGRAPH;\nlet _blankNodeCounter = 0;\n\nconst escapedLiteral = /^\"(.*\".*)(?=\"[^\"]*$)/;\nconst quadId = /^<<(\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) (\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) (\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+) ?(\"(?:\"\"|[^\"])*\"[^ ]*|[^ ]+)?>>$/;\n\n// ## DataFactory singleton\nconst DataFactory = {\n  namedNode,\n  blankNode,\n  variable,\n  literal,\n  defaultGraph,\n  quad,\n  triple: quad,\n};\nexport default DataFactory;\n\n// ## Term constructor\nexport class Term {\n  constructor(id) {\n    this.id = id;\n  }\n\n  // ### The value of this term\n  get value() {\n    return this.id;\n  }\n\n  // ### Returns whether this object represents the same term as the other\n  equals(other) {\n    // If both terms were created by this library,\n    // equality can be computed through ids\n    if (other instanceof Term)\n      return this.id === other.id;\n    // Otherwise, compare term type and value\n    return !!other && this.termType === other.termType &&\n                      this.value    === other.value;\n  }\n\n  // ### Implement hashCode for Immutable.js, since we implement `equals`\n  // https://immutable-js.com/docs/v4.0.0/ValueObject/#hashCode()\n  hashCode() {\n    return 0;\n  }\n\n  // ### Returns a plain object representation of this term\n  toJSON() {\n    return {\n      termType: this.termType,\n      value:    this.value,\n    };\n  }\n}\n\n\n// ## NamedNode constructor\nexport class NamedNode extends Term {\n  // ### The term type of this term\n  get termType() {\n    return 'NamedNode';\n  }\n}\n\n// ## Literal constructor\nexport class Literal extends Term {\n  // ### The term type of this term\n  get termType() {\n    return 'Literal';\n  }\n\n  // ### The text value of this literal\n  get value() {\n    return this.id.substring(1, this.id.lastIndexOf('\"'));\n  }\n\n  // ### The language of this literal\n  get language() {\n    // Find the last quotation mark (e.g., '\"abc\"@en-us')\n    const id = this.id;\n    let atPos = id.lastIndexOf('\"') + 1;\n    // If \"@\" it follows, return the remaining substring; empty otherwise\n    return atPos < id.length && id[atPos++] === '@' ? id.substr(atPos).toLowerCase() : '';\n  }\n\n  // ### The datatype IRI of this literal\n  get datatype() {\n    return new NamedNode(this.datatypeString);\n  }\n\n  // ### The datatype string of this literal\n  get datatypeString() {\n    // Find the last quotation mark (e.g., '\"abc\"^^http://ex.org/types#t')\n    const id = this.id, dtPos = id.lastIndexOf('\"') + 1;\n    const char = dtPos < id.length ? id[dtPos] : '';\n    // If \"^\" it follows, return the remaining substring\n    return char === '^' ? id.substr(dtPos + 2) :\n           // If \"@\" follows, return rdf:langString; xsd:string otherwise\n           (char !== '@' ? xsd.string : rdf.langString);\n  }\n\n  // ### Returns whether this object represents the same term as the other\n  equals(other) {\n    // If both literals were created by this library,\n    // equality can be computed through ids\n    if (other instanceof Literal)\n      return this.id === other.id;\n    // Otherwise, compare term type, value, language, and datatype\n    return !!other && !!other.datatype &&\n                      this.termType === other.termType &&\n                      this.value    === other.value    &&\n                      this.language === other.language &&\n                      this.datatype.value === other.datatype.value;\n  }\n\n  toJSON() {\n    return {\n      termType: this.termType,\n      value:    this.value,\n      language: this.language,\n      datatype: { termType: 'NamedNode', value: this.datatypeString },\n    };\n  }\n}\n\n// ## BlankNode constructor\nexport class BlankNode extends Term {\n  constructor(name) {\n    super(`_:${name}`);\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'BlankNode';\n  }\n\n  // ### The name of this blank node\n  get value() {\n    return this.id.substr(2);\n  }\n}\n\nexport class Variable extends Term {\n  constructor(name) {\n    super(`?${name}`);\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'Variable';\n  }\n\n  // ### The name of this variable\n  get value() {\n    return this.id.substr(1);\n  }\n}\n\n// ## DefaultGraph constructor\nexport class DefaultGraph extends Term {\n  constructor() {\n    super('');\n    return DEFAULTGRAPH || this;\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'DefaultGraph';\n  }\n\n  // ### Returns whether this object represents the same term as the other\n  equals(other) {\n    // If both terms were created by this library,\n    // equality can be computed through strict equality;\n    // otherwise, compare term types.\n    return (this === other) || (!!other && (this.termType === other.termType));\n  }\n}\n\n// ## DefaultGraph singleton\nDEFAULTGRAPH = new DefaultGraph();\n\n\n// ### Constructs a term from the given internal string ID\nexport function termFromId(id, factory) {\n  factory = factory || DataFactory;\n\n  // Falsy value or empty string indicate the default graph\n  if (!id)\n    return factory.defaultGraph();\n\n  // Identify the term type based on the first character\n  switch (id[0]) {\n  case '?':\n    return factory.variable(id.substr(1));\n  case '_':\n    return factory.blankNode(id.substr(2));\n  case '\"':\n    // Shortcut for internal literals\n    if (factory === DataFactory)\n      return new Literal(id);\n    // Literal without datatype or language\n    if (id[id.length - 1] === '\"')\n      return factory.literal(id.substr(1, id.length - 2));\n    // Literal with datatype or language\n    const endPos = id.lastIndexOf('\"', id.length - 1);\n    return factory.literal(id.substr(1, endPos - 1),\n            id[endPos + 1] === '@' ? id.substr(endPos + 2)\n                                   : factory.namedNode(id.substr(endPos + 3)));\n  case '<':\n    const components = quadId.exec(id);\n    return factory.quad(\n      termFromId(unescapeQuotes(components[1]), factory),\n      termFromId(unescapeQuotes(components[2]), factory),\n      termFromId(unescapeQuotes(components[3]), factory),\n      components[4] && termFromId(unescapeQuotes(components[4]), factory)\n    );\n  default:\n    return factory.namedNode(id);\n  }\n}\n\n// ### Constructs an internal string ID from the given term or ID string\nexport function termToId(term) {\n  if (typeof term === 'string')\n    return term;\n  if (term instanceof Term && term.termType !== 'Quad')\n    return term.id;\n  if (!term)\n    return DEFAULTGRAPH.id;\n\n  // Term instantiated with another library\n  switch (term.termType) {\n  case 'NamedNode':    return term.value;\n  case 'BlankNode':    return `_:${term.value}`;\n  case 'Variable':     return `?${term.value}`;\n  case 'DefaultGraph': return '';\n  case 'Literal':      return `\"${term.value}\"${\n    term.language ? `@${term.language}` :\n      (term.datatype && term.datatype.value !== xsd.string ? `^^${term.datatype.value}` : '')}`;\n  case 'Quad':\n    // To identify RDF* quad components, we escape quotes by doubling them.\n    // This avoids the overhead of backslash parsing of Turtle-like syntaxes.\n    return `<<${\n        escapeQuotes(termToId(term.subject))\n      } ${\n        escapeQuotes(termToId(term.predicate))\n      } ${\n        escapeQuotes(termToId(term.object))\n      }${\n        (isDefaultGraph(term.graph)) ? '' : ` ${termToId(term.graph)}`\n      }>>`;\n  default: throw new Error(`Unexpected termType: ${term.termType}`);\n  }\n}\n\n\n// ## Quad constructor\nexport class Quad extends Term {\n  constructor(subject, predicate, object, graph) {\n    super('');\n    this._subject   = subject;\n    this._predicate = predicate;\n    this._object    = object;\n    this._graph     = graph || DEFAULTGRAPH;\n  }\n\n  // ### The term type of this term\n  get termType() {\n    return 'Quad';\n  }\n\n  get subject() {\n    return this._subject;\n  }\n\n  get predicate() {\n    return this._predicate;\n  }\n\n  get object() {\n    return this._object;\n  }\n\n  get graph() {\n    return this._graph;\n  }\n\n  // ### Returns a plain object representation of this quad\n  toJSON() {\n    return {\n      termType:  this.termType,\n      subject:   this._subject.toJSON(),\n      predicate: this._predicate.toJSON(),\n      object:    this._object.toJSON(),\n      graph:     this._graph.toJSON(),\n    };\n  }\n\n  // ### Returns whether this object represents the same quad as the other\n  equals(other) {\n    return !!other && this._subject.equals(other.subject)     &&\n                      this._predicate.equals(other.predicate) &&\n                      this._object.equals(other.object)       &&\n                      this._graph.equals(other.graph);\n  }\n}\nexport { Quad as Triple };\n\n// ### Escapes the quotes within the given literal\nexport function escapeQuotes(id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"/g, '\"\"')}`);\n}\n\n// ### Unescapes the quotes within the given literal\nexport function unescapeQuotes(id) {\n  return id.replace(escapedLiteral, (_, quoted) => `\"${quoted.replace(/\"\"/g, '\"')}`);\n}\n\n// ### Creates an IRI\nfunction namedNode(iri) {\n  return new NamedNode(iri);\n}\n\n// ### Creates a blank node\nfunction blankNode(name) {\n  return new BlankNode(name || `n3-${_blankNodeCounter++}`);\n}\n\n// ### Creates a literal\nfunction literal(value, languageOrDataType) {\n  // Create a language-tagged string\n  if (typeof languageOrDataType === 'string')\n    return new Literal(`\"${value}\"@${languageOrDataType.toLowerCase()}`);\n\n  // Automatically determine datatype for booleans and numbers\n  let datatype = languageOrDataType ? languageOrDataType.value : '';\n  if (datatype === '') {\n    // Convert a boolean\n    if (typeof value === 'boolean')\n      datatype = xsd.boolean;\n    // Convert an integer or double\n    else if (typeof value === 'number') {\n      if (Number.isFinite(value))\n        datatype = Number.isInteger(value) ? xsd.integer : xsd.double;\n      else {\n        datatype = xsd.double;\n        if (!Number.isNaN(value))\n          value = value > 0 ? 'INF' : '-INF';\n      }\n    }\n  }\n\n  // Create a datatyped literal\n  return (datatype === '' || datatype === xsd.string) ?\n    new Literal(`\"${value}\"`) :\n    new Literal(`\"${value}\"^^${datatype}`);\n}\n\n// ### Creates a variable\nfunction variable(name) {\n  return new Variable(name);\n}\n\n// ### Returns the default graph\nfunction defaultGraph() {\n  return DEFAULTGRAPH;\n}\n\n// ### Creates a quad\nfunction quad(subject, predicate, object, graph) {\n  return new Quad(subject, predicate, object, graph);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}