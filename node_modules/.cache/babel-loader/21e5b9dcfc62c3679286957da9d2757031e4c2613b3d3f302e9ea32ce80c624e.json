{"ast":null,"code":"import _classCallCheck from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// **N3Parser** parses N3 documents.\nimport N3Lexer from './N3Lexer';\nimport N3DataFactory from './N3DataFactory';\nimport namespaces from './IRIs';\nvar blankNodePrefix = 0;\n\n// ## Constructor\nvar N3Parser = /*#__PURE__*/function () {\n  function N3Parser(options) {\n    _classCallCheck(this, N3Parser);\n    this._contextStack = [];\n    this._graph = null;\n\n    // Set the document IRI\n    options = options || {};\n    this._setBase(options.baseIRI);\n    options.factory && initDataFactory(this, options.factory);\n\n    // Set supported features depending on the format\n    var format = typeof options.format === 'string' ? options.format.match(/\\w*$/)[0].toLowerCase() : '',\n      isTurtle = /turtle/.test(format),\n      isTriG = /trig/.test(format),\n      isNTriples = /triple/.test(format),\n      isNQuads = /quad/.test(format),\n      isN3 = this._n3Mode = /n3/.test(format),\n      isLineMode = isNTriples || isNQuads;\n    if (!(this._supportsNamedGraphs = !(isTurtle || isN3))) this._readPredicateOrNamedGraph = this._readPredicate;\n    // Support triples in other graphs\n    this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3);\n    // Support nesting of triples\n    this._supportsRDFStar = format === '' || /star|\\*$/.test(format);\n    // Disable relative IRIs in N-Triples or N-Quads mode\n    if (isLineMode) this._resolveRelativeIRI = function (iri) {\n      return null;\n    };\n    this._blankNodePrefix = typeof options.blankNodePrefix !== 'string' ? '' : options.blankNodePrefix.replace(/^(?!_:)/, '_:');\n    this._lexer = options.lexer || new N3Lexer({\n      lineMode: isLineMode,\n      n3: isN3\n    });\n    // Disable explicit quantifiers by default\n    this._explicitQuantifiers = !!options.explicitQuantifiers;\n  }\n\n  // ## Static class methods\n\n  // ### `_resetBlankNodePrefix` restarts blank node prefix identification\n  _createClass(N3Parser, [{\n    key: \"_setBase\",\n    value:\n    // ## Private methods\n\n    // ### `_setBase` sets the base IRI to resolve relative IRIs\n    function _setBase(baseIRI) {\n      if (!baseIRI) {\n        this._base = '';\n        this._basePath = '';\n      } else {\n        // Remove fragment if present\n        var fragmentPos = baseIRI.indexOf('#');\n        if (fragmentPos >= 0) baseIRI = baseIRI.substr(0, fragmentPos);\n        // Set base IRI and its components\n        this._base = baseIRI;\n        this._basePath = baseIRI.indexOf('/') < 0 ? baseIRI : baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');\n        baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i);\n        this._baseRoot = baseIRI[0];\n        this._baseScheme = baseIRI[1];\n      }\n    }\n\n    // ### `_saveContext` stores the current parsing context\n    // when entering a new scope (list, blank node, formula)\n  }, {\n    key: \"_saveContext\",\n    value: function _saveContext(type, graph, subject, predicate, object) {\n      var n3Mode = this._n3Mode;\n      this._contextStack.push({\n        type: type,\n        subject: subject,\n        predicate: predicate,\n        object: object,\n        graph: graph,\n        inverse: n3Mode ? this._inversePredicate : false,\n        blankPrefix: n3Mode ? this._prefixes._ : '',\n        quantified: n3Mode ? this._quantified : null\n      });\n      // The settings below only apply to N3 streams\n      if (n3Mode) {\n        // Every new scope resets the predicate direction\n        this._inversePredicate = false;\n        // In N3, blank nodes are scoped to a formula\n        // (using a dot as separator, as a blank node label cannot start with it)\n        this._prefixes._ = this._graph ? \"\".concat(this._graph.id.substr(2), \".\") : '.';\n        // Quantifiers are scoped to a formula\n        this._quantified = Object.create(this._quantified);\n      }\n    }\n\n    // ### `_restoreContext` restores the parent context\n    // when leaving a scope (list, blank node, formula)\n  }, {\n    key: \"_restoreContext\",\n    value: function _restoreContext(type, token) {\n      // Obtain the previous context\n      var context = this._contextStack.pop();\n      if (!context || context.type !== type) return this._error(\"Unexpected \".concat(token.type), token);\n\n      // Restore the quad of the previous context\n      this._subject = context.subject;\n      this._predicate = context.predicate;\n      this._object = context.object;\n      this._graph = context.graph;\n\n      // Restore N3 context settings\n      if (this._n3Mode) {\n        this._inversePredicate = context.inverse;\n        this._prefixes._ = context.blankPrefix;\n        this._quantified = context.quantified;\n      }\n    }\n\n    // ### `_readInTopContext` reads a token when in the top context\n  }, {\n    key: \"_readInTopContext\",\n    value: function _readInTopContext(token) {\n      switch (token.type) {\n        // If an EOF token arrives in the top context, signal that we're done\n        case 'eof':\n          if (this._graph !== null) return this._error('Unclosed graph', token);\n          delete this._prefixes._;\n          return this._callback(null, null, this._prefixes);\n        // It could be a prefix declaration\n        case 'PREFIX':\n          this._sparqlStyle = true;\n        case '@prefix':\n          return this._readPrefix;\n        // It could be a base declaration\n        case 'BASE':\n          this._sparqlStyle = true;\n        case '@base':\n          return this._readBaseIRI;\n        // It could be a graph\n        case '{':\n          if (this._supportsNamedGraphs) {\n            this._graph = '';\n            this._subject = null;\n            return this._readSubject;\n          }\n        case 'GRAPH':\n          if (this._supportsNamedGraphs) return this._readNamedGraphLabel;\n        // Otherwise, the next token must be a subject\n        default:\n          return this._readSubject(token);\n      }\n    }\n\n    // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable\n  }, {\n    key: \"_readEntity\",\n    value: function _readEntity(token, quantifier) {\n      var value;\n      switch (token.type) {\n        // Read a relative or absolute IRI\n        case 'IRI':\n        case 'typeIRI':\n          var iri = this._resolveIRI(token.value);\n          if (iri === null) return this._error('Invalid IRI', token);\n          value = this._namedNode(iri);\n          break;\n        // Read a prefixed name\n        case 'type':\n        case 'prefixed':\n          var prefix = this._prefixes[token.prefix];\n          if (prefix === undefined) return this._error(\"Undefined prefix \\\"\".concat(token.prefix, \":\\\"\"), token);\n          value = this._namedNode(prefix + token.value);\n          break;\n        // Read a blank node\n        case 'blank':\n          value = this._blankNode(this._prefixes[token.prefix] + token.value);\n          break;\n        // Read a variable\n        case 'var':\n          value = this._variable(token.value.substr(1));\n          break;\n        // Everything else is not an entity\n        default:\n          return this._error(\"Expected entity but got \".concat(token.type), token);\n      }\n      // In N3 mode, replace the entity if it is quantified\n      if (!quantifier && this._n3Mode && value.id in this._quantified) value = this._quantified[value.id];\n      return value;\n    }\n\n    // ### `_readSubject` reads a quad's subject\n  }, {\n    key: \"_readSubject\",\n    value: function _readSubject(token) {\n      this._predicate = null;\n      switch (token.type) {\n        case '[':\n          // Start a new quad with a new blank node as subject\n          this._saveContext('blank', this._graph, this._subject = this._blankNode(), null, null);\n          return this._readBlankNodeHead;\n        case '(':\n          // Start a new list\n          this._saveContext('list', this._graph, this.RDF_NIL, null, null);\n          this._subject = null;\n          return this._readListItem;\n        case '{':\n          // Start a new formula\n          if (!this._n3Mode) return this._error('Unexpected graph', token);\n          this._saveContext('formula', this._graph, this._graph = this._blankNode(), null, null);\n          return this._readSubject;\n        case '}':\n          // No subject; the graph in which we are reading is closed instead\n          return this._readPunctuation(token);\n        case '@forSome':\n          if (!this._n3Mode) return this._error('Unexpected \"@forSome\"', token);\n          this._subject = null;\n          this._predicate = this.N3_FORSOME;\n          this._quantifier = this._blankNode;\n          return this._readQuantifierList;\n        case '@forAll':\n          if (!this._n3Mode) return this._error('Unexpected \"@forAll\"', token);\n          this._subject = null;\n          this._predicate = this.N3_FORALL;\n          this._quantifier = this._variable;\n          return this._readQuantifierList;\n        case 'literal':\n          if (!this._n3Mode) return this._error('Unexpected literal', token);\n          if (token.prefix.length === 0) {\n            this._literalValue = token.value;\n            return this._completeSubjectLiteral;\n          } else this._subject = this._literal(token.value, this._namedNode(token.prefix));\n          break;\n        case '<<':\n          if (!this._supportsRDFStar) return this._error('Unexpected RDF* syntax', token);\n          this._saveContext('<<', this._graph, null, null, null);\n          this._graph = null;\n          return this._readSubject;\n        default:\n          // Read the subject entity\n          if ((this._subject = this._readEntity(token)) === undefined) return;\n          // In N3 mode, the subject might be a path\n          if (this._n3Mode) return this._getPathReader(this._readPredicateOrNamedGraph);\n      }\n\n      // The next token must be a predicate,\n      // or, if the subject was actually a graph IRI, a named graph\n      return this._readPredicateOrNamedGraph;\n    }\n\n    // ### `_readPredicate` reads a quad's predicate\n  }, {\n    key: \"_readPredicate\",\n    value: function _readPredicate(token) {\n      var type = token.type;\n      switch (type) {\n        case 'inverse':\n          this._inversePredicate = true;\n        case 'abbreviation':\n          this._predicate = this.ABBREVIATIONS[token.value];\n          break;\n        case '.':\n        case ']':\n        case '}':\n          // Expected predicate didn't come, must have been trailing semicolon\n          if (this._predicate === null) return this._error(\"Unexpected \".concat(type), token);\n          this._subject = null;\n          return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);\n        case ';':\n          // Additional semicolons can be safely ignored\n          return this._predicate !== null ? this._readPredicate : this._error('Expected predicate but got ;', token);\n        case '[':\n          if (this._n3Mode) {\n            // Start a new quad with a new blank node as subject\n            this._saveContext('blank', this._graph, this._subject, this._subject = this._blankNode(), null);\n            return this._readBlankNodeHead;\n          }\n        case 'blank':\n          if (!this._n3Mode) return this._error('Disallowed blank node as predicate', token);\n        default:\n          if ((this._predicate = this._readEntity(token)) === undefined) return;\n      }\n      // The next token must be an object\n      return this._readObject;\n    }\n\n    // ### `_readObject` reads a quad's object\n  }, {\n    key: \"_readObject\",\n    value: function _readObject(token) {\n      switch (token.type) {\n        case 'literal':\n          // Regular literal, can still get a datatype or language\n          if (token.prefix.length === 0) {\n            this._literalValue = token.value;\n            return this._readDataTypeOrLang;\n          }\n          // Pre-datatyped string literal (prefix stores the datatype)\n          else this._object = this._literal(token.value, this._namedNode(token.prefix));\n          break;\n        case '[':\n          // Start a new quad with a new blank node as subject\n          this._saveContext('blank', this._graph, this._subject, this._predicate, this._subject = this._blankNode());\n          return this._readBlankNodeHead;\n        case '(':\n          // Start a new list\n          this._saveContext('list', this._graph, this._subject, this._predicate, this.RDF_NIL);\n          this._subject = null;\n          return this._readListItem;\n        case '{':\n          // Start a new formula\n          if (!this._n3Mode) return this._error('Unexpected graph', token);\n          this._saveContext('formula', this._graph, this._subject, this._predicate, this._graph = this._blankNode());\n          return this._readSubject;\n        case '<<':\n          if (!this._supportsRDFStar) return this._error('Unexpected RDF* syntax', token);\n          this._saveContext('<<', this._graph, this._subject, this._predicate, null);\n          this._graph = null;\n          return this._readSubject;\n        default:\n          // Read the object entity\n          if ((this._object = this._readEntity(token)) === undefined) return;\n          // In N3 mode, the object might be a path\n          if (this._n3Mode) return this._getPathReader(this._getContextEndReader());\n      }\n      return this._getContextEndReader();\n    }\n\n    // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph\n  }, {\n    key: \"_readPredicateOrNamedGraph\",\n    value: function _readPredicateOrNamedGraph(token) {\n      return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);\n    }\n\n    // ### `_readGraph` reads a graph\n  }, {\n    key: \"_readGraph\",\n    value: function _readGraph(token) {\n      if (token.type !== '{') return this._error(\"Expected graph but got \".concat(token.type), token);\n      // The \"subject\" we read is actually the GRAPH's label\n      this._graph = this._subject, this._subject = null;\n      return this._readSubject;\n    }\n\n    // ### `_readBlankNodeHead` reads the head of a blank node\n  }, {\n    key: \"_readBlankNodeHead\",\n    value: function _readBlankNodeHead(token) {\n      if (token.type === ']') {\n        this._subject = null;\n        return this._readBlankNodeTail(token);\n      } else {\n        this._predicate = null;\n        return this._readPredicate(token);\n      }\n    }\n\n    // ### `_readBlankNodeTail` reads the end of a blank node\n  }, {\n    key: \"_readBlankNodeTail\",\n    value: function _readBlankNodeTail(token) {\n      if (token.type !== ']') return this._readBlankNodePunctuation(token);\n\n      // Store blank node quad\n      if (this._subject !== null) this._emit(this._subject, this._predicate, this._object, this._graph);\n\n      // Restore the parent context containing this blank node\n      var empty = this._predicate === null;\n      this._restoreContext('blank', token);\n      // If the blank node was the object, restore previous context and read punctuation\n      if (this._object !== null) return this._getContextEndReader();\n      // If the blank node was the predicate, continue reading the object\n      else if (this._predicate !== null) return this._readObject;\n      // If the blank node was the subject, continue reading the predicate\n      else\n        // If the blank node was empty, it could be a named graph label\n        return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;\n    }\n\n    // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node\n  }, {\n    key: \"_readPredicateAfterBlank\",\n    value: function _readPredicateAfterBlank(token) {\n      switch (token.type) {\n        case '.':\n        case '}':\n          // No predicate is coming if the triple is terminated here\n          this._subject = null;\n          return this._readPunctuation(token);\n        default:\n          return this._readPredicate(token);\n      }\n    }\n\n    // ### `_readListItem` reads items from a list\n  }, {\n    key: \"_readListItem\",\n    value: function _readListItem(token) {\n      var item = null,\n        // The item of the list\n        list = null,\n        // The list itself\n        next = this._readListItem; // The next function to execute\n      var previousList = this._subject,\n        // The previous list that contains this list\n        stack = this._contextStack,\n        // The stack of parent contexts\n        parent = stack[stack.length - 1]; // The parent containing the current list\n\n      switch (token.type) {\n        case '[':\n          // Stack the current list quad and start a new quad with a blank node as subject\n          this._saveContext('blank', this._graph, list = this._blankNode(), this.RDF_FIRST, this._subject = item = this._blankNode());\n          next = this._readBlankNodeHead;\n          break;\n        case '(':\n          // Stack the current list quad and start a new list\n          this._saveContext('list', this._graph, list = this._blankNode(), this.RDF_FIRST, this.RDF_NIL);\n          this._subject = null;\n          break;\n        case ')':\n          // Closing the list; restore the parent context\n          this._restoreContext('list', token);\n          // If this list is contained within a parent list, return the membership quad here.\n          // This will be `<parent list element> rdf:first <this list>.`.\n          if (stack.length !== 0 && stack[stack.length - 1].type === 'list') this._emit(this._subject, this._predicate, this._object, this._graph);\n          // Was this list the parent's subject?\n          if (this._predicate === null) {\n            // The next token is the predicate\n            next = this._readPredicate;\n            // No list tail if this was an empty list\n            if (this._subject === this.RDF_NIL) return next;\n          }\n          // The list was in the parent context's object\n          else {\n            next = this._getContextEndReader();\n            // No list tail if this was an empty list\n            if (this._object === this.RDF_NIL) return next;\n          }\n          // Close the list by making the head nil\n          list = this.RDF_NIL;\n          break;\n        case 'literal':\n          // Regular literal, can still get a datatype or language\n          if (token.prefix.length === 0) {\n            this._literalValue = token.value;\n            next = this._readListItemDataTypeOrLang;\n          }\n          // Pre-datatyped string literal (prefix stores the datatype)\n          else {\n            item = this._literal(token.value, this._namedNode(token.prefix));\n            next = this._getContextEndReader();\n          }\n          break;\n        case '{':\n          // Start a new formula\n          if (!this._n3Mode) return this._error('Unexpected graph', token);\n          this._saveContext('formula', this._graph, this._subject, this._predicate, this._graph = this._blankNode());\n          return this._readSubject;\n        default:\n          if ((item = this._readEntity(token)) === undefined) return;\n      }\n\n      // Create a new blank node if no item head was assigned yet\n      if (list === null) this._subject = list = this._blankNode();\n\n      // Is this the first element of the list?\n      if (previousList === null) {\n        // This list is either the subject or the object of its parent\n        if (parent.predicate === null) parent.subject = list;else parent.object = list;\n      } else {\n        // Continue the previous list with the current list\n        this._emit(previousList, this.RDF_REST, list, this._graph);\n      }\n      // If an item was read, add it to the list\n      if (item !== null) {\n        // In N3 mode, the item might be a path\n        if (this._n3Mode && (token.type === 'IRI' || token.type === 'prefixed')) {\n          // Create a new context to add the item's path\n          this._saveContext('item', this._graph, list, this.RDF_FIRST, item);\n          this._subject = item, this._predicate = null;\n          // _readPath will restore the context and output the item\n          return this._getPathReader(this._readListItem);\n        }\n        // Output the item\n        this._emit(list, this.RDF_FIRST, item, this._graph);\n      }\n      return next;\n    }\n\n    // ### `_readDataTypeOrLang` reads an _optional_ datatype or language\n  }, {\n    key: \"_readDataTypeOrLang\",\n    value: function _readDataTypeOrLang(token) {\n      return this._completeObjectLiteral(token, false);\n    }\n\n    // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list\n  }, {\n    key: \"_readListItemDataTypeOrLang\",\n    value: function _readListItemDataTypeOrLang(token) {\n      return this._completeObjectLiteral(token, true);\n    }\n\n    // ### `_completeLiteral` completes a literal with an optional datatype or language\n  }, {\n    key: \"_completeLiteral\",\n    value: function _completeLiteral(token) {\n      // Create a simple string literal by default\n      var literal = this._literal(this._literalValue);\n      switch (token.type) {\n        // Create a datatyped literal\n        case 'type':\n        case 'typeIRI':\n          var datatype = this._readEntity(token);\n          if (datatype === undefined) return; // No datatype means an error occurred\n          literal = this._literal(this._literalValue, datatype);\n          token = null;\n          break;\n        // Create a language-tagged string\n        case 'langcode':\n          literal = this._literal(this._literalValue, token.value);\n          token = null;\n          break;\n      }\n      return {\n        token: token,\n        literal: literal\n      };\n    }\n\n    // Completes a literal in subject position\n  }, {\n    key: \"_completeSubjectLiteral\",\n    value: function _completeSubjectLiteral(token) {\n      this._subject = this._completeLiteral(token).literal;\n      return this._readPredicateOrNamedGraph;\n    }\n\n    // Completes a literal in object position\n  }, {\n    key: \"_completeObjectLiteral\",\n    value: function _completeObjectLiteral(token, listItem) {\n      var completed = this._completeLiteral(token);\n      if (!completed) return;\n      this._object = completed.literal;\n\n      // If this literal was part of a list, write the item\n      // (we could also check the context stack, but passing in a flag is faster)\n      if (listItem) this._emit(this._subject, this.RDF_FIRST, this._object, this._graph);\n      // If the token was consumed, continue with the rest of the input\n      if (completed.token === null) return this._getContextEndReader();\n      // Otherwise, consume the token now\n      else {\n        this._readCallback = this._getContextEndReader();\n        return this._readCallback(completed.token);\n      }\n    }\n\n    // ### `_readFormulaTail` reads the end of a formula\n  }, {\n    key: \"_readFormulaTail\",\n    value: function _readFormulaTail(token) {\n      if (token.type !== '}') return this._readPunctuation(token);\n\n      // Store the last quad of the formula\n      if (this._subject !== null) this._emit(this._subject, this._predicate, this._object, this._graph);\n\n      // Restore the parent context containing this formula\n      this._restoreContext('formula', token);\n      // If the formula was the subject, continue reading the predicate.\n      // If the formula was the object, read punctuation.\n      return this._object === null ? this._readPredicate : this._getContextEndReader();\n    }\n\n    // ### `_readPunctuation` reads punctuation between quads or quad parts\n  }, {\n    key: \"_readPunctuation\",\n    value: function _readPunctuation(token) {\n      var next,\n        graph = this._graph;\n      var subject = this._subject,\n        inversePredicate = this._inversePredicate;\n      switch (token.type) {\n        // A closing brace ends a graph\n        case '}':\n          if (this._graph === null) return this._error('Unexpected graph closing', token);\n          if (this._n3Mode) return this._readFormulaTail(token);\n          this._graph = null;\n        // A dot just ends the statement, without sharing anything with the next\n        case '.':\n          this._subject = null;\n          next = this._contextStack.length ? this._readSubject : this._readInTopContext;\n          if (inversePredicate) this._inversePredicate = false;\n          break;\n        // Semicolon means the subject is shared; predicate and object are different\n        case ';':\n          next = this._readPredicate;\n          break;\n        // Comma means both the subject and predicate are shared; the object is different\n        case ',':\n          next = this._readObject;\n          break;\n        default:\n          // An entity means this is a quad (only allowed if not already inside a graph)\n          if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== undefined) {\n            next = this._readQuadPunctuation;\n            break;\n          }\n          return this._error(\"Expected punctuation to follow \\\"\".concat(this._object.id, \"\\\"\"), token);\n      }\n      // A quad has been completed now, so return it\n      if (subject !== null) {\n        var predicate = this._predicate,\n          object = this._object;\n        if (!inversePredicate) this._emit(subject, predicate, object, graph);else this._emit(object, predicate, subject, graph);\n      }\n      return next;\n    }\n\n    // ### `_readBlankNodePunctuation` reads punctuation in a blank node\n  }, {\n    key: \"_readBlankNodePunctuation\",\n    value: function _readBlankNodePunctuation(token) {\n      var next;\n      switch (token.type) {\n        // Semicolon means the subject is shared; predicate and object are different\n        case ';':\n          next = this._readPredicate;\n          break;\n        // Comma means both the subject and predicate are shared; the object is different\n        case ',':\n          next = this._readObject;\n          break;\n        default:\n          return this._error(\"Expected punctuation to follow \\\"\".concat(this._object.id, \"\\\"\"), token);\n      }\n      // A quad has been completed now, so return it\n      this._emit(this._subject, this._predicate, this._object, this._graph);\n      return next;\n    }\n\n    // ### `_readQuadPunctuation` reads punctuation after a quad\n  }, {\n    key: \"_readQuadPunctuation\",\n    value: function _readQuadPunctuation(token) {\n      if (token.type !== '.') return this._error('Expected dot to follow quad', token);\n      return this._readInTopContext;\n    }\n\n    // ### `_readPrefix` reads the prefix of a prefix declaration\n  }, {\n    key: \"_readPrefix\",\n    value: function _readPrefix(token) {\n      if (token.type !== 'prefix') return this._error('Expected prefix to follow @prefix', token);\n      this._prefix = token.value;\n      return this._readPrefixIRI;\n    }\n\n    // ### `_readPrefixIRI` reads the IRI of a prefix declaration\n  }, {\n    key: \"_readPrefixIRI\",\n    value: function _readPrefixIRI(token) {\n      if (token.type !== 'IRI') return this._error(\"Expected IRI to follow prefix \\\"\".concat(this._prefix, \":\\\"\"), token);\n      var prefixNode = this._readEntity(token);\n      this._prefixes[this._prefix] = prefixNode.value;\n      this._prefixCallback(this._prefix, prefixNode);\n      return this._readDeclarationPunctuation;\n    }\n\n    // ### `_readBaseIRI` reads the IRI of a base declaration\n  }, {\n    key: \"_readBaseIRI\",\n    value: function _readBaseIRI(token) {\n      var iri = token.type === 'IRI' && this._resolveIRI(token.value);\n      if (!iri) return this._error('Expected valid IRI to follow base declaration', token);\n      this._setBase(iri);\n      return this._readDeclarationPunctuation;\n    }\n\n    // ### `_readNamedGraphLabel` reads the label of a named graph\n  }, {\n    key: \"_readNamedGraphLabel\",\n    value: function _readNamedGraphLabel(token) {\n      switch (token.type) {\n        case 'IRI':\n        case 'blank':\n        case 'prefixed':\n          return this._readSubject(token), this._readGraph;\n        case '[':\n          return this._readNamedGraphBlankLabel;\n        default:\n          return this._error('Invalid graph label', token);\n      }\n    }\n\n    // ### `_readNamedGraphLabel` reads a blank node label of a named graph\n  }, {\n    key: \"_readNamedGraphBlankLabel\",\n    value: function _readNamedGraphBlankLabel(token) {\n      if (token.type !== ']') return this._error('Invalid graph label', token);\n      this._subject = this._blankNode();\n      return this._readGraph;\n    }\n\n    // ### `_readDeclarationPunctuation` reads the punctuation of a declaration\n  }, {\n    key: \"_readDeclarationPunctuation\",\n    value: function _readDeclarationPunctuation(token) {\n      // SPARQL-style declarations don't have punctuation\n      if (this._sparqlStyle) {\n        this._sparqlStyle = false;\n        return this._readInTopContext(token);\n      }\n      if (token.type !== '.') return this._error('Expected declaration to end with a dot', token);\n      return this._readInTopContext;\n    }\n\n    // Reads a list of quantified symbols from a @forSome or @forAll statement\n  }, {\n    key: \"_readQuantifierList\",\n    value: function _readQuantifierList(token) {\n      var entity;\n      switch (token.type) {\n        case 'IRI':\n        case 'prefixed':\n          if ((entity = this._readEntity(token, true)) !== undefined) break;\n        default:\n          return this._error(\"Unexpected \".concat(token.type), token);\n      }\n      // Without explicit quantifiers, map entities to a quantified entity\n      if (!this._explicitQuantifiers) this._quantified[entity.id] = this._quantifier(this._blankNode().value);\n      // With explicit quantifiers, output the reified quantifier\n      else {\n        // If this is the first item, start a new quantifier list\n        if (this._subject === null) this._emit(this._graph || this.DEFAULTGRAPH, this._predicate, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);\n        // Otherwise, continue the previous list\n        else this._emit(this._subject, this.RDF_REST, this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);\n        // Output the list item\n        this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);\n      }\n      return this._readQuantifierPunctuation;\n    }\n\n    // Reads punctuation from a @forSome or @forAll statement\n  }, {\n    key: \"_readQuantifierPunctuation\",\n    value: function _readQuantifierPunctuation(token) {\n      // Read more quantifiers\n      if (token.type === ',') return this._readQuantifierList;\n      // End of the quantifier list\n      else {\n        // With explicit quantifiers, close the quantifier list\n        if (this._explicitQuantifiers) {\n          this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);\n          this._subject = null;\n        }\n        // Read a dot\n        this._readCallback = this._getContextEndReader();\n        return this._readCallback(token);\n      }\n    }\n\n    // ### `_getPathReader` reads a potential path and then resumes with the given function\n  }, {\n    key: \"_getPathReader\",\n    value: function _getPathReader(afterPath) {\n      this._afterPath = afterPath;\n      return this._readPath;\n    }\n\n    // ### `_readPath` reads a potential path\n  }, {\n    key: \"_readPath\",\n    value: function _readPath(token) {\n      switch (token.type) {\n        // Forward path\n        case '!':\n          return this._readForwardPath;\n        // Backward path\n        case '^':\n          return this._readBackwardPath;\n        // Not a path; resume reading where we left off\n        default:\n          var stack = this._contextStack,\n            parent = stack.length && stack[stack.length - 1];\n          // If we were reading a list item, we still need to output it\n          if (parent && parent.type === 'item') {\n            // The list item is the remaining subejct after reading the path\n            var item = this._subject;\n            // Switch back to the context of the list\n            this._restoreContext('item', token);\n            // Output the list item\n            this._emit(this._subject, this.RDF_FIRST, item, this._graph);\n          }\n          return this._afterPath(token);\n      }\n    }\n\n    // ### `_readForwardPath` reads a '!' path\n  }, {\n    key: \"_readForwardPath\",\n    value: function _readForwardPath(token) {\n      var subject, predicate;\n      var object = this._blankNode();\n      // The next token is the predicate\n      if ((predicate = this._readEntity(token)) === undefined) return;\n      // If we were reading a subject, replace the subject by the path's object\n      if (this._predicate === null) subject = this._subject, this._subject = object;\n      // If we were reading an object, replace the subject by the path's object\n      else subject = this._object, this._object = object;\n      // Emit the path's current quad and read its next section\n      this._emit(subject, predicate, object, this._graph);\n      return this._readPath;\n    }\n\n    // ### `_readBackwardPath` reads a '^' path\n  }, {\n    key: \"_readBackwardPath\",\n    value: function _readBackwardPath(token) {\n      var subject = this._blankNode();\n      var predicate, object;\n      // The next token is the predicate\n      if ((predicate = this._readEntity(token)) === undefined) return;\n      // If we were reading a subject, replace the subject by the path's subject\n      if (this._predicate === null) object = this._subject, this._subject = subject;\n      // If we were reading an object, replace the subject by the path's subject\n      else object = this._object, this._object = subject;\n      // Emit the path's current quad and read its next section\n      this._emit(subject, predicate, object, this._graph);\n      return this._readPath;\n    }\n\n    // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF* quad or the end of a nested RDF* triple\n  }, {\n    key: \"_readRDFStarTailOrGraph\",\n    value: function _readRDFStarTailOrGraph(token) {\n      if (token.type !== '>>') {\n        // An entity means this is a quad (only allowed if not already inside a graph)\n        if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== undefined) return this._readRDFStarTail;\n        return this._error(\"Expected >> to follow \\\"\".concat(this._object.id, \"\\\"\"), token);\n      }\n      return this._readRDFStarTail(token);\n    }\n\n    // ### `_readRDFStarTail` reads the end of a nested RDF* triple\n  }, {\n    key: \"_readRDFStarTail\",\n    value: function _readRDFStarTail(token) {\n      if (token.type !== '>>') return this._error(\"Expected >> but got \".concat(token.type), token);\n      // Read the quad and restore the previous context\n      var quad = this._quad(this._subject, this._predicate, this._object, this._graph || this.DEFAULTGRAPH);\n      this._restoreContext('<<', token);\n      // If the triple was the subject, continue by reading the predicate.\n      if (this._subject === null) {\n        this._subject = quad;\n        return this._readPredicate;\n      }\n      // If the triple was the object, read context end.\n      else {\n        this._object = quad;\n        return this._getContextEndReader();\n      }\n    }\n\n    // ### `_getContextEndReader` gets the next reader function at the end of a context\n  }, {\n    key: \"_getContextEndReader\",\n    value: function _getContextEndReader() {\n      var contextStack = this._contextStack;\n      if (!contextStack.length) return this._readPunctuation;\n      switch (contextStack[contextStack.length - 1].type) {\n        case 'blank':\n          return this._readBlankNodeTail;\n        case 'list':\n          return this._readListItem;\n        case 'formula':\n          return this._readFormulaTail;\n        case '<<':\n          return this._readRDFStarTailOrGraph;\n      }\n    }\n\n    // ### `_emit` sends a quad through the callback\n  }, {\n    key: \"_emit\",\n    value: function _emit(subject, predicate, object, graph) {\n      this._callback(null, this._quad(subject, predicate, object, graph || this.DEFAULTGRAPH));\n    }\n\n    // ### `_error` emits an error message through the callback\n  }, {\n    key: \"_error\",\n    value: function _error(message, token) {\n      var err = new Error(\"\".concat(message, \" on line \").concat(token.line, \".\"));\n      err.context = {\n        token: token,\n        line: token.line,\n        previousToken: this._lexer.previousToken\n      };\n      this._callback(err);\n      this._callback = noop;\n    }\n\n    // ### `_resolveIRI` resolves an IRI against the base path\n  }, {\n    key: \"_resolveIRI\",\n    value: function _resolveIRI(iri) {\n      return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);\n    }\n\n    // ### `_resolveRelativeIRI` resolves an IRI against the base path,\n    // assuming that a base path has been set and that the IRI is indeed relative\n  }, {\n    key: \"_resolveRelativeIRI\",\n    value: function _resolveRelativeIRI(iri) {\n      // An empty relative IRI indicates the base IRI\n      if (!iri.length) return this._base;\n      // Decide resolving strategy based in the first character\n      switch (iri[0]) {\n        // Resolve relative fragment IRIs against the base IRI\n        case '#':\n          return this._base + iri;\n        // Resolve relative query string IRIs by replacing the query string\n        case '?':\n          return this._base.replace(/(?:\\?.*)?$/, iri);\n        // Resolve root-relative IRIs at the root of the base IRI\n        case '/':\n          // Resolve scheme-relative IRIs to the scheme\n          return (iri[1] === '/' ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);\n        // Resolve all other IRIs at the base IRI's path\n        default:\n          // Relative IRIs cannot contain a colon in the first path segment\n          return /^[^/:]*:/.test(iri) ? null : this._removeDotSegments(this._basePath + iri);\n      }\n    }\n\n    // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986\n  }, {\n    key: \"_removeDotSegments\",\n    value: function _removeDotSegments(iri) {\n      // Don't modify the IRI if it does not contain any dot segments\n      if (!/(^|\\/)\\.\\.?($|[/#?])/.test(iri)) return iri;\n\n      // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n      var length = iri.length;\n      var result = '',\n        i = -1,\n        pathStart = -1,\n        segmentStart = 0,\n        next = '/';\n      while (i < length) {\n        switch (next) {\n          // The path starts with the first slash after the authority\n          case ':':\n            if (pathStart < 0) {\n              // Skip two slashes before the authority\n              if (iri[++i] === '/' && iri[++i] === '/')\n                // Skip to slash after the authority\n                while ((pathStart = i + 1) < length && iri[pathStart] !== '/') i = pathStart;\n            }\n            break;\n          // Don't modify a query string or fragment\n          case '?':\n          case '#':\n            i = length;\n            break;\n          // Handle '/.' or '/..' path segments\n          case '/':\n            if (iri[i + 1] === '.') {\n              next = iri[++i + 1];\n              switch (next) {\n                // Remove a '/.' segment\n                case '/':\n                  result += iri.substring(segmentStart, i - 1);\n                  segmentStart = i + 1;\n                  break;\n                // Remove a trailing '/.' segment\n                case undefined:\n                case '?':\n                case '#':\n                  return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n                // Remove a '/..' segment\n                case '.':\n                  next = iri[++i + 1];\n                  if (next === undefined || next === '/' || next === '?' || next === '#') {\n                    result += iri.substring(segmentStart, i - 2);\n                    // Try to remove the parent path from result\n                    if ((segmentStart = result.lastIndexOf('/')) >= pathStart) result = result.substr(0, segmentStart);\n                    // Remove a trailing '/..' segment\n                    if (next !== '/') return \"\".concat(result, \"/\").concat(iri.substr(i + 1));\n                    segmentStart = i + 1;\n                  }\n              }\n            }\n        }\n        next = iri[++i];\n      }\n      return result + iri.substring(segmentStart);\n    }\n\n    // ## Public methods\n\n    // ### `parse` parses the N3 input and emits each parsed quad through the callback\n  }, {\n    key: \"parse\",\n    value: function parse(input, quadCallback, prefixCallback) {\n      var _this = this;\n      // The read callback is the next function to be executed when a token arrives.\n      // We start reading in the top context.\n      this._readCallback = this._readInTopContext;\n      this._sparqlStyle = false;\n      this._prefixes = Object.create(null);\n      this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2) : \"b\".concat(blankNodePrefix++, \"_\");\n      this._prefixCallback = prefixCallback || noop;\n      this._inversePredicate = false;\n      this._quantified = Object.create(null);\n\n      // Parse synchronously if no quad callback is given\n      if (!quadCallback) {\n        var quads = [];\n        var error;\n        this._callback = function (e, t) {\n          e ? error = e : t && quads.push(t);\n        };\n        this._lexer.tokenize(input).every(function (token) {\n          return _this._readCallback = _this._readCallback(token);\n        });\n        if (error) throw error;\n        return quads;\n      }\n\n      // Parse asynchronously otherwise, executing the read callback when a token arrives\n      this._callback = quadCallback;\n      this._lexer.tokenize(input, function (error, token) {\n        if (error !== null) _this._callback(error), _this._callback = noop;else if (_this._readCallback) _this._readCallback = _this._readCallback(token);\n      });\n    }\n  }], [{\n    key: \"_resetBlankNodePrefix\",\n    value: function _resetBlankNodePrefix() {\n      blankNodePrefix = 0;\n    }\n  }]);\n  return N3Parser;\n}(); // The empty function\nexport { N3Parser as default };\nfunction noop() {}\n\n// Initializes the parser with the given data factory\nfunction initDataFactory(parser, factory) {\n  // Set factory methods\n  var namedNode = factory.namedNode;\n  parser._namedNode = namedNode;\n  parser._blankNode = factory.blankNode;\n  parser._literal = factory.literal;\n  parser._variable = factory.variable;\n  parser._quad = factory.quad;\n  parser.DEFAULTGRAPH = factory.defaultGraph();\n\n  // Set common named nodes\n  parser.RDF_FIRST = namedNode(namespaces.rdf.first);\n  parser.RDF_REST = namedNode(namespaces.rdf.rest);\n  parser.RDF_NIL = namedNode(namespaces.rdf.nil);\n  parser.N3_FORALL = namedNode(namespaces.r.forAll);\n  parser.N3_FORSOME = namedNode(namespaces.r.forSome);\n  parser.ABBREVIATIONS = {\n    'a': namedNode(namespaces.rdf.type),\n    '=': namedNode(namespaces.owl.sameAs),\n    '>': namedNode(namespaces.log.implies)\n  };\n  parser.QUANTIFIERS_GRAPH = namedNode('urn:n3:quantifiers');\n}\ninitDataFactory(N3Parser.prototype, N3DataFactory);","map":{"version":3,"names":["N3Lexer","N3DataFactory","namespaces","blankNodePrefix","N3Parser","options","_contextStack","_graph","_setBase","baseIRI","factory","initDataFactory","format","match","toLowerCase","isTurtle","test","isTriG","isNTriples","isNQuads","isN3","_n3Mode","isLineMode","_supportsNamedGraphs","_readPredicateOrNamedGraph","_readPredicate","_supportsQuads","_supportsRDFStar","_resolveRelativeIRI","iri","_blankNodePrefix","replace","_lexer","lexer","lineMode","n3","_explicitQuantifiers","explicitQuantifiers","_base","_basePath","fragmentPos","indexOf","substr","_baseRoot","_baseScheme","type","graph","subject","predicate","object","n3Mode","push","inverse","_inversePredicate","blankPrefix","_prefixes","_","quantified","_quantified","id","Object","create","token","context","pop","_error","_subject","_predicate","_object","_callback","_sparqlStyle","_readPrefix","_readBaseIRI","_readSubject","_readNamedGraphLabel","quantifier","value","_resolveIRI","_namedNode","prefix","undefined","_blankNode","_variable","_saveContext","_readBlankNodeHead","RDF_NIL","_readListItem","_readPunctuation","N3_FORSOME","_quantifier","_readQuantifierList","N3_FORALL","length","_literalValue","_completeSubjectLiteral","_literal","_readEntity","_getPathReader","ABBREVIATIONS","_readBlankNodeTail","_readObject","_readDataTypeOrLang","_getContextEndReader","_readGraph","_readBlankNodePunctuation","_emit","empty","_restoreContext","_readPredicateAfterBlank","item","list","next","previousList","stack","parent","RDF_FIRST","_readListItemDataTypeOrLang","RDF_REST","_completeObjectLiteral","literal","datatype","_completeLiteral","listItem","completed","_readCallback","inversePredicate","_readFormulaTail","_readInTopContext","_readQuadPunctuation","_prefix","_readPrefixIRI","prefixNode","_prefixCallback","_readDeclarationPunctuation","_readNamedGraphBlankLabel","entity","DEFAULTGRAPH","QUANTIFIERS_GRAPH","_readQuantifierPunctuation","afterPath","_afterPath","_readPath","_readForwardPath","_readBackwardPath","_readRDFStarTail","quad","_quad","contextStack","_readRDFStarTailOrGraph","message","err","Error","line","previousToken","noop","_removeDotSegments","result","i","pathStart","segmentStart","substring","lastIndexOf","input","quadCallback","prefixCallback","quads","error","e","t","tokenize","every","parser","namedNode","blankNode","variable","defaultGraph","rdf","first","rest","nil","r","forAll","forSome","owl","sameAs","log","implies","prototype"],"sources":["E:/react-todo-app/node_modules/n3/src/N3Parser.js"],"sourcesContent":["// **N3Parser** parses N3 documents.\nimport N3Lexer from './N3Lexer';\nimport N3DataFactory from './N3DataFactory';\nimport namespaces from './IRIs';\n\nlet blankNodePrefix = 0;\n\n// ## Constructor\nexport default class N3Parser {\n  constructor(options) {\n    this._contextStack = [];\n    this._graph = null;\n\n    // Set the document IRI\n    options = options || {};\n    this._setBase(options.baseIRI);\n    options.factory && initDataFactory(this, options.factory);\n\n    // Set supported features depending on the format\n    const format = (typeof options.format === 'string') ?\n                 options.format.match(/\\w*$/)[0].toLowerCase() : '',\n        isTurtle = /turtle/.test(format), isTriG = /trig/.test(format),\n        isNTriples = /triple/.test(format), isNQuads = /quad/.test(format),\n        isN3 = this._n3Mode = /n3/.test(format),\n        isLineMode = isNTriples || isNQuads;\n    if (!(this._supportsNamedGraphs = !(isTurtle || isN3)))\n      this._readPredicateOrNamedGraph = this._readPredicate;\n    // Support triples in other graphs\n    this._supportsQuads = !(isTurtle || isTriG || isNTriples || isN3);\n    // Support nesting of triples\n    this._supportsRDFStar = format === '' || /star|\\*$/.test(format);\n    // Disable relative IRIs in N-Triples or N-Quads mode\n    if (isLineMode)\n      this._resolveRelativeIRI = iri => { return null; };\n    this._blankNodePrefix = typeof options.blankNodePrefix !== 'string' ? '' :\n                              options.blankNodePrefix.replace(/^(?!_:)/, '_:');\n    this._lexer = options.lexer || new N3Lexer({ lineMode: isLineMode, n3: isN3 });\n    // Disable explicit quantifiers by default\n    this._explicitQuantifiers = !!options.explicitQuantifiers;\n  }\n\n  // ## Static class methods\n\n  // ### `_resetBlankNodePrefix` restarts blank node prefix identification\n  static _resetBlankNodePrefix() {\n    blankNodePrefix = 0;\n  }\n\n  // ## Private methods\n\n  // ### `_setBase` sets the base IRI to resolve relative IRIs\n  _setBase(baseIRI) {\n    if (!baseIRI) {\n      this._base = '';\n      this._basePath = '';\n    }\n    else {\n      // Remove fragment if present\n      const fragmentPos = baseIRI.indexOf('#');\n      if (fragmentPos >= 0)\n        baseIRI = baseIRI.substr(0, fragmentPos);\n      // Set base IRI and its components\n      this._base = baseIRI;\n      this._basePath   = baseIRI.indexOf('/') < 0 ? baseIRI :\n                         baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');\n      baseIRI = baseIRI.match(/^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i);\n      this._baseRoot   = baseIRI[0];\n      this._baseScheme = baseIRI[1];\n    }\n  }\n\n  // ### `_saveContext` stores the current parsing context\n  // when entering a new scope (list, blank node, formula)\n  _saveContext(type, graph, subject, predicate, object) {\n    const n3Mode = this._n3Mode;\n    this._contextStack.push({\n      type,\n      subject, predicate, object, graph,\n      inverse: n3Mode ? this._inversePredicate : false,\n      blankPrefix: n3Mode ? this._prefixes._ : '',\n      quantified: n3Mode ? this._quantified : null,\n    });\n    // The settings below only apply to N3 streams\n    if (n3Mode) {\n      // Every new scope resets the predicate direction\n      this._inversePredicate = false;\n      // In N3, blank nodes are scoped to a formula\n      // (using a dot as separator, as a blank node label cannot start with it)\n      this._prefixes._ = (this._graph ? `${this._graph.id.substr(2)}.` : '.');\n      // Quantifiers are scoped to a formula\n      this._quantified = Object.create(this._quantified);\n    }\n  }\n\n  // ### `_restoreContext` restores the parent context\n  // when leaving a scope (list, blank node, formula)\n  _restoreContext(type, token) {\n    // Obtain the previous context\n    const context = this._contextStack.pop();\n    if (!context || context.type !== type)\n      return this._error(`Unexpected ${token.type}`, token);\n\n    // Restore the quad of the previous context\n    this._subject   = context.subject;\n    this._predicate = context.predicate;\n    this._object    = context.object;\n    this._graph     = context.graph;\n\n    // Restore N3 context settings\n    if (this._n3Mode) {\n      this._inversePredicate = context.inverse;\n      this._prefixes._ = context.blankPrefix;\n      this._quantified = context.quantified;\n    }\n  }\n\n  // ### `_readInTopContext` reads a token when in the top context\n  _readInTopContext(token) {\n    switch (token.type) {\n    // If an EOF token arrives in the top context, signal that we're done\n    case 'eof':\n      if (this._graph !== null)\n        return this._error('Unclosed graph', token);\n      delete this._prefixes._;\n      return this._callback(null, null, this._prefixes);\n    // It could be a prefix declaration\n    case 'PREFIX':\n      this._sparqlStyle = true;\n    case '@prefix':\n      return this._readPrefix;\n    // It could be a base declaration\n    case 'BASE':\n      this._sparqlStyle = true;\n    case '@base':\n      return this._readBaseIRI;\n    // It could be a graph\n    case '{':\n      if (this._supportsNamedGraphs) {\n        this._graph = '';\n        this._subject = null;\n        return this._readSubject;\n      }\n    case 'GRAPH':\n      if (this._supportsNamedGraphs)\n        return this._readNamedGraphLabel;\n    // Otherwise, the next token must be a subject\n    default:\n      return this._readSubject(token);\n    }\n  }\n\n  // ### `_readEntity` reads an IRI, prefixed name, blank node, or variable\n  _readEntity(token, quantifier) {\n    let value;\n    switch (token.type) {\n    // Read a relative or absolute IRI\n    case 'IRI':\n    case 'typeIRI':\n      const iri = this._resolveIRI(token.value);\n      if (iri === null)\n        return this._error('Invalid IRI', token);\n      value = this._namedNode(iri);\n      break;\n    // Read a prefixed name\n    case 'type':\n    case 'prefixed':\n      const prefix = this._prefixes[token.prefix];\n      if (prefix === undefined)\n        return this._error(`Undefined prefix \"${token.prefix}:\"`, token);\n      value = this._namedNode(prefix + token.value);\n      break;\n    // Read a blank node\n    case 'blank':\n      value = this._blankNode(this._prefixes[token.prefix] + token.value);\n      break;\n    // Read a variable\n    case 'var':\n      value = this._variable(token.value.substr(1));\n      break;\n    // Everything else is not an entity\n    default:\n      return this._error(`Expected entity but got ${token.type}`, token);\n    }\n    // In N3 mode, replace the entity if it is quantified\n    if (!quantifier && this._n3Mode && (value.id in this._quantified))\n      value = this._quantified[value.id];\n    return value;\n  }\n\n  // ### `_readSubject` reads a quad's subject\n  _readSubject(token) {\n    this._predicate = null;\n    switch (token.type) {\n    case '[':\n      // Start a new quad with a new blank node as subject\n      this._saveContext('blank', this._graph,\n                        this._subject = this._blankNode(), null, null);\n      return this._readBlankNodeHead;\n    case '(':\n      // Start a new list\n      this._saveContext('list', this._graph, this.RDF_NIL, null, null);\n      this._subject = null;\n      return this._readListItem;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph,\n                        this._graph = this._blankNode(), null, null);\n      return this._readSubject;\n    case '}':\n       // No subject; the graph in which we are reading is closed instead\n      return this._readPunctuation(token);\n    case '@forSome':\n      if (!this._n3Mode)\n        return this._error('Unexpected \"@forSome\"', token);\n      this._subject = null;\n      this._predicate = this.N3_FORSOME;\n      this._quantifier = this._blankNode;\n      return this._readQuantifierList;\n    case '@forAll':\n      if (!this._n3Mode)\n        return this._error('Unexpected \"@forAll\"', token);\n      this._subject = null;\n      this._predicate = this.N3_FORALL;\n      this._quantifier = this._variable;\n      return this._readQuantifierList;\n    case 'literal':\n      if (!this._n3Mode)\n        return this._error('Unexpected literal', token);\n\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        return this._completeSubjectLiteral;\n      }\n      else\n        this._subject = this._literal(token.value, this._namedNode(token.prefix));\n\n      break;\n    case '<<':\n      if (!this._supportsRDFStar)\n        return this._error('Unexpected RDF* syntax', token);\n      this._saveContext('<<', this._graph, null, null, null);\n      this._graph = null;\n      return this._readSubject;\n    default:\n      // Read the subject entity\n      if ((this._subject = this._readEntity(token)) === undefined)\n        return;\n      // In N3 mode, the subject might be a path\n      if (this._n3Mode)\n        return this._getPathReader(this._readPredicateOrNamedGraph);\n    }\n\n    // The next token must be a predicate,\n    // or, if the subject was actually a graph IRI, a named graph\n    return this._readPredicateOrNamedGraph;\n  }\n\n  // ### `_readPredicate` reads a quad's predicate\n  _readPredicate(token) {\n    const type = token.type;\n    switch (type) {\n    case 'inverse':\n      this._inversePredicate = true;\n    case 'abbreviation':\n      this._predicate = this.ABBREVIATIONS[token.value];\n      break;\n    case '.':\n    case ']':\n    case '}':\n      // Expected predicate didn't come, must have been trailing semicolon\n      if (this._predicate === null)\n        return this._error(`Unexpected ${type}`, token);\n      this._subject = null;\n      return type === ']' ? this._readBlankNodeTail(token) : this._readPunctuation(token);\n    case ';':\n      // Additional semicolons can be safely ignored\n      return this._predicate !== null ? this._readPredicate :\n             this._error('Expected predicate but got ;', token);\n    case '[':\n      if (this._n3Mode) {\n        // Start a new quad with a new blank node as subject\n        this._saveContext('blank', this._graph, this._subject,\n                          this._subject = this._blankNode(), null);\n        return this._readBlankNodeHead;\n      }\n    case 'blank':\n      if (!this._n3Mode)\n        return this._error('Disallowed blank node as predicate', token);\n    default:\n      if ((this._predicate = this._readEntity(token)) === undefined)\n        return;\n    }\n    // The next token must be an object\n    return this._readObject;\n  }\n\n  // ### `_readObject` reads a quad's object\n  _readObject(token) {\n    switch (token.type) {\n    case 'literal':\n      // Regular literal, can still get a datatype or language\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        return this._readDataTypeOrLang;\n      }\n      // Pre-datatyped string literal (prefix stores the datatype)\n      else\n        this._object = this._literal(token.value, this._namedNode(token.prefix));\n      break;\n    case '[':\n      // Start a new quad with a new blank node as subject\n      this._saveContext('blank', this._graph, this._subject, this._predicate,\n                        this._subject = this._blankNode());\n      return this._readBlankNodeHead;\n    case '(':\n      // Start a new list\n      this._saveContext('list', this._graph, this._subject, this._predicate, this.RDF_NIL);\n      this._subject = null;\n      return this._readListItem;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph, this._subject, this._predicate,\n                        this._graph = this._blankNode());\n      return this._readSubject;\n    case '<<':\n      if (!this._supportsRDFStar)\n        return this._error('Unexpected RDF* syntax', token);\n      this._saveContext('<<', this._graph, this._subject, this._predicate, null);\n      this._graph = null;\n      return this._readSubject;\n    default:\n      // Read the object entity\n      if ((this._object = this._readEntity(token)) === undefined)\n        return;\n      // In N3 mode, the object might be a path\n      if (this._n3Mode)\n        return this._getPathReader(this._getContextEndReader());\n    }\n    return this._getContextEndReader();\n  }\n\n  // ### `_readPredicateOrNamedGraph` reads a quad's predicate, or a named graph\n  _readPredicateOrNamedGraph(token) {\n    return token.type === '{' ? this._readGraph(token) : this._readPredicate(token);\n  }\n\n  // ### `_readGraph` reads a graph\n  _readGraph(token) {\n    if (token.type !== '{')\n      return this._error(`Expected graph but got ${token.type}`, token);\n    // The \"subject\" we read is actually the GRAPH's label\n    this._graph = this._subject, this._subject = null;\n    return this._readSubject;\n  }\n\n  // ### `_readBlankNodeHead` reads the head of a blank node\n  _readBlankNodeHead(token) {\n    if (token.type === ']') {\n      this._subject = null;\n      return this._readBlankNodeTail(token);\n    }\n    else {\n      this._predicate = null;\n      return this._readPredicate(token);\n    }\n  }\n\n  // ### `_readBlankNodeTail` reads the end of a blank node\n  _readBlankNodeTail(token) {\n    if (token.type !== ']')\n      return this._readBlankNodePunctuation(token);\n\n    // Store blank node quad\n    if (this._subject !== null)\n      this._emit(this._subject, this._predicate, this._object, this._graph);\n\n    // Restore the parent context containing this blank node\n    const empty = this._predicate === null;\n    this._restoreContext('blank', token);\n    // If the blank node was the object, restore previous context and read punctuation\n    if (this._object !== null)\n      return this._getContextEndReader();\n    // If the blank node was the predicate, continue reading the object\n    else if (this._predicate !== null)\n      return this._readObject;\n    // If the blank node was the subject, continue reading the predicate\n    else\n      // If the blank node was empty, it could be a named graph label\n      return empty ? this._readPredicateOrNamedGraph : this._readPredicateAfterBlank;\n  }\n\n  // ### `_readPredicateAfterBlank` reads a predicate after an anonymous blank node\n  _readPredicateAfterBlank(token) {\n    switch (token.type) {\n    case '.':\n    case '}':\n      // No predicate is coming if the triple is terminated here\n      this._subject = null;\n      return this._readPunctuation(token);\n    default:\n      return this._readPredicate(token);\n    }\n  }\n\n  // ### `_readListItem` reads items from a list\n  _readListItem(token) {\n    let item = null,                      // The item of the list\n        list = null,                      // The list itself\n        next = this._readListItem;        // The next function to execute\n    const previousList = this._subject,   // The previous list that contains this list\n        stack = this._contextStack,       // The stack of parent contexts\n        parent = stack[stack.length - 1]; // The parent containing the current list\n\n    switch (token.type) {\n    case '[':\n      // Stack the current list quad and start a new quad with a blank node as subject\n      this._saveContext('blank', this._graph,\n                        list = this._blankNode(), this.RDF_FIRST,\n                        this._subject = item = this._blankNode());\n      next = this._readBlankNodeHead;\n      break;\n    case '(':\n      // Stack the current list quad and start a new list\n      this._saveContext('list', this._graph,\n                        list = this._blankNode(), this.RDF_FIRST, this.RDF_NIL);\n      this._subject = null;\n      break;\n    case ')':\n      // Closing the list; restore the parent context\n      this._restoreContext('list', token);\n      // If this list is contained within a parent list, return the membership quad here.\n      // This will be `<parent list element> rdf:first <this list>.`.\n      if (stack.length !== 0 && stack[stack.length - 1].type === 'list')\n        this._emit(this._subject, this._predicate, this._object, this._graph);\n      // Was this list the parent's subject?\n      if (this._predicate === null) {\n        // The next token is the predicate\n        next = this._readPredicate;\n        // No list tail if this was an empty list\n        if (this._subject === this.RDF_NIL)\n          return next;\n      }\n      // The list was in the parent context's object\n      else {\n        next = this._getContextEndReader();\n        // No list tail if this was an empty list\n        if (this._object === this.RDF_NIL)\n          return next;\n      }\n      // Close the list by making the head nil\n      list = this.RDF_NIL;\n      break;\n    case 'literal':\n      // Regular literal, can still get a datatype or language\n      if (token.prefix.length === 0) {\n        this._literalValue = token.value;\n        next = this._readListItemDataTypeOrLang;\n      }\n      // Pre-datatyped string literal (prefix stores the datatype)\n      else {\n        item = this._literal(token.value, this._namedNode(token.prefix));\n        next = this._getContextEndReader();\n      }\n      break;\n    case '{':\n      // Start a new formula\n      if (!this._n3Mode)\n        return this._error('Unexpected graph', token);\n      this._saveContext('formula', this._graph, this._subject, this._predicate,\n                        this._graph = this._blankNode());\n      return this._readSubject;\n    default:\n      if ((item = this._readEntity(token)) === undefined)\n        return;\n    }\n\n     // Create a new blank node if no item head was assigned yet\n    if (list === null)\n      this._subject = list = this._blankNode();\n\n    // Is this the first element of the list?\n    if (previousList === null) {\n      // This list is either the subject or the object of its parent\n      if (parent.predicate === null)\n        parent.subject = list;\n      else\n        parent.object = list;\n    }\n    else {\n      // Continue the previous list with the current list\n      this._emit(previousList, this.RDF_REST, list, this._graph);\n    }\n    // If an item was read, add it to the list\n    if (item !== null) {\n      // In N3 mode, the item might be a path\n      if (this._n3Mode && (token.type === 'IRI' || token.type === 'prefixed')) {\n        // Create a new context to add the item's path\n        this._saveContext('item', this._graph, list, this.RDF_FIRST, item);\n        this._subject = item, this._predicate = null;\n        // _readPath will restore the context and output the item\n        return this._getPathReader(this._readListItem);\n      }\n      // Output the item\n      this._emit(list, this.RDF_FIRST, item, this._graph);\n    }\n    return next;\n  }\n\n  // ### `_readDataTypeOrLang` reads an _optional_ datatype or language\n  _readDataTypeOrLang(token) {\n    return this._completeObjectLiteral(token, false);\n  }\n\n\n  // ### `_readListItemDataTypeOrLang` reads an _optional_ datatype or language in a list\n  _readListItemDataTypeOrLang(token) {\n    return this._completeObjectLiteral(token, true);\n  }\n\n  // ### `_completeLiteral` completes a literal with an optional datatype or language\n  _completeLiteral(token) {\n    // Create a simple string literal by default\n    let literal = this._literal(this._literalValue);\n\n    switch (token.type) {\n    // Create a datatyped literal\n    case 'type':\n    case 'typeIRI':\n      const datatype = this._readEntity(token);\n      if (datatype === undefined) return; // No datatype means an error occurred\n      literal = this._literal(this._literalValue, datatype);\n      token = null;\n      break;\n    // Create a language-tagged string\n    case 'langcode':\n      literal = this._literal(this._literalValue, token.value);\n      token = null;\n      break;\n    }\n\n    return { token, literal };\n  }\n\n  // Completes a literal in subject position\n  _completeSubjectLiteral(token) {\n    this._subject = this._completeLiteral(token).literal;\n    return this._readPredicateOrNamedGraph;\n  }\n\n  // Completes a literal in object position\n  _completeObjectLiteral(token, listItem) {\n    const completed = this._completeLiteral(token);\n    if (!completed)\n      return;\n    this._object = completed.literal;\n\n    // If this literal was part of a list, write the item\n    // (we could also check the context stack, but passing in a flag is faster)\n    if (listItem)\n      this._emit(this._subject, this.RDF_FIRST, this._object, this._graph);\n    // If the token was consumed, continue with the rest of the input\n    if (completed.token === null)\n      return this._getContextEndReader();\n    // Otherwise, consume the token now\n    else {\n      this._readCallback = this._getContextEndReader();\n      return this._readCallback(completed.token);\n    }\n  }\n\n  // ### `_readFormulaTail` reads the end of a formula\n  _readFormulaTail(token) {\n    if (token.type !== '}')\n      return this._readPunctuation(token);\n\n    // Store the last quad of the formula\n    if (this._subject !== null)\n      this._emit(this._subject, this._predicate, this._object, this._graph);\n\n    // Restore the parent context containing this formula\n    this._restoreContext('formula', token);\n    // If the formula was the subject, continue reading the predicate.\n    // If the formula was the object, read punctuation.\n    return this._object === null ? this._readPredicate : this._getContextEndReader();\n  }\n\n  // ### `_readPunctuation` reads punctuation between quads or quad parts\n  _readPunctuation(token) {\n    let next, graph = this._graph;\n    const subject = this._subject, inversePredicate = this._inversePredicate;\n    switch (token.type) {\n    // A closing brace ends a graph\n    case '}':\n      if (this._graph === null)\n        return this._error('Unexpected graph closing', token);\n      if (this._n3Mode)\n        return this._readFormulaTail(token);\n      this._graph = null;\n    // A dot just ends the statement, without sharing anything with the next\n    case '.':\n      this._subject = null;\n      next = this._contextStack.length ? this._readSubject : this._readInTopContext;\n      if (inversePredicate) this._inversePredicate = false;\n      break;\n    // Semicolon means the subject is shared; predicate and object are different\n    case ';':\n      next = this._readPredicate;\n      break;\n    // Comma means both the subject and predicate are shared; the object is different\n    case ',':\n      next = this._readObject;\n      break;\n    default:\n      // An entity means this is a quad (only allowed if not already inside a graph)\n      if (this._supportsQuads && this._graph === null && (graph = this._readEntity(token)) !== undefined) {\n        next = this._readQuadPunctuation;\n        break;\n      }\n      return this._error(`Expected punctuation to follow \"${this._object.id}\"`, token);\n    }\n    // A quad has been completed now, so return it\n    if (subject !== null) {\n      const predicate = this._predicate, object = this._object;\n      if (!inversePredicate)\n        this._emit(subject, predicate, object,  graph);\n      else\n        this._emit(object,  predicate, subject, graph);\n    }\n    return next;\n  }\n\n    // ### `_readBlankNodePunctuation` reads punctuation in a blank node\n  _readBlankNodePunctuation(token) {\n    let next;\n    switch (token.type) {\n    // Semicolon means the subject is shared; predicate and object are different\n    case ';':\n      next = this._readPredicate;\n      break;\n    // Comma means both the subject and predicate are shared; the object is different\n    case ',':\n      next = this._readObject;\n      break;\n    default:\n      return this._error(`Expected punctuation to follow \"${this._object.id}\"`, token);\n    }\n    // A quad has been completed now, so return it\n    this._emit(this._subject, this._predicate, this._object, this._graph);\n    return next;\n  }\n\n  // ### `_readQuadPunctuation` reads punctuation after a quad\n  _readQuadPunctuation(token) {\n    if (token.type !== '.')\n      return this._error('Expected dot to follow quad', token);\n    return this._readInTopContext;\n  }\n\n  // ### `_readPrefix` reads the prefix of a prefix declaration\n  _readPrefix(token) {\n    if (token.type !== 'prefix')\n      return this._error('Expected prefix to follow @prefix', token);\n    this._prefix = token.value;\n    return this._readPrefixIRI;\n  }\n\n  // ### `_readPrefixIRI` reads the IRI of a prefix declaration\n  _readPrefixIRI(token) {\n    if (token.type !== 'IRI')\n      return this._error(`Expected IRI to follow prefix \"${this._prefix}:\"`, token);\n    const prefixNode = this._readEntity(token);\n    this._prefixes[this._prefix] = prefixNode.value;\n    this._prefixCallback(this._prefix, prefixNode);\n    return this._readDeclarationPunctuation;\n  }\n\n  // ### `_readBaseIRI` reads the IRI of a base declaration\n  _readBaseIRI(token) {\n    const iri = token.type === 'IRI' && this._resolveIRI(token.value);\n    if (!iri)\n      return this._error('Expected valid IRI to follow base declaration', token);\n    this._setBase(iri);\n    return this._readDeclarationPunctuation;\n  }\n\n  // ### `_readNamedGraphLabel` reads the label of a named graph\n  _readNamedGraphLabel(token) {\n    switch (token.type) {\n    case 'IRI':\n    case 'blank':\n    case 'prefixed':\n      return this._readSubject(token), this._readGraph;\n    case '[':\n      return this._readNamedGraphBlankLabel;\n    default:\n      return this._error('Invalid graph label', token);\n    }\n  }\n\n  // ### `_readNamedGraphLabel` reads a blank node label of a named graph\n  _readNamedGraphBlankLabel(token) {\n    if (token.type !== ']')\n      return this._error('Invalid graph label', token);\n    this._subject = this._blankNode();\n    return this._readGraph;\n  }\n\n  // ### `_readDeclarationPunctuation` reads the punctuation of a declaration\n  _readDeclarationPunctuation(token) {\n    // SPARQL-style declarations don't have punctuation\n    if (this._sparqlStyle) {\n      this._sparqlStyle = false;\n      return this._readInTopContext(token);\n    }\n\n    if (token.type !== '.')\n      return this._error('Expected declaration to end with a dot', token);\n    return this._readInTopContext;\n  }\n\n  // Reads a list of quantified symbols from a @forSome or @forAll statement\n  _readQuantifierList(token) {\n    let entity;\n    switch (token.type) {\n    case 'IRI':\n    case 'prefixed':\n      if ((entity = this._readEntity(token, true)) !== undefined)\n        break;\n    default:\n      return this._error(`Unexpected ${token.type}`, token);\n    }\n    // Without explicit quantifiers, map entities to a quantified entity\n    if (!this._explicitQuantifiers)\n      this._quantified[entity.id] = this._quantifier(this._blankNode().value);\n    // With explicit quantifiers, output the reified quantifier\n    else {\n      // If this is the first item, start a new quantifier list\n      if (this._subject === null)\n        this._emit(this._graph || this.DEFAULTGRAPH, this._predicate,\n                   this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);\n      // Otherwise, continue the previous list\n      else\n        this._emit(this._subject, this.RDF_REST,\n                   this._subject = this._blankNode(), this.QUANTIFIERS_GRAPH);\n      // Output the list item\n      this._emit(this._subject, this.RDF_FIRST, entity, this.QUANTIFIERS_GRAPH);\n    }\n    return this._readQuantifierPunctuation;\n  }\n\n  // Reads punctuation from a @forSome or @forAll statement\n  _readQuantifierPunctuation(token) {\n    // Read more quantifiers\n    if (token.type === ',')\n      return this._readQuantifierList;\n    // End of the quantifier list\n    else {\n      // With explicit quantifiers, close the quantifier list\n      if (this._explicitQuantifiers) {\n        this._emit(this._subject, this.RDF_REST, this.RDF_NIL, this.QUANTIFIERS_GRAPH);\n        this._subject = null;\n      }\n      // Read a dot\n      this._readCallback = this._getContextEndReader();\n      return this._readCallback(token);\n    }\n  }\n\n  // ### `_getPathReader` reads a potential path and then resumes with the given function\n  _getPathReader(afterPath) {\n    this._afterPath = afterPath;\n    return this._readPath;\n  }\n\n  // ### `_readPath` reads a potential path\n  _readPath(token) {\n    switch (token.type) {\n    // Forward path\n    case '!': return this._readForwardPath;\n    // Backward path\n    case '^': return this._readBackwardPath;\n    // Not a path; resume reading where we left off\n    default:\n      const stack = this._contextStack, parent = stack.length && stack[stack.length - 1];\n      // If we were reading a list item, we still need to output it\n      if (parent && parent.type === 'item') {\n        // The list item is the remaining subejct after reading the path\n        const item = this._subject;\n        // Switch back to the context of the list\n        this._restoreContext('item', token);\n        // Output the list item\n        this._emit(this._subject, this.RDF_FIRST, item, this._graph);\n      }\n      return this._afterPath(token);\n    }\n  }\n\n  // ### `_readForwardPath` reads a '!' path\n  _readForwardPath(token) {\n    let subject, predicate;\n    const object = this._blankNode();\n    // The next token is the predicate\n    if ((predicate = this._readEntity(token)) === undefined)\n      return;\n    // If we were reading a subject, replace the subject by the path's object\n    if (this._predicate === null)\n      subject = this._subject, this._subject = object;\n    // If we were reading an object, replace the subject by the path's object\n    else\n      subject = this._object,  this._object  = object;\n    // Emit the path's current quad and read its next section\n    this._emit(subject, predicate, object, this._graph);\n    return this._readPath;\n  }\n\n  // ### `_readBackwardPath` reads a '^' path\n  _readBackwardPath(token) {\n    const subject = this._blankNode();\n    let predicate, object;\n    // The next token is the predicate\n    if ((predicate = this._readEntity(token)) === undefined)\n      return;\n    // If we were reading a subject, replace the subject by the path's subject\n    if (this._predicate === null)\n      object = this._subject, this._subject = subject;\n    // If we were reading an object, replace the subject by the path's subject\n    else\n      object = this._object,  this._object  = subject;\n    // Emit the path's current quad and read its next section\n    this._emit(subject, predicate, object, this._graph);\n    return this._readPath;\n  }\n\n  // ### `_readRDFStarTailOrGraph` reads the graph of a nested RDF* quad or the end of a nested RDF* triple\n  _readRDFStarTailOrGraph(token) {\n    if (token.type !== '>>') {\n      // An entity means this is a quad (only allowed if not already inside a graph)\n      if (this._supportsQuads && this._graph === null && (this._graph = this._readEntity(token)) !== undefined)\n        return this._readRDFStarTail;\n      return this._error(`Expected >> to follow \"${this._object.id}\"`, token);\n    }\n    return this._readRDFStarTail(token);\n  }\n\n  // ### `_readRDFStarTail` reads the end of a nested RDF* triple\n  _readRDFStarTail(token) {\n    if (token.type !== '>>')\n      return this._error(`Expected >> but got ${token.type}`, token);\n    // Read the quad and restore the previous context\n    const quad = this._quad(this._subject, this._predicate, this._object,\n      this._graph || this.DEFAULTGRAPH);\n    this._restoreContext('<<', token);\n    // If the triple was the subject, continue by reading the predicate.\n    if (this._subject === null) {\n      this._subject = quad;\n      return this._readPredicate;\n    }\n    // If the triple was the object, read context end.\n    else {\n      this._object = quad;\n      return this._getContextEndReader();\n    }\n  }\n\n  // ### `_getContextEndReader` gets the next reader function at the end of a context\n  _getContextEndReader() {\n    const contextStack = this._contextStack;\n    if (!contextStack.length)\n      return this._readPunctuation;\n\n    switch (contextStack[contextStack.length - 1].type) {\n    case 'blank':\n      return this._readBlankNodeTail;\n    case 'list':\n      return this._readListItem;\n    case 'formula':\n      return this._readFormulaTail;\n    case '<<':\n      return this._readRDFStarTailOrGraph;\n    }\n  }\n\n  // ### `_emit` sends a quad through the callback\n  _emit(subject, predicate, object, graph) {\n    this._callback(null, this._quad(subject, predicate, object, graph || this.DEFAULTGRAPH));\n  }\n\n  // ### `_error` emits an error message through the callback\n  _error(message, token) {\n    const err = new Error(`${message} on line ${token.line}.`);\n    err.context = {\n      token: token,\n      line: token.line,\n      previousToken: this._lexer.previousToken,\n    };\n    this._callback(err);\n    this._callback = noop;\n  }\n\n  // ### `_resolveIRI` resolves an IRI against the base path\n  _resolveIRI(iri) {\n    return /^[a-z][a-z0-9+.-]*:/i.test(iri) ? iri : this._resolveRelativeIRI(iri);\n  }\n\n  // ### `_resolveRelativeIRI` resolves an IRI against the base path,\n  // assuming that a base path has been set and that the IRI is indeed relative\n  _resolveRelativeIRI(iri) {\n    // An empty relative IRI indicates the base IRI\n    if (!iri.length)\n      return this._base;\n    // Decide resolving strategy based in the first character\n    switch (iri[0]) {\n    // Resolve relative fragment IRIs against the base IRI\n    case '#': return this._base + iri;\n    // Resolve relative query string IRIs by replacing the query string\n    case '?': return this._base.replace(/(?:\\?.*)?$/, iri);\n    // Resolve root-relative IRIs at the root of the base IRI\n    case '/':\n      // Resolve scheme-relative IRIs to the scheme\n      return (iri[1] === '/' ? this._baseScheme : this._baseRoot) + this._removeDotSegments(iri);\n    // Resolve all other IRIs at the base IRI's path\n    default:\n      // Relative IRIs cannot contain a colon in the first path segment\n      return (/^[^/:]*:/.test(iri)) ? null : this._removeDotSegments(this._basePath + iri);\n    }\n  }\n\n  // ### `_removeDotSegments` resolves './' and '../' path segments in an IRI as per RFC3986\n  _removeDotSegments(iri) {\n    // Don't modify the IRI if it does not contain any dot segments\n    if (!/(^|\\/)\\.\\.?($|[/#?])/.test(iri))\n      return iri;\n\n    // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'\n    const length = iri.length;\n    let result = '', i = -1, pathStart = -1, segmentStart = 0, next = '/';\n\n    while (i < length) {\n      switch (next) {\n      // The path starts with the first slash after the authority\n      case ':':\n        if (pathStart < 0) {\n          // Skip two slashes before the authority\n          if (iri[++i] === '/' && iri[++i] === '/')\n            // Skip to slash after the authority\n            while ((pathStart = i + 1) < length && iri[pathStart] !== '/')\n              i = pathStart;\n        }\n        break;\n      // Don't modify a query string or fragment\n      case '?':\n      case '#':\n        i = length;\n        break;\n      // Handle '/.' or '/..' path segments\n      case '/':\n        if (iri[i + 1] === '.') {\n          next = iri[++i + 1];\n          switch (next) {\n          // Remove a '/.' segment\n          case '/':\n            result += iri.substring(segmentStart, i - 1);\n            segmentStart = i + 1;\n            break;\n          // Remove a trailing '/.' segment\n          case undefined:\n          case '?':\n          case '#':\n            return result + iri.substring(segmentStart, i) + iri.substr(i + 1);\n          // Remove a '/..' segment\n          case '.':\n            next = iri[++i + 1];\n            if (next === undefined || next === '/' || next === '?' || next === '#') {\n              result += iri.substring(segmentStart, i - 2);\n              // Try to remove the parent path from result\n              if ((segmentStart = result.lastIndexOf('/')) >= pathStart)\n                result = result.substr(0, segmentStart);\n              // Remove a trailing '/..' segment\n              if (next !== '/')\n                return `${result}/${iri.substr(i + 1)}`;\n              segmentStart = i + 1;\n            }\n          }\n        }\n      }\n      next = iri[++i];\n    }\n    return result + iri.substring(segmentStart);\n  }\n\n  // ## Public methods\n\n  // ### `parse` parses the N3 input and emits each parsed quad through the callback\n  parse(input, quadCallback, prefixCallback) {\n    // The read callback is the next function to be executed when a token arrives.\n    // We start reading in the top context.\n    this._readCallback = this._readInTopContext;\n    this._sparqlStyle = false;\n    this._prefixes = Object.create(null);\n    this._prefixes._ = this._blankNodePrefix ? this._blankNodePrefix.substr(2)\n                                             : `b${blankNodePrefix++}_`;\n    this._prefixCallback = prefixCallback || noop;\n    this._inversePredicate = false;\n    this._quantified = Object.create(null);\n\n    // Parse synchronously if no quad callback is given\n    if (!quadCallback) {\n      const quads = [];\n      let error;\n      this._callback = (e, t) => { e ? (error = e) : t && quads.push(t); };\n      this._lexer.tokenize(input).every(token => {\n        return this._readCallback = this._readCallback(token);\n      });\n      if (error) throw error;\n      return quads;\n    }\n\n    // Parse asynchronously otherwise, executing the read callback when a token arrives\n    this._callback = quadCallback;\n    this._lexer.tokenize(input, (error, token) => {\n      if (error !== null)\n        this._callback(error), this._callback = noop;\n      else if (this._readCallback)\n        this._readCallback = this._readCallback(token);\n    });\n  }\n}\n\n// The empty function\nfunction noop() {}\n\n// Initializes the parser with the given data factory\nfunction initDataFactory(parser, factory) {\n  // Set factory methods\n  const namedNode = factory.namedNode;\n  parser._namedNode   = namedNode;\n  parser._blankNode   = factory.blankNode;\n  parser._literal     = factory.literal;\n  parser._variable    = factory.variable;\n  parser._quad        = factory.quad;\n  parser.DEFAULTGRAPH = factory.defaultGraph();\n\n  // Set common named nodes\n  parser.RDF_FIRST  = namedNode(namespaces.rdf.first);\n  parser.RDF_REST   = namedNode(namespaces.rdf.rest);\n  parser.RDF_NIL    = namedNode(namespaces.rdf.nil);\n  parser.N3_FORALL  = namedNode(namespaces.r.forAll);\n  parser.N3_FORSOME = namedNode(namespaces.r.forSome);\n  parser.ABBREVIATIONS = {\n    'a': namedNode(namespaces.rdf.type),\n    '=': namedNode(namespaces.owl.sameAs),\n    '>': namedNode(namespaces.log.implies),\n  };\n  parser.QUANTIFIERS_GRAPH = namedNode('urn:n3:quantifiers');\n}\ninitDataFactory(N3Parser.prototype, N3DataFactory);\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}