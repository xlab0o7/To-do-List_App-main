{"ast":null,"code":"import _classCallCheck from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n// **N3StreamParser** parses a text stream into a quad stream.\nimport N3Parser from './N3Parser';\nimport { Transform } from 'readable-stream';\n\n// ## Constructor\nvar N3StreamParser = /*#__PURE__*/function (_Transform) {\n  _inherits(N3StreamParser, _Transform);\n  var _super = _createSuper(N3StreamParser);\n  function N3StreamParser(options) {\n    var _this;\n    _classCallCheck(this, N3StreamParser);\n    _this = _super.call(this, {\n      decodeStrings: true\n    });\n    _this._readableState.objectMode = true;\n\n    // Set up parser with dummy stream to obtain `data` and `end` callbacks\n    var parser = new N3Parser(options);\n    var onData, onEnd;\n    parser.parse({\n      on: function on(event, callback) {\n        switch (event) {\n          case 'data':\n            onData = callback;\n            break;\n          case 'end':\n            onEnd = callback;\n            break;\n        }\n      }\n    },\n    // Handle quads by pushing them down the pipeline\n    function (error, quad) {\n      error && _this.emit('error', error) || quad && _this.push(quad);\n    },\n    // Emit prefixes through the `prefix` event\n    function (prefix, uri) {\n      _this.emit('prefix', prefix, uri);\n    });\n\n    // Implement Transform methods through parser callbacks\n    _this._transform = function (chunk, encoding, done) {\n      onData(chunk);\n      done();\n    };\n    _this._flush = function (done) {\n      onEnd();\n      done();\n    };\n    return _this;\n  }\n\n  // ### Parses a stream of strings\n  _createClass(N3StreamParser, [{\n    key: \"import\",\n    value: function _import(stream) {\n      var _this2 = this;\n      stream.on('data', function (chunk) {\n        _this2.write(chunk);\n      });\n      stream.on('end', function () {\n        _this2.end();\n      });\n      stream.on('error', function (error) {\n        _this2.emit('error', error);\n      });\n      return this;\n    }\n  }]);\n  return N3StreamParser;\n}(Transform);\nexport { N3StreamParser as default };","map":{"version":3,"names":["N3Parser","Transform","N3StreamParser","options","decodeStrings","_readableState","objectMode","parser","onData","onEnd","parse","on","event","callback","error","quad","emit","push","prefix","uri","_transform","chunk","encoding","done","_flush","stream","write","end"],"sources":["E:/react-todo-app/node_modules/n3/src/N3StreamParser.js"],"sourcesContent":["// **N3StreamParser** parses a text stream into a quad stream.\nimport N3Parser from './N3Parser';\nimport { Transform } from 'readable-stream';\n\n// ## Constructor\nexport default class N3StreamParser extends Transform {\n  constructor(options) {\n    super({ decodeStrings: true });\n    this._readableState.objectMode = true;\n\n    // Set up parser with dummy stream to obtain `data` and `end` callbacks\n    const parser = new N3Parser(options);\n    let onData, onEnd;\n    parser.parse({\n      on: (event, callback) => {\n        switch (event) {\n        case 'data': onData = callback; break;\n        case 'end':   onEnd = callback; break;\n        }\n      },\n    },\n      // Handle quads by pushing them down the pipeline\n      (error, quad) => { error && this.emit('error', error) || quad && this.push(quad); },\n      // Emit prefixes through the `prefix` event\n      (prefix, uri) => { this.emit('prefix', prefix, uri); }\n    );\n\n    // Implement Transform methods through parser callbacks\n    this._transform = (chunk, encoding, done) => { onData(chunk); done(); };\n    this._flush = done => { onEnd(); done(); };\n  }\n\n  // ### Parses a stream of strings\n  import(stream) {\n    stream.on('data',  chunk => { this.write(chunk); });\n    stream.on('end',   ()      => { this.end(); });\n    stream.on('error', error => { this.emit('error', error); });\n    return this;\n  }\n}\n"],"mappings":";;;;AAAA;AACA,OAAOA,QAAQ,MAAM,YAAY;AACjC,SAASC,SAAS,QAAQ,iBAAiB;;AAE3C;AAAA,IACqBC,cAAc;EAAA;EAAA;EACjC,wBAAYC,OAAO,EAAE;IAAA;IAAA;IACnB,0BAAM;MAAEC,aAAa,EAAE;IAAK,CAAC;IAC7B,MAAKC,cAAc,CAACC,UAAU,GAAG,IAAI;;IAErC;IACA,IAAMC,MAAM,GAAG,IAAIP,QAAQ,CAACG,OAAO,CAAC;IACpC,IAAIK,MAAM,EAAEC,KAAK;IACjBF,MAAM,CAACG,KAAK,CAAC;MACXC,EAAE,EAAE,YAACC,KAAK,EAAEC,QAAQ,EAAK;QACvB,QAAQD,KAAK;UACb,KAAK,MAAM;YAAEJ,MAAM,GAAGK,QAAQ;YAAE;UAChC,KAAK,KAAK;YAAIJ,KAAK,GAAGI,QAAQ;YAAE;QAAM;MAExC;IACF,CAAC;IACC;IACA,UAACC,KAAK,EAAEC,IAAI,EAAK;MAAED,KAAK,IAAI,MAAKE,IAAI,CAAC,OAAO,EAAEF,KAAK,CAAC,IAAIC,IAAI,IAAI,MAAKE,IAAI,CAACF,IAAI,CAAC;IAAE,CAAC;IACnF;IACA,UAACG,MAAM,EAAEC,GAAG,EAAK;MAAE,MAAKH,IAAI,CAAC,QAAQ,EAAEE,MAAM,EAAEC,GAAG,CAAC;IAAE,CAAC,CACvD;;IAED;IACA,MAAKC,UAAU,GAAG,UAACC,KAAK,EAAEC,QAAQ,EAAEC,IAAI,EAAK;MAAEf,MAAM,CAACa,KAAK,CAAC;MAAEE,IAAI,EAAE;IAAE,CAAC;IACvE,MAAKC,MAAM,GAAG,UAAAD,IAAI,EAAI;MAAEd,KAAK,EAAE;MAAEc,IAAI,EAAE;IAAE,CAAC;IAAC;EAC7C;;EAEA;EAAA;IAAA;IAAA,OACA,iBAAOE,MAAM,EAAE;MAAA;MACbA,MAAM,CAACd,EAAE,CAAC,MAAM,EAAG,UAAAU,KAAK,EAAI;QAAE,MAAI,CAACK,KAAK,CAACL,KAAK,CAAC;MAAE,CAAC,CAAC;MACnDI,MAAM,CAACd,EAAE,CAAC,KAAK,EAAI,YAAW;QAAE,MAAI,CAACgB,GAAG,EAAE;MAAE,CAAC,CAAC;MAC9CF,MAAM,CAACd,EAAE,CAAC,OAAO,EAAE,UAAAG,KAAK,EAAI;QAAE,MAAI,CAACE,IAAI,CAAC,OAAO,EAAEF,KAAK,CAAC;MAAE,CAAC,CAAC;MAC3D,OAAO,IAAI;IACb;EAAC;EAAA;AAAA,EAjCyCb,SAAS;AAAA,SAAhCC,cAAc"},"metadata":{},"sourceType":"module","externalDependencies":[]}