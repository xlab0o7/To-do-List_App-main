{"ast":null,"code":"import _classCallCheck from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n// **N3Lexer** tokenizes N3 documents.\nimport namespaces from './IRIs';\nimport queueMicrotask from 'queue-microtask';\nvar xsd = namespaces.xsd;\n\n// Regular expression and replacement string to escape N3 strings\nvar escapeSequence = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\([^])/g;\nvar escapeReplacements = {\n  '\\\\': '\\\\',\n  \"'\": \"'\",\n  '\"': '\"',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t',\n  'f': '\\f',\n  'b': '\\b',\n  '_': '_',\n  '~': '~',\n  '.': '.',\n  '-': '-',\n  '!': '!',\n  '$': '$',\n  '&': '&',\n  '(': '(',\n  ')': ')',\n  '*': '*',\n  '+': '+',\n  ',': ',',\n  ';': ';',\n  '=': '=',\n  '/': '/',\n  '?': '?',\n  '#': '#',\n  '@': '@',\n  '%': '%'\n};\nvar illegalIriChars = /[\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]/;\nvar lineModeRegExps = {\n  _iri: true,\n  _unescapedIri: true,\n  _simpleQuotedString: true,\n  _langcode: true,\n  _blank: true,\n  _newline: true,\n  _comment: true,\n  _whitespace: true,\n  _endOfFile: true\n};\nvar invalidRegExp = /$0^/;\n\n// ## Constructor\nvar N3Lexer = /*#__PURE__*/function () {\n  function N3Lexer(options) {\n    _classCallCheck(this, N3Lexer);\n    // ## Regular expressions\n    // It's slightly faster to have these as properties than as in-scope variables\n    this._iri = /^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/; // IRI with escape sequences; needs sanity check after unescaping\n    this._unescapedIri = /^<([^\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/; // IRI without escape sequences; no unescaping\n    this._simpleQuotedString = /^\"([^\"\\\\\\r\\n]*)\"(?=[^\"])/; // string without escape sequences\n    this._simpleApostropheString = /^'([^'\\\\\\r\\n]*)'(?=[^'])/;\n    this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\\-])/i;\n    this._prefix = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:(?=[#\\s<])/;\n    this._prefixed = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:((?:(?:[0-:A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])(?:(?:[\\.\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])*(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~]))?)?)(?:[ \\t]+|(?=\\.?[,;!\\^\\s#()\\[\\]\\{\\}\"'<>]))/;\n    this._variable = /^\\?(?:(?:[A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?=[.,;!\\^\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._blank = /^_:((?:[0-9A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?:[ \\t]+|(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>]))/;\n    this._number = /^[\\-+]?(?:(\\d+\\.\\d*|\\.?\\d+)[eE][\\-+]?|\\d*(\\.)?)\\d+(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._boolean = /^(?:true|false)(?=[.,;\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._keyword = /^@[a-z]+(?=[\\s#<:])/i;\n    this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\\s#<])/i;\n    this._shortPredicates = /^a(?=[\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._newline = /^[ \\t]*(?:#[^\\n\\r]*)?(?:\\r\\n|\\n|\\r)[ \\t]*/;\n    this._comment = /#([^\\n\\r]*)/;\n    this._whitespace = /^[ \\t]+/;\n    this._endOfFile = /^(?:#[^\\n\\r]*)?$/;\n    options = options || {};\n\n    // In line mode (N-Triples or N-Quads), only simple features may be parsed\n    if (this._lineMode = !!options.lineMode) {\n      this._n3Mode = false;\n      // Don't tokenize special literals\n      for (var key in this) {\n        if (!(key in lineModeRegExps) && this[key] instanceof RegExp) this[key] = invalidRegExp;\n      }\n    }\n    // When not in line mode, enable N3 functionality by default\n    else {\n      this._n3Mode = options.n3 !== false;\n    }\n    // Don't output comment tokens by default\n    this._comments = !!options.comments;\n    // Cache the last tested closing position of long literals\n    this._literalClosingPos = 0;\n  }\n\n  // ## Private methods\n\n  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback\n  _createClass(N3Lexer, [{\n    key: \"_tokenizeToEnd\",\n    value: function _tokenizeToEnd(callback, inputFinished) {\n      // Continue parsing as far as possible; the loop will return eventually\n      var input = this._input;\n      var currentLineLength = input.length;\n      while (true) {\n        // Count and skip whitespace lines\n        var whiteSpaceMatch = void 0,\n          comment = void 0;\n        while (whiteSpaceMatch = this._newline.exec(input)) {\n          // Try to find a comment\n          if (this._comments && (comment = this._comment.exec(whiteSpaceMatch[0]))) emitToken('comment', comment[1], '', this._line, whiteSpaceMatch[0].length);\n          // Advance the input\n          input = input.substr(whiteSpaceMatch[0].length, input.length);\n          currentLineLength = input.length;\n          this._line++;\n        }\n        // Skip whitespace on current line\n        if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input))) input = input.substr(whiteSpaceMatch[0].length, input.length);\n\n        // Stop for now if we're at the end\n        if (this._endOfFile.test(input)) {\n          // If the input is finished, emit EOF\n          if (inputFinished) {\n            // Try to find a final comment\n            if (this._comments && (comment = this._comment.exec(input))) emitToken('comment', comment[1], '', this._line, input.length);\n            input = null;\n            emitToken('eof', '', '', this._line, 0);\n          }\n          return this._input = input;\n        }\n\n        // Look for specific token types based on the first character\n        var line = this._line,\n          firstChar = input[0];\n        var type = '',\n          value = '',\n          prefix = '',\n          match = null,\n          matchLength = 0,\n          inconclusive = false;\n        switch (firstChar) {\n          case '^':\n            // We need at least 3 tokens lookahead to distinguish ^^<IRI> and ^^pre:fixed\n            if (input.length < 3) break;\n            // Try to match a type\n            else if (input[1] === '^') {\n              this._previousMarker = '^^';\n              // Move to type IRI or prefixed name\n              input = input.substr(2);\n              if (input[0] !== '<') {\n                inconclusive = true;\n                break;\n              }\n            }\n            // If no type, it must be a path expression\n            else {\n              if (this._n3Mode) {\n                matchLength = 1;\n                type = '^';\n              }\n              break;\n            }\n          // Fall through in case the type is an IRI\n          case '<':\n            // Try to find a full IRI without escape sequences\n            if (match = this._unescapedIri.exec(input)) type = 'IRI', value = match[1];\n            // Try to find a full IRI with escape sequences\n            else if (match = this._iri.exec(input)) {\n              value = this._unescape(match[1]);\n              if (value === null || illegalIriChars.test(value)) return reportSyntaxError(this);\n              type = 'IRI';\n            }\n            // Try to find a nested triple\n            else if (input.length > 1 && input[1] === '<') type = '<<', matchLength = 2;\n            // Try to find a backwards implication arrow\n            else if (this._n3Mode && input.length > 1 && input[1] === '=') type = 'inverse', matchLength = 2, value = '>';\n            break;\n          case '>':\n            if (input.length > 1 && input[1] === '>') type = '>>', matchLength = 2;\n            break;\n          case '_':\n            // Try to find a blank node. Since it can contain (but not end with) a dot,\n            // we always need a non-dot character before deciding it is a blank node.\n            // Therefore, try inserting a space if we're at the end of the input.\n            if ((match = this._blank.exec(input)) || inputFinished && (match = this._blank.exec(\"\".concat(input, \" \")))) type = 'blank', prefix = '_', value = match[1];\n            break;\n          case '\"':\n            // Try to find a literal without escape sequences\n            if (match = this._simpleQuotedString.exec(input)) value = match[1];\n            // Try to find a literal wrapped in three pairs of quotes\n            else {\n              var _this$_parseLiteral = this._parseLiteral(input);\n              value = _this$_parseLiteral.value;\n              matchLength = _this$_parseLiteral.matchLength;\n              if (value === null) return reportSyntaxError(this);\n            }\n            if (match !== null || matchLength !== 0) {\n              type = 'literal';\n              this._literalClosingPos = 0;\n            }\n            break;\n          case \"'\":\n            if (!this._lineMode) {\n              // Try to find a literal without escape sequences\n              if (match = this._simpleApostropheString.exec(input)) value = match[1];\n              // Try to find a literal wrapped in three pairs of quotes\n              else {\n                var _this$_parseLiteral2 = this._parseLiteral(input);\n                value = _this$_parseLiteral2.value;\n                matchLength = _this$_parseLiteral2.matchLength;\n                if (value === null) return reportSyntaxError(this);\n              }\n              if (match !== null || matchLength !== 0) {\n                type = 'literal';\n                this._literalClosingPos = 0;\n              }\n            }\n            break;\n          case '?':\n            // Try to find a variable\n            if (this._n3Mode && (match = this._variable.exec(input))) type = 'var', value = match[0];\n            break;\n          case '@':\n            // Try to find a language code\n            if (this._previousMarker === 'literal' && (match = this._langcode.exec(input))) type = 'langcode', value = match[1];\n            // Try to find a keyword\n            else if (match = this._keyword.exec(input)) type = match[0];\n            break;\n          case '.':\n            // Try to find a dot as punctuation\n            if (input.length === 1 ? inputFinished : input[1] < '0' || input[1] > '9') {\n              type = '.';\n              matchLength = 1;\n              break;\n            }\n          // Fall through to numerical case (could be a decimal dot)\n\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9':\n          case '+':\n          case '-':\n            // Try to find a number. Since it can contain (but not end with) a dot,\n            // we always need a non-dot character before deciding it is a number.\n            // Therefore, try inserting a space if we're at the end of the input.\n            if (match = this._number.exec(input) || inputFinished && (match = this._number.exec(\"\".concat(input, \" \")))) {\n              type = 'literal', value = match[0];\n              prefix = typeof match[1] === 'string' ? xsd.double : typeof match[2] === 'string' ? xsd.decimal : xsd.integer;\n            }\n            break;\n          case 'B':\n          case 'b':\n          case 'p':\n          case 'P':\n          case 'G':\n          case 'g':\n            // Try to find a SPARQL-style keyword\n            if (match = this._sparqlKeyword.exec(input)) type = match[0].toUpperCase();else inconclusive = true;\n            break;\n          case 'f':\n          case 't':\n            // Try to match a boolean\n            if (match = this._boolean.exec(input)) type = 'literal', value = match[0], prefix = xsd.boolean;else inconclusive = true;\n            break;\n          case 'a':\n            // Try to find an abbreviated predicate\n            if (match = this._shortPredicates.exec(input)) type = 'abbreviation', value = 'a';else inconclusive = true;\n            break;\n          case '=':\n            // Try to find an implication arrow or equals sign\n            if (this._n3Mode && input.length > 1) {\n              type = 'abbreviation';\n              if (input[1] !== '>') matchLength = 1, value = '=';else matchLength = 2, value = '>';\n            }\n            break;\n          case '!':\n            if (!this._n3Mode) break;\n          case ',':\n          case ';':\n          case '[':\n          case ']':\n          case '(':\n          case ')':\n          case '{':\n          case '}':\n            if (!this._lineMode) {\n              matchLength = 1;\n              type = firstChar;\n            }\n            break;\n          default:\n            inconclusive = true;\n        }\n\n        // Some first characters do not allow an immediate decision, so inspect more\n        if (inconclusive) {\n          // Try to find a prefix\n          if ((this._previousMarker === '@prefix' || this._previousMarker === 'PREFIX') && (match = this._prefix.exec(input))) type = 'prefix', value = match[1] || '';\n          // Try to find a prefixed name. Since it can contain (but not end with) a dot,\n          // we always need a non-dot character before deciding it is a prefixed name.\n          // Therefore, try inserting a space if we're at the end of the input.\n          else if ((match = this._prefixed.exec(input)) || inputFinished && (match = this._prefixed.exec(\"\".concat(input, \" \")))) type = 'prefixed', prefix = match[1] || '', value = this._unescape(match[2]);\n        }\n\n        // A type token is special: it can only be emitted after an IRI or prefixed name is read\n        if (this._previousMarker === '^^') {\n          switch (type) {\n            case 'prefixed':\n              type = 'type';\n              break;\n            case 'IRI':\n              type = 'typeIRI';\n              break;\n            default:\n              type = '';\n          }\n        }\n\n        // What if nothing of the above was found?\n        if (!type) {\n          // We could be in streaming mode, and then we just wait for more input to arrive.\n          // Otherwise, a syntax error has occurred in the input.\n          // One exception: error on an unaccounted linebreak (= not inside a triple-quoted literal).\n          if (inputFinished || !/^'''|^\"\"\"/.test(input) && /\\n|\\r/.test(input)) return reportSyntaxError(this);else return this._input = input;\n        }\n\n        // Emit the parsed token\n        var length = matchLength || match[0].length;\n        var token = emitToken(type, value, prefix, line, length);\n        this.previousToken = token;\n        this._previousMarker = type;\n\n        // Advance to next part to tokenize\n        input = input.substr(length, input.length);\n      }\n\n      // Emits the token through the callback\n      function emitToken(type, value, prefix, line, length) {\n        var start = input ? currentLineLength - input.length : currentLineLength;\n        var end = start + length;\n        var token = {\n          type: type,\n          value: value,\n          prefix: prefix,\n          line: line,\n          start: start,\n          end: end\n        };\n        callback(null, token);\n        return token;\n      }\n      // Signals the syntax error through the callback\n      function reportSyntaxError(self) {\n        callback(self._syntaxError(/^\\S*/.exec(input)[0]));\n      }\n    }\n\n    // ### `_unescape` replaces N3 escape codes by their corresponding characters\n  }, {\n    key: \"_unescape\",\n    value: function _unescape(item) {\n      var invalid = false;\n      var replaced = item.replace(escapeSequence, function (sequence, unicode4, unicode8, escapedChar) {\n        // 4-digit unicode character\n        if (typeof unicode4 === 'string') return String.fromCharCode(Number.parseInt(unicode4, 16));\n        // 8-digit unicode character\n        if (typeof unicode8 === 'string') {\n          var charCode = Number.parseInt(unicode8, 16);\n          return charCode <= 0xFFFF ? String.fromCharCode(Number.parseInt(unicode8, 16)) : String.fromCharCode(0xD800 + ((charCode -= 0x10000) >> 10), 0xDC00 + (charCode & 0x3FF));\n        }\n        // fixed escape sequence\n        if (escapedChar in escapeReplacements) return escapeReplacements[escapedChar];\n        // invalid escape sequence\n        invalid = true;\n        return '';\n      });\n      return invalid ? null : replaced;\n    }\n\n    // ### `_parseLiteral` parses a literal into an unescaped value\n  }, {\n    key: \"_parseLiteral\",\n    value: function _parseLiteral(input) {\n      // Ensure we have enough lookahead to identify triple-quoted strings\n      if (input.length >= 3) {\n        // Identify the opening quote(s)\n        var opening = input.match(/^(?:\"\"\"|\"|'''|'|)/)[0];\n        var openingLength = opening.length;\n\n        // Find the next candidate closing quotes\n        var closingPos = Math.max(this._literalClosingPos, openingLength);\n        while ((closingPos = input.indexOf(opening, closingPos)) > 0) {\n          // Count backslashes right before the closing quotes\n          var backslashCount = 0;\n          while (input[closingPos - backslashCount - 1] === '\\\\') backslashCount++;\n\n          // An even number of backslashes (in particular 0)\n          // means these are actual, non-escaped closing quotes\n          if (backslashCount % 2 === 0) {\n            // Extract and unescape the value\n            var raw = input.substring(openingLength, closingPos);\n            var lines = raw.split(/\\r\\n|\\r|\\n/).length - 1;\n            var matchLength = closingPos + openingLength;\n            // Only triple-quoted strings can be multi-line\n            if (openingLength === 1 && lines !== 0 || openingLength === 3 && this._lineMode) break;\n            this._line += lines;\n            return {\n              value: this._unescape(raw),\n              matchLength: matchLength\n            };\n          }\n          closingPos++;\n        }\n        this._literalClosingPos = input.length - openingLength + 1;\n      }\n      return {\n        value: '',\n        matchLength: 0\n      };\n    }\n\n    // ### `_syntaxError` creates a syntax error for the given issue\n  }, {\n    key: \"_syntaxError\",\n    value: function _syntaxError(issue) {\n      this._input = null;\n      var err = new Error(\"Unexpected \\\"\".concat(issue, \"\\\" on line \").concat(this._line, \".\"));\n      err.context = {\n        token: undefined,\n        line: this._line,\n        previousToken: this.previousToken\n      };\n      return err;\n    }\n\n    // ### Strips off any starting UTF BOM mark.\n  }, {\n    key: \"_readStartingBom\",\n    value: function _readStartingBom(input) {\n      return input.startsWith(\"\\uFEFF\") ? input.substr(1) : input;\n    }\n\n    // ## Public methods\n\n    // ### `tokenize` starts the transformation of an N3 document into an array of tokens.\n    // The input can be a string or a stream.\n  }, {\n    key: \"tokenize\",\n    value: function tokenize(input, callback) {\n      var _this = this;\n      this._line = 1;\n\n      // If the input is a string, continuously emit tokens through the callback until the end\n      if (typeof input === 'string') {\n        this._input = this._readStartingBom(input);\n        // If a callback was passed, asynchronously call it\n        if (typeof callback === 'function') queueMicrotask(function () {\n          return _this._tokenizeToEnd(callback, true);\n        });\n        // If no callback was passed, tokenize synchronously and return\n        else {\n          var tokens = [];\n          var error;\n          this._tokenizeToEnd(function (e, t) {\n            return e ? error = e : tokens.push(t);\n          }, true);\n          if (error) throw error;\n          return tokens;\n        }\n      }\n      // Otherwise, the input must be a stream\n      else {\n        this._pendingBuffer = null;\n        if (typeof input.setEncoding === 'function') input.setEncoding('utf8');\n        // Adds the data chunk to the buffer and parses as far as possible\n        input.on('data', function (data) {\n          if (_this._input !== null && data.length !== 0) {\n            // Prepend any previous pending writes\n            if (_this._pendingBuffer) {\n              data = Buffer.concat([_this._pendingBuffer, data]);\n              _this._pendingBuffer = null;\n            }\n            // Hold if the buffer ends in an incomplete unicode sequence\n            if (data[data.length - 1] & 0x80) {\n              _this._pendingBuffer = data;\n            }\n            // Otherwise, tokenize as far as possible\n            else {\n              // Only read a BOM at the start\n              if (typeof _this._input === 'undefined') _this._input = _this._readStartingBom(typeof data === 'string' ? data : data.toString());else _this._input += data;\n              _this._tokenizeToEnd(callback, false);\n            }\n          }\n        });\n        // Parses until the end\n        input.on('end', function () {\n          if (typeof _this._input === 'string') _this._tokenizeToEnd(callback, true);\n        });\n        input.on('error', callback);\n      }\n    }\n  }]);\n  return N3Lexer;\n}();\nexport { N3Lexer as default };","map":{"version":3,"names":["namespaces","queueMicrotask","xsd","escapeSequence","escapeReplacements","illegalIriChars","lineModeRegExps","_iri","_unescapedIri","_simpleQuotedString","_langcode","_blank","_newline","_comment","_whitespace","_endOfFile","invalidRegExp","N3Lexer","options","_simpleApostropheString","_prefix","_prefixed","_variable","_number","_boolean","_keyword","_sparqlKeyword","_shortPredicates","_lineMode","lineMode","_n3Mode","key","RegExp","n3","_comments","comments","_literalClosingPos","callback","inputFinished","input","_input","currentLineLength","length","whiteSpaceMatch","comment","exec","emitToken","_line","substr","test","line","firstChar","type","value","prefix","match","matchLength","inconclusive","_previousMarker","_unescape","reportSyntaxError","_parseLiteral","double","decimal","integer","toUpperCase","boolean","token","previousToken","start","end","self","_syntaxError","item","invalid","replaced","replace","sequence","unicode4","unicode8","escapedChar","String","fromCharCode","Number","parseInt","charCode","opening","openingLength","closingPos","Math","max","indexOf","backslashCount","raw","substring","lines","split","issue","err","Error","context","undefined","startsWith","_readStartingBom","_tokenizeToEnd","tokens","error","e","t","push","_pendingBuffer","setEncoding","on","data","Buffer","concat","toString"],"sources":["E:/react-todo-app/node_modules/n3/src/N3Lexer.js"],"sourcesContent":["// **N3Lexer** tokenizes N3 documents.\nimport namespaces from './IRIs';\nimport queueMicrotask from 'queue-microtask';\n\nconst { xsd } = namespaces;\n\n// Regular expression and replacement string to escape N3 strings\nconst escapeSequence = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\([^])/g;\nconst escapeReplacements = {\n  '\\\\': '\\\\', \"'\": \"'\", '\"': '\"',\n  'n': '\\n', 'r': '\\r', 't': '\\t', 'f': '\\f', 'b': '\\b',\n  '_': '_', '~': '~', '.': '.', '-': '-', '!': '!', '$': '$', '&': '&',\n  '(': '(', ')': ')', '*': '*', '+': '+', ',': ',', ';': ';', '=': '=',\n  '/': '/', '?': '?', '#': '#', '@': '@', '%': '%',\n};\nconst illegalIriChars = /[\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]/;\n\nconst lineModeRegExps = {\n  _iri: true,\n  _unescapedIri: true,\n  _simpleQuotedString: true,\n  _langcode: true,\n  _blank: true,\n  _newline: true,\n  _comment: true,\n  _whitespace: true,\n  _endOfFile: true,\n};\nconst invalidRegExp = /$0^/;\n\n// ## Constructor\nexport default class N3Lexer {\n  constructor(options) {\n    // ## Regular expressions\n    // It's slightly faster to have these as properties than as in-scope variables\n    this._iri = /^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/; // IRI with escape sequences; needs sanity check after unescaping\n    this._unescapedIri = /^<([^\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/; // IRI without escape sequences; no unescaping\n    this._simpleQuotedString = /^\"([^\"\\\\\\r\\n]*)\"(?=[^\"])/; // string without escape sequences\n    this._simpleApostropheString = /^'([^'\\\\\\r\\n]*)'(?=[^'])/;\n    this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\\-])/i;\n    this._prefix = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:(?=[#\\s<])/;\n    this._prefixed = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:((?:(?:[0-:A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])(?:(?:[\\.\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])*(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~]))?)?)(?:[ \\t]+|(?=\\.?[,;!\\^\\s#()\\[\\]\\{\\}\"'<>]))/;\n    this._variable = /^\\?(?:(?:[A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?=[.,;!\\^\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._blank = /^_:((?:[0-9A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?:[ \\t]+|(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>]))/;\n    this._number = /^[\\-+]?(?:(\\d+\\.\\d*|\\.?\\d+)[eE][\\-+]?|\\d*(\\.)?)\\d+(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._boolean = /^(?:true|false)(?=[.,;\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._keyword = /^@[a-z]+(?=[\\s#<:])/i;\n    this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\\s#<])/i;\n    this._shortPredicates = /^a(?=[\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._newline = /^[ \\t]*(?:#[^\\n\\r]*)?(?:\\r\\n|\\n|\\r)[ \\t]*/;\n    this._comment = /#([^\\n\\r]*)/;\n    this._whitespace = /^[ \\t]+/;\n    this._endOfFile = /^(?:#[^\\n\\r]*)?$/;\n    options = options || {};\n\n    // In line mode (N-Triples or N-Quads), only simple features may be parsed\n    if (this._lineMode = !!options.lineMode) {\n      this._n3Mode = false;\n      // Don't tokenize special literals\n      for (const key in this) {\n        if (!(key in lineModeRegExps) && this[key] instanceof RegExp)\n          this[key] = invalidRegExp;\n      }\n    }\n    // When not in line mode, enable N3 functionality by default\n    else {\n      this._n3Mode = options.n3 !== false;\n    }\n    // Don't output comment tokens by default\n    this._comments = !!options.comments;\n    // Cache the last tested closing position of long literals\n    this._literalClosingPos = 0;\n  }\n\n  // ## Private methods\n\n  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback\n  _tokenizeToEnd(callback, inputFinished) {\n    // Continue parsing as far as possible; the loop will return eventually\n    let input = this._input;\n    let currentLineLength = input.length;\n    while (true) {\n      // Count and skip whitespace lines\n      let whiteSpaceMatch, comment;\n      while (whiteSpaceMatch = this._newline.exec(input)) {\n        // Try to find a comment\n        if (this._comments && (comment = this._comment.exec(whiteSpaceMatch[0])))\n          emitToken('comment', comment[1], '', this._line, whiteSpaceMatch[0].length);\n        // Advance the input\n        input = input.substr(whiteSpaceMatch[0].length, input.length);\n        currentLineLength = input.length;\n        this._line++;\n      }\n      // Skip whitespace on current line\n      if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input)))\n        input = input.substr(whiteSpaceMatch[0].length, input.length);\n\n      // Stop for now if we're at the end\n      if (this._endOfFile.test(input)) {\n        // If the input is finished, emit EOF\n        if (inputFinished) {\n          // Try to find a final comment\n          if (this._comments && (comment = this._comment.exec(input)))\n            emitToken('comment', comment[1], '', this._line, input.length);\n          input = null;\n          emitToken('eof', '', '', this._line, 0);\n        }\n        return this._input = input;\n      }\n\n      // Look for specific token types based on the first character\n      const line = this._line, firstChar = input[0];\n      let type = '', value = '', prefix = '',\n          match = null, matchLength = 0, inconclusive = false;\n      switch (firstChar) {\n      case '^':\n        // We need at least 3 tokens lookahead to distinguish ^^<IRI> and ^^pre:fixed\n        if (input.length < 3)\n          break;\n        // Try to match a type\n        else if (input[1] === '^') {\n          this._previousMarker = '^^';\n          // Move to type IRI or prefixed name\n          input = input.substr(2);\n          if (input[0] !== '<') {\n            inconclusive = true;\n            break;\n          }\n        }\n        // If no type, it must be a path expression\n        else {\n          if (this._n3Mode) {\n            matchLength = 1;\n            type = '^';\n          }\n          break;\n        }\n        // Fall through in case the type is an IRI\n      case '<':\n        // Try to find a full IRI without escape sequences\n        if (match = this._unescapedIri.exec(input))\n          type = 'IRI', value = match[1];\n        // Try to find a full IRI with escape sequences\n        else if (match = this._iri.exec(input)) {\n          value = this._unescape(match[1]);\n          if (value === null || illegalIriChars.test(value))\n            return reportSyntaxError(this);\n          type = 'IRI';\n        }\n        // Try to find a nested triple\n        else if (input.length > 1 && input[1] === '<')\n          type = '<<', matchLength = 2;\n        // Try to find a backwards implication arrow\n        else if (this._n3Mode && input.length > 1 && input[1] === '=')\n          type = 'inverse', matchLength = 2, value = '>';\n        break;\n\n      case '>':\n        if (input.length > 1 && input[1] === '>')\n          type = '>>', matchLength = 2;\n        break;\n\n      case '_':\n        // Try to find a blank node. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a blank node.\n        // Therefore, try inserting a space if we're at the end of the input.\n        if ((match = this._blank.exec(input)) ||\n            inputFinished && (match = this._blank.exec(`${input} `)))\n          type = 'blank', prefix = '_', value = match[1];\n        break;\n\n      case '\"':\n        // Try to find a literal without escape sequences\n        if (match = this._simpleQuotedString.exec(input))\n          value = match[1];\n        // Try to find a literal wrapped in three pairs of quotes\n        else {\n          ({ value, matchLength } = this._parseLiteral(input));\n          if (value === null)\n            return reportSyntaxError(this);\n        }\n        if (match !== null || matchLength !== 0) {\n          type = 'literal';\n          this._literalClosingPos = 0;\n        }\n        break;\n\n      case \"'\":\n        if (!this._lineMode) {\n          // Try to find a literal without escape sequences\n          if (match = this._simpleApostropheString.exec(input))\n            value = match[1];\n          // Try to find a literal wrapped in three pairs of quotes\n          else {\n            ({ value, matchLength } = this._parseLiteral(input));\n            if (value === null)\n              return reportSyntaxError(this);\n          }\n          if (match !== null || matchLength !== 0) {\n            type = 'literal';\n            this._literalClosingPos = 0;\n          }\n        }\n        break;\n\n      case '?':\n        // Try to find a variable\n        if (this._n3Mode && (match = this._variable.exec(input)))\n          type = 'var', value = match[0];\n        break;\n\n      case '@':\n        // Try to find a language code\n        if (this._previousMarker === 'literal' && (match = this._langcode.exec(input)))\n          type = 'langcode', value = match[1];\n        // Try to find a keyword\n        else if (match = this._keyword.exec(input))\n          type = match[0];\n        break;\n\n      case '.':\n        // Try to find a dot as punctuation\n        if (input.length === 1 ? inputFinished : (input[1] < '0' || input[1] > '9')) {\n          type = '.';\n          matchLength = 1;\n          break;\n        }\n        // Fall through to numerical case (could be a decimal dot)\n\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '+':\n      case '-':\n        // Try to find a number. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a number.\n        // Therefore, try inserting a space if we're at the end of the input.\n        if (match = this._number.exec(input) ||\n            inputFinished && (match = this._number.exec(`${input} `))) {\n          type = 'literal', value = match[0];\n          prefix = (typeof match[1] === 'string' ? xsd.double :\n                    (typeof match[2] === 'string' ? xsd.decimal : xsd.integer));\n        }\n        break;\n\n      case 'B':\n      case 'b':\n      case 'p':\n      case 'P':\n      case 'G':\n      case 'g':\n        // Try to find a SPARQL-style keyword\n        if (match = this._sparqlKeyword.exec(input))\n          type = match[0].toUpperCase();\n        else\n          inconclusive = true;\n        break;\n\n      case 'f':\n      case 't':\n        // Try to match a boolean\n        if (match = this._boolean.exec(input))\n          type = 'literal', value = match[0], prefix = xsd.boolean;\n        else\n          inconclusive = true;\n        break;\n\n      case 'a':\n        // Try to find an abbreviated predicate\n        if (match = this._shortPredicates.exec(input))\n          type = 'abbreviation', value = 'a';\n        else\n          inconclusive = true;\n        break;\n\n      case '=':\n        // Try to find an implication arrow or equals sign\n        if (this._n3Mode && input.length > 1) {\n          type = 'abbreviation';\n          if (input[1] !== '>')\n            matchLength = 1, value = '=';\n          else\n            matchLength = 2, value = '>';\n        }\n        break;\n\n      case '!':\n        if (!this._n3Mode)\n          break;\n      case ',':\n      case ';':\n      case '[':\n      case ']':\n      case '(':\n      case ')':\n      case '{':\n      case '}':\n        if (!this._lineMode) {\n          matchLength = 1;\n          type = firstChar;\n        }\n        break;\n\n      default:\n        inconclusive = true;\n      }\n\n      // Some first characters do not allow an immediate decision, so inspect more\n      if (inconclusive) {\n        // Try to find a prefix\n        if ((this._previousMarker === '@prefix' || this._previousMarker === 'PREFIX') &&\n            (match = this._prefix.exec(input)))\n          type = 'prefix', value = match[1] || '';\n        // Try to find a prefixed name. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a prefixed name.\n        // Therefore, try inserting a space if we're at the end of the input.\n        else if ((match = this._prefixed.exec(input)) ||\n                 inputFinished && (match = this._prefixed.exec(`${input} `)))\n          type = 'prefixed', prefix = match[1] || '', value = this._unescape(match[2]);\n      }\n\n      // A type token is special: it can only be emitted after an IRI or prefixed name is read\n      if (this._previousMarker === '^^') {\n        switch (type) {\n        case 'prefixed': type = 'type';    break;\n        case 'IRI':      type = 'typeIRI'; break;\n        default:         type = '';\n        }\n      }\n\n      // What if nothing of the above was found?\n      if (!type) {\n        // We could be in streaming mode, and then we just wait for more input to arrive.\n        // Otherwise, a syntax error has occurred in the input.\n        // One exception: error on an unaccounted linebreak (= not inside a triple-quoted literal).\n        if (inputFinished || (!/^'''|^\"\"\"/.test(input) && /\\n|\\r/.test(input)))\n          return reportSyntaxError(this);\n        else\n          return this._input = input;\n      }\n\n      // Emit the parsed token\n      const length = matchLength || match[0].length;\n      const token = emitToken(type, value, prefix, line, length);\n      this.previousToken = token;\n      this._previousMarker = type;\n\n      // Advance to next part to tokenize\n      input = input.substr(length, input.length);\n    }\n\n    // Emits the token through the callback\n    function emitToken(type, value, prefix, line, length) {\n      const start = input ? currentLineLength - input.length : currentLineLength;\n      const end = start + length;\n      const token = { type, value, prefix, line, start, end };\n      callback(null, token);\n      return token;\n    }\n    // Signals the syntax error through the callback\n    function reportSyntaxError(self) { callback(self._syntaxError(/^\\S*/.exec(input)[0])); }\n  }\n\n  // ### `_unescape` replaces N3 escape codes by their corresponding characters\n  _unescape(item) {\n    let invalid = false;\n    const replaced = item.replace(escapeSequence, (sequence, unicode4, unicode8, escapedChar) => {\n      // 4-digit unicode character\n      if (typeof unicode4 === 'string')\n        return String.fromCharCode(Number.parseInt(unicode4, 16));\n      // 8-digit unicode character\n      if (typeof unicode8 === 'string') {\n        let charCode = Number.parseInt(unicode8, 16);\n        return charCode <= 0xFFFF ? String.fromCharCode(Number.parseInt(unicode8, 16)) :\n          String.fromCharCode(0xD800 + ((charCode -= 0x10000) >> 10), 0xDC00 + (charCode & 0x3FF));\n      }\n      // fixed escape sequence\n      if (escapedChar in escapeReplacements)\n        return escapeReplacements[escapedChar];\n      // invalid escape sequence\n      invalid = true;\n      return '';\n    });\n    return invalid ? null : replaced;\n  }\n\n  // ### `_parseLiteral` parses a literal into an unescaped value\n  _parseLiteral(input) {\n    // Ensure we have enough lookahead to identify triple-quoted strings\n    if (input.length >= 3) {\n      // Identify the opening quote(s)\n      const opening = input.match(/^(?:\"\"\"|\"|'''|'|)/)[0];\n      const openingLength = opening.length;\n\n      // Find the next candidate closing quotes\n      let closingPos = Math.max(this._literalClosingPos, openingLength);\n      while ((closingPos = input.indexOf(opening, closingPos)) > 0) {\n        // Count backslashes right before the closing quotes\n        let backslashCount = 0;\n        while (input[closingPos - backslashCount - 1] === '\\\\')\n          backslashCount++;\n\n        // An even number of backslashes (in particular 0)\n        // means these are actual, non-escaped closing quotes\n        if (backslashCount % 2 === 0) {\n          // Extract and unescape the value\n          const raw = input.substring(openingLength, closingPos);\n          const lines = raw.split(/\\r\\n|\\r|\\n/).length - 1;\n          const matchLength = closingPos + openingLength;\n          // Only triple-quoted strings can be multi-line\n          if (openingLength === 1 && lines !== 0 ||\n              openingLength === 3 && this._lineMode)\n            break;\n          this._line += lines;\n          return { value: this._unescape(raw), matchLength };\n        }\n        closingPos++;\n      }\n      this._literalClosingPos = input.length - openingLength + 1;\n    }\n    return { value: '', matchLength: 0 };\n  }\n\n  // ### `_syntaxError` creates a syntax error for the given issue\n  _syntaxError(issue) {\n    this._input = null;\n    const err = new Error(`Unexpected \"${issue}\" on line ${this._line}.`);\n    err.context = {\n      token: undefined,\n      line: this._line,\n      previousToken: this.previousToken,\n    };\n    return err;\n  }\n\n  // ### Strips off any starting UTF BOM mark.\n  _readStartingBom(input) {\n    return input.startsWith('\\ufeff') ? input.substr(1) : input;\n  }\n\n  // ## Public methods\n\n  // ### `tokenize` starts the transformation of an N3 document into an array of tokens.\n  // The input can be a string or a stream.\n  tokenize(input, callback) {\n    this._line = 1;\n\n    // If the input is a string, continuously emit tokens through the callback until the end\n    if (typeof input === 'string') {\n      this._input = this._readStartingBom(input);\n      // If a callback was passed, asynchronously call it\n      if (typeof callback === 'function')\n        queueMicrotask(() => this._tokenizeToEnd(callback, true));\n      // If no callback was passed, tokenize synchronously and return\n      else {\n        const tokens = [];\n        let error;\n        this._tokenizeToEnd((e, t) => e ? (error = e) : tokens.push(t), true);\n        if (error) throw error;\n        return tokens;\n      }\n    }\n    // Otherwise, the input must be a stream\n    else {\n      this._pendingBuffer = null;\n      if (typeof input.setEncoding === 'function')\n        input.setEncoding('utf8');\n      // Adds the data chunk to the buffer and parses as far as possible\n      input.on('data', data => {\n        if (this._input !== null && data.length !== 0) {\n          // Prepend any previous pending writes\n          if (this._pendingBuffer) {\n            data = Buffer.concat([this._pendingBuffer, data]);\n            this._pendingBuffer = null;\n          }\n          // Hold if the buffer ends in an incomplete unicode sequence\n          if (data[data.length - 1] & 0x80) {\n            this._pendingBuffer = data;\n          }\n          // Otherwise, tokenize as far as possible\n          else {\n            // Only read a BOM at the start\n            if (typeof this._input === 'undefined')\n              this._input = this._readStartingBom(typeof data === 'string' ? data : data.toString());\n            else\n              this._input += data;\n            this._tokenizeToEnd(callback, false);\n          }\n        }\n      });\n      // Parses until the end\n      input.on('end', () => {\n        if (typeof this._input === 'string')\n          this._tokenizeToEnd(callback, true);\n      });\n      input.on('error', callback);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}