{"ast":null,"code":"'use strict';\n\nvar crossFetch = require('cross-fetch');\nvar jose = require('jose');\nvar uuid = require('uuid');\nconst SOLID_CLIENT_AUTHN_KEY_PREFIX = \"solidClientAuthn:\";\nconst PREFERRED_SIGNING_ALG = [\"ES256\", \"RS256\"];\nconst EVENTS = {\n  ERROR: \"error\",\n  LOGIN: \"login\",\n  LOGOUT: \"logout\",\n  NEW_REFRESH_TOKEN: \"newRefreshToken\",\n  SESSION_EXPIRED: \"sessionExpired\",\n  SESSION_EXTENDED: \"sessionExtended\",\n  SESSION_RESTORED: \"sessionRestore\",\n  TIMEOUT_SET: \"timeoutSet\"\n};\nconst REFRESH_BEFORE_EXPIRATION_SECONDS = 5;\nconst SCOPE_OPENID = \"openid\";\nconst SCOPE_OFFLINE = \"offline_access\";\nconst SCOPE_WEBID = \"webid\";\nconst DEFAULT_SCOPES = [SCOPE_OPENID, SCOPE_OFFLINE, SCOPE_WEBID].join(\" \");\nclass AggregateHandler {\n  constructor(handleables) {\n    this.handleables = handleables;\n  }\n  async getProperHandler(params) {\n    const canHandleList = await Promise.all(this.handleables.map(handleable => handleable.canHandle(...params)));\n    for (let i = 0; i < canHandleList.length; i += 1) {\n      if (canHandleList[i]) {\n        return this.handleables[i];\n      }\n    }\n    return null;\n  }\n  async canHandle() {\n    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {\n      params[_key] = arguments[_key];\n    }\n    return (await this.getProperHandler(params)) !== null;\n  }\n  async handle() {\n    for (var _len2 = arguments.length, params = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      params[_key2] = arguments[_key2];\n    }\n    const handler = await this.getProperHandler(params);\n    if (handler) {\n      return handler.handle(...params);\n    }\n    throw new Error(`[${this.constructor.name}] cannot find a suitable handler for: ${params.map(param => {\n      try {\n        return JSON.stringify(param);\n      } catch (err) {\n        return param.toString();\n      }\n    }).join(\", \")}`);\n  }\n}\nasync function fetchJwks(jwksIri, issuerIri) {\n  const jwksResponse = await crossFetch.fetch(jwksIri);\n  if (jwksResponse.status !== 200) {\n    throw new Error(`Could not fetch JWKS for [${issuerIri}] at [${jwksIri}]: ${jwksResponse.status} ${jwksResponse.statusText}`);\n  }\n  let jwk;\n  try {\n    jwk = (await jwksResponse.json()).keys[0];\n  } catch (e) {\n    throw new Error(`Malformed JWKS for [${issuerIri}] at [${jwksIri}]: ${e.message}`);\n  }\n  return jwk;\n}\nasync function getWebidFromTokenPayload(idToken, jwksIri, issuerIri, clientId) {\n  const jwk = await fetchJwks(jwksIri, issuerIri);\n  let payload;\n  try {\n    const {\n      payload: verifiedPayload\n    } = await jose.jwtVerify(idToken, await jose.importJWK(jwk), {\n      issuer: issuerIri,\n      audience: clientId\n    });\n    payload = verifiedPayload;\n  } catch (e) {\n    throw new Error(`Token verification failed: ${e.stack}`);\n  }\n  if (typeof payload.webid === \"string\") {\n    return payload.webid;\n  }\n  if (typeof payload.sub !== \"string\") {\n    throw new Error(`The token ${JSON.stringify(payload)} is invalid: it has no 'webid' claim and no 'sub' claim.`);\n  }\n  try {\n    new URL(payload.sub);\n    return payload.sub;\n  } catch (e) {\n    throw new Error(`The token has no 'webid' claim, and its 'sub' claim of [${payload.sub}] is invalid as a URL - error [${e}].`);\n  }\n}\nfunction isSupportedTokenType(token) {\n  return typeof token === \"string\" && [\"DPoP\", \"Bearer\"].includes(token);\n}\nconst USER_SESSION_PREFIX = \"solidClientAuthenticationUser\";\nfunction isValidUrl(url) {\n  try {\n    new URL(url);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\nfunction determineSigningAlg(supported, preferred) {\n  var _a;\n  return (_a = preferred.find(signingAlg => {\n    return supported.includes(signingAlg);\n  })) !== null && _a !== void 0 ? _a : null;\n}\nfunction determineClientType(options, issuerConfig) {\n  if (options.clientId !== undefined && !isValidUrl(options.clientId)) {\n    return \"static\";\n  }\n  if (issuerConfig.scopesSupported.includes(\"webid\") && options.clientId !== undefined && isValidUrl(options.clientId)) {\n    return \"solid-oidc\";\n  }\n  return \"dynamic\";\n}\nasync function handleRegistration(options, issuerConfig, storageUtility, clientRegistrar) {\n  const clientType = determineClientType(options, issuerConfig);\n  if (clientType === \"dynamic\") {\n    return clientRegistrar.getClient({\n      sessionId: options.sessionId,\n      clientName: options.clientName,\n      redirectUrl: options.redirectUrl\n    }, issuerConfig);\n  }\n  await storageUtility.setForUser(options.sessionId, {\n    clientId: options.clientId\n  });\n  if (options.clientSecret) {\n    await storageUtility.setForUser(options.sessionId, {\n      clientSecret: options.clientSecret\n    });\n  }\n  if (options.clientName) {\n    await storageUtility.setForUser(options.sessionId, {\n      clientName: options.clientName\n    });\n  }\n  return {\n    clientId: options.clientId,\n    clientSecret: options.clientSecret,\n    clientName: options.clientName,\n    clientType\n  };\n}\nasync function getSessionIdFromOauthState(storageUtility, oauthState) {\n  return storageUtility.getForUser(oauthState, \"sessionId\");\n}\nasync function loadOidcContextFromStorage(sessionId, storageUtility, configFetcher) {\n  try {\n    const [issuerIri, codeVerifier, storedRedirectIri, dpop] = await Promise.all([storageUtility.getForUser(sessionId, \"issuer\", {\n      errorIfNull: true\n    }), storageUtility.getForUser(sessionId, \"codeVerifier\"), storageUtility.getForUser(sessionId, \"redirectUrl\"), storageUtility.getForUser(sessionId, \"dpop\", {\n      errorIfNull: true\n    })]);\n    await storageUtility.deleteForUser(sessionId, \"codeVerifier\");\n    const issuerConfig = await configFetcher.fetchConfig(issuerIri);\n    return {\n      codeVerifier,\n      redirectUrl: storedRedirectIri,\n      issuerConfig,\n      dpop: dpop === \"true\"\n    };\n  } catch (e) {\n    throw new Error(`Failed to retrieve OIDC context from storage associated with session [${sessionId}]: ${e}`);\n  }\n}\nasync function saveSessionInfoToStorage(storageUtility, sessionId, webId, isLoggedIn, refreshToken, secure, dpopKey) {\n  if (refreshToken !== undefined) {\n    await storageUtility.setForUser(sessionId, {\n      refreshToken\n    }, {\n      secure\n    });\n  }\n  if (webId !== undefined) {\n    await storageUtility.setForUser(sessionId, {\n      webId\n    }, {\n      secure\n    });\n  }\n  if (isLoggedIn !== undefined) {\n    await storageUtility.setForUser(sessionId, {\n      isLoggedIn\n    }, {\n      secure\n    });\n  }\n  if (dpopKey !== undefined) {\n    await storageUtility.setForUser(sessionId, {\n      publicKey: JSON.stringify(dpopKey.publicKey),\n      privateKey: JSON.stringify(await jose.exportJWK(dpopKey.privateKey))\n    }, {\n      secure\n    });\n  }\n}\nclass StorageUtility {\n  constructor(secureStorage, insecureStorage) {\n    this.secureStorage = secureStorage;\n    this.insecureStorage = insecureStorage;\n  }\n  getKey(userId) {\n    return `solidClientAuthenticationUser:${userId}`;\n  }\n  async getUserData(userId, secure) {\n    const stored = await (secure ? this.secureStorage : this.insecureStorage).get(this.getKey(userId));\n    if (stored === undefined) {\n      return {};\n    }\n    try {\n      return JSON.parse(stored);\n    } catch (err) {\n      throw new Error(`Data for user [${userId}] in [${secure ? \"secure\" : \"unsecure\"}] storage is corrupted - expected valid JSON, but got: ${stored}`);\n    }\n  }\n  async setUserData(userId, data, secure) {\n    await (secure ? this.secureStorage : this.insecureStorage).set(this.getKey(userId), JSON.stringify(data));\n  }\n  async get(key, options) {\n    const value = await ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).get(key);\n    if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {\n      throw new Error(`[${key}] is not stored`);\n    }\n    return value;\n  }\n  async set(key, value, options) {\n    return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).set(key, value);\n  }\n  async delete(key, options) {\n    return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(key);\n  }\n  async getForUser(userId, key, options) {\n    const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\n    let value;\n    if (!userData || !userData[key]) {\n      value = undefined;\n    }\n    value = userData[key];\n    if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {\n      throw new Error(`Field [${key}] for user [${userId}] is not stored`);\n    }\n    return value || undefined;\n  }\n  async setForUser(userId, values, options) {\n    let userData;\n    try {\n      userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\n    } catch (_a) {\n      userData = {};\n    }\n    await this.setUserData(userId, {\n      ...userData,\n      ...values\n    }, options === null || options === void 0 ? void 0 : options.secure);\n  }\n  async deleteForUser(userId, key, options) {\n    const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\n    delete userData[key];\n    await this.setUserData(userId, userData, options === null || options === void 0 ? void 0 : options.secure);\n  }\n  async deleteAllUserData(userId, options) {\n    await ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(this.getKey(userId));\n  }\n}\nclass InMemoryStorage {\n  constructor() {\n    this.map = {};\n  }\n  async get(key) {\n    return this.map[key] || undefined;\n  }\n  async set(key, value) {\n    this.map[key] = value;\n  }\n  async delete(key) {\n    delete this.map[key];\n  }\n}\nclass ConfigurationError extends Error {\n  constructor(message) {\n    super(message);\n  }\n}\nclass NotImplementedError extends Error {\n  constructor(methodName) {\n    super(`[${methodName}] is not implemented`);\n  }\n}\nclass InvalidResponseError extends Error {\n  constructor(missingFields) {\n    super(`Invalid response from OIDC provider: missing fields ${missingFields}`);\n    this.missingFields = missingFields;\n  }\n}\nclass OidcProviderError extends Error {\n  constructor(message, error, errorDescription) {\n    super(message);\n    this.error = error;\n    this.errorDescription = errorDescription;\n  }\n}\nfunction normalizeHTU(audience) {\n  const audienceUrl = new URL(audience);\n  return new URL(audienceUrl.pathname, audienceUrl.origin).toString();\n}\nasync function createDpopHeader(audience, method, dpopKey) {\n  return new jose.SignJWT({\n    htu: normalizeHTU(audience),\n    htm: method.toUpperCase(),\n    jti: uuid.v4()\n  }).setProtectedHeader({\n    alg: PREFERRED_SIGNING_ALG[0],\n    jwk: dpopKey.publicKey,\n    typ: \"dpop+jwt\"\n  }).setIssuedAt().sign(dpopKey.privateKey, {});\n}\nasync function generateDpopKeyPair() {\n  const {\n    privateKey,\n    publicKey\n  } = await jose.generateKeyPair(PREFERRED_SIGNING_ALG[0]);\n  const dpopKeyPair = {\n    privateKey,\n    publicKey: await jose.exportJWK(publicKey)\n  };\n  [dpopKeyPair.publicKey.alg] = PREFERRED_SIGNING_ALG;\n  return dpopKeyPair;\n}\nconst DEFAULT_EXPIRATION_TIME_SECONDS = 600;\nfunction isExpectedAuthError(statusCode) {\n  return [401, 403].includes(statusCode);\n}\nasync function buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions) {\n  var _a;\n  const headers = new crossFetch.Headers(defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.headers);\n  headers.set(\"Authorization\", `DPoP ${authToken}`);\n  headers.set(\"DPoP\", await createDpopHeader(targetUrl, (_a = defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.method) !== null && _a !== void 0 ? _a : \"get\", dpopKey));\n  return {\n    ...defaultOptions,\n    headers\n  };\n}\nasync function buildAuthenticatedHeaders(targetUrl, authToken, dpopKey, defaultOptions) {\n  if (dpopKey !== undefined) {\n    return buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions);\n  }\n  const headers = new crossFetch.Headers(defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.headers);\n  headers.set(\"Authorization\", `Bearer ${authToken}`);\n  return {\n    ...defaultOptions,\n    headers\n  };\n}\nasync function makeAuthenticatedRequest(unauthFetch, accessToken, url, defaultRequestInit, dpopKey) {\n  return unauthFetch(url, await buildAuthenticatedHeaders(url.toString(), accessToken, dpopKey, defaultRequestInit));\n}\nasync function refreshAccessToken(refreshOptions, dpopKey, eventEmitter) {\n  var _a;\n  const tokenSet = await refreshOptions.tokenRefresher.refresh(refreshOptions.sessionId, refreshOptions.refreshToken, dpopKey);\n  eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(EVENTS.SESSION_EXTENDED, (_a = tokenSet.expiresIn) !== null && _a !== void 0 ? _a : DEFAULT_EXPIRATION_TIME_SECONDS);\n  if (typeof tokenSet.refreshToken === \"string\") {\n    eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(EVENTS.NEW_REFRESH_TOKEN, tokenSet.refreshToken);\n  }\n  return {\n    accessToken: tokenSet.accessToken,\n    refreshToken: tokenSet.refreshToken,\n    expiresIn: tokenSet.expiresIn\n  };\n}\nconst computeRefreshDelay = expiresIn => {\n  if (expiresIn !== undefined) {\n    return expiresIn - REFRESH_BEFORE_EXPIRATION_SECONDS > 0 ? expiresIn - REFRESH_BEFORE_EXPIRATION_SECONDS : expiresIn;\n  }\n  return DEFAULT_EXPIRATION_TIME_SECONDS;\n};\nasync function buildAuthenticatedFetch(unauthFetch, accessToken, options) {\n  var _a;\n  let currentAccessToken = accessToken;\n  let latestTimeout;\n  const currentRefreshOptions = options === null || options === void 0 ? void 0 : options.refreshOptions;\n  if (currentRefreshOptions !== undefined) {\n    const proactivelyRefreshToken = async () => {\n      var _a, _b, _c, _d;\n      try {\n        const {\n          accessToken: refreshedAccessToken,\n          refreshToken,\n          expiresIn\n        } = await refreshAccessToken(currentRefreshOptions, options.dpopKey, options.eventEmitter);\n        currentAccessToken = refreshedAccessToken;\n        if (refreshToken !== undefined) {\n          currentRefreshOptions.refreshToken = refreshToken;\n        }\n        clearTimeout(latestTimeout);\n        latestTimeout = setTimeout(proactivelyRefreshToken, computeRefreshDelay(expiresIn) * 1000);\n        (_a = options.eventEmitter) === null || _a === void 0 ? void 0 : _a.emit(EVENTS.TIMEOUT_SET, latestTimeout);\n      } catch (e) {\n        if (e instanceof OidcProviderError) {\n          (_b = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _b === void 0 ? void 0 : _b.emit(EVENTS.ERROR, e.error, e.errorDescription);\n          (_c = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _c === void 0 ? void 0 : _c.emit(EVENTS.SESSION_EXPIRED);\n        }\n        if (e instanceof InvalidResponseError && e.missingFields.includes(\"access_token\")) {\n          (_d = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _d === void 0 ? void 0 : _d.emit(EVENTS.SESSION_EXPIRED);\n        }\n      }\n    };\n    latestTimeout = setTimeout(proactivelyRefreshToken, computeRefreshDelay(options.expiresIn) * 1000);\n    (_a = options.eventEmitter) === null || _a === void 0 ? void 0 : _a.emit(EVENTS.TIMEOUT_SET, latestTimeout);\n  } else if (options !== undefined && options.eventEmitter !== undefined) {\n    const expirationTimeout = setTimeout(() => {\n      options.eventEmitter.emit(EVENTS.SESSION_EXPIRED);\n    }, computeRefreshDelay(options.expiresIn) * 1000);\n    options.eventEmitter.emit(EVENTS.TIMEOUT_SET, expirationTimeout);\n  }\n  return async (url, requestInit) => {\n    let response = await makeAuthenticatedRequest(unauthFetch, currentAccessToken, url, requestInit, options === null || options === void 0 ? void 0 : options.dpopKey);\n    const failedButNotExpectedAuthError = !response.ok && !isExpectedAuthError(response.status);\n    if (response.ok || failedButNotExpectedAuthError) {\n      return response;\n    }\n    const hasBeenRedirected = response.url !== url;\n    if (hasBeenRedirected && (options === null || options === void 0 ? void 0 : options.dpopKey) !== undefined) {\n      response = await makeAuthenticatedRequest(unauthFetch, currentAccessToken, response.url, requestInit, options.dpopKey);\n    }\n    return response;\n  };\n}\nconst StorageUtilityGetResponse = \"getResponse\";\nconst StorageUtilityMock = {\n  get: async (key, options) => StorageUtilityGetResponse,\n  set: async (key, value) => {},\n  delete: async key => {},\n  getForUser: async (userId, key, options) => StorageUtilityGetResponse,\n  setForUser: async (userId, values, options) => {},\n  deleteForUser: async (userId, key, options) => {},\n  deleteAllUserData: async (userId, options) => {}\n};\nconst mockStorage = stored => {\n  const store = stored;\n  return {\n    get: async key => {\n      if (store[key] === undefined) {\n        return undefined;\n      }\n      if (typeof store[key] === \"string\") {\n        return store[key];\n      }\n      return JSON.stringify(store[key]);\n    },\n    set: async (key, value) => {\n      store[key] = value;\n    },\n    delete: async key => {\n      delete store[key];\n    }\n  };\n};\nconst mockStorageUtility = function (stored) {\n  let isSecure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (isSecure) {\n    return new StorageUtility(mockStorage(stored), mockStorage({}));\n  }\n  return new StorageUtility(mockStorage({}), mockStorage(stored));\n};\nexports.AggregateHandler = AggregateHandler;\nexports.ConfigurationError = ConfigurationError;\nexports.DEFAULT_SCOPES = DEFAULT_SCOPES;\nexports.EVENTS = EVENTS;\nexports.InMemoryStorage = InMemoryStorage;\nexports.InvalidResponseError = InvalidResponseError;\nexports.NotImplementedError = NotImplementedError;\nexports.OidcProviderError = OidcProviderError;\nexports.PREFERRED_SIGNING_ALG = PREFERRED_SIGNING_ALG;\nexports.REFRESH_BEFORE_EXPIRATION_SECONDS = REFRESH_BEFORE_EXPIRATION_SECONDS;\nexports.SOLID_CLIENT_AUTHN_KEY_PREFIX = SOLID_CLIENT_AUTHN_KEY_PREFIX;\nexports.StorageUtility = StorageUtility;\nexports.StorageUtilityGetResponse = StorageUtilityGetResponse;\nexports.StorageUtilityMock = StorageUtilityMock;\nexports.USER_SESSION_PREFIX = USER_SESSION_PREFIX;\nexports.buildAuthenticatedFetch = buildAuthenticatedFetch;\nexports.createDpopHeader = createDpopHeader;\nexports.determineSigningAlg = determineSigningAlg;\nexports.fetchJwks = fetchJwks;\nexports.generateDpopKeyPair = generateDpopKeyPair;\nexports.getSessionIdFromOauthState = getSessionIdFromOauthState;\nexports.getWebidFromTokenPayload = getWebidFromTokenPayload;\nexports.handleRegistration = handleRegistration;\nexports.isSupportedTokenType = isSupportedTokenType;\nexports.loadOidcContextFromStorage = loadOidcContextFromStorage;\nexports.mockStorage = mockStorage;\nexports.mockStorageUtility = mockStorageUtility;\nexports.saveSessionInfoToStorage = saveSessionInfoToStorage;","map":{"version":3,"names":["crossFetch","require","jose","uuid","SOLID_CLIENT_AUTHN_KEY_PREFIX","PREFERRED_SIGNING_ALG","EVENTS","ERROR","LOGIN","LOGOUT","NEW_REFRESH_TOKEN","SESSION_EXPIRED","SESSION_EXTENDED","SESSION_RESTORED","TIMEOUT_SET","REFRESH_BEFORE_EXPIRATION_SECONDS","SCOPE_OPENID","SCOPE_OFFLINE","SCOPE_WEBID","DEFAULT_SCOPES","join","AggregateHandler","constructor","handleables","getProperHandler","params","canHandleList","Promise","all","map","handleable","canHandle","i","length","handle","handler","Error","name","param","JSON","stringify","err","toString","fetchJwks","jwksIri","issuerIri","jwksResponse","fetch","status","statusText","jwk","json","keys","e","message","getWebidFromTokenPayload","idToken","clientId","payload","verifiedPayload","jwtVerify","importJWK","issuer","audience","stack","webid","sub","URL","isSupportedTokenType","token","includes","USER_SESSION_PREFIX","isValidUrl","url","_a","determineSigningAlg","supported","preferred","find","signingAlg","determineClientType","options","issuerConfig","undefined","scopesSupported","handleRegistration","storageUtility","clientRegistrar","clientType","getClient","sessionId","clientName","redirectUrl","setForUser","clientSecret","getSessionIdFromOauthState","oauthState","getForUser","loadOidcContextFromStorage","configFetcher","codeVerifier","storedRedirectIri","dpop","errorIfNull","deleteForUser","fetchConfig","saveSessionInfoToStorage","webId","isLoggedIn","refreshToken","secure","dpopKey","publicKey","privateKey","exportJWK","StorageUtility","secureStorage","insecureStorage","getKey","userId","getUserData","stored","get","parse","setUserData","data","set","key","value","delete","userData","values","deleteAllUserData","InMemoryStorage","ConfigurationError","NotImplementedError","methodName","InvalidResponseError","missingFields","OidcProviderError","error","errorDescription","normalizeHTU","audienceUrl","pathname","origin","createDpopHeader","method","SignJWT","htu","htm","toUpperCase","jti","v4","setProtectedHeader","alg","typ","setIssuedAt","sign","generateDpopKeyPair","generateKeyPair","dpopKeyPair","DEFAULT_EXPIRATION_TIME_SECONDS","isExpectedAuthError","statusCode","buildDpopFetchOptions","targetUrl","authToken","defaultOptions","headers","Headers","buildAuthenticatedHeaders","makeAuthenticatedRequest","unauthFetch","accessToken","defaultRequestInit","refreshAccessToken","refreshOptions","eventEmitter","tokenSet","tokenRefresher","refresh","emit","expiresIn","computeRefreshDelay","buildAuthenticatedFetch","currentAccessToken","latestTimeout","currentRefreshOptions","proactivelyRefreshToken","_b","_c","_d","refreshedAccessToken","clearTimeout","setTimeout","expirationTimeout","requestInit","response","failedButNotExpectedAuthError","ok","hasBeenRedirected","StorageUtilityGetResponse","StorageUtilityMock","mockStorage","store","mockStorageUtility","isSecure","exports"],"sources":["G:/To-do-List_App-main/node_modules/@inrupt/solid-client-authn-core/dist/index.js"],"sourcesContent":["'use strict';\n\nvar crossFetch = require('cross-fetch');\nvar jose = require('jose');\nvar uuid = require('uuid');\n\nconst SOLID_CLIENT_AUTHN_KEY_PREFIX = \"solidClientAuthn:\";\r\nconst PREFERRED_SIGNING_ALG = [\"ES256\", \"RS256\"];\r\nconst EVENTS = {\r\n    ERROR: \"error\",\r\n    LOGIN: \"login\",\r\n    LOGOUT: \"logout\",\r\n    NEW_REFRESH_TOKEN: \"newRefreshToken\",\r\n    SESSION_EXPIRED: \"sessionExpired\",\r\n    SESSION_EXTENDED: \"sessionExtended\",\r\n    SESSION_RESTORED: \"sessionRestore\",\r\n    TIMEOUT_SET: \"timeoutSet\",\r\n};\r\nconst REFRESH_BEFORE_EXPIRATION_SECONDS = 5;\r\nconst SCOPE_OPENID = \"openid\";\r\nconst SCOPE_OFFLINE = \"offline_access\";\r\nconst SCOPE_WEBID = \"webid\";\r\nconst DEFAULT_SCOPES = [SCOPE_OPENID, SCOPE_OFFLINE, SCOPE_WEBID].join(\" \");\n\nclass AggregateHandler {\r\n    constructor(handleables) {\r\n        this.handleables = handleables;\r\n    }\r\n    async getProperHandler(params) {\r\n        const canHandleList = await Promise.all(this.handleables.map((handleable) => handleable.canHandle(...params)));\r\n        for (let i = 0; i < canHandleList.length; i += 1) {\r\n            if (canHandleList[i]) {\r\n                return this.handleables[i];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    async canHandle(...params) {\r\n        return (await this.getProperHandler(params)) !== null;\r\n    }\r\n    async handle(...params) {\r\n        const handler = await this.getProperHandler(params);\r\n        if (handler) {\r\n            return handler.handle(...params);\r\n        }\r\n        throw new Error(`[${this.constructor.name}] cannot find a suitable handler for: ${params\r\n            .map((param) => {\r\n            try {\r\n                return JSON.stringify(param);\r\n            }\r\n            catch (err) {\r\n                return param.toString();\r\n            }\r\n        })\r\n            .join(\", \")}`);\r\n    }\r\n}\n\nasync function fetchJwks(jwksIri, issuerIri) {\r\n    const jwksResponse = await crossFetch.fetch(jwksIri);\r\n    if (jwksResponse.status !== 200) {\r\n        throw new Error(`Could not fetch JWKS for [${issuerIri}] at [${jwksIri}]: ${jwksResponse.status} ${jwksResponse.statusText}`);\r\n    }\r\n    let jwk;\r\n    try {\r\n        jwk = (await jwksResponse.json()).keys[0];\r\n    }\r\n    catch (e) {\r\n        throw new Error(`Malformed JWKS for [${issuerIri}] at [${jwksIri}]: ${e.message}`);\r\n    }\r\n    return jwk;\r\n}\r\nasync function getWebidFromTokenPayload(idToken, jwksIri, issuerIri, clientId) {\r\n    const jwk = await fetchJwks(jwksIri, issuerIri);\r\n    let payload;\r\n    try {\r\n        const { payload: verifiedPayload } = await jose.jwtVerify(idToken, await jose.importJWK(jwk), {\r\n            issuer: issuerIri,\r\n            audience: clientId,\r\n        });\r\n        payload = verifiedPayload;\r\n    }\r\n    catch (e) {\r\n        throw new Error(`Token verification failed: ${e.stack}`);\r\n    }\r\n    if (typeof payload.webid === \"string\") {\r\n        return payload.webid;\r\n    }\r\n    if (typeof payload.sub !== \"string\") {\r\n        throw new Error(`The token ${JSON.stringify(payload)} is invalid: it has no 'webid' claim and no 'sub' claim.`);\r\n    }\r\n    try {\r\n        new URL(payload.sub);\r\n        return payload.sub;\r\n    }\r\n    catch (e) {\r\n        throw new Error(`The token has no 'webid' claim, and its 'sub' claim of [${payload.sub}] is invalid as a URL - error [${e}].`);\r\n    }\r\n}\n\nfunction isSupportedTokenType(token) {\r\n    return typeof token === \"string\" && [\"DPoP\", \"Bearer\"].includes(token);\r\n}\n\nconst USER_SESSION_PREFIX = \"solidClientAuthenticationUser\";\n\nfunction isValidUrl(url) {\r\n    try {\r\n        new URL(url);\r\n        return true;\r\n    }\r\n    catch (_a) {\r\n        return false;\r\n    }\r\n}\r\nfunction determineSigningAlg(supported, preferred) {\r\n    var _a;\r\n    return ((_a = preferred.find((signingAlg) => {\r\n        return supported.includes(signingAlg);\r\n    })) !== null && _a !== void 0 ? _a : null);\r\n}\r\nfunction determineClientType(options, issuerConfig) {\r\n    if (options.clientId !== undefined && !isValidUrl(options.clientId)) {\r\n        return \"static\";\r\n    }\r\n    if (issuerConfig.scopesSupported.includes(\"webid\") &&\r\n        options.clientId !== undefined &&\r\n        isValidUrl(options.clientId)) {\r\n        return \"solid-oidc\";\r\n    }\r\n    return \"dynamic\";\r\n}\r\nasync function handleRegistration(options, issuerConfig, storageUtility, clientRegistrar) {\r\n    const clientType = determineClientType(options, issuerConfig);\r\n    if (clientType === \"dynamic\") {\r\n        return clientRegistrar.getClient({\r\n            sessionId: options.sessionId,\r\n            clientName: options.clientName,\r\n            redirectUrl: options.redirectUrl,\r\n        }, issuerConfig);\r\n    }\r\n    await storageUtility.setForUser(options.sessionId, {\r\n        clientId: options.clientId,\r\n    });\r\n    if (options.clientSecret) {\r\n        await storageUtility.setForUser(options.sessionId, {\r\n            clientSecret: options.clientSecret,\r\n        });\r\n    }\r\n    if (options.clientName) {\r\n        await storageUtility.setForUser(options.sessionId, {\r\n            clientName: options.clientName,\r\n        });\r\n    }\r\n    return {\r\n        clientId: options.clientId,\r\n        clientSecret: options.clientSecret,\r\n        clientName: options.clientName,\r\n        clientType,\r\n    };\r\n}\n\nasync function getSessionIdFromOauthState(storageUtility, oauthState) {\r\n    return storageUtility.getForUser(oauthState, \"sessionId\");\r\n}\r\nasync function loadOidcContextFromStorage(sessionId, storageUtility, configFetcher) {\r\n    try {\r\n        const [issuerIri, codeVerifier, storedRedirectIri, dpop] = await Promise.all([\r\n            storageUtility.getForUser(sessionId, \"issuer\", {\r\n                errorIfNull: true,\r\n            }),\r\n            storageUtility.getForUser(sessionId, \"codeVerifier\"),\r\n            storageUtility.getForUser(sessionId, \"redirectUrl\"),\r\n            storageUtility.getForUser(sessionId, \"dpop\", { errorIfNull: true }),\r\n        ]);\r\n        await storageUtility.deleteForUser(sessionId, \"codeVerifier\");\r\n        const issuerConfig = await configFetcher.fetchConfig(issuerIri);\r\n        return {\r\n            codeVerifier,\r\n            redirectUrl: storedRedirectIri,\r\n            issuerConfig,\r\n            dpop: dpop === \"true\",\r\n        };\r\n    }\r\n    catch (e) {\r\n        throw new Error(`Failed to retrieve OIDC context from storage associated with session [${sessionId}]: ${e}`);\r\n    }\r\n}\r\nasync function saveSessionInfoToStorage(storageUtility, sessionId, webId, isLoggedIn, refreshToken, secure, dpopKey) {\r\n    if (refreshToken !== undefined) {\r\n        await storageUtility.setForUser(sessionId, { refreshToken }, { secure });\r\n    }\r\n    if (webId !== undefined) {\r\n        await storageUtility.setForUser(sessionId, { webId }, { secure });\r\n    }\r\n    if (isLoggedIn !== undefined) {\r\n        await storageUtility.setForUser(sessionId, { isLoggedIn }, { secure });\r\n    }\r\n    if (dpopKey !== undefined) {\r\n        await storageUtility.setForUser(sessionId, {\r\n            publicKey: JSON.stringify(dpopKey.publicKey),\r\n            privateKey: JSON.stringify(await jose.exportJWK(dpopKey.privateKey)),\r\n        }, { secure });\r\n    }\r\n}\r\nclass StorageUtility {\r\n    constructor(secureStorage, insecureStorage) {\r\n        this.secureStorage = secureStorage;\r\n        this.insecureStorage = insecureStorage;\r\n    }\r\n    getKey(userId) {\r\n        return `solidClientAuthenticationUser:${userId}`;\r\n    }\r\n    async getUserData(userId, secure) {\r\n        const stored = await (secure\r\n            ? this.secureStorage\r\n            : this.insecureStorage).get(this.getKey(userId));\r\n        if (stored === undefined) {\r\n            return {};\r\n        }\r\n        try {\r\n            return JSON.parse(stored);\r\n        }\r\n        catch (err) {\r\n            throw new Error(`Data for user [${userId}] in [${secure ? \"secure\" : \"unsecure\"}] storage is corrupted - expected valid JSON, but got: ${stored}`);\r\n        }\r\n    }\r\n    async setUserData(userId, data, secure) {\r\n        await (secure ? this.secureStorage : this.insecureStorage).set(this.getKey(userId), JSON.stringify(data));\r\n    }\r\n    async get(key, options) {\r\n        const value = await ((options === null || options === void 0 ? void 0 : options.secure)\r\n            ? this.secureStorage\r\n            : this.insecureStorage).get(key);\r\n        if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {\r\n            throw new Error(`[${key}] is not stored`);\r\n        }\r\n        return value;\r\n    }\r\n    async set(key, value, options) {\r\n        return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).set(key, value);\r\n    }\r\n    async delete(key, options) {\r\n        return ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(key);\r\n    }\r\n    async getForUser(userId, key, options) {\r\n        const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\r\n        let value;\r\n        if (!userData || !userData[key]) {\r\n            value = undefined;\r\n        }\r\n        value = userData[key];\r\n        if (value === undefined && (options === null || options === void 0 ? void 0 : options.errorIfNull)) {\r\n            throw new Error(`Field [${key}] for user [${userId}] is not stored`);\r\n        }\r\n        return value || undefined;\r\n    }\r\n    async setForUser(userId, values, options) {\r\n        let userData;\r\n        try {\r\n            userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\r\n        }\r\n        catch (_a) {\r\n            userData = {};\r\n        }\r\n        await this.setUserData(userId, { ...userData, ...values }, options === null || options === void 0 ? void 0 : options.secure);\r\n    }\r\n    async deleteForUser(userId, key, options) {\r\n        const userData = await this.getUserData(userId, options === null || options === void 0 ? void 0 : options.secure);\r\n        delete userData[key];\r\n        await this.setUserData(userId, userData, options === null || options === void 0 ? void 0 : options.secure);\r\n    }\r\n    async deleteAllUserData(userId, options) {\r\n        await ((options === null || options === void 0 ? void 0 : options.secure) ? this.secureStorage : this.insecureStorage).delete(this.getKey(userId));\r\n    }\r\n}\n\nclass InMemoryStorage {\r\n    constructor() {\r\n        this.map = {};\r\n    }\r\n    async get(key) {\r\n        return this.map[key] || undefined;\r\n    }\r\n    async set(key, value) {\r\n        this.map[key] = value;\r\n    }\r\n    async delete(key) {\r\n        delete this.map[key];\r\n    }\r\n}\n\nclass ConfigurationError extends Error {\r\n    constructor(message) {\r\n        super(message);\r\n    }\r\n}\n\nclass NotImplementedError extends Error {\r\n    constructor(methodName) {\r\n        super(`[${methodName}] is not implemented`);\r\n    }\r\n}\n\nclass InvalidResponseError extends Error {\r\n    constructor(missingFields) {\r\n        super(`Invalid response from OIDC provider: missing fields ${missingFields}`);\r\n        this.missingFields = missingFields;\r\n    }\r\n}\n\nclass OidcProviderError extends Error {\r\n    constructor(message, error, errorDescription) {\r\n        super(message);\r\n        this.error = error;\r\n        this.errorDescription = errorDescription;\r\n    }\r\n}\n\nfunction normalizeHTU(audience) {\r\n    const audienceUrl = new URL(audience);\r\n    return new URL(audienceUrl.pathname, audienceUrl.origin).toString();\r\n}\r\nasync function createDpopHeader(audience, method, dpopKey) {\r\n    return new jose.SignJWT({\r\n        htu: normalizeHTU(audience),\r\n        htm: method.toUpperCase(),\r\n        jti: uuid.v4(),\r\n    })\r\n        .setProtectedHeader({\r\n        alg: PREFERRED_SIGNING_ALG[0],\r\n        jwk: dpopKey.publicKey,\r\n        typ: \"dpop+jwt\",\r\n    })\r\n        .setIssuedAt()\r\n        .sign(dpopKey.privateKey, {});\r\n}\r\nasync function generateDpopKeyPair() {\r\n    const { privateKey, publicKey } = await jose.generateKeyPair(PREFERRED_SIGNING_ALG[0]);\r\n    const dpopKeyPair = {\r\n        privateKey,\r\n        publicKey: await jose.exportJWK(publicKey),\r\n    };\r\n    [dpopKeyPair.publicKey.alg] = PREFERRED_SIGNING_ALG;\r\n    return dpopKeyPair;\r\n}\n\nconst DEFAULT_EXPIRATION_TIME_SECONDS = 600;\r\nfunction isExpectedAuthError(statusCode) {\r\n    return [401, 403].includes(statusCode);\r\n}\r\nasync function buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions) {\r\n    var _a;\r\n    const headers = new crossFetch.Headers(defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.headers);\r\n    headers.set(\"Authorization\", `DPoP ${authToken}`);\r\n    headers.set(\"DPoP\", await createDpopHeader(targetUrl, (_a = defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.method) !== null && _a !== void 0 ? _a : \"get\", dpopKey));\r\n    return {\r\n        ...defaultOptions,\r\n        headers,\r\n    };\r\n}\r\nasync function buildAuthenticatedHeaders(targetUrl, authToken, dpopKey, defaultOptions) {\r\n    if (dpopKey !== undefined) {\r\n        return buildDpopFetchOptions(targetUrl, authToken, dpopKey, defaultOptions);\r\n    }\r\n    const headers = new crossFetch.Headers(defaultOptions === null || defaultOptions === void 0 ? void 0 : defaultOptions.headers);\r\n    headers.set(\"Authorization\", `Bearer ${authToken}`);\r\n    return {\r\n        ...defaultOptions,\r\n        headers,\r\n    };\r\n}\r\nasync function makeAuthenticatedRequest(unauthFetch, accessToken, url, defaultRequestInit, dpopKey) {\r\n    return unauthFetch(url, await buildAuthenticatedHeaders(url.toString(), accessToken, dpopKey, defaultRequestInit));\r\n}\r\nasync function refreshAccessToken(refreshOptions, dpopKey, eventEmitter) {\r\n    var _a;\r\n    const tokenSet = await refreshOptions.tokenRefresher.refresh(refreshOptions.sessionId, refreshOptions.refreshToken, dpopKey);\r\n    eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(EVENTS.SESSION_EXTENDED, (_a = tokenSet.expiresIn) !== null && _a !== void 0 ? _a : DEFAULT_EXPIRATION_TIME_SECONDS);\r\n    if (typeof tokenSet.refreshToken === \"string\") {\r\n        eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(EVENTS.NEW_REFRESH_TOKEN, tokenSet.refreshToken);\r\n    }\r\n    return {\r\n        accessToken: tokenSet.accessToken,\r\n        refreshToken: tokenSet.refreshToken,\r\n        expiresIn: tokenSet.expiresIn,\r\n    };\r\n}\r\nconst computeRefreshDelay = (expiresIn) => {\r\n    if (expiresIn !== undefined) {\r\n        return expiresIn - REFRESH_BEFORE_EXPIRATION_SECONDS > 0\r\n            ?\r\n                expiresIn - REFRESH_BEFORE_EXPIRATION_SECONDS\r\n            : expiresIn;\r\n    }\r\n    return DEFAULT_EXPIRATION_TIME_SECONDS;\r\n};\r\nasync function buildAuthenticatedFetch(unauthFetch, accessToken, options) {\r\n    var _a;\r\n    let currentAccessToken = accessToken;\r\n    let latestTimeout;\r\n    const currentRefreshOptions = options === null || options === void 0 ? void 0 : options.refreshOptions;\r\n    if (currentRefreshOptions !== undefined) {\r\n        const proactivelyRefreshToken = async () => {\r\n            var _a, _b, _c, _d;\r\n            try {\r\n                const { accessToken: refreshedAccessToken, refreshToken, expiresIn, } = await refreshAccessToken(currentRefreshOptions, options.dpopKey, options.eventEmitter);\r\n                currentAccessToken = refreshedAccessToken;\r\n                if (refreshToken !== undefined) {\r\n                    currentRefreshOptions.refreshToken = refreshToken;\r\n                }\r\n                clearTimeout(latestTimeout);\r\n                latestTimeout = setTimeout(proactivelyRefreshToken, computeRefreshDelay(expiresIn) * 1000);\r\n                (_a = options.eventEmitter) === null || _a === void 0 ? void 0 : _a.emit(EVENTS.TIMEOUT_SET, latestTimeout);\r\n            }\r\n            catch (e) {\r\n                if (e instanceof OidcProviderError) {\r\n                    (_b = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _b === void 0 ? void 0 : _b.emit(EVENTS.ERROR, e.error, e.errorDescription);\r\n                    (_c = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _c === void 0 ? void 0 : _c.emit(EVENTS.SESSION_EXPIRED);\r\n                }\r\n                if (e instanceof InvalidResponseError &&\r\n                    e.missingFields.includes(\"access_token\")) {\r\n                    (_d = options === null || options === void 0 ? void 0 : options.eventEmitter) === null || _d === void 0 ? void 0 : _d.emit(EVENTS.SESSION_EXPIRED);\r\n                }\r\n            }\r\n        };\r\n        latestTimeout = setTimeout(proactivelyRefreshToken, computeRefreshDelay(options.expiresIn) * 1000);\r\n        (_a = options.eventEmitter) === null || _a === void 0 ? void 0 : _a.emit(EVENTS.TIMEOUT_SET, latestTimeout);\r\n    }\r\n    else if (options !== undefined && options.eventEmitter !== undefined) {\r\n        const expirationTimeout = setTimeout(() => {\r\n            options.eventEmitter.emit(EVENTS.SESSION_EXPIRED);\r\n        }, computeRefreshDelay(options.expiresIn) * 1000);\r\n        options.eventEmitter.emit(EVENTS.TIMEOUT_SET, expirationTimeout);\r\n    }\r\n    return async (url, requestInit) => {\r\n        let response = await makeAuthenticatedRequest(unauthFetch, currentAccessToken, url, requestInit, options === null || options === void 0 ? void 0 : options.dpopKey);\r\n        const failedButNotExpectedAuthError = !response.ok && !isExpectedAuthError(response.status);\r\n        if (response.ok || failedButNotExpectedAuthError) {\r\n            return response;\r\n        }\r\n        const hasBeenRedirected = response.url !== url;\r\n        if (hasBeenRedirected && (options === null || options === void 0 ? void 0 : options.dpopKey) !== undefined) {\r\n            response = await makeAuthenticatedRequest(unauthFetch, currentAccessToken, response.url, requestInit, options.dpopKey);\r\n        }\r\n        return response;\r\n    };\r\n}\n\nconst StorageUtilityGetResponse = \"getResponse\";\r\nconst StorageUtilityMock = {\r\n    get: async (key, options) => StorageUtilityGetResponse,\r\n    set: async (key, value) => {\r\n    },\r\n    delete: async (key) => {\r\n    },\r\n    getForUser: async (userId, key, options) => StorageUtilityGetResponse,\r\n    setForUser: async (userId, values, options) => {\r\n    },\r\n    deleteForUser: async (userId, key, options) => {\r\n    },\r\n    deleteAllUserData: async (userId, options) => {\r\n    },\r\n};\r\nconst mockStorage = (stored) => {\r\n    const store = stored;\r\n    return {\r\n        get: async (key) => {\r\n            if (store[key] === undefined) {\r\n                return undefined;\r\n            }\r\n            if (typeof store[key] === \"string\") {\r\n                return store[key];\r\n            }\r\n            return JSON.stringify(store[key]);\r\n        },\r\n        set: async (key, value) => {\r\n            store[key] = value;\r\n        },\r\n        delete: async (key) => {\r\n            delete store[key];\r\n        },\r\n    };\r\n};\r\nconst mockStorageUtility = (stored, isSecure = false) => {\r\n    if (isSecure) {\r\n        return new StorageUtility(mockStorage(stored), mockStorage({}));\r\n    }\r\n    return new StorageUtility(mockStorage({}), mockStorage(stored));\r\n};\n\nexports.AggregateHandler = AggregateHandler;\nexports.ConfigurationError = ConfigurationError;\nexports.DEFAULT_SCOPES = DEFAULT_SCOPES;\nexports.EVENTS = EVENTS;\nexports.InMemoryStorage = InMemoryStorage;\nexports.InvalidResponseError = InvalidResponseError;\nexports.NotImplementedError = NotImplementedError;\nexports.OidcProviderError = OidcProviderError;\nexports.PREFERRED_SIGNING_ALG = PREFERRED_SIGNING_ALG;\nexports.REFRESH_BEFORE_EXPIRATION_SECONDS = REFRESH_BEFORE_EXPIRATION_SECONDS;\nexports.SOLID_CLIENT_AUTHN_KEY_PREFIX = SOLID_CLIENT_AUTHN_KEY_PREFIX;\nexports.StorageUtility = StorageUtility;\nexports.StorageUtilityGetResponse = StorageUtilityGetResponse;\nexports.StorageUtilityMock = StorageUtilityMock;\nexports.USER_SESSION_PREFIX = USER_SESSION_PREFIX;\nexports.buildAuthenticatedFetch = buildAuthenticatedFetch;\nexports.createDpopHeader = createDpopHeader;\nexports.determineSigningAlg = determineSigningAlg;\nexports.fetchJwks = fetchJwks;\nexports.generateDpopKeyPair = generateDpopKeyPair;\nexports.getSessionIdFromOauthState = getSessionIdFromOauthState;\nexports.getWebidFromTokenPayload = getWebidFromTokenPayload;\nexports.handleRegistration = handleRegistration;\nexports.isSupportedTokenType = isSupportedTokenType;\nexports.loadOidcContextFromStorage = loadOidcContextFromStorage;\nexports.mockStorage = mockStorage;\nexports.mockStorageUtility = mockStorageUtility;\nexports.saveSessionInfoToStorage = saveSessionInfoToStorage;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}