{"ast":null,"code":"/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst types = require('./types');\nconst api = {};\nmodule.exports = api;\n\n// define URL parser\n// parseUri 1.2.2\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\n// with local jsonld.js modifications\napi.parsers = {\n  simple: {\n    // RFC 3986 basic parts\n    keys: ['href', 'scheme', 'authority', 'path', 'query', 'fragment'],\n    /* eslint-disable-next-line max-len */\n    regex: /^(?:([^:\\/?#]+):)?(?:\\/\\/([^\\/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/\n  },\n  full: {\n    keys: ['href', 'protocol', 'scheme', 'authority', 'auth', 'user', 'password', 'hostname', 'port', 'path', 'directory', 'file', 'query', 'fragment'],\n    /* eslint-disable-next-line max-len */\n    regex: /^(([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?(?:(((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/\n  }\n};\napi.parse = (str, parser) => {\n  const parsed = {};\n  const o = api.parsers[parser || 'full'];\n  const m = o.regex.exec(str);\n  let i = o.keys.length;\n  while (i--) {\n    parsed[o.keys[i]] = m[i] === undefined ? null : m[i];\n  }\n\n  // remove default ports in found in URLs\n  if (parsed.scheme === 'https' && parsed.port === '443' || parsed.scheme === 'http' && parsed.port === '80') {\n    parsed.href = parsed.href.replace(':' + parsed.port, '');\n    parsed.authority = parsed.authority.replace(':' + parsed.port, '');\n    parsed.port = null;\n  }\n  parsed.normalizedPath = api.removeDotSegments(parsed.path);\n  return parsed;\n};\n\n/**\n * Prepends a base IRI to the given relative IRI.\n *\n * @param base the base IRI.\n * @param iri the relative IRI.\n *\n * @return the absolute IRI.\n */\napi.prependBase = (base, iri) => {\n  // skip IRI processing\n  if (base === null) {\n    return iri;\n  }\n  // already an absolute IRI\n  if (api.isAbsolute(iri)) {\n    return iri;\n  }\n\n  // parse base if it is a string\n  if (!base || types.isString(base)) {\n    base = api.parse(base || '');\n  }\n\n  // parse given IRI\n  const rel = api.parse(iri);\n\n  // per RFC3986 5.2.2\n  const transform = {\n    protocol: base.protocol || ''\n  };\n  if (rel.authority !== null) {\n    transform.authority = rel.authority;\n    transform.path = rel.path;\n    transform.query = rel.query;\n  } else {\n    transform.authority = base.authority;\n    if (rel.path === '') {\n      transform.path = base.path;\n      if (rel.query !== null) {\n        transform.query = rel.query;\n      } else {\n        transform.query = base.query;\n      }\n    } else {\n      if (rel.path.indexOf('/') === 0) {\n        // IRI represents an absolute path\n        transform.path = rel.path;\n      } else {\n        // merge paths\n        let path = base.path;\n\n        // append relative path to the end of the last directory from base\n        path = path.substr(0, path.lastIndexOf('/') + 1);\n        if ((path.length > 0 || base.authority) && path.substr(-1) !== '/') {\n          path += '/';\n        }\n        path += rel.path;\n        transform.path = path;\n      }\n      transform.query = rel.query;\n    }\n  }\n  if (rel.path !== '') {\n    // remove slashes and dots in path\n    transform.path = api.removeDotSegments(transform.path);\n  }\n\n  // construct URL\n  let rval = transform.protocol;\n  if (transform.authority !== null) {\n    rval += '//' + transform.authority;\n  }\n  rval += transform.path;\n  if (transform.query !== null) {\n    rval += '?' + transform.query;\n  }\n  if (rel.fragment !== null) {\n    rval += '#' + rel.fragment;\n  }\n\n  // handle empty base\n  if (rval === '') {\n    rval = './';\n  }\n  return rval;\n};\n\n/**\n * Removes a base IRI from the given absolute IRI.\n *\n * @param base the base IRI.\n * @param iri the absolute IRI.\n *\n * @return the relative IRI if relative to base, otherwise the absolute IRI.\n */\napi.removeBase = (base, iri) => {\n  // skip IRI processing\n  if (base === null) {\n    return iri;\n  }\n  if (!base || types.isString(base)) {\n    base = api.parse(base || '');\n  }\n\n  // establish base root\n  let root = '';\n  if (base.href !== '') {\n    root += (base.protocol || '') + '//' + (base.authority || '');\n  } else if (iri.indexOf('//')) {\n    // support network-path reference with empty base\n    root += '//';\n  }\n\n  // IRI not relative to base\n  if (iri.indexOf(root) !== 0) {\n    return iri;\n  }\n\n  // remove root from IRI and parse remainder\n  const rel = api.parse(iri.substr(root.length));\n\n  // remove path segments that match (do not remove last segment unless there\n  // is a hash or query)\n  const baseSegments = base.normalizedPath.split('/');\n  const iriSegments = rel.normalizedPath.split('/');\n  const last = rel.fragment || rel.query ? 0 : 1;\n  while (baseSegments.length > 0 && iriSegments.length > last) {\n    if (baseSegments[0] !== iriSegments[0]) {\n      break;\n    }\n    baseSegments.shift();\n    iriSegments.shift();\n  }\n\n  // use '../' for each non-matching base segment\n  let rval = '';\n  if (baseSegments.length > 0) {\n    // don't count the last segment (if it ends with '/' last path doesn't\n    // count and if it doesn't end with '/' it isn't a path)\n    baseSegments.pop();\n    for (let i = 0; i < baseSegments.length; ++i) {\n      rval += '../';\n    }\n  }\n\n  // prepend remaining segments\n  rval += iriSegments.join('/');\n\n  // add query and hash\n  if (rel.query !== null) {\n    rval += '?' + rel.query;\n  }\n  if (rel.fragment !== null) {\n    rval += '#' + rel.fragment;\n  }\n\n  // handle empty base\n  if (rval === '') {\n    rval = './';\n  }\n  return rval;\n};\n\n/**\n * Removes dot segments from a URL path.\n *\n * @param path the path to remove dot segments from.\n */\napi.removeDotSegments = path => {\n  // RFC 3986 5.2.4 (reworked)\n\n  // empty path shortcut\n  if (path.length === 0) {\n    return '';\n  }\n  const input = path.split('/');\n  const output = [];\n  while (input.length > 0) {\n    const next = input.shift();\n    const done = input.length === 0;\n    if (next === '.') {\n      if (done) {\n        // ensure output has trailing /\n        output.push('');\n      }\n      continue;\n    }\n    if (next === '..') {\n      output.pop();\n      if (done) {\n        // ensure output has trailing /\n        output.push('');\n      }\n      continue;\n    }\n    output.push(next);\n  }\n\n  // if path was absolute, ensure output has leading /\n  if (path[0] === '/' && output.length > 0 && output[0] !== '') {\n    output.unshift('');\n  }\n  if (output.length === 1 && output[0] === '') {\n    return '/';\n  }\n  return output.join('/');\n};\n\n// TODO: time better isAbsolute/isRelative checks using full regexes:\n// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html\n\n// regex to check for absolute IRI (starting scheme and ':') or blank node IRI\nconst isAbsoluteRegex = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^\\s]*$/;\n\n/**\n * Returns true if the given value is an absolute IRI or blank node IRI, false\n * if not.\n * Note: This weak check only checks for a correct starting scheme.\n *\n * @param v the value to check.\n *\n * @return true if the value is an absolute IRI, false if not.\n */\napi.isAbsolute = v => types.isString(v) && isAbsoluteRegex.test(v);\n\n/**\n * Returns true if the given value is a relative IRI, false if not.\n * Note: this is a weak check.\n *\n * @param v the value to check.\n *\n * @return true if the value is a relative IRI, false if not.\n */\napi.isRelative = v => types.isString(v);","map":{"version":3,"names":["types","require","api","module","exports","parsers","simple","keys","regex","full","parse","str","parser","parsed","o","m","exec","i","length","undefined","scheme","port","href","replace","authority","normalizedPath","removeDotSegments","path","prependBase","base","iri","isAbsolute","isString","rel","transform","protocol","query","indexOf","substr","lastIndexOf","rval","fragment","removeBase","root","baseSegments","split","iriSegments","last","shift","pop","join","input","output","next","done","push","unshift","isAbsoluteRegex","v","test","isRelative"],"sources":["E:/react-todo-app/node_modules/jsonld/lib/url.js"],"sourcesContent":["/*\n * Copyright (c) 2017 Digital Bazaar, Inc. All rights reserved.\n */\n'use strict';\n\nconst types = require('./types');\n\nconst api = {};\nmodule.exports = api;\n\n// define URL parser\n// parseUri 1.2.2\n// (c) Steven Levithan <stevenlevithan.com>\n// MIT License\n// with local jsonld.js modifications\napi.parsers = {\n  simple: {\n    // RFC 3986 basic parts\n    keys: [\n      'href', 'scheme', 'authority', 'path', 'query', 'fragment'\n    ],\n    /* eslint-disable-next-line max-len */\n    regex: /^(?:([^:\\/?#]+):)?(?:\\/\\/([^\\/?#]*))?([^?#]*)(?:\\?([^#]*))?(?:#(.*))?/\n  },\n  full: {\n    keys: [\n      'href', 'protocol', 'scheme', 'authority', 'auth', 'user', 'password',\n      'hostname', 'port', 'path', 'directory', 'file', 'query', 'fragment'\n    ],\n    /* eslint-disable-next-line max-len */\n    regex: /^(([^:\\/?#]+):)?(?:\\/\\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?))?(?:(((?:[^?#\\/]*\\/)*)([^?#]*))(?:\\?([^#]*))?(?:#(.*))?)/\n  }\n};\napi.parse = (str, parser) => {\n  const parsed = {};\n  const o = api.parsers[parser || 'full'];\n  const m = o.regex.exec(str);\n  let i = o.keys.length;\n  while(i--) {\n    parsed[o.keys[i]] = (m[i] === undefined) ? null : m[i];\n  }\n\n  // remove default ports in found in URLs\n  if((parsed.scheme === 'https' && parsed.port === '443') ||\n    (parsed.scheme === 'http' && parsed.port === '80')) {\n    parsed.href = parsed.href.replace(':' + parsed.port, '');\n    parsed.authority = parsed.authority.replace(':' + parsed.port, '');\n    parsed.port = null;\n  }\n\n  parsed.normalizedPath = api.removeDotSegments(parsed.path);\n  return parsed;\n};\n\n/**\n * Prepends a base IRI to the given relative IRI.\n *\n * @param base the base IRI.\n * @param iri the relative IRI.\n *\n * @return the absolute IRI.\n */\napi.prependBase = (base, iri) => {\n  // skip IRI processing\n  if(base === null) {\n    return iri;\n  }\n  // already an absolute IRI\n  if(api.isAbsolute(iri)) {\n    return iri;\n  }\n\n  // parse base if it is a string\n  if(!base || types.isString(base)) {\n    base = api.parse(base || '');\n  }\n\n  // parse given IRI\n  const rel = api.parse(iri);\n\n  // per RFC3986 5.2.2\n  const transform = {\n    protocol: base.protocol || ''\n  };\n\n  if(rel.authority !== null) {\n    transform.authority = rel.authority;\n    transform.path = rel.path;\n    transform.query = rel.query;\n  } else {\n    transform.authority = base.authority;\n\n    if(rel.path === '') {\n      transform.path = base.path;\n      if(rel.query !== null) {\n        transform.query = rel.query;\n      } else {\n        transform.query = base.query;\n      }\n    } else {\n      if(rel.path.indexOf('/') === 0) {\n        // IRI represents an absolute path\n        transform.path = rel.path;\n      } else {\n        // merge paths\n        let path = base.path;\n\n        // append relative path to the end of the last directory from base\n        path = path.substr(0, path.lastIndexOf('/') + 1);\n        if((path.length > 0 || base.authority) && path.substr(-1) !== '/') {\n          path += '/';\n        }\n        path += rel.path;\n\n        transform.path = path;\n      }\n      transform.query = rel.query;\n    }\n  }\n\n  if(rel.path !== '') {\n    // remove slashes and dots in path\n    transform.path = api.removeDotSegments(transform.path);\n  }\n\n  // construct URL\n  let rval = transform.protocol;\n  if(transform.authority !== null) {\n    rval += '//' + transform.authority;\n  }\n  rval += transform.path;\n  if(transform.query !== null) {\n    rval += '?' + transform.query;\n  }\n  if(rel.fragment !== null) {\n    rval += '#' + rel.fragment;\n  }\n\n  // handle empty base\n  if(rval === '') {\n    rval = './';\n  }\n\n  return rval;\n};\n\n/**\n * Removes a base IRI from the given absolute IRI.\n *\n * @param base the base IRI.\n * @param iri the absolute IRI.\n *\n * @return the relative IRI if relative to base, otherwise the absolute IRI.\n */\napi.removeBase = (base, iri) => {\n  // skip IRI processing\n  if(base === null) {\n    return iri;\n  }\n\n  if(!base || types.isString(base)) {\n    base = api.parse(base || '');\n  }\n\n  // establish base root\n  let root = '';\n  if(base.href !== '') {\n    root += (base.protocol || '') + '//' + (base.authority || '');\n  } else if(iri.indexOf('//')) {\n    // support network-path reference with empty base\n    root += '//';\n  }\n\n  // IRI not relative to base\n  if(iri.indexOf(root) !== 0) {\n    return iri;\n  }\n\n  // remove root from IRI and parse remainder\n  const rel = api.parse(iri.substr(root.length));\n\n  // remove path segments that match (do not remove last segment unless there\n  // is a hash or query)\n  const baseSegments = base.normalizedPath.split('/');\n  const iriSegments = rel.normalizedPath.split('/');\n  const last = (rel.fragment || rel.query) ? 0 : 1;\n  while(baseSegments.length > 0 && iriSegments.length > last) {\n    if(baseSegments[0] !== iriSegments[0]) {\n      break;\n    }\n    baseSegments.shift();\n    iriSegments.shift();\n  }\n\n  // use '../' for each non-matching base segment\n  let rval = '';\n  if(baseSegments.length > 0) {\n    // don't count the last segment (if it ends with '/' last path doesn't\n    // count and if it doesn't end with '/' it isn't a path)\n    baseSegments.pop();\n    for(let i = 0; i < baseSegments.length; ++i) {\n      rval += '../';\n    }\n  }\n\n  // prepend remaining segments\n  rval += iriSegments.join('/');\n\n  // add query and hash\n  if(rel.query !== null) {\n    rval += '?' + rel.query;\n  }\n  if(rel.fragment !== null) {\n    rval += '#' + rel.fragment;\n  }\n\n  // handle empty base\n  if(rval === '') {\n    rval = './';\n  }\n\n  return rval;\n};\n\n/**\n * Removes dot segments from a URL path.\n *\n * @param path the path to remove dot segments from.\n */\napi.removeDotSegments = path => {\n  // RFC 3986 5.2.4 (reworked)\n\n  // empty path shortcut\n  if(path.length === 0) {\n    return '';\n  }\n\n  const input = path.split('/');\n  const output = [];\n\n  while(input.length > 0) {\n    const next = input.shift();\n    const done = input.length === 0;\n\n    if(next === '.') {\n      if(done) {\n        // ensure output has trailing /\n        output.push('');\n      }\n      continue;\n    }\n\n    if(next === '..') {\n      output.pop();\n      if(done) {\n        // ensure output has trailing /\n        output.push('');\n      }\n      continue;\n    }\n\n    output.push(next);\n  }\n\n  // if path was absolute, ensure output has leading /\n  if(path[0] === '/' && output.length > 0 && output[0] !== '') {\n    output.unshift('');\n  }\n  if(output.length === 1 && output[0] === '') {\n    return '/';\n  }\n\n  return output.join('/');\n};\n\n// TODO: time better isAbsolute/isRelative checks using full regexes:\n// http://jmrware.com/articles/2009/uri_regexp/URI_regex.html\n\n// regex to check for absolute IRI (starting scheme and ':') or blank node IRI\nconst isAbsoluteRegex = /^([A-Za-z][A-Za-z0-9+-.]*|_):[^\\s]*$/;\n\n/**\n * Returns true if the given value is an absolute IRI or blank node IRI, false\n * if not.\n * Note: This weak check only checks for a correct starting scheme.\n *\n * @param v the value to check.\n *\n * @return true if the value is an absolute IRI, false if not.\n */\napi.isAbsolute = v => types.isString(v) && isAbsoluteRegex.test(v);\n\n/**\n * Returns true if the given value is a relative IRI, false if not.\n * Note: this is a weak check.\n *\n * @param v the value to check.\n *\n * @return true if the value is a relative IRI, false if not.\n */\napi.isRelative = v => types.isString(v);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}