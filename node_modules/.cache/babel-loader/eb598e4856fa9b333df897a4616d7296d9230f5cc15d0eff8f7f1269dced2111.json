{"ast":null,"code":"'use strict';\n\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i;\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/;\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g;\nvar DELIMITER_PATTERN = /[;,\"]/;\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/;\n\n/**\n * Token character pattern\n * @type {RegExp}\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nvar TOKEN_PATTERN = /^[!#$%&'*+\\-\\.^_`|~\\da-zA-Z]+$/;\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2\n};\nfunction trim(value) {\n  return value.replace(WS_TRIM_PATTERN, '');\n}\nfunction hasWhitespace(value) {\n  return WS_CHAR_PATTERN.test(value);\n}\nfunction skipWhitespace(value, offset) {\n  while (hasWhitespace(value[offset])) {\n    offset++;\n  }\n  return offset;\n}\nfunction needsQuotes(value) {\n  return WS_DELIMITER_PATTERN.test(value) || !TOKEN_PATTERN.test(value);\n}\n\n/**\n * Shallow compares two objects to check if their properties match.\n * @param {object} object1 First object to compare.\n * @param {object} object2 Second object to compare.\n * @returns {boolean} Do the objects have matching properties.\n */\nfunction shallowCompareObjects(object1, object2) {\n  return Object.keys(object1).length === Object.keys(object2).length && Object.keys(object1).every(key => key in object2 && object1[key] === object2[key]);\n}\nclass Link {\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  constructor(value) {\n    /** @type {Array} URI references */\n    this.refs = [];\n    if (value) {\n      this.parse(value);\n    }\n  }\n\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  rel(value) {\n    var links = [];\n    var type = value.toLowerCase();\n    for (var i = 0; i < this.refs.length; i++) {\n      if (this.refs[i].rel.toLowerCase() === type) {\n        links.push(this.refs[i]);\n      }\n    }\n    return links;\n  }\n\n  /**\n   * Get refs where given attribute has a given value\n   * @param {String} attr\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  get(attr, value) {\n    attr = attr.toLowerCase();\n    var links = [];\n    for (var i = 0; i < this.refs.length; i++) {\n      if (this.refs[i][attr] === value) {\n        links.push(this.refs[i]);\n      }\n    }\n    return links;\n  }\n\n  /** Sets a reference. */\n  set(link) {\n    this.refs.push(link);\n    return this;\n  }\n\n  /**\n   * Sets a reference if a reference with similar properties isn’t already set.\n   */\n  setUnique(link) {\n    if (!this.refs.some(ref => shallowCompareObjects(ref, link))) {\n      this.refs.push(link);\n    }\n    return this;\n  }\n  has(attr, value) {\n    attr = attr.toLowerCase();\n    for (var i = 0; i < this.refs.length; i++) {\n      if (this.refs[i][attr] === value) {\n        return true;\n      }\n    }\n    return false;\n  }\n  parse(value, offset) {\n    offset = offset || 0;\n    value = offset ? value.slice(offset) : value;\n\n    // Trim & unfold folded lines\n    value = trim(value).replace(WS_FOLD_PATTERN, '');\n    var state = STATE.IDLE;\n    var length = value.length;\n    var offset = 0;\n    var ref = null;\n    while (offset < length) {\n      if (state === STATE.IDLE) {\n        if (hasWhitespace(value[offset])) {\n          offset++;\n          continue;\n        } else if (value[offset] === '<') {\n          if (ref != null) {\n            ref.rel != null ? this.refs.push(...Link.expandRelations(ref)) : this.refs.push(ref);\n          }\n          var end = value.indexOf('>', offset);\n          if (end === -1) throw new Error('Expected end of URI delimiter at offset ' + offset);\n          ref = {\n            uri: value.slice(offset + 1, end)\n          };\n          // this.refs.push( ref )\n          offset = end;\n          state = STATE.URI;\n        } else {\n          throw new Error('Unexpected character \"' + value[offset] + '\" at offset ' + offset);\n        }\n        offset++;\n      } else if (state === STATE.URI) {\n        if (hasWhitespace(value[offset])) {\n          offset++;\n          continue;\n        } else if (value[offset] === ';') {\n          state = STATE.ATTR;\n          offset++;\n        } else if (value[offset] === ',') {\n          state = STATE.IDLE;\n          offset++;\n        } else {\n          throw new Error('Unexpected character \"' + value[offset] + '\" at offset ' + offset);\n        }\n      } else if (state === STATE.ATTR) {\n        if (value[offset] === ';' || hasWhitespace(value[offset])) {\n          offset++;\n          continue;\n        }\n        var end = value.indexOf('=', offset);\n        if (end === -1) throw new Error('Expected attribute delimiter at offset ' + offset);\n        var attr = trim(value.slice(offset, end)).toLowerCase();\n        var attrValue = '';\n        offset = end + 1;\n        offset = skipWhitespace(value, offset);\n        if (value[offset] === '\"') {\n          offset++;\n          while (offset < length) {\n            if (value[offset] === '\"') {\n              offset++;\n              break;\n            }\n            if (value[offset] === '\\\\') {\n              offset++;\n            }\n            attrValue += value[offset];\n            offset++;\n          }\n        } else {\n          var end = offset + 1;\n          while (!DELIMITER_PATTERN.test(value[end]) && end < length) {\n            end++;\n          }\n          attrValue = value.slice(offset, end);\n          offset = end;\n        }\n        if (ref[attr] && Link.isSingleOccurenceAttr(attr)) {\n          // Ignore multiples of attributes which may only appear once\n        } else if (attr[attr.length - 1] === '*') {\n          ref[attr] = Link.parseExtendedValue(attrValue);\n        } else {\n          attrValue = attr === 'type' ? attrValue.toLowerCase() : attrValue;\n          if (ref[attr] != null) {\n            if (Array.isArray(ref[attr])) {\n              ref[attr].push(attrValue);\n            } else {\n              ref[attr] = [ref[attr], attrValue];\n            }\n          } else {\n            ref[attr] = attrValue;\n          }\n        }\n        switch (value[offset]) {\n          case ',':\n            state = STATE.IDLE;\n            break;\n          case ';':\n            state = STATE.ATTR;\n            break;\n        }\n        offset++;\n      } else {\n        throw new Error('Unknown parser state \"' + state + '\"');\n      }\n    }\n    if (ref != null) {\n      ref.rel != null ? this.refs.push(...Link.expandRelations(ref)) : this.refs.push(ref);\n    }\n    ref = null;\n    return this;\n  }\n  toString() {\n    var refs = [];\n    var link = '';\n    var ref = null;\n    for (var i = 0; i < this.refs.length; i++) {\n      ref = this.refs[i];\n      link = Object.keys(this.refs[i]).reduce(function (link, attr) {\n        if (attr === 'uri') return link;\n        return link + '; ' + Link.formatAttribute(attr, ref[attr]);\n      }, '<' + ref.uri + '>');\n      refs.push(link);\n    }\n    return refs.join(', ');\n  }\n}\n\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\nLink.isCompatibleEncoding = function (value) {\n  return COMPATIBLE_ENCODING_PATTERN.test(value);\n};\nLink.parse = function (value, offset) {\n  return new Link().parse(value, offset);\n};\nLink.isSingleOccurenceAttr = function (attr) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' || attr === 'title' || attr === 'title*';\n};\nLink.isTokenAttr = function (attr) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor';\n};\nLink.escapeQuotes = function (value) {\n  return value.replace(/\"/g, '\\\\\"');\n};\nLink.expandRelations = function (ref) {\n  var rels = ref.rel.split(' ');\n  return rels.map(function (rel) {\n    var value = Object.assign({}, ref);\n    value.rel = rel;\n    return value;\n  });\n};\n\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\nLink.parseExtendedValue = function (value) {\n  var parts = /([^']+)?(?:'([^']*)')?(.+)/.exec(value);\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding(parts[1]) ? null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding(parts[1]) ? decodeURIComponent(parts[3]) : parts[3]\n  };\n};\n\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\nLink.formatExtendedAttribute = function (attr, data) {\n  var encoding = (data.encoding || 'utf-8').toUpperCase();\n  var language = data.language || 'en';\n  var encodedValue = '';\n  if (Buffer.isBuffer(data.value) && Link.isCompatibleEncoding(encoding)) {\n    encodedValue = data.value.toString(encoding);\n  } else if (Buffer.isBuffer(data.value)) {\n    encodedValue = data.value.toString('hex').replace(/[0-9a-f]{2}/gi, '%$1');\n  } else {\n    encodedValue = encodeURIComponent(data.value);\n  }\n  return attr + '=' + encoding + '\\'' + language + '\\'' + encodedValue;\n};\n\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\nLink.formatAttribute = function (attr, value) {\n  if (Array.isArray(value)) {\n    return value.map(item => {\n      return Link.formatAttribute(attr, item);\n    }).join('; ');\n  }\n  if (attr[attr.length - 1] === '*' || typeof value !== 'string') {\n    return Link.formatExtendedAttribute(attr, value);\n  }\n  if (Link.isTokenAttr(attr)) {\n    value = needsQuotes(value) ? '\"' + Link.escapeQuotes(value) + '\"' : Link.escapeQuotes(value);\n  } else if (needsQuotes(value)) {\n    value = encodeURIComponent(value);\n    // We don't need to escape <SP> <,> <;> within quotes\n    value = value.replace(/%20/g, ' ').replace(/%2C/g, ',').replace(/%3B/g, ';');\n    value = '\"' + value + '\"';\n  }\n  return attr + '=' + value;\n};\nmodule.exports = Link;","map":{"version":3,"names":["COMPATIBLE_ENCODING_PATTERN","WS_TRIM_PATTERN","WS_CHAR_PATTERN","WS_FOLD_PATTERN","DELIMITER_PATTERN","WS_DELIMITER_PATTERN","TOKEN_PATTERN","STATE","IDLE","URI","ATTR","trim","value","replace","hasWhitespace","test","skipWhitespace","offset","needsQuotes","shallowCompareObjects","object1","object2","Object","keys","length","every","key","Link","constructor","refs","parse","rel","links","type","toLowerCase","i","push","get","attr","set","link","setUnique","some","ref","has","slice","state","expandRelations","end","indexOf","Error","uri","attrValue","isSingleOccurenceAttr","parseExtendedValue","Array","isArray","toString","reduce","formatAttribute","join","isCompatibleEncoding","isTokenAttr","escapeQuotes","rels","split","map","assign","parts","exec","language","encoding","decodeURIComponent","formatExtendedAttribute","data","toUpperCase","encodedValue","Buffer","isBuffer","encodeURIComponent","item","module","exports"],"sources":["E:/react-todo-app/node_modules/http-link-header/lib/link.js"],"sourcesContent":["'use strict'\n\nvar COMPATIBLE_ENCODING_PATTERN = /^utf-?8|ascii|utf-?16-?le|ucs-?2|base-?64|latin-?1$/i\nvar WS_TRIM_PATTERN = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g\nvar WS_CHAR_PATTERN = /\\s|\\uFEFF|\\xA0/\nvar WS_FOLD_PATTERN = /\\r?\\n[\\x20\\x09]+/g\nvar DELIMITER_PATTERN = /[;,\"]/\nvar WS_DELIMITER_PATTERN = /[;,\"]|\\s/\n\n/**\n * Token character pattern\n * @type {RegExp}\n * @see https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\nvar TOKEN_PATTERN = /^[!#$%&'*+\\-\\.^_`|~\\da-zA-Z]+$/\n\nvar STATE = {\n  IDLE: 1 << 0,\n  URI: 1 << 1,\n  ATTR: 1 << 2,\n}\n\nfunction trim( value ) {\n  return value.replace( WS_TRIM_PATTERN, '' )\n}\n\nfunction hasWhitespace( value ) {\n  return WS_CHAR_PATTERN.test( value )\n}\n\nfunction skipWhitespace( value, offset ) {\n  while( hasWhitespace( value[offset] ) ) {\n    offset++\n  }\n  return offset\n}\n\nfunction needsQuotes( value ) {\n  return WS_DELIMITER_PATTERN.test( value ) ||\n    !TOKEN_PATTERN.test( value )\n}\n\n/**\n * Shallow compares two objects to check if their properties match.\n * @param {object} object1 First object to compare.\n * @param {object} object2 Second object to compare.\n * @returns {boolean} Do the objects have matching properties.\n */\nfunction shallowCompareObjects( object1, object2 ) {\n  return (\n    Object.keys( object1 ).length === Object.keys( object2 ).length &&\n    Object.keys( object1 ).every(\n      ( key ) => key in object2 && object1[ key ] === object2[ key ]\n    )\n  );\n}\n\nclass Link {\n\n  /**\n   * Link\n   * @constructor\n   * @param {String} [value]\n   * @returns {Link}\n   */\n  constructor( value ) {\n\n    /** @type {Array} URI references */\n    this.refs = []\n\n    if( value ) {\n      this.parse( value )\n    }\n\n  }\n\n  /**\n   * Get refs with given relation type\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  rel( value ) {\n\n    var links = []\n    var type = value.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ].rel.toLowerCase() === type ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /**\n   * Get refs where given attribute has a given value\n   * @param {String} attr\n   * @param {String} value\n   * @returns {Array<Object>}\n   */\n  get( attr, value ) {\n\n    attr = attr.toLowerCase()\n\n    var links = []\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ][ attr ] === value ) {\n        links.push( this.refs[ i ] )\n      }\n    }\n\n    return links\n\n  }\n\n  /** Sets a reference. */\n  set( link ) {\n    this.refs.push( link )\n    return this\n  }\n\n  /**\n   * Sets a reference if a reference with similar properties isn’t already set.\n   */\n  setUnique( link ) {\n\n    if( !this.refs.some(( ref ) => shallowCompareObjects( ref, link )) ) {\n      this.refs.push( link )\n    }\n\n    return this\n\n  }\n\n  has( attr, value ) {\n\n    attr = attr.toLowerCase()\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      if( this.refs[ i ][ attr ] === value ) {\n        return true\n      }\n    }\n\n    return false\n\n  }\n\n  parse( value, offset ) {\n\n    offset = offset || 0\n    value = offset ? value.slice( offset ) : value\n\n    // Trim & unfold folded lines\n    value = trim( value ).replace( WS_FOLD_PATTERN, '' )\n\n    var state = STATE.IDLE\n    var length = value.length\n    var offset = 0\n    var ref = null\n\n    while( offset < length ) {\n      if( state === STATE.IDLE ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === '<' ) {\n          if( ref != null ) {\n            ref.rel != null ?\n              this.refs.push( ...Link.expandRelations( ref ) ) :\n              this.refs.push( ref )\n          }\n          var end = value.indexOf( '>', offset )\n          if( end === -1 ) throw new Error( 'Expected end of URI delimiter at offset ' + offset )\n          ref = { uri: value.slice( offset + 1, end ) }\n          // this.refs.push( ref )\n          offset = end\n          state = STATE.URI\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n        offset++\n      } else if( state === STATE.URI ) {\n        if( hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        } else if( value[offset] === ';' ) {\n          state = STATE.ATTR\n          offset++\n        } else if( value[offset] === ',' ) {\n          state = STATE.IDLE\n          offset++\n        } else {\n          throw new Error( 'Unexpected character \"' + value[offset] + '\" at offset ' + offset )\n        }\n      } else if( state === STATE.ATTR ) {\n        if( value[offset] ===';' || hasWhitespace( value[offset] ) ) {\n          offset++\n          continue\n        }\n        var end = value.indexOf( '=', offset )\n        if( end === -1 ) throw new Error( 'Expected attribute delimiter at offset ' + offset )\n        var attr = trim( value.slice( offset, end ) ).toLowerCase()\n        var attrValue = ''\n        offset = end + 1\n        offset = skipWhitespace( value, offset )\n        if( value[offset] === '\"' ) {\n          offset++\n          while( offset < length ) {\n            if( value[offset] === '\"' ) {\n              offset++; break\n            }\n            if( value[offset] === '\\\\' ) {\n              offset++\n            }\n            attrValue += value[offset]\n            offset++\n          }\n        } else {\n          var end = offset + 1\n          while( !DELIMITER_PATTERN.test( value[end] ) && end < length ) {\n            end++\n          }\n          attrValue = value.slice( offset, end )\n          offset = end\n        }\n        if( ref[ attr ] && Link.isSingleOccurenceAttr( attr ) ) {\n          // Ignore multiples of attributes which may only appear once\n        } else if( attr[ attr.length - 1 ] === '*' ) {\n          ref[ attr ] = Link.parseExtendedValue( attrValue )\n        } else {\n          attrValue = attr === 'type' ?\n            attrValue.toLowerCase() : attrValue\n          if( ref[ attr ] != null ) {\n            if( Array.isArray( ref[ attr ] ) ) {\n              ref[ attr ].push( attrValue )\n            } else {\n              ref[ attr ] = [ ref[ attr ], attrValue ]\n            }\n          } else {\n            ref[ attr ] = attrValue\n          }\n        }\n        switch( value[offset] ) {\n          case ',': state = STATE.IDLE; break\n          case ';': state = STATE.ATTR; break\n        }\n        offset++\n      } else {\n        throw new Error( 'Unknown parser state \"' + state + '\"' )\n      }\n    }\n\n    if( ref != null ) {\n      ref.rel != null ?\n        this.refs.push( ...Link.expandRelations( ref ) ) :\n        this.refs.push( ref )\n    }\n\n    ref = null\n\n    return this\n\n  }\n\n  toString() {\n\n    var refs = []\n    var link = ''\n    var ref = null\n\n    for( var i = 0; i < this.refs.length; i++ ) {\n      ref = this.refs[i]\n      link = Object.keys( this.refs[i] ).reduce( function( link, attr ) {\n        if( attr === 'uri' ) return link\n        return link + '; ' + Link.formatAttribute( attr, ref[ attr ] )\n      }, '<' + ref.uri + '>' )\n      refs.push( link )\n    }\n\n    return refs.join( ', ' )\n\n  }\n\n}\n\n/**\n * Determines whether an encoding can be\n * natively handled with a `Buffer`\n * @param {String} value\n * @returns {Boolean}\n */\nLink.isCompatibleEncoding = function( value ) {\n  return COMPATIBLE_ENCODING_PATTERN.test( value )\n}\n\nLink.parse = function( value, offset ) {\n  return new Link().parse( value, offset )\n}\n\nLink.isSingleOccurenceAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'media' ||\n    attr === 'title' || attr === 'title*'\n}\n\nLink.isTokenAttr = function( attr ) {\n  return attr === 'rel' || attr === 'type' || attr === 'anchor'\n}\n\nLink.escapeQuotes = function( value ) {\n  return value.replace( /\"/g, '\\\\\"' )\n}\n\nLink.expandRelations = function( ref ) {\n  var rels = ref.rel.split( ' ' )\n  return rels.map( function( rel ) {\n    var value = Object.assign( {}, ref )\n    value.rel = rel\n    return value\n  })\n}\n\n/**\n * Parses an extended value and attempts to decode it\n * @internal\n * @param {String} value\n * @return {Object}\n */\nLink.parseExtendedValue = function( value ) {\n  var parts = /([^']+)?(?:'([^']*)')?(.+)/.exec( value )\n  return {\n    language: parts[2].toLowerCase(),\n    encoding: Link.isCompatibleEncoding( parts[1] ) ?\n      null : parts[1].toLowerCase(),\n    value: Link.isCompatibleEncoding( parts[1] ) ?\n      decodeURIComponent( parts[3] ) : parts[3]\n  }\n}\n\n/**\n * Format a given extended attribute and it's value\n * @param {String} attr\n * @param {Object} data\n * @return {String}\n */\nLink.formatExtendedAttribute = function( attr, data ) {\n\n  var encoding = ( data.encoding || 'utf-8' ).toUpperCase()\n  var language = data.language || 'en'\n\n  var encodedValue = ''\n\n  if( Buffer.isBuffer( data.value ) && Link.isCompatibleEncoding( encoding ) ) {\n    encodedValue = data.value.toString( encoding )\n  } else if( Buffer.isBuffer( data.value ) ) {\n    encodedValue = data.value.toString( 'hex' )\n      .replace( /[0-9a-f]{2}/gi, '%$1' )\n  } else {\n    encodedValue = encodeURIComponent( data.value )\n  }\n\n  return attr + '=' + encoding + '\\'' +\n    language + '\\'' + encodedValue\n\n}\n\n/**\n * Format a given attribute and it's value\n * @param {String} attr\n * @param {String|Object} value\n * @return {String}\n */\nLink.formatAttribute = function( attr, value ) {\n\n  if( Array.isArray( value ) ) {\n    return value.map(( item ) => {\n      return Link.formatAttribute( attr, item )\n    }).join( '; ' )\n  }\n\n  if( attr[ attr.length - 1 ] === '*' || typeof value !== 'string' ) {\n    return Link.formatExtendedAttribute( attr, value )\n  }\n\n  if( Link.isTokenAttr( attr ) ) {\n    value = needsQuotes( value ) ?\n      '\"' + Link.escapeQuotes( value ) + '\"' :\n      Link.escapeQuotes( value )\n  } else if( needsQuotes( value ) ) {\n    value = encodeURIComponent( value )\n    // We don't need to escape <SP> <,> <;> within quotes\n    value = value\n      .replace( /%20/g, ' ' )\n      .replace( /%2C/g, ',' )\n      .replace( /%3B/g, ';' )\n\n    value = '\"' + value + '\"'\n  }\n\n  return attr + '=' + value\n\n}\n\nmodule.exports = Link\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,2BAA2B,GAAG,sDAAsD;AACxF,IAAIC,eAAe,GAAG,oCAAoC;AAC1D,IAAIC,eAAe,GAAG,gBAAgB;AACtC,IAAIC,eAAe,GAAG,mBAAmB;AACzC,IAAIC,iBAAiB,GAAG,OAAO;AAC/B,IAAIC,oBAAoB,GAAG,UAAU;;AAErC;AACA;AACA;AACA;AACA;AACA,IAAIC,aAAa,GAAG,gCAAgC;AAEpD,IAAIC,KAAK,GAAG;EACVC,IAAI,EAAE,CAAC,IAAI,CAAC;EACZC,GAAG,EAAE,CAAC,IAAI,CAAC;EACXC,IAAI,EAAE,CAAC,IAAI;AACb,CAAC;AAED,SAASC,IAAI,CAAEC,KAAK,EAAG;EACrB,OAAOA,KAAK,CAACC,OAAO,CAAEZ,eAAe,EAAE,EAAE,CAAE;AAC7C;AAEA,SAASa,aAAa,CAAEF,KAAK,EAAG;EAC9B,OAAOV,eAAe,CAACa,IAAI,CAAEH,KAAK,CAAE;AACtC;AAEA,SAASI,cAAc,CAAEJ,KAAK,EAAEK,MAAM,EAAG;EACvC,OAAOH,aAAa,CAAEF,KAAK,CAACK,MAAM,CAAC,CAAE,EAAG;IACtCA,MAAM,EAAE;EACV;EACA,OAAOA,MAAM;AACf;AAEA,SAASC,WAAW,CAAEN,KAAK,EAAG;EAC5B,OAAOP,oBAAoB,CAACU,IAAI,CAAEH,KAAK,CAAE,IACvC,CAACN,aAAa,CAACS,IAAI,CAAEH,KAAK,CAAE;AAChC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASO,qBAAqB,CAAEC,OAAO,EAAEC,OAAO,EAAG;EACjD,OACEC,MAAM,CAACC,IAAI,CAAEH,OAAO,CAAE,CAACI,MAAM,KAAKF,MAAM,CAACC,IAAI,CAAEF,OAAO,CAAE,CAACG,MAAM,IAC/DF,MAAM,CAACC,IAAI,CAAEH,OAAO,CAAE,CAACK,KAAK,CACxBC,GAAG,IAAMA,GAAG,IAAIL,OAAO,IAAID,OAAO,CAAEM,GAAG,CAAE,KAAKL,OAAO,CAAEK,GAAG,CAAE,CAC/D;AAEL;AAEA,MAAMC,IAAI,CAAC;EAET;AACF;AACA;AACA;AACA;AACA;EACEC,WAAW,CAAEhB,KAAK,EAAG;IAEnB;IACA,IAAI,CAACiB,IAAI,GAAG,EAAE;IAEd,IAAIjB,KAAK,EAAG;MACV,IAAI,CAACkB,KAAK,CAAElB,KAAK,CAAE;IACrB;EAEF;;EAEA;AACF;AACA;AACA;AACA;EACEmB,GAAG,CAAEnB,KAAK,EAAG;IAEX,IAAIoB,KAAK,GAAG,EAAE;IACd,IAAIC,IAAI,GAAGrB,KAAK,CAACsB,WAAW,EAAE;IAE9B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACN,IAAI,CAACL,MAAM,EAAEW,CAAC,EAAE,EAAG;MAC1C,IAAI,IAAI,CAACN,IAAI,CAAEM,CAAC,CAAE,CAACJ,GAAG,CAACG,WAAW,EAAE,KAAKD,IAAI,EAAG;QAC9CD,KAAK,CAACI,IAAI,CAAE,IAAI,CAACP,IAAI,CAAEM,CAAC,CAAE,CAAE;MAC9B;IACF;IAEA,OAAOH,KAAK;EAEd;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEK,GAAG,CAAEC,IAAI,EAAE1B,KAAK,EAAG;IAEjB0B,IAAI,GAAGA,IAAI,CAACJ,WAAW,EAAE;IAEzB,IAAIF,KAAK,GAAG,EAAE;IAEd,KAAK,IAAIG,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACN,IAAI,CAACL,MAAM,EAAEW,CAAC,EAAE,EAAG;MAC1C,IAAI,IAAI,CAACN,IAAI,CAAEM,CAAC,CAAE,CAAEG,IAAI,CAAE,KAAK1B,KAAK,EAAG;QACrCoB,KAAK,CAACI,IAAI,CAAE,IAAI,CAACP,IAAI,CAAEM,CAAC,CAAE,CAAE;MAC9B;IACF;IAEA,OAAOH,KAAK;EAEd;;EAEA;EACAO,GAAG,CAAEC,IAAI,EAAG;IACV,IAAI,CAACX,IAAI,CAACO,IAAI,CAAEI,IAAI,CAAE;IACtB,OAAO,IAAI;EACb;;EAEA;AACF;AACA;EACEC,SAAS,CAAED,IAAI,EAAG;IAEhB,IAAI,CAAC,IAAI,CAACX,IAAI,CAACa,IAAI,CAAGC,GAAG,IAAMxB,qBAAqB,CAAEwB,GAAG,EAAEH,IAAI,CAAE,CAAC,EAAG;MACnE,IAAI,CAACX,IAAI,CAACO,IAAI,CAAEI,IAAI,CAAE;IACxB;IAEA,OAAO,IAAI;EAEb;EAEAI,GAAG,CAAEN,IAAI,EAAE1B,KAAK,EAAG;IAEjB0B,IAAI,GAAGA,IAAI,CAACJ,WAAW,EAAE;IAEzB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACN,IAAI,CAACL,MAAM,EAAEW,CAAC,EAAE,EAAG;MAC1C,IAAI,IAAI,CAACN,IAAI,CAAEM,CAAC,CAAE,CAAEG,IAAI,CAAE,KAAK1B,KAAK,EAAG;QACrC,OAAO,IAAI;MACb;IACF;IAEA,OAAO,KAAK;EAEd;EAEAkB,KAAK,CAAElB,KAAK,EAAEK,MAAM,EAAG;IAErBA,MAAM,GAAGA,MAAM,IAAI,CAAC;IACpBL,KAAK,GAAGK,MAAM,GAAGL,KAAK,CAACiC,KAAK,CAAE5B,MAAM,CAAE,GAAGL,KAAK;;IAE9C;IACAA,KAAK,GAAGD,IAAI,CAAEC,KAAK,CAAE,CAACC,OAAO,CAAEV,eAAe,EAAE,EAAE,CAAE;IAEpD,IAAI2C,KAAK,GAAGvC,KAAK,CAACC,IAAI;IACtB,IAAIgB,MAAM,GAAGZ,KAAK,CAACY,MAAM;IACzB,IAAIP,MAAM,GAAG,CAAC;IACd,IAAI0B,GAAG,GAAG,IAAI;IAEd,OAAO1B,MAAM,GAAGO,MAAM,EAAG;MACvB,IAAIsB,KAAK,KAAKvC,KAAK,CAACC,IAAI,EAAG;QACzB,IAAIM,aAAa,CAAEF,KAAK,CAACK,MAAM,CAAC,CAAE,EAAG;UACnCA,MAAM,EAAE;UACR;QACF,CAAC,MAAM,IAAIL,KAAK,CAACK,MAAM,CAAC,KAAK,GAAG,EAAG;UACjC,IAAI0B,GAAG,IAAI,IAAI,EAAG;YAChBA,GAAG,CAACZ,GAAG,IAAI,IAAI,GACb,IAAI,CAACF,IAAI,CAACO,IAAI,CAAE,GAAGT,IAAI,CAACoB,eAAe,CAAEJ,GAAG,CAAE,CAAE,GAChD,IAAI,CAACd,IAAI,CAACO,IAAI,CAAEO,GAAG,CAAE;UACzB;UACA,IAAIK,GAAG,GAAGpC,KAAK,CAACqC,OAAO,CAAE,GAAG,EAAEhC,MAAM,CAAE;UACtC,IAAI+B,GAAG,KAAK,CAAC,CAAC,EAAG,MAAM,IAAIE,KAAK,CAAE,0CAA0C,GAAGjC,MAAM,CAAE;UACvF0B,GAAG,GAAG;YAAEQ,GAAG,EAAEvC,KAAK,CAACiC,KAAK,CAAE5B,MAAM,GAAG,CAAC,EAAE+B,GAAG;UAAG,CAAC;UAC7C;UACA/B,MAAM,GAAG+B,GAAG;UACZF,KAAK,GAAGvC,KAAK,CAACE,GAAG;QACnB,CAAC,MAAM;UACL,MAAM,IAAIyC,KAAK,CAAE,wBAAwB,GAAGtC,KAAK,CAACK,MAAM,CAAC,GAAG,cAAc,GAAGA,MAAM,CAAE;QACvF;QACAA,MAAM,EAAE;MACV,CAAC,MAAM,IAAI6B,KAAK,KAAKvC,KAAK,CAACE,GAAG,EAAG;QAC/B,IAAIK,aAAa,CAAEF,KAAK,CAACK,MAAM,CAAC,CAAE,EAAG;UACnCA,MAAM,EAAE;UACR;QACF,CAAC,MAAM,IAAIL,KAAK,CAACK,MAAM,CAAC,KAAK,GAAG,EAAG;UACjC6B,KAAK,GAAGvC,KAAK,CAACG,IAAI;UAClBO,MAAM,EAAE;QACV,CAAC,MAAM,IAAIL,KAAK,CAACK,MAAM,CAAC,KAAK,GAAG,EAAG;UACjC6B,KAAK,GAAGvC,KAAK,CAACC,IAAI;UAClBS,MAAM,EAAE;QACV,CAAC,MAAM;UACL,MAAM,IAAIiC,KAAK,CAAE,wBAAwB,GAAGtC,KAAK,CAACK,MAAM,CAAC,GAAG,cAAc,GAAGA,MAAM,CAAE;QACvF;MACF,CAAC,MAAM,IAAI6B,KAAK,KAAKvC,KAAK,CAACG,IAAI,EAAG;QAChC,IAAIE,KAAK,CAACK,MAAM,CAAC,KAAI,GAAG,IAAIH,aAAa,CAAEF,KAAK,CAACK,MAAM,CAAC,CAAE,EAAG;UAC3DA,MAAM,EAAE;UACR;QACF;QACA,IAAI+B,GAAG,GAAGpC,KAAK,CAACqC,OAAO,CAAE,GAAG,EAAEhC,MAAM,CAAE;QACtC,IAAI+B,GAAG,KAAK,CAAC,CAAC,EAAG,MAAM,IAAIE,KAAK,CAAE,yCAAyC,GAAGjC,MAAM,CAAE;QACtF,IAAIqB,IAAI,GAAG3B,IAAI,CAAEC,KAAK,CAACiC,KAAK,CAAE5B,MAAM,EAAE+B,GAAG,CAAE,CAAE,CAACd,WAAW,EAAE;QAC3D,IAAIkB,SAAS,GAAG,EAAE;QAClBnC,MAAM,GAAG+B,GAAG,GAAG,CAAC;QAChB/B,MAAM,GAAGD,cAAc,CAAEJ,KAAK,EAAEK,MAAM,CAAE;QACxC,IAAIL,KAAK,CAACK,MAAM,CAAC,KAAK,GAAG,EAAG;UAC1BA,MAAM,EAAE;UACR,OAAOA,MAAM,GAAGO,MAAM,EAAG;YACvB,IAAIZ,KAAK,CAACK,MAAM,CAAC,KAAK,GAAG,EAAG;cAC1BA,MAAM,EAAE;cAAE;YACZ;YACA,IAAIL,KAAK,CAACK,MAAM,CAAC,KAAK,IAAI,EAAG;cAC3BA,MAAM,EAAE;YACV;YACAmC,SAAS,IAAIxC,KAAK,CAACK,MAAM,CAAC;YAC1BA,MAAM,EAAE;UACV;QACF,CAAC,MAAM;UACL,IAAI+B,GAAG,GAAG/B,MAAM,GAAG,CAAC;UACpB,OAAO,CAACb,iBAAiB,CAACW,IAAI,CAAEH,KAAK,CAACoC,GAAG,CAAC,CAAE,IAAIA,GAAG,GAAGxB,MAAM,EAAG;YAC7DwB,GAAG,EAAE;UACP;UACAI,SAAS,GAAGxC,KAAK,CAACiC,KAAK,CAAE5B,MAAM,EAAE+B,GAAG,CAAE;UACtC/B,MAAM,GAAG+B,GAAG;QACd;QACA,IAAIL,GAAG,CAAEL,IAAI,CAAE,IAAIX,IAAI,CAAC0B,qBAAqB,CAAEf,IAAI,CAAE,EAAG;UACtD;QAAA,CACD,MAAM,IAAIA,IAAI,CAAEA,IAAI,CAACd,MAAM,GAAG,CAAC,CAAE,KAAK,GAAG,EAAG;UAC3CmB,GAAG,CAAEL,IAAI,CAAE,GAAGX,IAAI,CAAC2B,kBAAkB,CAAEF,SAAS,CAAE;QACpD,CAAC,MAAM;UACLA,SAAS,GAAGd,IAAI,KAAK,MAAM,GACzBc,SAAS,CAAClB,WAAW,EAAE,GAAGkB,SAAS;UACrC,IAAIT,GAAG,CAAEL,IAAI,CAAE,IAAI,IAAI,EAAG;YACxB,IAAIiB,KAAK,CAACC,OAAO,CAAEb,GAAG,CAAEL,IAAI,CAAE,CAAE,EAAG;cACjCK,GAAG,CAAEL,IAAI,CAAE,CAACF,IAAI,CAAEgB,SAAS,CAAE;YAC/B,CAAC,MAAM;cACLT,GAAG,CAAEL,IAAI,CAAE,GAAG,CAAEK,GAAG,CAAEL,IAAI,CAAE,EAAEc,SAAS,CAAE;YAC1C;UACF,CAAC,MAAM;YACLT,GAAG,CAAEL,IAAI,CAAE,GAAGc,SAAS;UACzB;QACF;QACA,QAAQxC,KAAK,CAACK,MAAM,CAAC;UACnB,KAAK,GAAG;YAAE6B,KAAK,GAAGvC,KAAK,CAACC,IAAI;YAAE;UAC9B,KAAK,GAAG;YAAEsC,KAAK,GAAGvC,KAAK,CAACG,IAAI;YAAE;QAAK;QAErCO,MAAM,EAAE;MACV,CAAC,MAAM;QACL,MAAM,IAAIiC,KAAK,CAAE,wBAAwB,GAAGJ,KAAK,GAAG,GAAG,CAAE;MAC3D;IACF;IAEA,IAAIH,GAAG,IAAI,IAAI,EAAG;MAChBA,GAAG,CAACZ,GAAG,IAAI,IAAI,GACb,IAAI,CAACF,IAAI,CAACO,IAAI,CAAE,GAAGT,IAAI,CAACoB,eAAe,CAAEJ,GAAG,CAAE,CAAE,GAChD,IAAI,CAACd,IAAI,CAACO,IAAI,CAAEO,GAAG,CAAE;IACzB;IAEAA,GAAG,GAAG,IAAI;IAEV,OAAO,IAAI;EAEb;EAEAc,QAAQ,GAAG;IAET,IAAI5B,IAAI,GAAG,EAAE;IACb,IAAIW,IAAI,GAAG,EAAE;IACb,IAAIG,GAAG,GAAG,IAAI;IAEd,KAAK,IAAIR,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG,IAAI,CAACN,IAAI,CAACL,MAAM,EAAEW,CAAC,EAAE,EAAG;MAC1CQ,GAAG,GAAG,IAAI,CAACd,IAAI,CAACM,CAAC,CAAC;MAClBK,IAAI,GAAGlB,MAAM,CAACC,IAAI,CAAE,IAAI,CAACM,IAAI,CAACM,CAAC,CAAC,CAAE,CAACuB,MAAM,CAAE,UAAUlB,IAAI,EAAEF,IAAI,EAAG;QAChE,IAAIA,IAAI,KAAK,KAAK,EAAG,OAAOE,IAAI;QAChC,OAAOA,IAAI,GAAG,IAAI,GAAGb,IAAI,CAACgC,eAAe,CAAErB,IAAI,EAAEK,GAAG,CAAEL,IAAI,CAAE,CAAE;MAChE,CAAC,EAAE,GAAG,GAAGK,GAAG,CAACQ,GAAG,GAAG,GAAG,CAAE;MACxBtB,IAAI,CAACO,IAAI,CAAEI,IAAI,CAAE;IACnB;IAEA,OAAOX,IAAI,CAAC+B,IAAI,CAAE,IAAI,CAAE;EAE1B;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACAjC,IAAI,CAACkC,oBAAoB,GAAG,UAAUjD,KAAK,EAAG;EAC5C,OAAOZ,2BAA2B,CAACe,IAAI,CAAEH,KAAK,CAAE;AAClD,CAAC;AAEDe,IAAI,CAACG,KAAK,GAAG,UAAUlB,KAAK,EAAEK,MAAM,EAAG;EACrC,OAAO,IAAIU,IAAI,EAAE,CAACG,KAAK,CAAElB,KAAK,EAAEK,MAAM,CAAE;AAC1C,CAAC;AAEDU,IAAI,CAAC0B,qBAAqB,GAAG,UAAUf,IAAI,EAAG;EAC5C,OAAOA,IAAI,KAAK,KAAK,IAAIA,IAAI,KAAK,MAAM,IAAIA,IAAI,KAAK,OAAO,IAC1DA,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK,QAAQ;AACzC,CAAC;AAEDX,IAAI,CAACmC,WAAW,GAAG,UAAUxB,IAAI,EAAG;EAClC,OAAOA,IAAI,KAAK,KAAK,IAAIA,IAAI,KAAK,MAAM,IAAIA,IAAI,KAAK,QAAQ;AAC/D,CAAC;AAEDX,IAAI,CAACoC,YAAY,GAAG,UAAUnD,KAAK,EAAG;EACpC,OAAOA,KAAK,CAACC,OAAO,CAAE,IAAI,EAAE,KAAK,CAAE;AACrC,CAAC;AAEDc,IAAI,CAACoB,eAAe,GAAG,UAAUJ,GAAG,EAAG;EACrC,IAAIqB,IAAI,GAAGrB,GAAG,CAACZ,GAAG,CAACkC,KAAK,CAAE,GAAG,CAAE;EAC/B,OAAOD,IAAI,CAACE,GAAG,CAAE,UAAUnC,GAAG,EAAG;IAC/B,IAAInB,KAAK,GAAGU,MAAM,CAAC6C,MAAM,CAAE,CAAC,CAAC,EAAExB,GAAG,CAAE;IACpC/B,KAAK,CAACmB,GAAG,GAAGA,GAAG;IACf,OAAOnB,KAAK;EACd,CAAC,CAAC;AACJ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAe,IAAI,CAAC2B,kBAAkB,GAAG,UAAU1C,KAAK,EAAG;EAC1C,IAAIwD,KAAK,GAAG,4BAA4B,CAACC,IAAI,CAAEzD,KAAK,CAAE;EACtD,OAAO;IACL0D,QAAQ,EAAEF,KAAK,CAAC,CAAC,CAAC,CAAClC,WAAW,EAAE;IAChCqC,QAAQ,EAAE5C,IAAI,CAACkC,oBAAoB,CAAEO,KAAK,CAAC,CAAC,CAAC,CAAE,GAC7C,IAAI,GAAGA,KAAK,CAAC,CAAC,CAAC,CAAClC,WAAW,EAAE;IAC/BtB,KAAK,EAAEe,IAAI,CAACkC,oBAAoB,CAAEO,KAAK,CAAC,CAAC,CAAC,CAAE,GAC1CI,kBAAkB,CAAEJ,KAAK,CAAC,CAAC,CAAC,CAAE,GAAGA,KAAK,CAAC,CAAC;EAC5C,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAzC,IAAI,CAAC8C,uBAAuB,GAAG,UAAUnC,IAAI,EAAEoC,IAAI,EAAG;EAEpD,IAAIH,QAAQ,GAAG,CAAEG,IAAI,CAACH,QAAQ,IAAI,OAAO,EAAGI,WAAW,EAAE;EACzD,IAAIL,QAAQ,GAAGI,IAAI,CAACJ,QAAQ,IAAI,IAAI;EAEpC,IAAIM,YAAY,GAAG,EAAE;EAErB,IAAIC,MAAM,CAACC,QAAQ,CAAEJ,IAAI,CAAC9D,KAAK,CAAE,IAAIe,IAAI,CAACkC,oBAAoB,CAAEU,QAAQ,CAAE,EAAG;IAC3EK,YAAY,GAAGF,IAAI,CAAC9D,KAAK,CAAC6C,QAAQ,CAAEc,QAAQ,CAAE;EAChD,CAAC,MAAM,IAAIM,MAAM,CAACC,QAAQ,CAAEJ,IAAI,CAAC9D,KAAK,CAAE,EAAG;IACzCgE,YAAY,GAAGF,IAAI,CAAC9D,KAAK,CAAC6C,QAAQ,CAAE,KAAK,CAAE,CACxC5C,OAAO,CAAE,eAAe,EAAE,KAAK,CAAE;EACtC,CAAC,MAAM;IACL+D,YAAY,GAAGG,kBAAkB,CAAEL,IAAI,CAAC9D,KAAK,CAAE;EACjD;EAEA,OAAO0B,IAAI,GAAG,GAAG,GAAGiC,QAAQ,GAAG,IAAI,GACjCD,QAAQ,GAAG,IAAI,GAAGM,YAAY;AAElC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACAjD,IAAI,CAACgC,eAAe,GAAG,UAAUrB,IAAI,EAAE1B,KAAK,EAAG;EAE7C,IAAI2C,KAAK,CAACC,OAAO,CAAE5C,KAAK,CAAE,EAAG;IAC3B,OAAOA,KAAK,CAACsD,GAAG,CAAGc,IAAI,IAAM;MAC3B,OAAOrD,IAAI,CAACgC,eAAe,CAAErB,IAAI,EAAE0C,IAAI,CAAE;IAC3C,CAAC,CAAC,CAACpB,IAAI,CAAE,IAAI,CAAE;EACjB;EAEA,IAAItB,IAAI,CAAEA,IAAI,CAACd,MAAM,GAAG,CAAC,CAAE,KAAK,GAAG,IAAI,OAAOZ,KAAK,KAAK,QAAQ,EAAG;IACjE,OAAOe,IAAI,CAAC8C,uBAAuB,CAAEnC,IAAI,EAAE1B,KAAK,CAAE;EACpD;EAEA,IAAIe,IAAI,CAACmC,WAAW,CAAExB,IAAI,CAAE,EAAG;IAC7B1B,KAAK,GAAGM,WAAW,CAAEN,KAAK,CAAE,GAC1B,GAAG,GAAGe,IAAI,CAACoC,YAAY,CAAEnD,KAAK,CAAE,GAAG,GAAG,GACtCe,IAAI,CAACoC,YAAY,CAAEnD,KAAK,CAAE;EAC9B,CAAC,MAAM,IAAIM,WAAW,CAAEN,KAAK,CAAE,EAAG;IAChCA,KAAK,GAAGmE,kBAAkB,CAAEnE,KAAK,CAAE;IACnC;IACAA,KAAK,GAAGA,KAAK,CACVC,OAAO,CAAE,MAAM,EAAE,GAAG,CAAE,CACtBA,OAAO,CAAE,MAAM,EAAE,GAAG,CAAE,CACtBA,OAAO,CAAE,MAAM,EAAE,GAAG,CAAE;IAEzBD,KAAK,GAAG,GAAG,GAAGA,KAAK,GAAG,GAAG;EAC3B;EAEA,OAAO0B,IAAI,GAAG,GAAG,GAAG1B,KAAK;AAE3B,CAAC;AAEDqE,MAAM,CAACC,OAAO,GAAGvD,IAAI"},"metadata":{},"sourceType":"script","externalDependencies":[]}