{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\nvar oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\nvar TokenRefresher = /*#__PURE__*/function () {\n  function TokenRefresher(storageUtility, issuerConfigFetcher, clientRegistrar) {\n    _classCallCheck(this, TokenRefresher);\n    this.storageUtility = storageUtility;\n    this.issuerConfigFetcher = issuerConfigFetcher;\n    this.clientRegistrar = clientRegistrar;\n  }\n  _createClass(TokenRefresher, [{\n    key: \"refresh\",\n    value: function () {\n      var _refresh = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(sessionId, refreshToken, dpopKey, eventEmitter) {\n        var oidcContext, clientInfo, tokenSet;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return (0, solid_client_authn_core_1.loadOidcContextFromStorage)(sessionId, this.storageUtility, this.issuerConfigFetcher);\n            case 2:\n              oidcContext = _context.sent;\n              _context.next = 5;\n              return this.clientRegistrar.getClient({\n                sessionId: sessionId\n              }, oidcContext.issuerConfig);\n            case 5:\n              clientInfo = _context.sent;\n              if (!(refreshToken === undefined)) {\n                _context.next = 8;\n                break;\n              }\n              throw new Error(\"Session [\".concat(sessionId, \"] has no refresh token to allow it to refresh its access token.\"));\n            case 8:\n              if (!(oidcContext.dpop && dpopKey === undefined)) {\n                _context.next = 10;\n                break;\n              }\n              throw new Error(\"For session [\".concat(sessionId, \"], the key bound to the DPoP access token must be provided to refresh said access token.\"));\n            case 10:\n              _context.next = 12;\n              return (0, oidc_client_ext_1.refresh)(refreshToken, oidcContext.issuerConfig, clientInfo, dpopKey);\n            case 12:\n              tokenSet = _context.sent;\n              if (!(tokenSet.refreshToken !== undefined)) {\n                _context.next = 17;\n                break;\n              }\n              eventEmitter === null || eventEmitter === void 0 ? void 0 : eventEmitter.emit(solid_client_authn_core_1.EVENTS.NEW_REFRESH_TOKEN, tokenSet.refreshToken);\n              _context.next = 17;\n              return this.storageUtility.setForUser(sessionId, {\n                refreshToken: tokenSet.refreshToken\n              });\n            case 17:\n              return _context.abrupt(\"return\", tokenSet);\n            case 18:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function refresh(_x, _x2, _x3, _x4) {\n        return _refresh.apply(this, arguments);\n      }\n      return refresh;\n    }()\n  }]);\n  return TokenRefresher;\n}();\nexports.default = TokenRefresher;","map":{"version":3,"mappings":";;;;;;;;;AA0BA;AAWA;AAAkD,IAU7BA,cAAc;EACjC,wBACUC,cAA+B,EAC/BC,mBAAyC,EACzCC,eAAiC;IAAA;IAFjC,mBAAc,GAAdF,cAAc;IACd,wBAAmB,GAAnBC,mBAAmB;IACnB,oBAAe,GAAfC,eAAe;EACtB;EAAC;IAAA;IAAA;MAAA,0EAEJ,iBACEC,SAAiB,EACjBC,YAAqB,EACrBC,OAAiB,EACjBC,YAA2B;QAAA;QAAA;UAAA;YAAA;cAAA;cAAA,OAED,wDAA0B,EAClDH,SAAS,EACT,IAAI,CAACH,cAAc,EACnB,IAAI,CAACC,mBAAmB,CACzB;YAAA;cAJKM,WAAW;cAAA;cAAA,OAMiB,IAAI,CAACL,eAAe,CAACM,SAAS,CAC9D;gBAAEL,SAAS,EAATA;cAAS,CAAE,EACbI,WAAW,CAACE,YAAY,CACzB;YAAA;cAHKC,UAAU;cAAA,MAKZN,YAAY,KAAKO,SAAS;gBAAA;gBAAA;cAAA;cAAA,MAEtB,IAAIC,KAAK,oBACDT,SAAS,qEACtB;YAAA;cAAA,MAGCI,WAAW,CAACM,IAAI,IAAIR,OAAO,KAAKM,SAAS;gBAAA;gBAAA;cAAA;cAAA,MACrC,IAAIC,KAAK,wBACGT,SAAS,8FAC1B;YAAA;cAAA;cAAA,OAGoB,6BAAO,EAC5BC,YAAY,EACZG,WAAW,CAACE,YAAY,EACxBC,UAAU,EACVL,OAAO,CACR;YAAA;cALKS,QAAQ;cAAA,MAOVA,QAAQ,CAACV,YAAY,KAAKO,SAAS;gBAAA;gBAAA;cAAA;cACrCL,YAAY,aAAZA,YAAY,uBAAZA,YAAY,CAAES,IAAI,CAACC,gCAAM,CAACC,iBAAiB,EAAEH,QAAQ,CAACV,YAAY,CAAC;cAAC;cAAA,OAC9D,IAAI,CAACJ,cAAc,CAACkB,UAAU,CAACf,SAAS,EAAE;gBAC9CC,YAAY,EAAEU,QAAQ,CAACV;eACxB,CAAC;YAAA;cAAA,iCAEGU,QAAQ;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CAChB;MAAA;QAAA;MAAA;MAAA;IAAA;EAAA;EAAA;AAAA;AAnDHK","names":["TokenRefresher","storageUtility","issuerConfigFetcher","clientRegistrar","sessionId","refreshToken","dpopKey","eventEmitter","oidcContext","getClient","issuerConfig","clientInfo","undefined","Error","dpop","tokenSet","emit","solid_client_authn_core_1","NEW_REFRESH_TOKEN","setForUser","exports"],"sources":["E:\\react-todo-app\\node_modules\\@inrupt\\solid-client-authn-browser\\src\\login\\oidc\\refresh\\TokenRefresher.ts"],"sourcesContent":["//\n// Copyright 2022 Inrupt Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n// Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n/**\n * @hidden\n * @packageDocumentation\n */\n\nimport {\n  IClient,\n  IClientRegistrar,\n  IIssuerConfigFetcher,\n  IStorageUtility,\n  loadOidcContextFromStorage,\n  KeyPair,\n  ITokenRefresher,\n  TokenEndpointResponse,\n  EVENTS,\n} from \"@inrupt/solid-client-authn-core\";\nimport { refresh } from \"@inrupt/oidc-client-ext\";\nimport { EventEmitter } from \"events\";\n\n// Some identifiers are not in camelcase on purpose, as they are named using the\n// official names from the OIDC/OAuth2 specifications.\n/* eslint-disable camelcase */\n\n/**\n * @hidden\n */\nexport default class TokenRefresher implements ITokenRefresher {\n  constructor(\n    private storageUtility: IStorageUtility,\n    private issuerConfigFetcher: IIssuerConfigFetcher,\n    private clientRegistrar: IClientRegistrar\n  ) {}\n\n  async refresh(\n    sessionId: string,\n    refreshToken?: string,\n    dpopKey?: KeyPair,\n    eventEmitter?: EventEmitter\n  ): Promise<TokenEndpointResponse> {\n    const oidcContext = await loadOidcContextFromStorage(\n      sessionId,\n      this.storageUtility,\n      this.issuerConfigFetcher\n    );\n    // This should also retrieve the client from storage\n    const clientInfo: IClient = await this.clientRegistrar.getClient(\n      { sessionId },\n      oidcContext.issuerConfig\n    );\n\n    if (refreshToken === undefined) {\n      // TODO: in a next PR, look up storage for a refresh token\n      throw new Error(\n        `Session [${sessionId}] has no refresh token to allow it to refresh its access token.`\n      );\n    }\n\n    if (oidcContext.dpop && dpopKey === undefined) {\n      throw new Error(\n        `For session [${sessionId}], the key bound to the DPoP access token must be provided to refresh said access token.`\n      );\n    }\n\n    const tokenSet = await refresh(\n      refreshToken,\n      oidcContext.issuerConfig,\n      clientInfo,\n      dpopKey\n    );\n\n    if (tokenSet.refreshToken !== undefined) {\n      eventEmitter?.emit(EVENTS.NEW_REFRESH_TOKEN, tokenSet.refreshToken);\n      await this.storageUtility.setForUser(sessionId, {\n        refreshToken: tokenSet.refreshToken,\n      });\n    }\n    return tokenSet;\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}