{"ast":null,"code":"import _slicedToArray from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { decode as base64url } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nexport function decodeProtectedHeader(token) {\n  var protectedB64u;\n  if (typeof token === 'string') {\n    var parts = token.split('.');\n    if (parts.length === 3 || parts.length === 5) {\n      ;\n      var _parts = _slicedToArray(parts, 1);\n      protectedB64u = _parts[0];\n    }\n  } else if (typeof token === 'object' && token) {\n    if ('protected' in token) {\n      protectedB64u = token.protected;\n    } else {\n      throw new TypeError('Token does not contain a Protected Header');\n    }\n  }\n  try {\n    if (typeof protectedB64u !== 'string' || !protectedB64u) {\n      throw new Error();\n    }\n    var result = JSON.parse(decoder.decode(base64url(protectedB64u)));\n    if (!isObject(result)) {\n      throw new Error();\n    }\n    return result;\n  } catch (_a) {\n    throw new TypeError('Invalid Token or Protected Header formatting');\n  }\n}","map":{"version":3,"names":["decode","base64url","decoder","isObject","decodeProtectedHeader","token","protectedB64u","parts","split","length","protected","TypeError","Error","result","JSON","parse","_a"],"sources":["E:/react-todo-app/node_modules/jose/dist/browser/util/decode_protected_header.js"],"sourcesContent":["import { decode as base64url } from './base64url.js';\nimport { decoder } from '../lib/buffer_utils.js';\nimport isObject from '../lib/is_object.js';\nexport function decodeProtectedHeader(token) {\n    let protectedB64u;\n    if (typeof token === 'string') {\n        const parts = token.split('.');\n        if (parts.length === 3 || parts.length === 5) {\n            ;\n            [protectedB64u] = parts;\n        }\n    }\n    else if (typeof token === 'object' && token) {\n        if ('protected' in token) {\n            protectedB64u = token.protected;\n        }\n        else {\n            throw new TypeError('Token does not contain a Protected Header');\n        }\n    }\n    try {\n        if (typeof protectedB64u !== 'string' || !protectedB64u) {\n            throw new Error();\n        }\n        const result = JSON.parse(decoder.decode(base64url(protectedB64u)));\n        if (!isObject(result)) {\n            throw new Error();\n        }\n        return result;\n    }\n    catch (_a) {\n        throw new TypeError('Invalid Token or Protected Header formatting');\n    }\n}\n"],"mappings":";AAAA,SAASA,MAAM,IAAIC,SAAS,QAAQ,gBAAgB;AACpD,SAASC,OAAO,QAAQ,wBAAwB;AAChD,OAAOC,QAAQ,MAAM,qBAAqB;AAC1C,OAAO,SAASC,qBAAqB,CAACC,KAAK,EAAE;EACzC,IAAIC,aAAa;EACjB,IAAI,OAAOD,KAAK,KAAK,QAAQ,EAAE;IAC3B,IAAME,KAAK,GAAGF,KAAK,CAACG,KAAK,CAAC,GAAG,CAAC;IAC9B,IAAID,KAAK,CAACE,MAAM,KAAK,CAAC,IAAIF,KAAK,CAACE,MAAM,KAAK,CAAC,EAAE;MAC1C;MAAC,4BACiBF,KAAK;MAAtBD,aAAa;IAClB;EACJ,CAAC,MACI,IAAI,OAAOD,KAAK,KAAK,QAAQ,IAAIA,KAAK,EAAE;IACzC,IAAI,WAAW,IAAIA,KAAK,EAAE;MACtBC,aAAa,GAAGD,KAAK,CAACK,SAAS;IACnC,CAAC,MACI;MACD,MAAM,IAAIC,SAAS,CAAC,2CAA2C,CAAC;IACpE;EACJ;EACA,IAAI;IACA,IAAI,OAAOL,aAAa,KAAK,QAAQ,IAAI,CAACA,aAAa,EAAE;MACrD,MAAM,IAAIM,KAAK,EAAE;IACrB;IACA,IAAMC,MAAM,GAAGC,IAAI,CAACC,KAAK,CAACb,OAAO,CAACF,MAAM,CAACC,SAAS,CAACK,aAAa,CAAC,CAAC,CAAC;IACnE,IAAI,CAACH,QAAQ,CAACU,MAAM,CAAC,EAAE;MACnB,MAAM,IAAID,KAAK,EAAE;IACrB;IACA,OAAOC,MAAM;EACjB,CAAC,CACD,OAAOG,EAAE,EAAE;IACP,MAAM,IAAIL,SAAS,CAAC,8CAA8C,CAAC;EACvE;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}