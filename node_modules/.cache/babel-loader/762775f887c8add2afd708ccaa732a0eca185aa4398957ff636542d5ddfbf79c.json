{"ast":null,"code":"/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n;\n\n'use strict';\nconst {\n  AbortError,\n  codes\n} = require('../../ours/errors');\nconst {\n  ERR_INVALID_ARG_TYPE,\n  ERR_STREAM_PREMATURE_CLOSE\n} = codes;\nconst {\n  kEmptyObject,\n  once\n} = require('../../ours/util');\nconst {\n  validateAbortSignal,\n  validateFunction,\n  validateObject\n} = require('../validators');\nconst {\n  Promise\n} = require('../../ours/primordials');\nconst {\n  isClosed,\n  isReadable,\n  isReadableNodeStream,\n  isReadableFinished,\n  isReadableErrored,\n  isWritable,\n  isWritableNodeStream,\n  isWritableFinished,\n  isWritableErrored,\n  isNodeStream,\n  willEmitClose: _willEmitClose\n} = require('./utils');\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function';\n}\nconst nop = () => {};\nfunction eos(stream, options, callback) {\n  var _options$readable, _options$writable;\n  if (arguments.length === 2) {\n    callback = options;\n    options = kEmptyObject;\n  } else if (options == null) {\n    options = kEmptyObject;\n  } else {\n    validateObject(options, 'options');\n  }\n  validateFunction(callback, 'callback');\n  validateAbortSignal(options.signal, 'options.signal');\n  callback = once(callback);\n  const readable = (_options$readable = options.readable) !== null && _options$readable !== undefined ? _options$readable : isReadableNodeStream(stream);\n  const writable = (_options$writable = options.writable) !== null && _options$writable !== undefined ? _options$writable : isWritableNodeStream(stream);\n  if (!isNodeStream(stream)) {\n    // TODO: Webstreams.\n    throw new ERR_INVALID_ARG_TYPE('stream', 'Stream', stream);\n  }\n  const wState = stream._writableState;\n  const rState = stream._readableState;\n  const onlegacyfinish = () => {\n    if (!stream.writable) {\n      onfinish();\n    }\n  };\n\n  // TODO (ronag): Improve soft detection to include core modules and\n  // common ecosystem modules that do properly emit 'close' but fail\n  // this generic check.\n  let willEmitClose = _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable;\n  let writableFinished = isWritableFinished(stream, false);\n  const onfinish = () => {\n    writableFinished = true;\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false;\n    }\n    if (willEmitClose && (!stream.readable || readable)) {\n      return;\n    }\n    if (!readable || readableFinished) {\n      callback.call(stream);\n    }\n  };\n  let readableFinished = isReadableFinished(stream, false);\n  const onend = () => {\n    readableFinished = true;\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false;\n    }\n    if (willEmitClose && (!stream.writable || writable)) {\n      return;\n    }\n    if (!writable || writableFinished) {\n      callback.call(stream);\n    }\n  };\n  const onerror = err => {\n    callback.call(stream, err);\n  };\n  let closed = isClosed(stream);\n  const onclose = () => {\n    closed = true;\n    const errored = isWritableErrored(stream) || isReadableErrored(stream);\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored);\n    }\n    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n    }\n    if (writable && !writableFinished) {\n      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE());\n    }\n    callback.call(stream);\n  };\n  const onrequest = () => {\n    stream.req.on('finish', onfinish);\n  };\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish);\n    if (!willEmitClose) {\n      stream.on('abort', onclose);\n    }\n    if (stream.req) {\n      onrequest();\n    } else {\n      stream.on('request', onrequest);\n    }\n  } else if (writable && !wState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish);\n    stream.on('close', onlegacyfinish);\n  }\n\n  // Not all streams will emit 'close' after 'aborted'.\n  if (!willEmitClose && typeof stream.aborted === 'boolean') {\n    stream.on('aborted', onclose);\n  }\n  stream.on('end', onend);\n  stream.on('finish', onfinish);\n  if (options.error !== false) {\n    stream.on('error', onerror);\n  }\n  stream.on('close', onclose);\n  if (closed) {\n    process.nextTick(onclose);\n  } else if (wState !== null && wState !== undefined && wState.errorEmitted || rState !== null && rState !== undefined && rState.errorEmitted) {\n    if (!willEmitClose) {\n      process.nextTick(onclose);\n    }\n  } else if (!readable && (!willEmitClose || isReadable(stream)) && (writableFinished || isWritable(stream) === false)) {\n    process.nextTick(onclose);\n  } else if (!writable && (!willEmitClose || isWritable(stream)) && (readableFinished || isReadable(stream) === false)) {\n    process.nextTick(onclose);\n  } else if (rState && stream.req && stream.aborted) {\n    process.nextTick(onclose);\n  }\n  const cleanup = () => {\n    callback = nop;\n    stream.removeListener('aborted', onclose);\n    stream.removeListener('complete', onfinish);\n    stream.removeListener('abort', onclose);\n    stream.removeListener('request', onrequest);\n    if (stream.req) stream.req.removeListener('finish', onfinish);\n    stream.removeListener('end', onlegacyfinish);\n    stream.removeListener('close', onlegacyfinish);\n    stream.removeListener('finish', onfinish);\n    stream.removeListener('end', onend);\n    stream.removeListener('error', onerror);\n    stream.removeListener('close', onclose);\n  };\n  if (options.signal && !closed) {\n    const abort = () => {\n      // Keep it because cleanup removes it.\n      const endCallback = callback;\n      cleanup();\n      endCallback.call(stream, new AbortError(undefined, {\n        cause: options.signal.reason\n      }));\n    };\n    if (options.signal.aborted) {\n      process.nextTick(abort);\n    } else {\n      const originalCallback = callback;\n      callback = once(function () {\n        options.signal.removeEventListener('abort', abort);\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n        originalCallback.apply(stream, args);\n      });\n      options.signal.addEventListener('abort', abort);\n    }\n  }\n  return cleanup;\n}\nfunction finished(stream, opts) {\n  return new Promise((resolve, reject) => {\n    eos(stream, opts, err => {\n      if (err) {\n        reject(err);\n      } else {\n        resolve();\n      }\n    });\n  });\n}\nmodule.exports = eos;\nmodule.exports.finished = finished;","map":{"version":3,"names":["process","require","AbortError","codes","ERR_INVALID_ARG_TYPE","ERR_STREAM_PREMATURE_CLOSE","kEmptyObject","once","validateAbortSignal","validateFunction","validateObject","Promise","isClosed","isReadable","isReadableNodeStream","isReadableFinished","isReadableErrored","isWritable","isWritableNodeStream","isWritableFinished","isWritableErrored","isNodeStream","willEmitClose","_willEmitClose","isRequest","stream","setHeader","abort","nop","eos","options","callback","_options$readable","_options$writable","arguments","length","signal","readable","undefined","writable","wState","_writableState","rState","_readableState","onlegacyfinish","onfinish","writableFinished","destroyed","readableFinished","call","onend","onerror","err","closed","onclose","errored","onrequest","req","on","aborted","error","nextTick","errorEmitted","cleanup","removeListener","endCallback","cause","reason","originalCallback","removeEventListener","args","apply","addEventListener","finished","opts","resolve","reject","module","exports"],"sources":["G:/To-do-List_App-main/node_modules/n3/node_modules/readable-stream/lib/internal/streams/end-of-stream.js"],"sourcesContent":["/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/end-of-stream with\n// permission from the author, Mathias Buus (@mafintosh).\n\n;('use strict')\nconst { AbortError, codes } = require('../../ours/errors')\nconst { ERR_INVALID_ARG_TYPE, ERR_STREAM_PREMATURE_CLOSE } = codes\nconst { kEmptyObject, once } = require('../../ours/util')\nconst { validateAbortSignal, validateFunction, validateObject } = require('../validators')\nconst { Promise } = require('../../ours/primordials')\nconst {\n  isClosed,\n  isReadable,\n  isReadableNodeStream,\n  isReadableFinished,\n  isReadableErrored,\n  isWritable,\n  isWritableNodeStream,\n  isWritableFinished,\n  isWritableErrored,\n  isNodeStream,\n  willEmitClose: _willEmitClose\n} = require('./utils')\nfunction isRequest(stream) {\n  return stream.setHeader && typeof stream.abort === 'function'\n}\nconst nop = () => {}\nfunction eos(stream, options, callback) {\n  var _options$readable, _options$writable\n  if (arguments.length === 2) {\n    callback = options\n    options = kEmptyObject\n  } else if (options == null) {\n    options = kEmptyObject\n  } else {\n    validateObject(options, 'options')\n  }\n  validateFunction(callback, 'callback')\n  validateAbortSignal(options.signal, 'options.signal')\n  callback = once(callback)\n  const readable =\n    (_options$readable = options.readable) !== null && _options$readable !== undefined\n      ? _options$readable\n      : isReadableNodeStream(stream)\n  const writable =\n    (_options$writable = options.writable) !== null && _options$writable !== undefined\n      ? _options$writable\n      : isWritableNodeStream(stream)\n  if (!isNodeStream(stream)) {\n    // TODO: Webstreams.\n    throw new ERR_INVALID_ARG_TYPE('stream', 'Stream', stream)\n  }\n  const wState = stream._writableState\n  const rState = stream._readableState\n  const onlegacyfinish = () => {\n    if (!stream.writable) {\n      onfinish()\n    }\n  }\n\n  // TODO (ronag): Improve soft detection to include core modules and\n  // common ecosystem modules that do properly emit 'close' but fail\n  // this generic check.\n  let willEmitClose =\n    _willEmitClose(stream) && isReadableNodeStream(stream) === readable && isWritableNodeStream(stream) === writable\n  let writableFinished = isWritableFinished(stream, false)\n  const onfinish = () => {\n    writableFinished = true\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false\n    }\n    if (willEmitClose && (!stream.readable || readable)) {\n      return\n    }\n    if (!readable || readableFinished) {\n      callback.call(stream)\n    }\n  }\n  let readableFinished = isReadableFinished(stream, false)\n  const onend = () => {\n    readableFinished = true\n    // Stream should not be destroyed here. If it is that\n    // means that user space is doing something differently and\n    // we cannot trust willEmitClose.\n    if (stream.destroyed) {\n      willEmitClose = false\n    }\n    if (willEmitClose && (!stream.writable || writable)) {\n      return\n    }\n    if (!writable || writableFinished) {\n      callback.call(stream)\n    }\n  }\n  const onerror = (err) => {\n    callback.call(stream, err)\n  }\n  let closed = isClosed(stream)\n  const onclose = () => {\n    closed = true\n    const errored = isWritableErrored(stream) || isReadableErrored(stream)\n    if (errored && typeof errored !== 'boolean') {\n      return callback.call(stream, errored)\n    }\n    if (readable && !readableFinished && isReadableNodeStream(stream, true)) {\n      if (!isReadableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())\n    }\n    if (writable && !writableFinished) {\n      if (!isWritableFinished(stream, false)) return callback.call(stream, new ERR_STREAM_PREMATURE_CLOSE())\n    }\n    callback.call(stream)\n  }\n  const onrequest = () => {\n    stream.req.on('finish', onfinish)\n  }\n  if (isRequest(stream)) {\n    stream.on('complete', onfinish)\n    if (!willEmitClose) {\n      stream.on('abort', onclose)\n    }\n    if (stream.req) {\n      onrequest()\n    } else {\n      stream.on('request', onrequest)\n    }\n  } else if (writable && !wState) {\n    // legacy streams\n    stream.on('end', onlegacyfinish)\n    stream.on('close', onlegacyfinish)\n  }\n\n  // Not all streams will emit 'close' after 'aborted'.\n  if (!willEmitClose && typeof stream.aborted === 'boolean') {\n    stream.on('aborted', onclose)\n  }\n  stream.on('end', onend)\n  stream.on('finish', onfinish)\n  if (options.error !== false) {\n    stream.on('error', onerror)\n  }\n  stream.on('close', onclose)\n  if (closed) {\n    process.nextTick(onclose)\n  } else if (\n    (wState !== null && wState !== undefined && wState.errorEmitted) ||\n    (rState !== null && rState !== undefined && rState.errorEmitted)\n  ) {\n    if (!willEmitClose) {\n      process.nextTick(onclose)\n    }\n  } else if (\n    !readable &&\n    (!willEmitClose || isReadable(stream)) &&\n    (writableFinished || isWritable(stream) === false)\n  ) {\n    process.nextTick(onclose)\n  } else if (\n    !writable &&\n    (!willEmitClose || isWritable(stream)) &&\n    (readableFinished || isReadable(stream) === false)\n  ) {\n    process.nextTick(onclose)\n  } else if (rState && stream.req && stream.aborted) {\n    process.nextTick(onclose)\n  }\n  const cleanup = () => {\n    callback = nop\n    stream.removeListener('aborted', onclose)\n    stream.removeListener('complete', onfinish)\n    stream.removeListener('abort', onclose)\n    stream.removeListener('request', onrequest)\n    if (stream.req) stream.req.removeListener('finish', onfinish)\n    stream.removeListener('end', onlegacyfinish)\n    stream.removeListener('close', onlegacyfinish)\n    stream.removeListener('finish', onfinish)\n    stream.removeListener('end', onend)\n    stream.removeListener('error', onerror)\n    stream.removeListener('close', onclose)\n  }\n  if (options.signal && !closed) {\n    const abort = () => {\n      // Keep it because cleanup removes it.\n      const endCallback = callback\n      cleanup()\n      endCallback.call(\n        stream,\n        new AbortError(undefined, {\n          cause: options.signal.reason\n        })\n      )\n    }\n    if (options.signal.aborted) {\n      process.nextTick(abort)\n    } else {\n      const originalCallback = callback\n      callback = once((...args) => {\n        options.signal.removeEventListener('abort', abort)\n        originalCallback.apply(stream, args)\n      })\n      options.signal.addEventListener('abort', abort)\n    }\n  }\n  return cleanup\n}\nfunction finished(stream, opts) {\n  return new Promise((resolve, reject) => {\n    eos(stream, opts, (err) => {\n      if (err) {\n        reject(err)\n      } else {\n        resolve()\n      }\n    })\n  })\n}\nmodule.exports = eos\nmodule.exports.finished = finished\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}