{"ast":null,"code":"import _regeneratorRuntime from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _toConsumableArray from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { isCloudflareWorkers } from './env.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { encodeBase64 } from './base64url.js';\nimport formatPEM from '../lib/format_pem.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { types } from './is_key_like.js';\nvar genericExport = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(keyType, keyFormat, key) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (isCryptoKey(key)) {\n            _context.next = 2;\n            break;\n          }\n          throw new TypeError(invalidKeyInput.apply(void 0, [key].concat(_toConsumableArray(types))));\n        case 2:\n          if (key.extractable) {\n            _context.next = 4;\n            break;\n          }\n          throw new TypeError('CryptoKey is not extractable');\n        case 4:\n          if (!(key.type !== keyType)) {\n            _context.next = 6;\n            break;\n          }\n          throw new TypeError(\"key is not a \".concat(keyType, \" key\"));\n        case 6:\n          _context.t0 = formatPEM;\n          _context.t1 = encodeBase64;\n          _context.t2 = Uint8Array;\n          _context.next = 11;\n          return crypto.subtle.exportKey(keyFormat, key);\n        case 11:\n          _context.t3 = _context.sent;\n          _context.t4 = new _context.t2(_context.t3);\n          _context.t5 = (0, _context.t1)(_context.t4);\n          _context.t6 = \"\".concat(keyType.toUpperCase(), \" KEY\");\n          return _context.abrupt(\"return\", (0, _context.t0)(_context.t5, _context.t6));\n        case 16:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return function genericExport(_x, _x2, _x3) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var toSPKI = function toSPKI(key) {\n  return genericExport('public', 'spki', key);\n};\nexport var toPKCS8 = function toPKCS8(key) {\n  return genericExport('private', 'pkcs8', key);\n};\nvar findOid = function findOid(keyData, oid) {\n  var from = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  if (from === 0) {\n    oid.unshift(oid.length);\n    oid.unshift(0x06);\n  }\n  var i = keyData.indexOf(oid[0], from);\n  if (i === -1) return false;\n  var sub = keyData.subarray(i, i + oid.length);\n  if (sub.length !== oid.length) return false;\n  return sub.every(function (value, index) {\n    return value === oid[index];\n  }) || findOid(keyData, oid, i + 1);\n};\nvar getNamedCurve = function getNamedCurve(keyData) {\n  switch (true) {\n    case findOid(keyData, [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07]):\n      return 'P-256';\n    case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x22]):\n      return 'P-384';\n    case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x23]):\n      return 'P-521';\n    case findOid(keyData, [0x2b, 0x65, 0x6e]):\n      return 'X25519';\n    case findOid(keyData, [0x2b, 0x65, 0x6f]):\n      return 'X448';\n    case findOid(keyData, [0x2b, 0x65, 0x70]):\n      return 'Ed25519';\n    case findOid(keyData, [0x2b, 0x65, 0x71]):\n      return 'Ed448';\n    default:\n      throw new JOSENotSupported('Invalid or unsupported EC Key Curve or OKP Key Sub Type');\n  }\n};\nvar genericImport = /*#__PURE__*/function () {\n  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(replace, keyFormat, pem, alg, options) {\n    var _a, algorithm, keyUsages, keyData, isPublic, namedCurve, _namedCurve;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          keyData = new Uint8Array(atob(pem.replace(replace, '')).split('').map(function (c) {\n            return c.charCodeAt(0);\n          }));\n          isPublic = keyFormat === 'spki';\n          _context2.t0 = alg;\n          _context2.next = _context2.t0 === 'PS256' ? 5 : _context2.t0 === 'PS384' ? 5 : _context2.t0 === 'PS512' ? 5 : _context2.t0 === 'RS256' ? 8 : _context2.t0 === 'RS384' ? 8 : _context2.t0 === 'RS512' ? 8 : _context2.t0 === 'RSA-OAEP' ? 11 : _context2.t0 === 'RSA-OAEP-256' ? 11 : _context2.t0 === 'RSA-OAEP-384' ? 11 : _context2.t0 === 'RSA-OAEP-512' ? 11 : _context2.t0 === 'ES256' ? 14 : _context2.t0 === 'ES384' ? 17 : _context2.t0 === 'ES512' ? 20 : _context2.t0 === 'ECDH-ES' ? 23 : _context2.t0 === 'ECDH-ES+A128KW' ? 23 : _context2.t0 === 'ECDH-ES+A192KW' ? 23 : _context2.t0 === 'ECDH-ES+A256KW' ? 23 : _context2.t0 === (isCloudflareWorkers() && 'EdDSA') ? 27 : _context2.t0 === 'EdDSA' ? 31 : 34;\n          break;\n        case 5:\n          algorithm = {\n            name: 'RSA-PSS',\n            hash: \"SHA-\".concat(alg.slice(-3))\n          };\n          keyUsages = isPublic ? ['verify'] : ['sign'];\n          return _context2.abrupt(\"break\", 35);\n        case 8:\n          algorithm = {\n            name: 'RSASSA-PKCS1-v1_5',\n            hash: \"SHA-\".concat(alg.slice(-3))\n          };\n          keyUsages = isPublic ? ['verify'] : ['sign'];\n          return _context2.abrupt(\"break\", 35);\n        case 11:\n          algorithm = {\n            name: 'RSA-OAEP',\n            hash: \"SHA-\".concat(parseInt(alg.slice(-3), 10) || 1)\n          };\n          keyUsages = isPublic ? ['encrypt', 'wrapKey'] : ['decrypt', 'unwrapKey'];\n          return _context2.abrupt(\"break\", 35);\n        case 14:\n          algorithm = {\n            name: 'ECDSA',\n            namedCurve: 'P-256'\n          };\n          keyUsages = isPublic ? ['verify'] : ['sign'];\n          return _context2.abrupt(\"break\", 35);\n        case 17:\n          algorithm = {\n            name: 'ECDSA',\n            namedCurve: 'P-384'\n          };\n          keyUsages = isPublic ? ['verify'] : ['sign'];\n          return _context2.abrupt(\"break\", 35);\n        case 20:\n          algorithm = {\n            name: 'ECDSA',\n            namedCurve: 'P-521'\n          };\n          keyUsages = isPublic ? ['verify'] : ['sign'];\n          return _context2.abrupt(\"break\", 35);\n        case 23:\n          namedCurve = getNamedCurve(keyData);\n          algorithm = namedCurve.startsWith('P-') ? {\n            name: 'ECDH',\n            namedCurve: namedCurve\n          } : {\n            name: namedCurve\n          };\n          keyUsages = isPublic ? [] : ['deriveBits'];\n          return _context2.abrupt(\"break\", 35);\n        case 27:\n          _namedCurve = getNamedCurve(keyData).toUpperCase();\n          algorithm = {\n            name: \"NODE-\".concat(_namedCurve),\n            namedCurve: \"NODE-\".concat(_namedCurve)\n          };\n          keyUsages = isPublic ? ['verify'] : ['sign'];\n          return _context2.abrupt(\"break\", 35);\n        case 31:\n          algorithm = {\n            name: getNamedCurve(keyData)\n          };\n          keyUsages = isPublic ? ['verify'] : ['sign'];\n          return _context2.abrupt(\"break\", 35);\n        case 34:\n          throw new JOSENotSupported('Invalid or unsupported \"alg\" (Algorithm) value');\n        case 35:\n          return _context2.abrupt(\"return\", crypto.subtle.importKey(keyFormat, keyData, algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages));\n        case 36:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return function genericImport(_x4, _x5, _x6, _x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n}();\nexport var fromPKCS8 = function fromPKCS8(pem, alg, options) {\n  return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g, 'pkcs8', pem, alg, options);\n};\nexport var fromSPKI = function fromSPKI(pem, alg, options) {\n  return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g, 'spki', pem, alg, options);\n};","map":{"version":3,"names":["isCloudflareWorkers","crypto","isCryptoKey","invalidKeyInput","encodeBase64","formatPEM","JOSENotSupported","types","genericExport","keyType","keyFormat","key","TypeError","extractable","type","Uint8Array","subtle","exportKey","toUpperCase","toSPKI","toPKCS8","findOid","keyData","oid","from","unshift","length","i","indexOf","sub","subarray","every","value","index","getNamedCurve","genericImport","replace","pem","alg","options","atob","split","map","c","charCodeAt","isPublic","algorithm","name","hash","slice","keyUsages","parseInt","namedCurve","startsWith","importKey","_a","fromPKCS8","fromSPKI"],"sources":["E:/react-todo-app/node_modules/jose/dist/browser/runtime/asn1.js"],"sourcesContent":["import { isCloudflareWorkers } from './env.js';\nimport crypto, { isCryptoKey } from './webcrypto.js';\nimport invalidKeyInput from '../lib/invalid_key_input.js';\nimport { encodeBase64 } from './base64url.js';\nimport formatPEM from '../lib/format_pem.js';\nimport { JOSENotSupported } from '../util/errors.js';\nimport { types } from './is_key_like.js';\nconst genericExport = async (keyType, keyFormat, key) => {\n    if (!isCryptoKey(key)) {\n        throw new TypeError(invalidKeyInput(key, ...types));\n    }\n    if (!key.extractable) {\n        throw new TypeError('CryptoKey is not extractable');\n    }\n    if (key.type !== keyType) {\n        throw new TypeError(`key is not a ${keyType} key`);\n    }\n    return formatPEM(encodeBase64(new Uint8Array(await crypto.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);\n};\nexport const toSPKI = (key) => {\n    return genericExport('public', 'spki', key);\n};\nexport const toPKCS8 = (key) => {\n    return genericExport('private', 'pkcs8', key);\n};\nconst findOid = (keyData, oid, from = 0) => {\n    if (from === 0) {\n        oid.unshift(oid.length);\n        oid.unshift(0x06);\n    }\n    let i = keyData.indexOf(oid[0], from);\n    if (i === -1)\n        return false;\n    const sub = keyData.subarray(i, i + oid.length);\n    if (sub.length !== oid.length)\n        return false;\n    return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);\n};\nconst getNamedCurve = (keyData) => {\n    switch (true) {\n        case findOid(keyData, [0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07]):\n            return 'P-256';\n        case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x22]):\n            return 'P-384';\n        case findOid(keyData, [0x2b, 0x81, 0x04, 0x00, 0x23]):\n            return 'P-521';\n        case findOid(keyData, [0x2b, 0x65, 0x6e]):\n            return 'X25519';\n        case findOid(keyData, [0x2b, 0x65, 0x6f]):\n            return 'X448';\n        case findOid(keyData, [0x2b, 0x65, 0x70]):\n            return 'Ed25519';\n        case findOid(keyData, [0x2b, 0x65, 0x71]):\n            return 'Ed448';\n        default:\n            throw new JOSENotSupported('Invalid or unsupported EC Key Curve or OKP Key Sub Type');\n    }\n};\nconst genericImport = async (replace, keyFormat, pem, alg, options) => {\n    var _a;\n    let algorithm;\n    let keyUsages;\n    const keyData = new Uint8Array(atob(pem.replace(replace, ''))\n        .split('')\n        .map((c) => c.charCodeAt(0)));\n    const isPublic = keyFormat === 'spki';\n    switch (alg) {\n        case 'PS256':\n        case 'PS384':\n        case 'PS512':\n            algorithm = { name: 'RSA-PSS', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'RS256':\n        case 'RS384':\n        case 'RS512':\n            algorithm = { name: 'RSASSA-PKCS1-v1_5', hash: `SHA-${alg.slice(-3)}` };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'RSA-OAEP':\n        case 'RSA-OAEP-256':\n        case 'RSA-OAEP-384':\n        case 'RSA-OAEP-512':\n            algorithm = {\n                name: 'RSA-OAEP',\n                hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,\n            };\n            keyUsages = isPublic ? ['encrypt', 'wrapKey'] : ['decrypt', 'unwrapKey'];\n            break;\n        case 'ES256':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-256' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ES384':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-384' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ES512':\n            algorithm = { name: 'ECDSA', namedCurve: 'P-521' };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        case 'ECDH-ES':\n        case 'ECDH-ES+A128KW':\n        case 'ECDH-ES+A192KW':\n        case 'ECDH-ES+A256KW': {\n            const namedCurve = getNamedCurve(keyData);\n            algorithm = namedCurve.startsWith('P-') ? { name: 'ECDH', namedCurve } : { name: namedCurve };\n            keyUsages = isPublic ? [] : ['deriveBits'];\n            break;\n        }\n        case isCloudflareWorkers() && 'EdDSA': {\n            const namedCurve = getNamedCurve(keyData).toUpperCase();\n            algorithm = { name: `NODE-${namedCurve}`, namedCurve: `NODE-${namedCurve}` };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        }\n        case 'EdDSA':\n            algorithm = { name: getNamedCurve(keyData) };\n            keyUsages = isPublic ? ['verify'] : ['sign'];\n            break;\n        default:\n            throw new JOSENotSupported('Invalid or unsupported \"alg\" (Algorithm) value');\n    }\n    return crypto.subtle.importKey(keyFormat, keyData, algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);\n};\nexport const fromPKCS8 = (pem, alg, options) => {\n    return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\\s)/g, 'pkcs8', pem, alg, options);\n};\nexport const fromSPKI = (pem, alg, options) => {\n    return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\\s)/g, 'spki', pem, alg, options);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}