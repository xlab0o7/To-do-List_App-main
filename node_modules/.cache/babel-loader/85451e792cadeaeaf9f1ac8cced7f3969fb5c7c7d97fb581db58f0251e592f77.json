{"ast":null,"code":"// **N3Lexer** tokenizes N3 documents.\nimport namespaces from './IRIs';\nimport queueMicrotask from 'queue-microtask';\nconst {\n  xsd\n} = namespaces;\n\n// Regular expression and replacement string to escape N3 strings\nconst escapeSequence = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\([^])/g;\nconst escapeReplacements = {\n  '\\\\': '\\\\',\n  \"'\": \"'\",\n  '\"': '\"',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t',\n  'f': '\\f',\n  'b': '\\b',\n  '_': '_',\n  '~': '~',\n  '.': '.',\n  '-': '-',\n  '!': '!',\n  '$': '$',\n  '&': '&',\n  '(': '(',\n  ')': ')',\n  '*': '*',\n  '+': '+',\n  ',': ',',\n  ';': ';',\n  '=': '=',\n  '/': '/',\n  '?': '?',\n  '#': '#',\n  '@': '@',\n  '%': '%'\n};\nconst illegalIriChars = /[\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]/;\nconst lineModeRegExps = {\n  _iri: true,\n  _unescapedIri: true,\n  _simpleQuotedString: true,\n  _langcode: true,\n  _blank: true,\n  _newline: true,\n  _comment: true,\n  _whitespace: true,\n  _endOfFile: true\n};\nconst invalidRegExp = /$0^/;\n\n// ## Constructor\nexport default class N3Lexer {\n  constructor(options) {\n    // ## Regular expressions\n    // It's slightly faster to have these as properties than as in-scope variables\n    this._iri = /^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/; // IRI with escape sequences; needs sanity check after unescaping\n    this._unescapedIri = /^<([^\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/; // IRI without escape sequences; no unescaping\n    this._simpleQuotedString = /^\"([^\"\\\\\\r\\n]*)\"(?=[^\"])/; // string without escape sequences\n    this._simpleApostropheString = /^'([^'\\\\\\r\\n]*)'(?=[^'])/;\n    this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\\-])/i;\n    this._prefix = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:(?=[#\\s<])/;\n    this._prefixed = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:((?:(?:[0-:A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])(?:(?:[\\.\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])*(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~]))?)?)(?:[ \\t]+|(?=\\.?[,;!\\^\\s#()\\[\\]\\{\\}\"'<>]))/;\n    this._variable = /^\\?(?:(?:[A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?=[.,;!\\^\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._blank = /^_:((?:[0-9A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?:[ \\t]+|(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>]))/;\n    this._number = /^[\\-+]?(?:(\\d+\\.\\d*|\\.?\\d+)[eE][\\-+]?|\\d*(\\.)?)\\d+(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._boolean = /^(?:true|false)(?=[.,;\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._keyword = /^@[a-z]+(?=[\\s#<:])/i;\n    this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\\s#<])/i;\n    this._shortPredicates = /^a(?=[\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._newline = /^[ \\t]*(?:#[^\\n\\r]*)?(?:\\r\\n|\\n|\\r)[ \\t]*/;\n    this._comment = /#([^\\n\\r]*)/;\n    this._whitespace = /^[ \\t]+/;\n    this._endOfFile = /^(?:#[^\\n\\r]*)?$/;\n    options = options || {};\n\n    // In line mode (N-Triples or N-Quads), only simple features may be parsed\n    if (this._lineMode = !!options.lineMode) {\n      this._n3Mode = false;\n      // Don't tokenize special literals\n      for (const key in this) {\n        if (!(key in lineModeRegExps) && this[key] instanceof RegExp) this[key] = invalidRegExp;\n      }\n    }\n    // When not in line mode, enable N3 functionality by default\n    else {\n      this._n3Mode = options.n3 !== false;\n    }\n    // Don't output comment tokens by default\n    this._comments = !!options.comments;\n    // Cache the last tested closing position of long literals\n    this._literalClosingPos = 0;\n  }\n\n  // ## Private methods\n\n  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback\n  _tokenizeToEnd(callback, inputFinished) {\n    // Continue parsing as far as possible; the loop will return eventually\n    let input = this._input;\n    let currentLineLength = input.length;\n    while (true) {\n      // Count and skip whitespace lines\n      let whiteSpaceMatch, comment;\n      while (whiteSpaceMatch = this._newline.exec(input)) {\n        // Try to find a comment\n        if (this._comments && (comment = this._comment.exec(whiteSpaceMatch[0]))) emitToken('comment', comment[1], '', this._line, whiteSpaceMatch[0].length);\n        // Advance the input\n        input = input.substr(whiteSpaceMatch[0].length, input.length);\n        currentLineLength = input.length;\n        this._line++;\n      }\n      // Skip whitespace on current line\n      if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input))) input = input.substr(whiteSpaceMatch[0].length, input.length);\n\n      // Stop for now if we're at the end\n      if (this._endOfFile.test(input)) {\n        // If the input is finished, emit EOF\n        if (inputFinished) {\n          // Try to find a final comment\n          if (this._comments && (comment = this._comment.exec(input))) emitToken('comment', comment[1], '', this._line, input.length);\n          input = null;\n          emitToken('eof', '', '', this._line, 0);\n        }\n        return this._input = input;\n      }\n\n      // Look for specific token types based on the first character\n      const line = this._line,\n        firstChar = input[0];\n      let type = '',\n        value = '',\n        prefix = '',\n        match = null,\n        matchLength = 0,\n        inconclusive = false;\n      switch (firstChar) {\n        case '^':\n          // We need at least 3 tokens lookahead to distinguish ^^<IRI> and ^^pre:fixed\n          if (input.length < 3) break;\n          // Try to match a type\n          else if (input[1] === '^') {\n            this._previousMarker = '^^';\n            // Move to type IRI or prefixed name\n            input = input.substr(2);\n            if (input[0] !== '<') {\n              inconclusive = true;\n              break;\n            }\n          }\n          // If no type, it must be a path expression\n          else {\n            if (this._n3Mode) {\n              matchLength = 1;\n              type = '^';\n            }\n            break;\n          }\n        // Fall through in case the type is an IRI\n        case '<':\n          // Try to find a full IRI without escape sequences\n          if (match = this._unescapedIri.exec(input)) type = 'IRI', value = match[1];\n          // Try to find a full IRI with escape sequences\n          else if (match = this._iri.exec(input)) {\n            value = this._unescape(match[1]);\n            if (value === null || illegalIriChars.test(value)) return reportSyntaxError(this);\n            type = 'IRI';\n          }\n          // Try to find a nested triple\n          else if (input.length > 1 && input[1] === '<') type = '<<', matchLength = 2;\n          // Try to find a backwards implication arrow\n          else if (this._n3Mode && input.length > 1 && input[1] === '=') type = 'inverse', matchLength = 2, value = '>';\n          break;\n        case '>':\n          if (input.length > 1 && input[1] === '>') type = '>>', matchLength = 2;\n          break;\n        case '_':\n          // Try to find a blank node. Since it can contain (but not end with) a dot,\n          // we always need a non-dot character before deciding it is a blank node.\n          // Therefore, try inserting a space if we're at the end of the input.\n          if ((match = this._blank.exec(input)) || inputFinished && (match = this._blank.exec(`${input} `))) type = 'blank', prefix = '_', value = match[1];\n          break;\n        case '\"':\n          // Try to find a literal without escape sequences\n          if (match = this._simpleQuotedString.exec(input)) value = match[1];\n          // Try to find a literal wrapped in three pairs of quotes\n          else {\n            ({\n              value,\n              matchLength\n            } = this._parseLiteral(input));\n            if (value === null) return reportSyntaxError(this);\n          }\n          if (match !== null || matchLength !== 0) {\n            type = 'literal';\n            this._literalClosingPos = 0;\n          }\n          break;\n        case \"'\":\n          if (!this._lineMode) {\n            // Try to find a literal without escape sequences\n            if (match = this._simpleApostropheString.exec(input)) value = match[1];\n            // Try to find a literal wrapped in three pairs of quotes\n            else {\n              ({\n                value,\n                matchLength\n              } = this._parseLiteral(input));\n              if (value === null) return reportSyntaxError(this);\n            }\n            if (match !== null || matchLength !== 0) {\n              type = 'literal';\n              this._literalClosingPos = 0;\n            }\n          }\n          break;\n        case '?':\n          // Try to find a variable\n          if (this._n3Mode && (match = this._variable.exec(input))) type = 'var', value = match[0];\n          break;\n        case '@':\n          // Try to find a language code\n          if (this._previousMarker === 'literal' && (match = this._langcode.exec(input))) type = 'langcode', value = match[1];\n          // Try to find a keyword\n          else if (match = this._keyword.exec(input)) type = match[0];\n          break;\n        case '.':\n          // Try to find a dot as punctuation\n          if (input.length === 1 ? inputFinished : input[1] < '0' || input[1] > '9') {\n            type = '.';\n            matchLength = 1;\n            break;\n          }\n        // Fall through to numerical case (could be a decimal dot)\n\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9':\n        case '+':\n        case '-':\n          // Try to find a number. Since it can contain (but not end with) a dot,\n          // we always need a non-dot character before deciding it is a number.\n          // Therefore, try inserting a space if we're at the end of the input.\n          if (match = this._number.exec(input) || inputFinished && (match = this._number.exec(`${input} `))) {\n            type = 'literal', value = match[0];\n            prefix = typeof match[1] === 'string' ? xsd.double : typeof match[2] === 'string' ? xsd.decimal : xsd.integer;\n          }\n          break;\n        case 'B':\n        case 'b':\n        case 'p':\n        case 'P':\n        case 'G':\n        case 'g':\n          // Try to find a SPARQL-style keyword\n          if (match = this._sparqlKeyword.exec(input)) type = match[0].toUpperCase();else inconclusive = true;\n          break;\n        case 'f':\n        case 't':\n          // Try to match a boolean\n          if (match = this._boolean.exec(input)) type = 'literal', value = match[0], prefix = xsd.boolean;else inconclusive = true;\n          break;\n        case 'a':\n          // Try to find an abbreviated predicate\n          if (match = this._shortPredicates.exec(input)) type = 'abbreviation', value = 'a';else inconclusive = true;\n          break;\n        case '=':\n          // Try to find an implication arrow or equals sign\n          if (this._n3Mode && input.length > 1) {\n            type = 'abbreviation';\n            if (input[1] !== '>') matchLength = 1, value = '=';else matchLength = 2, value = '>';\n          }\n          break;\n        case '!':\n          if (!this._n3Mode) break;\n        case ',':\n        case ';':\n        case '[':\n        case ']':\n        case '(':\n        case ')':\n        case '{':\n        case '}':\n          if (!this._lineMode) {\n            matchLength = 1;\n            type = firstChar;\n          }\n          break;\n        default:\n          inconclusive = true;\n      }\n\n      // Some first characters do not allow an immediate decision, so inspect more\n      if (inconclusive) {\n        // Try to find a prefix\n        if ((this._previousMarker === '@prefix' || this._previousMarker === 'PREFIX') && (match = this._prefix.exec(input))) type = 'prefix', value = match[1] || '';\n        // Try to find a prefixed name. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a prefixed name.\n        // Therefore, try inserting a space if we're at the end of the input.\n        else if ((match = this._prefixed.exec(input)) || inputFinished && (match = this._prefixed.exec(`${input} `))) type = 'prefixed', prefix = match[1] || '', value = this._unescape(match[2]);\n      }\n\n      // A type token is special: it can only be emitted after an IRI or prefixed name is read\n      if (this._previousMarker === '^^') {\n        switch (type) {\n          case 'prefixed':\n            type = 'type';\n            break;\n          case 'IRI':\n            type = 'typeIRI';\n            break;\n          default:\n            type = '';\n        }\n      }\n\n      // What if nothing of the above was found?\n      if (!type) {\n        // We could be in streaming mode, and then we just wait for more input to arrive.\n        // Otherwise, a syntax error has occurred in the input.\n        // One exception: error on an unaccounted linebreak (= not inside a triple-quoted literal).\n        if (inputFinished || !/^'''|^\"\"\"/.test(input) && /\\n|\\r/.test(input)) return reportSyntaxError(this);else return this._input = input;\n      }\n\n      // Emit the parsed token\n      const length = matchLength || match[0].length;\n      const token = emitToken(type, value, prefix, line, length);\n      this.previousToken = token;\n      this._previousMarker = type;\n\n      // Advance to next part to tokenize\n      input = input.substr(length, input.length);\n    }\n\n    // Emits the token through the callback\n    function emitToken(type, value, prefix, line, length) {\n      const start = input ? currentLineLength - input.length : currentLineLength;\n      const end = start + length;\n      const token = {\n        type,\n        value,\n        prefix,\n        line,\n        start,\n        end\n      };\n      callback(null, token);\n      return token;\n    }\n    // Signals the syntax error through the callback\n    function reportSyntaxError(self) {\n      callback(self._syntaxError(/^\\S*/.exec(input)[0]));\n    }\n  }\n\n  // ### `_unescape` replaces N3 escape codes by their corresponding characters\n  _unescape(item) {\n    let invalid = false;\n    const replaced = item.replace(escapeSequence, (sequence, unicode4, unicode8, escapedChar) => {\n      // 4-digit unicode character\n      if (typeof unicode4 === 'string') return String.fromCharCode(Number.parseInt(unicode4, 16));\n      // 8-digit unicode character\n      if (typeof unicode8 === 'string') {\n        let charCode = Number.parseInt(unicode8, 16);\n        return charCode <= 0xFFFF ? String.fromCharCode(Number.parseInt(unicode8, 16)) : String.fromCharCode(0xD800 + ((charCode -= 0x10000) >> 10), 0xDC00 + (charCode & 0x3FF));\n      }\n      // fixed escape sequence\n      if (escapedChar in escapeReplacements) return escapeReplacements[escapedChar];\n      // invalid escape sequence\n      invalid = true;\n      return '';\n    });\n    return invalid ? null : replaced;\n  }\n\n  // ### `_parseLiteral` parses a literal into an unescaped value\n  _parseLiteral(input) {\n    // Ensure we have enough lookahead to identify triple-quoted strings\n    if (input.length >= 3) {\n      // Identify the opening quote(s)\n      const opening = input.match(/^(?:\"\"\"|\"|'''|'|)/)[0];\n      const openingLength = opening.length;\n\n      // Find the next candidate closing quotes\n      let closingPos = Math.max(this._literalClosingPos, openingLength);\n      while ((closingPos = input.indexOf(opening, closingPos)) > 0) {\n        // Count backslashes right before the closing quotes\n        let backslashCount = 0;\n        while (input[closingPos - backslashCount - 1] === '\\\\') backslashCount++;\n\n        // An even number of backslashes (in particular 0)\n        // means these are actual, non-escaped closing quotes\n        if (backslashCount % 2 === 0) {\n          // Extract and unescape the value\n          const raw = input.substring(openingLength, closingPos);\n          const lines = raw.split(/\\r\\n|\\r|\\n/).length - 1;\n          const matchLength = closingPos + openingLength;\n          // Only triple-quoted strings can be multi-line\n          if (openingLength === 1 && lines !== 0 || openingLength === 3 && this._lineMode) break;\n          this._line += lines;\n          return {\n            value: this._unescape(raw),\n            matchLength\n          };\n        }\n        closingPos++;\n      }\n      this._literalClosingPos = input.length - openingLength + 1;\n    }\n    return {\n      value: '',\n      matchLength: 0\n    };\n  }\n\n  // ### `_syntaxError` creates a syntax error for the given issue\n  _syntaxError(issue) {\n    this._input = null;\n    const err = new Error(`Unexpected \"${issue}\" on line ${this._line}.`);\n    err.context = {\n      token: undefined,\n      line: this._line,\n      previousToken: this.previousToken\n    };\n    return err;\n  }\n\n  // ### Strips off any starting UTF BOM mark.\n  _readStartingBom(input) {\n    return input.startsWith('\\ufeff') ? input.substr(1) : input;\n  }\n\n  // ## Public methods\n\n  // ### `tokenize` starts the transformation of an N3 document into an array of tokens.\n  // The input can be a string or a stream.\n  tokenize(input, callback) {\n    this._line = 1;\n\n    // If the input is a string, continuously emit tokens through the callback until the end\n    if (typeof input === 'string') {\n      this._input = this._readStartingBom(input);\n      // If a callback was passed, asynchronously call it\n      if (typeof callback === 'function') queueMicrotask(() => this._tokenizeToEnd(callback, true));\n      // If no callback was passed, tokenize synchronously and return\n      else {\n        const tokens = [];\n        let error;\n        this._tokenizeToEnd((e, t) => e ? error = e : tokens.push(t), true);\n        if (error) throw error;\n        return tokens;\n      }\n    }\n    // Otherwise, the input must be a stream\n    else {\n      this._pendingBuffer = null;\n      if (typeof input.setEncoding === 'function') input.setEncoding('utf8');\n      // Adds the data chunk to the buffer and parses as far as possible\n      input.on('data', data => {\n        if (this._input !== null && data.length !== 0) {\n          // Prepend any previous pending writes\n          if (this._pendingBuffer) {\n            data = Buffer.concat([this._pendingBuffer, data]);\n            this._pendingBuffer = null;\n          }\n          // Hold if the buffer ends in an incomplete unicode sequence\n          if (data[data.length - 1] & 0x80) {\n            this._pendingBuffer = data;\n          }\n          // Otherwise, tokenize as far as possible\n          else {\n            // Only read a BOM at the start\n            if (typeof this._input === 'undefined') this._input = this._readStartingBom(typeof data === 'string' ? data : data.toString());else this._input += data;\n            this._tokenizeToEnd(callback, false);\n          }\n        }\n      });\n      // Parses until the end\n      input.on('end', () => {\n        if (typeof this._input === 'string') this._tokenizeToEnd(callback, true);\n      });\n      input.on('error', callback);\n    }\n  }\n}","map":{"version":3,"names":["namespaces","queueMicrotask","xsd","escapeSequence","escapeReplacements","illegalIriChars","lineModeRegExps","_iri","_unescapedIri","_simpleQuotedString","_langcode","_blank","_newline","_comment","_whitespace","_endOfFile","invalidRegExp","N3Lexer","constructor","options","_simpleApostropheString","_prefix","_prefixed","_variable","_number","_boolean","_keyword","_sparqlKeyword","_shortPredicates","_lineMode","lineMode","_n3Mode","key","RegExp","n3","_comments","comments","_literalClosingPos","_tokenizeToEnd","callback","inputFinished","input","_input","currentLineLength","length","whiteSpaceMatch","comment","exec","emitToken","_line","substr","test","line","firstChar","type","value","prefix","match","matchLength","inconclusive","_previousMarker","_unescape","reportSyntaxError","_parseLiteral","double","decimal","integer","toUpperCase","boolean","token","previousToken","start","end","self","_syntaxError","item","invalid","replaced","replace","sequence","unicode4","unicode8","escapedChar","String","fromCharCode","Number","parseInt","charCode","opening","openingLength","closingPos","Math","max","indexOf","backslashCount","raw","substring","lines","split","issue","err","Error","context","undefined","_readStartingBom","startsWith","tokenize","tokens","error","e","t","push","_pendingBuffer","setEncoding","on","data","Buffer","concat","toString"],"sources":["E:/react-todo-app/node_modules/n3/src/N3Lexer.js"],"sourcesContent":["// **N3Lexer** tokenizes N3 documents.\nimport namespaces from './IRIs';\nimport queueMicrotask from 'queue-microtask';\n\nconst { xsd } = namespaces;\n\n// Regular expression and replacement string to escape N3 strings\nconst escapeSequence = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\([^])/g;\nconst escapeReplacements = {\n  '\\\\': '\\\\', \"'\": \"'\", '\"': '\"',\n  'n': '\\n', 'r': '\\r', 't': '\\t', 'f': '\\f', 'b': '\\b',\n  '_': '_', '~': '~', '.': '.', '-': '-', '!': '!', '$': '$', '&': '&',\n  '(': '(', ')': ')', '*': '*', '+': '+', ',': ',', ';': ';', '=': '=',\n  '/': '/', '?': '?', '#': '#', '@': '@', '%': '%',\n};\nconst illegalIriChars = /[\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]/;\n\nconst lineModeRegExps = {\n  _iri: true,\n  _unescapedIri: true,\n  _simpleQuotedString: true,\n  _langcode: true,\n  _blank: true,\n  _newline: true,\n  _comment: true,\n  _whitespace: true,\n  _endOfFile: true,\n};\nconst invalidRegExp = /$0^/;\n\n// ## Constructor\nexport default class N3Lexer {\n  constructor(options) {\n    // ## Regular expressions\n    // It's slightly faster to have these as properties than as in-scope variables\n    this._iri = /^<((?:[^ <>{}\\\\]|\\\\[uU])+)>[ \\t]*/; // IRI with escape sequences; needs sanity check after unescaping\n    this._unescapedIri = /^<([^\\x00-\\x20<>\\\\\"\\{\\}\\|\\^\\`]*)>[ \\t]*/; // IRI without escape sequences; no unescaping\n    this._simpleQuotedString = /^\"([^\"\\\\\\r\\n]*)\"(?=[^\"])/; // string without escape sequences\n    this._simpleApostropheString = /^'([^'\\\\\\r\\n]*)'(?=[^'])/;\n    this._langcode = /^@([a-z]+(?:-[a-z0-9]+)*)(?=[^a-z0-9\\-])/i;\n    this._prefix = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:(?=[#\\s<])/;\n    this._prefixed = /^((?:[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)?:((?:(?:[0-:A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])(?:(?:[\\.\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~])*(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff]|%[0-9a-fA-F]{2}|\\\\[!#-\\/;=?\\-@_~]))?)?)(?:[ \\t]+|(?=\\.?[,;!\\^\\s#()\\[\\]\\{\\}\"'<>]))/;\n    this._variable = /^\\?(?:(?:[A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:[\\-0-:A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?=[.,;!\\^\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._blank = /^_:((?:[0-9A-Z_a-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02ff\\u0370-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])(?:\\.?[\\-0-9A-Z_a-z\\xb7\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u037d\\u037f-\\u1fff\\u200c\\u200d\\u203f\\u2040\\u2070-\\u218f\\u2c00-\\u2fef\\u3001-\\ud7ff\\uf900-\\ufdcf\\ufdf0-\\ufffd]|[\\ud800-\\udb7f][\\udc00-\\udfff])*)(?:[ \\t]+|(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>]))/;\n    this._number = /^[\\-+]?(?:(\\d+\\.\\d*|\\.?\\d+)[eE][\\-+]?|\\d*(\\.)?)\\d+(?=\\.?[,;:\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._boolean = /^(?:true|false)(?=[.,;\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._keyword = /^@[a-z]+(?=[\\s#<:])/i;\n    this._sparqlKeyword = /^(?:PREFIX|BASE|GRAPH)(?=[\\s#<])/i;\n    this._shortPredicates = /^a(?=[\\s#()\\[\\]\\{\\}\"'<>])/;\n    this._newline = /^[ \\t]*(?:#[^\\n\\r]*)?(?:\\r\\n|\\n|\\r)[ \\t]*/;\n    this._comment = /#([^\\n\\r]*)/;\n    this._whitespace = /^[ \\t]+/;\n    this._endOfFile = /^(?:#[^\\n\\r]*)?$/;\n    options = options || {};\n\n    // In line mode (N-Triples or N-Quads), only simple features may be parsed\n    if (this._lineMode = !!options.lineMode) {\n      this._n3Mode = false;\n      // Don't tokenize special literals\n      for (const key in this) {\n        if (!(key in lineModeRegExps) && this[key] instanceof RegExp)\n          this[key] = invalidRegExp;\n      }\n    }\n    // When not in line mode, enable N3 functionality by default\n    else {\n      this._n3Mode = options.n3 !== false;\n    }\n    // Don't output comment tokens by default\n    this._comments = !!options.comments;\n    // Cache the last tested closing position of long literals\n    this._literalClosingPos = 0;\n  }\n\n  // ## Private methods\n\n  // ### `_tokenizeToEnd` tokenizes as for as possible, emitting tokens through the callback\n  _tokenizeToEnd(callback, inputFinished) {\n    // Continue parsing as far as possible; the loop will return eventually\n    let input = this._input;\n    let currentLineLength = input.length;\n    while (true) {\n      // Count and skip whitespace lines\n      let whiteSpaceMatch, comment;\n      while (whiteSpaceMatch = this._newline.exec(input)) {\n        // Try to find a comment\n        if (this._comments && (comment = this._comment.exec(whiteSpaceMatch[0])))\n          emitToken('comment', comment[1], '', this._line, whiteSpaceMatch[0].length);\n        // Advance the input\n        input = input.substr(whiteSpaceMatch[0].length, input.length);\n        currentLineLength = input.length;\n        this._line++;\n      }\n      // Skip whitespace on current line\n      if (!whiteSpaceMatch && (whiteSpaceMatch = this._whitespace.exec(input)))\n        input = input.substr(whiteSpaceMatch[0].length, input.length);\n\n      // Stop for now if we're at the end\n      if (this._endOfFile.test(input)) {\n        // If the input is finished, emit EOF\n        if (inputFinished) {\n          // Try to find a final comment\n          if (this._comments && (comment = this._comment.exec(input)))\n            emitToken('comment', comment[1], '', this._line, input.length);\n          input = null;\n          emitToken('eof', '', '', this._line, 0);\n        }\n        return this._input = input;\n      }\n\n      // Look for specific token types based on the first character\n      const line = this._line, firstChar = input[0];\n      let type = '', value = '', prefix = '',\n          match = null, matchLength = 0, inconclusive = false;\n      switch (firstChar) {\n      case '^':\n        // We need at least 3 tokens lookahead to distinguish ^^<IRI> and ^^pre:fixed\n        if (input.length < 3)\n          break;\n        // Try to match a type\n        else if (input[1] === '^') {\n          this._previousMarker = '^^';\n          // Move to type IRI or prefixed name\n          input = input.substr(2);\n          if (input[0] !== '<') {\n            inconclusive = true;\n            break;\n          }\n        }\n        // If no type, it must be a path expression\n        else {\n          if (this._n3Mode) {\n            matchLength = 1;\n            type = '^';\n          }\n          break;\n        }\n        // Fall through in case the type is an IRI\n      case '<':\n        // Try to find a full IRI without escape sequences\n        if (match = this._unescapedIri.exec(input))\n          type = 'IRI', value = match[1];\n        // Try to find a full IRI with escape sequences\n        else if (match = this._iri.exec(input)) {\n          value = this._unescape(match[1]);\n          if (value === null || illegalIriChars.test(value))\n            return reportSyntaxError(this);\n          type = 'IRI';\n        }\n        // Try to find a nested triple\n        else if (input.length > 1 && input[1] === '<')\n          type = '<<', matchLength = 2;\n        // Try to find a backwards implication arrow\n        else if (this._n3Mode && input.length > 1 && input[1] === '=')\n          type = 'inverse', matchLength = 2, value = '>';\n        break;\n\n      case '>':\n        if (input.length > 1 && input[1] === '>')\n          type = '>>', matchLength = 2;\n        break;\n\n      case '_':\n        // Try to find a blank node. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a blank node.\n        // Therefore, try inserting a space if we're at the end of the input.\n        if ((match = this._blank.exec(input)) ||\n            inputFinished && (match = this._blank.exec(`${input} `)))\n          type = 'blank', prefix = '_', value = match[1];\n        break;\n\n      case '\"':\n        // Try to find a literal without escape sequences\n        if (match = this._simpleQuotedString.exec(input))\n          value = match[1];\n        // Try to find a literal wrapped in three pairs of quotes\n        else {\n          ({ value, matchLength } = this._parseLiteral(input));\n          if (value === null)\n            return reportSyntaxError(this);\n        }\n        if (match !== null || matchLength !== 0) {\n          type = 'literal';\n          this._literalClosingPos = 0;\n        }\n        break;\n\n      case \"'\":\n        if (!this._lineMode) {\n          // Try to find a literal without escape sequences\n          if (match = this._simpleApostropheString.exec(input))\n            value = match[1];\n          // Try to find a literal wrapped in three pairs of quotes\n          else {\n            ({ value, matchLength } = this._parseLiteral(input));\n            if (value === null)\n              return reportSyntaxError(this);\n          }\n          if (match !== null || matchLength !== 0) {\n            type = 'literal';\n            this._literalClosingPos = 0;\n          }\n        }\n        break;\n\n      case '?':\n        // Try to find a variable\n        if (this._n3Mode && (match = this._variable.exec(input)))\n          type = 'var', value = match[0];\n        break;\n\n      case '@':\n        // Try to find a language code\n        if (this._previousMarker === 'literal' && (match = this._langcode.exec(input)))\n          type = 'langcode', value = match[1];\n        // Try to find a keyword\n        else if (match = this._keyword.exec(input))\n          type = match[0];\n        break;\n\n      case '.':\n        // Try to find a dot as punctuation\n        if (input.length === 1 ? inputFinished : (input[1] < '0' || input[1] > '9')) {\n          type = '.';\n          matchLength = 1;\n          break;\n        }\n        // Fall through to numerical case (could be a decimal dot)\n\n      case '0':\n      case '1':\n      case '2':\n      case '3':\n      case '4':\n      case '5':\n      case '6':\n      case '7':\n      case '8':\n      case '9':\n      case '+':\n      case '-':\n        // Try to find a number. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a number.\n        // Therefore, try inserting a space if we're at the end of the input.\n        if (match = this._number.exec(input) ||\n            inputFinished && (match = this._number.exec(`${input} `))) {\n          type = 'literal', value = match[0];\n          prefix = (typeof match[1] === 'string' ? xsd.double :\n                    (typeof match[2] === 'string' ? xsd.decimal : xsd.integer));\n        }\n        break;\n\n      case 'B':\n      case 'b':\n      case 'p':\n      case 'P':\n      case 'G':\n      case 'g':\n        // Try to find a SPARQL-style keyword\n        if (match = this._sparqlKeyword.exec(input))\n          type = match[0].toUpperCase();\n        else\n          inconclusive = true;\n        break;\n\n      case 'f':\n      case 't':\n        // Try to match a boolean\n        if (match = this._boolean.exec(input))\n          type = 'literal', value = match[0], prefix = xsd.boolean;\n        else\n          inconclusive = true;\n        break;\n\n      case 'a':\n        // Try to find an abbreviated predicate\n        if (match = this._shortPredicates.exec(input))\n          type = 'abbreviation', value = 'a';\n        else\n          inconclusive = true;\n        break;\n\n      case '=':\n        // Try to find an implication arrow or equals sign\n        if (this._n3Mode && input.length > 1) {\n          type = 'abbreviation';\n          if (input[1] !== '>')\n            matchLength = 1, value = '=';\n          else\n            matchLength = 2, value = '>';\n        }\n        break;\n\n      case '!':\n        if (!this._n3Mode)\n          break;\n      case ',':\n      case ';':\n      case '[':\n      case ']':\n      case '(':\n      case ')':\n      case '{':\n      case '}':\n        if (!this._lineMode) {\n          matchLength = 1;\n          type = firstChar;\n        }\n        break;\n\n      default:\n        inconclusive = true;\n      }\n\n      // Some first characters do not allow an immediate decision, so inspect more\n      if (inconclusive) {\n        // Try to find a prefix\n        if ((this._previousMarker === '@prefix' || this._previousMarker === 'PREFIX') &&\n            (match = this._prefix.exec(input)))\n          type = 'prefix', value = match[1] || '';\n        // Try to find a prefixed name. Since it can contain (but not end with) a dot,\n        // we always need a non-dot character before deciding it is a prefixed name.\n        // Therefore, try inserting a space if we're at the end of the input.\n        else if ((match = this._prefixed.exec(input)) ||\n                 inputFinished && (match = this._prefixed.exec(`${input} `)))\n          type = 'prefixed', prefix = match[1] || '', value = this._unescape(match[2]);\n      }\n\n      // A type token is special: it can only be emitted after an IRI or prefixed name is read\n      if (this._previousMarker === '^^') {\n        switch (type) {\n        case 'prefixed': type = 'type';    break;\n        case 'IRI':      type = 'typeIRI'; break;\n        default:         type = '';\n        }\n      }\n\n      // What if nothing of the above was found?\n      if (!type) {\n        // We could be in streaming mode, and then we just wait for more input to arrive.\n        // Otherwise, a syntax error has occurred in the input.\n        // One exception: error on an unaccounted linebreak (= not inside a triple-quoted literal).\n        if (inputFinished || (!/^'''|^\"\"\"/.test(input) && /\\n|\\r/.test(input)))\n          return reportSyntaxError(this);\n        else\n          return this._input = input;\n      }\n\n      // Emit the parsed token\n      const length = matchLength || match[0].length;\n      const token = emitToken(type, value, prefix, line, length);\n      this.previousToken = token;\n      this._previousMarker = type;\n\n      // Advance to next part to tokenize\n      input = input.substr(length, input.length);\n    }\n\n    // Emits the token through the callback\n    function emitToken(type, value, prefix, line, length) {\n      const start = input ? currentLineLength - input.length : currentLineLength;\n      const end = start + length;\n      const token = { type, value, prefix, line, start, end };\n      callback(null, token);\n      return token;\n    }\n    // Signals the syntax error through the callback\n    function reportSyntaxError(self) { callback(self._syntaxError(/^\\S*/.exec(input)[0])); }\n  }\n\n  // ### `_unescape` replaces N3 escape codes by their corresponding characters\n  _unescape(item) {\n    let invalid = false;\n    const replaced = item.replace(escapeSequence, (sequence, unicode4, unicode8, escapedChar) => {\n      // 4-digit unicode character\n      if (typeof unicode4 === 'string')\n        return String.fromCharCode(Number.parseInt(unicode4, 16));\n      // 8-digit unicode character\n      if (typeof unicode8 === 'string') {\n        let charCode = Number.parseInt(unicode8, 16);\n        return charCode <= 0xFFFF ? String.fromCharCode(Number.parseInt(unicode8, 16)) :\n          String.fromCharCode(0xD800 + ((charCode -= 0x10000) >> 10), 0xDC00 + (charCode & 0x3FF));\n      }\n      // fixed escape sequence\n      if (escapedChar in escapeReplacements)\n        return escapeReplacements[escapedChar];\n      // invalid escape sequence\n      invalid = true;\n      return '';\n    });\n    return invalid ? null : replaced;\n  }\n\n  // ### `_parseLiteral` parses a literal into an unescaped value\n  _parseLiteral(input) {\n    // Ensure we have enough lookahead to identify triple-quoted strings\n    if (input.length >= 3) {\n      // Identify the opening quote(s)\n      const opening = input.match(/^(?:\"\"\"|\"|'''|'|)/)[0];\n      const openingLength = opening.length;\n\n      // Find the next candidate closing quotes\n      let closingPos = Math.max(this._literalClosingPos, openingLength);\n      while ((closingPos = input.indexOf(opening, closingPos)) > 0) {\n        // Count backslashes right before the closing quotes\n        let backslashCount = 0;\n        while (input[closingPos - backslashCount - 1] === '\\\\')\n          backslashCount++;\n\n        // An even number of backslashes (in particular 0)\n        // means these are actual, non-escaped closing quotes\n        if (backslashCount % 2 === 0) {\n          // Extract and unescape the value\n          const raw = input.substring(openingLength, closingPos);\n          const lines = raw.split(/\\r\\n|\\r|\\n/).length - 1;\n          const matchLength = closingPos + openingLength;\n          // Only triple-quoted strings can be multi-line\n          if (openingLength === 1 && lines !== 0 ||\n              openingLength === 3 && this._lineMode)\n            break;\n          this._line += lines;\n          return { value: this._unescape(raw), matchLength };\n        }\n        closingPos++;\n      }\n      this._literalClosingPos = input.length - openingLength + 1;\n    }\n    return { value: '', matchLength: 0 };\n  }\n\n  // ### `_syntaxError` creates a syntax error for the given issue\n  _syntaxError(issue) {\n    this._input = null;\n    const err = new Error(`Unexpected \"${issue}\" on line ${this._line}.`);\n    err.context = {\n      token: undefined,\n      line: this._line,\n      previousToken: this.previousToken,\n    };\n    return err;\n  }\n\n  // ### Strips off any starting UTF BOM mark.\n  _readStartingBom(input) {\n    return input.startsWith('\\ufeff') ? input.substr(1) : input;\n  }\n\n  // ## Public methods\n\n  // ### `tokenize` starts the transformation of an N3 document into an array of tokens.\n  // The input can be a string or a stream.\n  tokenize(input, callback) {\n    this._line = 1;\n\n    // If the input is a string, continuously emit tokens through the callback until the end\n    if (typeof input === 'string') {\n      this._input = this._readStartingBom(input);\n      // If a callback was passed, asynchronously call it\n      if (typeof callback === 'function')\n        queueMicrotask(() => this._tokenizeToEnd(callback, true));\n      // If no callback was passed, tokenize synchronously and return\n      else {\n        const tokens = [];\n        let error;\n        this._tokenizeToEnd((e, t) => e ? (error = e) : tokens.push(t), true);\n        if (error) throw error;\n        return tokens;\n      }\n    }\n    // Otherwise, the input must be a stream\n    else {\n      this._pendingBuffer = null;\n      if (typeof input.setEncoding === 'function')\n        input.setEncoding('utf8');\n      // Adds the data chunk to the buffer and parses as far as possible\n      input.on('data', data => {\n        if (this._input !== null && data.length !== 0) {\n          // Prepend any previous pending writes\n          if (this._pendingBuffer) {\n            data = Buffer.concat([this._pendingBuffer, data]);\n            this._pendingBuffer = null;\n          }\n          // Hold if the buffer ends in an incomplete unicode sequence\n          if (data[data.length - 1] & 0x80) {\n            this._pendingBuffer = data;\n          }\n          // Otherwise, tokenize as far as possible\n          else {\n            // Only read a BOM at the start\n            if (typeof this._input === 'undefined')\n              this._input = this._readStartingBom(typeof data === 'string' ? data : data.toString());\n            else\n              this._input += data;\n            this._tokenizeToEnd(callback, false);\n          }\n        }\n      });\n      // Parses until the end\n      input.on('end', () => {\n        if (typeof this._input === 'string')\n          this._tokenizeToEnd(callback, true);\n      });\n      input.on('error', callback);\n    }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}