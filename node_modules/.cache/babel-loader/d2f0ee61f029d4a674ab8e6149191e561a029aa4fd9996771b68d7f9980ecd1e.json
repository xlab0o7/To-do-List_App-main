{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SessionInfoManager = exports.clear = exports.getUnauthenticatedSession = void 0;\nconst solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\nconst uuid_1 = require(\"uuid\");\nconst oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\nfunction getUnauthenticatedSession() {\n  return {\n    isLoggedIn: false,\n    sessionId: (0, uuid_1.v4)(),\n    fetch\n  };\n}\nexports.getUnauthenticatedSession = getUnauthenticatedSession;\nasync function clear(sessionId, storage) {\n  await Promise.all([storage.deleteAllUserData(sessionId, {\n    secure: false\n  }), storage.deleteAllUserData(sessionId, {\n    secure: true\n  }), storage.delete(\"clientKey\", {\n    secure: false\n  })]);\n  await (0, oidc_client_ext_1.clearOidcPersistentStorage)();\n}\nexports.clear = clear;\nclass SessionInfoManager {\n  constructor(storageUtility) {\n    this.storageUtility = storageUtility;\n  }\n  update(_sessionId, _options) {\n    throw new Error(\"Not Implemented\");\n  }\n  async get(sessionId) {\n    var _a;\n    const isLoggedIn = await this.storageUtility.getForUser(sessionId, \"isLoggedIn\", {\n      secure: true\n    });\n    const webId = await this.storageUtility.getForUser(sessionId, \"webId\", {\n      secure: true\n    });\n    const clientId = await this.storageUtility.getForUser(sessionId, \"clientId\", {\n      secure: false\n    });\n    const clientSecret = await this.storageUtility.getForUser(sessionId, \"clientSecret\", {\n      secure: false\n    });\n    const redirectUrl = await this.storageUtility.getForUser(sessionId, \"redirectUrl\", {\n      secure: false\n    });\n    const refreshToken = await this.storageUtility.getForUser(sessionId, \"refreshToken\", {\n      secure: true\n    });\n    const issuer = await this.storageUtility.getForUser(sessionId, \"issuer\", {\n      secure: false\n    });\n    const tokenType = (_a = await this.storageUtility.getForUser(sessionId, \"tokenType\", {\n      secure: false\n    })) !== null && _a !== void 0 ? _a : \"DPoP\";\n    if (!(0, solid_client_authn_core_1.isSupportedTokenType)(tokenType)) {\n      throw new Error(`Tokens of type [${tokenType}] are not supported.`);\n    }\n    if (clientId === undefined && isLoggedIn === undefined && webId === undefined && refreshToken === undefined) {\n      return undefined;\n    }\n    return {\n      sessionId,\n      webId,\n      isLoggedIn: isLoggedIn === \"true\",\n      redirectUrl,\n      refreshToken,\n      issuer,\n      clientAppId: clientId,\n      clientAppSecret: clientSecret,\n      tokenType\n    };\n  }\n  async getAll() {\n    throw new Error(\"Not implemented\");\n  }\n  async clear(sessionId) {\n    return clear(sessionId, this.storageUtility);\n  }\n  async register(_sessionId) {\n    throw new Error(\"Not implemented\");\n  }\n  async getRegisteredSessionIdAll() {\n    throw new Error(\"Not implemented\");\n  }\n  async clearAll() {\n    throw new Error(\"Not implemented\");\n  }\n}\nexports.SessionInfoManager = SessionInfoManager;","map":{"version":3,"mappings":"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","names":["getUnauthenticatedSession","isLoggedIn","sessionId","fetch","exports","clear","storage","Promise","all","deleteAllUserData","secure","delete","SessionInfoManager","constructor","storageUtility","update","_sessionId","_options","Error","get","getForUser","webId","clientId","clientSecret","redirectUrl","refreshToken","issuer","tokenType","undefined","clientAppId","clientAppSecret","getAll","register","getRegisteredSessionIdAll","clearAll"],"sources":["E:\\react-todo-app\\node_modules\\@inrupt\\solid-client-authn-browser\\src\\sessionInfo\\SessionInfoManager.ts"],"sourcesContent":["//\n// Copyright 2022 Inrupt Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n// Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n/**\n * @hidden\n * @packageDocumentation\n */\n\nimport {\n  ISessionInfo,\n  ISessionInfoManager,\n  ISessionInternalInfo,\n  ISessionInfoManagerOptions,\n  IStorageUtility,\n  isSupportedTokenType,\n} from \"@inrupt/solid-client-authn-core\";\nimport { v4 } from \"uuid\";\nimport { clearOidcPersistentStorage } from \"@inrupt/oidc-client-ext\";\n\nexport function getUnauthenticatedSession(): ISessionInfo & {\n  fetch: typeof fetch;\n} {\n  return {\n    isLoggedIn: false,\n    sessionId: v4(),\n    fetch,\n  };\n}\n\n/**\n * @param sessionId\n * @param storage\n * @hidden\n */\nexport async function clear(\n  sessionId: string,\n  storage: IStorageUtility\n): Promise<void> {\n  await Promise.all([\n    storage.deleteAllUserData(sessionId, { secure: false }),\n    storage.deleteAllUserData(sessionId, { secure: true }),\n    // FIXME: This is needed until the DPoP key is stored safely\n    storage.delete(\"clientKey\", { secure: false }),\n  ]);\n  await clearOidcPersistentStorage();\n}\n\n/**\n * @hidden\n */\nexport class SessionInfoManager implements ISessionInfoManager {\n  constructor(private storageUtility: IStorageUtility) {}\n\n  // eslint-disable-next-line class-methods-use-this\n  update(\n    _sessionId: string,\n    _options: ISessionInfoManagerOptions\n  ): Promise<void> {\n    // const localUserId: string = options.localUserId || this.uuidGenerator.v4();\n    // if (options.loggedIn) {\n    //   return {\n    //     sessionId,\n    //     loggedIn: true,\n    //     webId: options.webId as string,\n    //     neededAction: options.neededAction || { actionType: \"inaction\" },\n    //     state: options.state,\n    //     logout: async (): Promise<void> => {\n    //       // TODO: handle if webid isn't here\n    //       return this.logoutHandler.handle(localUserId);\n    //     },\n    //     fetch: (url: RequestInfo, init?: RequestInit): Promise<Response> => {\n    //       // TODO: handle if webid isn't here\n    //       return this.authenticatedFetcher.handle(\n    //         {\n    //           localUserId,\n    //           type: \"dpop\"\n    //         },\n    //         url,\n    //         init\n    //       );\n    //     }\n    //   };\n    // } else {\n    //   return {\n    //     localUserId,\n    //     loggedIn: false,\n    //     neededAction: options.neededAction || { actionType: \"inaction\" }\n    //   };\n    // }\n    throw new Error(\"Not Implemented\");\n  }\n\n  async get(\n    sessionId: string\n  ): Promise<(ISessionInfo & ISessionInternalInfo) | undefined> {\n    const isLoggedIn = await this.storageUtility.getForUser(\n      sessionId,\n      \"isLoggedIn\",\n      {\n        secure: true,\n      }\n    );\n\n    const webId = await this.storageUtility.getForUser(sessionId, \"webId\", {\n      secure: true,\n    });\n\n    const clientId = await this.storageUtility.getForUser(\n      sessionId,\n      \"clientId\",\n      {\n        secure: false,\n      }\n    );\n\n    const clientSecret = await this.storageUtility.getForUser(\n      sessionId,\n      \"clientSecret\",\n      {\n        secure: false,\n      }\n    );\n\n    const redirectUrl = await this.storageUtility.getForUser(\n      sessionId,\n      \"redirectUrl\",\n      {\n        secure: false,\n      }\n    );\n\n    const refreshToken = await this.storageUtility.getForUser(\n      sessionId,\n      \"refreshToken\",\n      {\n        secure: true,\n      }\n    );\n\n    const issuer = await this.storageUtility.getForUser(sessionId, \"issuer\", {\n      secure: false,\n    });\n\n    const tokenType =\n      (await this.storageUtility.getForUser(sessionId, \"tokenType\", {\n        secure: false,\n      })) ?? \"DPoP\";\n\n    if (!isSupportedTokenType(tokenType)) {\n      throw new Error(`Tokens of type [${tokenType}] are not supported.`);\n    }\n\n    if (\n      clientId === undefined &&\n      isLoggedIn === undefined &&\n      webId === undefined &&\n      refreshToken === undefined\n    ) {\n      return undefined;\n    }\n\n    return {\n      sessionId,\n      webId,\n      isLoggedIn: isLoggedIn === \"true\",\n      redirectUrl,\n      refreshToken,\n      issuer,\n      clientAppId: clientId,\n      clientAppSecret: clientSecret,\n      tokenType,\n    };\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  async getAll(): Promise<(ISessionInfo & ISessionInternalInfo)[]> {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * This function removes all session-related information from storage.\n   * @param sessionId the session identifier\n   * @param storage the storage where session info is stored\n   * @hidden\n   */\n  async clear(sessionId: string): Promise<void> {\n    return clear(sessionId, this.storageUtility);\n  }\n\n  /**\n   * Registers a new session, so that its ID can be retrieved.\n   * @param sessionId\n   */\n  async register(_sessionId: string): Promise<void> {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Returns all the registered session IDs. Differs from getAll, which also\n   * returns additional session information.\n   */\n  async getRegisteredSessionIdAll(): Promise<string[]> {\n    throw new Error(\"Not implemented\");\n  }\n\n  /**\n   * Deletes all information about all sessions, including their registrations.\n   */\n  async clearAll(): Promise<void> {\n    throw new Error(\"Not implemented\");\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}