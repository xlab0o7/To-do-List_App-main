{"ast":null,"code":"var _asyncToGenerator = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _regeneratorRuntime = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _wrapAsyncGenerator = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/wrapAsyncGenerator.js\").default;\nvar _awaitAsyncGenerator = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/awaitAsyncGenerator.js\").default;\nvar _asyncGeneratorDelegate = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/asyncGeneratorDelegate.js\").default;\nvar _asyncIterator = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\n/* replacement start */\n\nvar process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n;\n\n'use strict';\nvar _require = require('../../ours/primordials'),\n  ArrayIsArray = _require.ArrayIsArray,\n  Promise = _require.Promise,\n  SymbolAsyncIterator = _require.SymbolAsyncIterator;\nvar eos = require('./end-of-stream');\nvar _require2 = require('../../ours/util'),\n  once = _require2.once;\nvar destroyImpl = require('./destroy');\nvar Duplex = require('./duplex');\nvar _require3 = require('../../ours/errors'),\n  aggregateTwoErrors = _require3.aggregateTwoErrors,\n  _require3$codes = _require3.codes,\n  ERR_INVALID_ARG_TYPE = _require3$codes.ERR_INVALID_ARG_TYPE,\n  ERR_INVALID_RETURN_VALUE = _require3$codes.ERR_INVALID_RETURN_VALUE,\n  ERR_MISSING_ARGS = _require3$codes.ERR_MISSING_ARGS,\n  ERR_STREAM_DESTROYED = _require3$codes.ERR_STREAM_DESTROYED,\n  ERR_STREAM_PREMATURE_CLOSE = _require3$codes.ERR_STREAM_PREMATURE_CLOSE,\n  AbortError = _require3.AbortError;\nvar _require4 = require('../validators'),\n  validateFunction = _require4.validateFunction,\n  validateAbortSignal = _require4.validateAbortSignal;\nvar _require5 = require('./utils'),\n  isIterable = _require5.isIterable,\n  isReadable = _require5.isReadable,\n  isReadableNodeStream = _require5.isReadableNodeStream,\n  isNodeStream = _require5.isNodeStream;\nvar AbortController = globalThis.AbortController || require('abort-controller').AbortController;\nvar PassThrough;\nvar Readable;\nfunction destroyer(stream, reading, writing) {\n  var finished = false;\n  stream.on('close', function () {\n    finished = true;\n  });\n  var cleanup = eos(stream, {\n    readable: reading,\n    writable: writing\n  }, function (err) {\n    finished = !err;\n  });\n  return {\n    destroy: function destroy(err) {\n      if (finished) return;\n      finished = true;\n      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'));\n    },\n    cleanup: cleanup\n  };\n}\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]');\n  return streams.pop();\n}\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val;\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val);\n  }\n  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val);\n}\nfunction fromReadable(_x) {\n  return _fromReadable.apply(this, arguments);\n}\nfunction _fromReadable() {\n  _fromReadable = _wrapAsyncGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(val) {\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (!Readable) {\n            Readable = require('./readable');\n          }\n          return _context.delegateYield(_asyncGeneratorDelegate(_asyncIterator(Readable.prototype[SymbolAsyncIterator].call(val)), _awaitAsyncGenerator), \"t0\", 2);\n        case 2:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _fromReadable.apply(this, arguments);\n}\nfunction pump(_x2, _x3, _x4, _x5) {\n  return _pump.apply(this, arguments);\n}\nfunction _pump() {\n  _pump = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(iterable, writable, finish, _ref) {\n    var end, error, onresolve, resume, wait, cleanup, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, chunk;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          end = _ref.end;\n          onresolve = null;\n          resume = function resume(err) {\n            if (err) {\n              error = err;\n            }\n            if (onresolve) {\n              var callback = onresolve;\n              onresolve = null;\n              callback();\n            }\n          };\n          wait = function wait() {\n            return new Promise(function (resolve, reject) {\n              if (error) {\n                reject(error);\n              } else {\n                onresolve = function onresolve() {\n                  if (error) {\n                    reject(error);\n                  } else {\n                    resolve();\n                  }\n                };\n              }\n            });\n          };\n          writable.on('drain', resume);\n          cleanup = eos(writable, {\n            readable: false\n          }, resume);\n          _context2.prev = 6;\n          if (!writable.writableNeedDrain) {\n            _context2.next = 10;\n            break;\n          }\n          _context2.next = 10;\n          return wait();\n        case 10:\n          _iteratorAbruptCompletion = false;\n          _didIteratorError = false;\n          _context2.prev = 12;\n          _iterator = _asyncIterator(iterable);\n        case 14:\n          _context2.next = 16;\n          return _iterator.next();\n        case 16:\n          if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n            _context2.next = 24;\n            break;\n          }\n          chunk = _step.value;\n          if (writable.write(chunk)) {\n            _context2.next = 21;\n            break;\n          }\n          _context2.next = 21;\n          return wait();\n        case 21:\n          _iteratorAbruptCompletion = false;\n          _context2.next = 14;\n          break;\n        case 24:\n          _context2.next = 30;\n          break;\n        case 26:\n          _context2.prev = 26;\n          _context2.t0 = _context2[\"catch\"](12);\n          _didIteratorError = true;\n          _iteratorError = _context2.t0;\n        case 30:\n          _context2.prev = 30;\n          _context2.prev = 31;\n          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n            _context2.next = 35;\n            break;\n          }\n          _context2.next = 35;\n          return _iterator.return();\n        case 35:\n          _context2.prev = 35;\n          if (!_didIteratorError) {\n            _context2.next = 38;\n            break;\n          }\n          throw _iteratorError;\n        case 38:\n          return _context2.finish(35);\n        case 39:\n          return _context2.finish(30);\n        case 40:\n          if (end) {\n            writable.end();\n          }\n          _context2.next = 43;\n          return wait();\n        case 43:\n          finish();\n          _context2.next = 49;\n          break;\n        case 46:\n          _context2.prev = 46;\n          _context2.t1 = _context2[\"catch\"](6);\n          finish(error !== _context2.t1 ? aggregateTwoErrors(error, _context2.t1) : _context2.t1);\n        case 49:\n          _context2.prev = 49;\n          cleanup();\n          writable.off('drain', resume);\n          return _context2.finish(49);\n        case 53:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[6, 46, 49, 53], [12, 26, 30, 40], [31,, 35, 39]]);\n  }));\n  return _pump.apply(this, arguments);\n}\nfunction pipeline() {\n  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {\n    streams[_key] = arguments[_key];\n  }\n  return pipelineImpl(streams, once(popCallback(streams)));\n}\nfunction pipelineImpl(streams, callback, opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0];\n  }\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams');\n  }\n  var ac = new AbortController();\n  var signal = ac.signal;\n  var outerSignal = opts === null || opts === undefined ? undefined : opts.signal;\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  var lastStreamCleanup = [];\n  validateAbortSignal(outerSignal, 'options.signal');\n  function abort() {\n    finishImpl(new AbortError());\n  }\n  outerSignal === null || outerSignal === undefined ? undefined : outerSignal.addEventListener('abort', abort);\n  var error;\n  var value;\n  var destroys = [];\n  var finishCount = 0;\n  function finish(err) {\n    finishImpl(err, --finishCount === 0);\n  }\n  function finishImpl(err, final) {\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err;\n    }\n    if (!error && !final) {\n      return;\n    }\n    while (destroys.length) {\n      destroys.shift()(error);\n    }\n    outerSignal === null || outerSignal === undefined ? undefined : outerSignal.removeEventListener('abort', abort);\n    ac.abort();\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach(function (fn) {\n          return fn();\n        });\n      }\n      process.nextTick(callback, error, value);\n    }\n  }\n  var ret;\n  var _loop = function _loop() {\n    var stream = streams[i];\n    var reading = i < streams.length - 1;\n    var writing = i > 0;\n    var end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false;\n    var isLastStream = i === streams.length - 1;\n    if (isNodeStream(stream)) {\n      // Catch stream errors that occur after pipe/pump has completed.\n      var onError = function onError(err) {\n        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n          finish(err);\n        }\n      };\n      if (end) {\n        var _destroyer = destroyer(stream, reading, writing),\n          destroy = _destroyer.destroy,\n          cleanup = _destroyer.cleanup;\n        destroys.push(destroy);\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup);\n        }\n      }\n      stream.on('error', onError);\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(function () {\n          stream.removeListener('error', onError);\n        });\n      }\n    }\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({\n          signal: signal\n        });\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret);\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream)) {\n        ret = stream;\n      } else {\n        ret = Duplex.from(stream);\n      }\n    } else if (typeof stream === 'function') {\n      ret = makeAsyncIterable(ret);\n      ret = stream(ret, {\n        signal: signal\n      });\n      if (reading) {\n        if (!isIterable(ret, true)) {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', \"transform[\".concat(i - 1, \"]\"), ret);\n        }\n      } else {\n        if (!PassThrough) {\n          PassThrough = require('./passthrough');\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        var pt = new PassThrough({\n          objectMode: true\n        });\n\n        // Handle Promises/A+ spec, `then` could be a getter that throws on\n        // second use.\n        var then = (_ret = ret) === null || _ret === undefined ? undefined : _ret.then;\n        if (typeof then === 'function') {\n          finishCount++;\n          then.call(ret, function (val) {\n            value = val;\n            if (val != null) {\n              pt.write(val);\n            }\n            if (end) {\n              pt.end();\n            }\n            process.nextTick(finish);\n          }, function (err) {\n            pt.destroy(err);\n            process.nextTick(finish, err);\n          });\n        } else if (isIterable(ret, true)) {\n          finishCount++;\n          pump(ret, pt, finish, {\n            end: end\n          });\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret);\n        }\n        ret = pt;\n        var _destroyer2 = destroyer(ret, false, true),\n          _destroy = _destroyer2.destroy,\n          _cleanup = _destroyer2.cleanup;\n        destroys.push(_destroy);\n        if (isLastStream) {\n          lastStreamCleanup.push(_cleanup);\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2;\n        var _cleanup2 = pipe(ret, stream, finish, {\n          end: end\n        });\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(_cleanup2);\n        }\n      } else if (isIterable(ret)) {\n        finishCount++;\n        pump(ret, stream, finish, {\n          end: end\n        });\n      } else {\n        throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], ret);\n      }\n      ret = stream;\n    } else {\n      ret = Duplex.from(stream);\n    }\n  };\n  for (var i = 0; i < streams.length; i++) {\n    var _ret;\n    _loop();\n  }\n  if (signal !== null && signal !== undefined && signal.aborted || outerSignal !== null && outerSignal !== undefined && outerSignal.aborted) {\n    process.nextTick(abort);\n  }\n  return ret;\n}\nfunction pipe(src, dst, finish, _ref2) {\n  var end = _ref2.end;\n  var ended = false;\n  dst.on('close', function () {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE());\n    }\n  });\n  src.pipe(dst, {\n    end: end\n  });\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but \"secretly\" don't close the underlying fd.\n    src.once('end', function () {\n      ended = true;\n      dst.end();\n    });\n  } else {\n    finish();\n  }\n  eos(src, {\n    readable: true,\n    writable: false\n  }, function (err) {\n    var rState = src._readableState;\n    if (err && err.code === 'ERR_STREAM_PREMATURE_CLOSE' && rState && rState.ended && !rState.errored && !rState.errorEmitted) {\n      // Some readable streams will emit 'close' before 'end'. However, since\n      // this is on the readable side 'end' should still be emitted if the\n      // stream has been ended and no error emitted. This should be allowed in\n      // favor of backwards compatibility. Since the stream is piped to a\n      // destination this should not result in any observable difference.\n      // We don't need to check if this is a writable premature close since\n      // eos will only fail with premature close on the reading side for\n      // duplex streams.\n      src.once('end', finish).once('error', finish);\n    } else {\n      finish(err);\n    }\n  });\n  return eos(dst, {\n    readable: false,\n    writable: true\n  }, finish);\n}\nmodule.exports = {\n  pipelineImpl: pipelineImpl,\n  pipeline: pipeline\n};","map":{"version":3,"names":["process","require","ArrayIsArray","Promise","SymbolAsyncIterator","eos","once","destroyImpl","Duplex","aggregateTwoErrors","codes","ERR_INVALID_ARG_TYPE","ERR_INVALID_RETURN_VALUE","ERR_MISSING_ARGS","ERR_STREAM_DESTROYED","ERR_STREAM_PREMATURE_CLOSE","AbortError","validateFunction","validateAbortSignal","isIterable","isReadable","isReadableNodeStream","isNodeStream","AbortController","globalThis","PassThrough","Readable","destroyer","stream","reading","writing","finished","on","cleanup","readable","writable","err","destroy","popCallback","streams","length","pop","makeAsyncIterable","val","fromReadable","prototype","call","pump","iterable","finish","end","onresolve","resume","error","callback","wait","resolve","reject","writableNeedDrain","chunk","write","off","pipeline","pipelineImpl","opts","ac","signal","outerSignal","undefined","lastStreamCleanup","abort","finishImpl","addEventListener","value","destroys","finishCount","final","code","shift","removeEventListener","forEach","fn","nextTick","ret","i","isLastStream","onError","name","push","removeListener","from","pt","objectMode","then","_ret","pipe","aborted","src","dst","ended","rState","_readableState","errored","errorEmitted","module","exports"],"sources":["E:/react-todo-app/node_modules/n3/node_modules/readable-stream/lib/internal/streams/pipeline.js"],"sourcesContent":["/* replacement start */\n\nconst process = require('process/')\n\n/* replacement end */\n// Ported from https://github.com/mafintosh/pump with\n// permission from the author, Mathias Buus (@mafintosh).\n\n;('use strict')\nconst { ArrayIsArray, Promise, SymbolAsyncIterator } = require('../../ours/primordials')\nconst eos = require('./end-of-stream')\nconst { once } = require('../../ours/util')\nconst destroyImpl = require('./destroy')\nconst Duplex = require('./duplex')\nconst {\n  aggregateTwoErrors,\n  codes: {\n    ERR_INVALID_ARG_TYPE,\n    ERR_INVALID_RETURN_VALUE,\n    ERR_MISSING_ARGS,\n    ERR_STREAM_DESTROYED,\n    ERR_STREAM_PREMATURE_CLOSE\n  },\n  AbortError\n} = require('../../ours/errors')\nconst { validateFunction, validateAbortSignal } = require('../validators')\nconst { isIterable, isReadable, isReadableNodeStream, isNodeStream } = require('./utils')\nconst AbortController = globalThis.AbortController || require('abort-controller').AbortController\nlet PassThrough\nlet Readable\nfunction destroyer(stream, reading, writing) {\n  let finished = false\n  stream.on('close', () => {\n    finished = true\n  })\n  const cleanup = eos(\n    stream,\n    {\n      readable: reading,\n      writable: writing\n    },\n    (err) => {\n      finished = !err\n    }\n  )\n  return {\n    destroy: (err) => {\n      if (finished) return\n      finished = true\n      destroyImpl.destroyer(stream, err || new ERR_STREAM_DESTROYED('pipe'))\n    },\n    cleanup\n  }\n}\nfunction popCallback(streams) {\n  // Streams should never be an empty array. It should always contain at least\n  // a single stream. Therefore optimize for the average case instead of\n  // checking for length === 0 as well.\n  validateFunction(streams[streams.length - 1], 'streams[stream.length - 1]')\n  return streams.pop()\n}\nfunction makeAsyncIterable(val) {\n  if (isIterable(val)) {\n    return val\n  } else if (isReadableNodeStream(val)) {\n    // Legacy streams are not Iterable.\n    return fromReadable(val)\n  }\n  throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], val)\n}\nasync function* fromReadable(val) {\n  if (!Readable) {\n    Readable = require('./readable')\n  }\n  yield* Readable.prototype[SymbolAsyncIterator].call(val)\n}\nasync function pump(iterable, writable, finish, { end }) {\n  let error\n  let onresolve = null\n  const resume = (err) => {\n    if (err) {\n      error = err\n    }\n    if (onresolve) {\n      const callback = onresolve\n      onresolve = null\n      callback()\n    }\n  }\n  const wait = () =>\n    new Promise((resolve, reject) => {\n      if (error) {\n        reject(error)\n      } else {\n        onresolve = () => {\n          if (error) {\n            reject(error)\n          } else {\n            resolve()\n          }\n        }\n      }\n    })\n  writable.on('drain', resume)\n  const cleanup = eos(\n    writable,\n    {\n      readable: false\n    },\n    resume\n  )\n  try {\n    if (writable.writableNeedDrain) {\n      await wait()\n    }\n    for await (const chunk of iterable) {\n      if (!writable.write(chunk)) {\n        await wait()\n      }\n    }\n    if (end) {\n      writable.end()\n    }\n    await wait()\n    finish()\n  } catch (err) {\n    finish(error !== err ? aggregateTwoErrors(error, err) : err)\n  } finally {\n    cleanup()\n    writable.off('drain', resume)\n  }\n}\nfunction pipeline(...streams) {\n  return pipelineImpl(streams, once(popCallback(streams)))\n}\nfunction pipelineImpl(streams, callback, opts) {\n  if (streams.length === 1 && ArrayIsArray(streams[0])) {\n    streams = streams[0]\n  }\n  if (streams.length < 2) {\n    throw new ERR_MISSING_ARGS('streams')\n  }\n  const ac = new AbortController()\n  const signal = ac.signal\n  const outerSignal = opts === null || opts === undefined ? undefined : opts.signal\n\n  // Need to cleanup event listeners if last stream is readable\n  // https://github.com/nodejs/node/issues/35452\n  const lastStreamCleanup = []\n  validateAbortSignal(outerSignal, 'options.signal')\n  function abort() {\n    finishImpl(new AbortError())\n  }\n  outerSignal === null || outerSignal === undefined ? undefined : outerSignal.addEventListener('abort', abort)\n  let error\n  let value\n  const destroys = []\n  let finishCount = 0\n  function finish(err) {\n    finishImpl(err, --finishCount === 0)\n  }\n  function finishImpl(err, final) {\n    if (err && (!error || error.code === 'ERR_STREAM_PREMATURE_CLOSE')) {\n      error = err\n    }\n    if (!error && !final) {\n      return\n    }\n    while (destroys.length) {\n      destroys.shift()(error)\n    }\n    outerSignal === null || outerSignal === undefined ? undefined : outerSignal.removeEventListener('abort', abort)\n    ac.abort()\n    if (final) {\n      if (!error) {\n        lastStreamCleanup.forEach((fn) => fn())\n      }\n      process.nextTick(callback, error, value)\n    }\n  }\n  let ret\n  for (let i = 0; i < streams.length; i++) {\n    const stream = streams[i]\n    const reading = i < streams.length - 1\n    const writing = i > 0\n    const end = reading || (opts === null || opts === undefined ? undefined : opts.end) !== false\n    const isLastStream = i === streams.length - 1\n    if (isNodeStream(stream)) {\n      if (end) {\n        const { destroy, cleanup } = destroyer(stream, reading, writing)\n        destroys.push(destroy)\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n\n      // Catch stream errors that occur after pipe/pump has completed.\n      function onError(err) {\n        if (err && err.name !== 'AbortError' && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {\n          finish(err)\n        }\n      }\n      stream.on('error', onError)\n      if (isReadable(stream) && isLastStream) {\n        lastStreamCleanup.push(() => {\n          stream.removeListener('error', onError)\n        })\n      }\n    }\n    if (i === 0) {\n      if (typeof stream === 'function') {\n        ret = stream({\n          signal\n        })\n        if (!isIterable(ret)) {\n          throw new ERR_INVALID_RETURN_VALUE('Iterable, AsyncIterable or Stream', 'source', ret)\n        }\n      } else if (isIterable(stream) || isReadableNodeStream(stream)) {\n        ret = stream\n      } else {\n        ret = Duplex.from(stream)\n      }\n    } else if (typeof stream === 'function') {\n      ret = makeAsyncIterable(ret)\n      ret = stream(ret, {\n        signal\n      })\n      if (reading) {\n        if (!isIterable(ret, true)) {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable', `transform[${i - 1}]`, ret)\n        }\n      } else {\n        var _ret\n        if (!PassThrough) {\n          PassThrough = require('./passthrough')\n        }\n\n        // If the last argument to pipeline is not a stream\n        // we must create a proxy stream so that pipeline(...)\n        // always returns a stream which can be further\n        // composed through `.pipe(stream)`.\n\n        const pt = new PassThrough({\n          objectMode: true\n        })\n\n        // Handle Promises/A+ spec, `then` could be a getter that throws on\n        // second use.\n        const then = (_ret = ret) === null || _ret === undefined ? undefined : _ret.then\n        if (typeof then === 'function') {\n          finishCount++\n          then.call(\n            ret,\n            (val) => {\n              value = val\n              if (val != null) {\n                pt.write(val)\n              }\n              if (end) {\n                pt.end()\n              }\n              process.nextTick(finish)\n            },\n            (err) => {\n              pt.destroy(err)\n              process.nextTick(finish, err)\n            }\n          )\n        } else if (isIterable(ret, true)) {\n          finishCount++\n          pump(ret, pt, finish, {\n            end\n          })\n        } else {\n          throw new ERR_INVALID_RETURN_VALUE('AsyncIterable or Promise', 'destination', ret)\n        }\n        ret = pt\n        const { destroy, cleanup } = destroyer(ret, false, true)\n        destroys.push(destroy)\n        if (isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      }\n    } else if (isNodeStream(stream)) {\n      if (isReadableNodeStream(ret)) {\n        finishCount += 2\n        const cleanup = pipe(ret, stream, finish, {\n          end\n        })\n        if (isReadable(stream) && isLastStream) {\n          lastStreamCleanup.push(cleanup)\n        }\n      } else if (isIterable(ret)) {\n        finishCount++\n        pump(ret, stream, finish, {\n          end\n        })\n      } else {\n        throw new ERR_INVALID_ARG_TYPE('val', ['Readable', 'Iterable', 'AsyncIterable'], ret)\n      }\n      ret = stream\n    } else {\n      ret = Duplex.from(stream)\n    }\n  }\n  if (\n    (signal !== null && signal !== undefined && signal.aborted) ||\n    (outerSignal !== null && outerSignal !== undefined && outerSignal.aborted)\n  ) {\n    process.nextTick(abort)\n  }\n  return ret\n}\nfunction pipe(src, dst, finish, { end }) {\n  let ended = false\n  dst.on('close', () => {\n    if (!ended) {\n      // Finish if the destination closes before the source has completed.\n      finish(new ERR_STREAM_PREMATURE_CLOSE())\n    }\n  })\n  src.pipe(dst, {\n    end\n  })\n  if (end) {\n    // Compat. Before node v10.12.0 stdio used to throw an error so\n    // pipe() did/does not end() stdio destinations.\n    // Now they allow it but \"secretly\" don't close the underlying fd.\n    src.once('end', () => {\n      ended = true\n      dst.end()\n    })\n  } else {\n    finish()\n  }\n  eos(\n    src,\n    {\n      readable: true,\n      writable: false\n    },\n    (err) => {\n      const rState = src._readableState\n      if (\n        err &&\n        err.code === 'ERR_STREAM_PREMATURE_CLOSE' &&\n        rState &&\n        rState.ended &&\n        !rState.errored &&\n        !rState.errorEmitted\n      ) {\n        // Some readable streams will emit 'close' before 'end'. However, since\n        // this is on the readable side 'end' should still be emitted if the\n        // stream has been ended and no error emitted. This should be allowed in\n        // favor of backwards compatibility. Since the stream is piped to a\n        // destination this should not result in any observable difference.\n        // We don't need to check if this is a writable premature close since\n        // eos will only fail with premature close on the reading side for\n        // duplex streams.\n        src.once('end', finish).once('error', finish)\n      } else {\n        finish(err)\n      }\n    }\n  )\n  return eos(\n    dst,\n    {\n      readable: false,\n      writable: true\n    },\n    finish\n  )\n}\nmodule.exports = {\n  pipelineImpl,\n  pipeline\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}