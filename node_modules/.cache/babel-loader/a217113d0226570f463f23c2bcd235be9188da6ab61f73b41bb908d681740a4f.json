{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _classCallCheck = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"E:/react-todo-app/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AuthCodeRedirectHandler = void 0;\nvar solid_client_authn_core_1 = require(\"@inrupt/solid-client-authn-core\");\nvar oidc_client_ext_1 = require(\"@inrupt/oidc-client-ext\");\nvar AuthCodeRedirectHandler = /*#__PURE__*/function () {\n  function AuthCodeRedirectHandler(storageUtility, sessionInfoManager, issuerConfigFetcher, clientRegistrar, tokerRefresher) {\n    _classCallCheck(this, AuthCodeRedirectHandler);\n    this.storageUtility = storageUtility;\n    this.sessionInfoManager = sessionInfoManager;\n    this.issuerConfigFetcher = issuerConfigFetcher;\n    this.clientRegistrar = clientRegistrar;\n    this.tokerRefresher = tokerRefresher;\n  }\n  _createClass(AuthCodeRedirectHandler, [{\n    key: \"canHandle\",\n    value: function () {\n      var _canHandle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(redirectUrl) {\n        var myUrl;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              myUrl = new URL(redirectUrl);\n              return _context.abrupt(\"return\", myUrl.searchParams.get(\"code\") !== null && myUrl.searchParams.get(\"state\") !== null);\n            case 5:\n              _context.prev = 5;\n              _context.t0 = _context[\"catch\"](0);\n              throw new Error(\"[\".concat(redirectUrl, \"] is not a valid URL, and cannot be used as a redirect URL: \").concat(_context.t0));\n            case 8:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[0, 5]]);\n      }));\n      function canHandle(_x) {\n        return _canHandle.apply(this, arguments);\n      }\n      return canHandle;\n    }()\n  }, {\n    key: \"handle\",\n    value: function () {\n      var _handle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(redirectUrl, eventEmitter) {\n        var url, oauthState, storedSessionId, _yield, issuerConfig, codeVerifier, storedRedirectIri, isDpop, iss, client, tokens, tokenCreatedAt, refreshOptions, authFetch, sessionInfo;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.canHandle(redirectUrl);\n            case 2:\n              if (_context2.sent) {\n                _context2.next = 4;\n                break;\n              }\n              throw new Error(\"AuthCodeRedirectHandler cannot handle [\".concat(redirectUrl, \"]: it is missing one of [code, state].\"));\n            case 4:\n              url = new URL(redirectUrl);\n              oauthState = url.searchParams.get(\"state\");\n              _context2.next = 8;\n              return this.storageUtility.getForUser(oauthState, \"sessionId\", {\n                errorIfNull: true\n              });\n            case 8:\n              storedSessionId = _context2.sent;\n              _context2.next = 11;\n              return (0, solid_client_authn_core_1.loadOidcContextFromStorage)(storedSessionId, this.storageUtility, this.issuerConfigFetcher);\n            case 11:\n              _yield = _context2.sent;\n              issuerConfig = _yield.issuerConfig;\n              codeVerifier = _yield.codeVerifier;\n              storedRedirectIri = _yield.redirectUrl;\n              isDpop = _yield.dpop;\n              iss = url.searchParams.get(\"iss\");\n              if (!(typeof iss === \"string\" && iss !== issuerConfig.issuer)) {\n                _context2.next = 19;\n                break;\n              }\n              throw new Error(\"The value of the iss parameter (\".concat(iss, \") does not match the issuer identifier of the authorization server (\").concat(issuerConfig.issuer, \"). See [rfc9207](https://www.rfc-editor.org/rfc/rfc9207.html#section-2.3-3.1.1)\"));\n            case 19:\n              if (!(codeVerifier === undefined)) {\n                _context2.next = 21;\n                break;\n              }\n              throw new Error(\"The code verifier for session \".concat(storedSessionId, \" is missing from storage.\"));\n            case 21:\n              if (!(storedRedirectIri === undefined)) {\n                _context2.next = 23;\n                break;\n              }\n              throw new Error(\"The redirect URL for session \".concat(storedSessionId, \" is missing from storage.\"));\n            case 23:\n              _context2.next = 25;\n              return this.clientRegistrar.getClient({\n                sessionId: storedSessionId\n              }, issuerConfig);\n            case 25:\n              client = _context2.sent;\n              tokenCreatedAt = Date.now();\n              if (!isDpop) {\n                _context2.next = 34;\n                break;\n              }\n              _context2.next = 30;\n              return (0, oidc_client_ext_1.getDpopToken)(issuerConfig, client, {\n                grantType: \"authorization_code\",\n                code: url.searchParams.get(\"code\"),\n                codeVerifier: codeVerifier,\n                redirectUrl: storedRedirectIri\n              });\n            case 30:\n              tokens = _context2.sent;\n              window.localStorage.removeItem(\"oidc.\".concat(oauthState));\n              _context2.next = 37;\n              break;\n            case 34:\n              _context2.next = 36;\n              return (0, oidc_client_ext_1.getBearerToken)(url.toString());\n            case 36:\n              tokens = _context2.sent;\n            case 37:\n              if (tokens.refreshToken !== undefined) {\n                refreshOptions = {\n                  sessionId: storedSessionId,\n                  refreshToken: tokens.refreshToken,\n                  tokenRefresher: this.tokerRefresher\n                };\n              }\n              _context2.next = 40;\n              return (0, solid_client_authn_core_1.buildAuthenticatedFetch)(fetch, tokens.accessToken, {\n                dpopKey: tokens.dpopKey,\n                refreshOptions: refreshOptions,\n                eventEmitter: eventEmitter,\n                expiresIn: tokens.expiresIn\n              });\n            case 40:\n              authFetch = _context2.sent;\n              _context2.next = 43;\n              return this.storageUtility.setForUser(storedSessionId, {\n                webId: tokens.webId,\n                isLoggedIn: \"true\"\n              }, {\n                secure: true\n              });\n            case 43:\n              url.searchParams.delete(\"code\");\n              _context2.next = 46;\n              return this.storageUtility.setForUser(storedSessionId, {\n                redirectUrl: url.toString()\n              }, {\n                secure: false\n              });\n            case 46:\n              _context2.next = 48;\n              return this.sessionInfoManager.get(storedSessionId);\n            case 48:\n              sessionInfo = _context2.sent;\n              if (sessionInfo) {\n                _context2.next = 51;\n                break;\n              }\n              throw new Error(\"Could not retrieve session: [\".concat(storedSessionId, \"].\"));\n            case 51:\n              return _context2.abrupt(\"return\", Object.assign(sessionInfo, {\n                fetch: authFetch,\n                expirationDate: typeof tokens.expiresIn === \"number\" ? tokenCreatedAt + tokens.expiresIn * 1000 : null\n              }));\n            case 52:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function handle(_x2, _x3) {\n        return _handle.apply(this, arguments);\n      }\n      return handle;\n    }()\n  }]);\n  return AuthCodeRedirectHandler;\n}();\nexports.AuthCodeRedirectHandler = AuthCodeRedirectHandler;","map":{"version":3,"mappings":"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","names":["AuthCodeRedirectHandler","storageUtility","sessionInfoManager","issuerConfigFetcher","clientRegistrar","tokerRefresher","redirectUrl","myUrl","URL","searchParams","get","Error","eventEmitter","canHandle","url","oauthState","getForUser","errorIfNull","storedSessionId","issuerConfig","codeVerifier","storedRedirectIri","isDpop","dpop","iss","issuer","undefined","getClient","sessionId","client","tokenCreatedAt","Date","now","grantType","code","tokens","window","localStorage","removeItem","toString","refreshToken","refreshOptions","tokenRefresher","fetch","accessToken","dpopKey","expiresIn","authFetch","setForUser","webId","isLoggedIn","secure","delete","sessionInfo","Object","assign","expirationDate","exports"],"sources":["E:\\react-todo-app\\node_modules\\@inrupt\\solid-client-authn-browser\\src\\login\\oidc\\incomingRedirectHandler\\AuthCodeRedirectHandler.ts"],"sourcesContent":["//\n// Copyright 2022 Inrupt Inc.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal in\n// the Software without restriction, including without limitation the rights to use,\n// copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the\n// Software, and to permit persons to whom the Software is furnished to do so,\n// subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n// INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n// PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n// SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//\n\n/**\n * @hidden\n * @packageDocumentation\n */\n// FIXME: The following doesn't work in the browser, it results in all the fetches\n// being unauthenticated. This should be looked into when migrating to universal-fetch.\n// import { fetch } from \"cross-fetch\";\n\nimport {\n  buildAuthenticatedFetch,\n  IClient,\n  IClientRegistrar,\n  IIssuerConfigFetcher,\n  IIncomingRedirectHandler,\n  ISessionInfo,\n  ISessionInfoManager,\n  IStorageUtility,\n  ITokenRefresher,\n  loadOidcContextFromStorage,\n  RefreshOptions,\n} from \"@inrupt/solid-client-authn-core\";\nimport {\n  getDpopToken,\n  getBearerToken,\n  CodeExchangeResult,\n} from \"@inrupt/oidc-client-ext\";\nimport { EventEmitter } from \"events\";\n\n/**\n * @hidden\n */\nexport class AuthCodeRedirectHandler implements IIncomingRedirectHandler {\n  constructor(\n    private storageUtility: IStorageUtility,\n    private sessionInfoManager: ISessionInfoManager,\n    private issuerConfigFetcher: IIssuerConfigFetcher,\n    private clientRegistrar: IClientRegistrar,\n    private tokerRefresher: ITokenRefresher\n  ) {}\n\n  async canHandle(redirectUrl: string): Promise<boolean> {\n    try {\n      const myUrl = new URL(redirectUrl);\n      return (\n        myUrl.searchParams.get(\"code\") !== null &&\n        myUrl.searchParams.get(\"state\") !== null\n      );\n    } catch (e) {\n      throw new Error(\n        `[${redirectUrl}] is not a valid URL, and cannot be used as a redirect URL: ${e}`\n      );\n    }\n  }\n\n  async handle(\n    redirectUrl: string,\n    eventEmitter?: EventEmitter\n  ): Promise<ISessionInfo & { fetch: typeof fetch }> {\n    if (!(await this.canHandle(redirectUrl))) {\n      throw new Error(\n        `AuthCodeRedirectHandler cannot handle [${redirectUrl}]: it is missing one of [code, state].`\n      );\n    }\n\n    const url = new URL(redirectUrl);\n    const oauthState = url.searchParams.get(\"state\") as string;\n\n    const storedSessionId = (await this.storageUtility.getForUser(\n      oauthState,\n      \"sessionId\",\n      {\n        errorIfNull: true,\n      }\n    )) as string;\n\n    const {\n      issuerConfig,\n      codeVerifier,\n      redirectUrl: storedRedirectIri,\n      dpop: isDpop,\n    } = await loadOidcContextFromStorage(\n      storedSessionId,\n      this.storageUtility,\n      this.issuerConfigFetcher\n    );\n\n    const iss = url.searchParams.get(\"iss\");\n\n    if (typeof iss === \"string\" && iss !== issuerConfig.issuer) {\n      throw new Error(\n        `The value of the iss parameter (${iss}) does not match the issuer identifier of the authorization server (${issuerConfig.issuer}). See [rfc9207](https://www.rfc-editor.org/rfc/rfc9207.html#section-2.3-3.1.1)`\n      );\n    }\n\n    if (codeVerifier === undefined) {\n      throw new Error(\n        `The code verifier for session ${storedSessionId} is missing from storage.`\n      );\n    }\n\n    if (storedRedirectIri === undefined) {\n      throw new Error(\n        `The redirect URL for session ${storedSessionId} is missing from storage.`\n      );\n    }\n\n    const client: IClient = await this.clientRegistrar.getClient(\n      { sessionId: storedSessionId },\n      issuerConfig\n    );\n\n    let tokens: CodeExchangeResult;\n    const tokenCreatedAt = Date.now();\n\n    if (isDpop) {\n      tokens = await getDpopToken(issuerConfig, client, {\n        grantType: \"authorization_code\",\n        // We rely on our 'canHandle' function checking that the OAuth 'code'\n        // parameter is present in our query string.\n        code: url.searchParams.get(\"code\") as string,\n        codeVerifier,\n        redirectUrl: storedRedirectIri,\n      });\n\n      // Delete oidc-client-specific session information from storage. This is\n      // done automatically when retrieving a bearer token, but since the DPoP\n      // binding uses our custom code, this needs to be done manually.\n      window.localStorage.removeItem(`oidc.${oauthState}`);\n    } else {\n      tokens = await getBearerToken(url.toString());\n    }\n\n    let refreshOptions: RefreshOptions | undefined;\n    if (tokens.refreshToken !== undefined) {\n      refreshOptions = {\n        sessionId: storedSessionId,\n        refreshToken: tokens.refreshToken,\n        tokenRefresher: this.tokerRefresher,\n      };\n    }\n\n    const authFetch = await buildAuthenticatedFetch(fetch, tokens.accessToken, {\n      dpopKey: tokens.dpopKey,\n      refreshOptions,\n      eventEmitter,\n      expiresIn: tokens.expiresIn,\n    });\n\n    await this.storageUtility.setForUser(\n      storedSessionId,\n      {\n        webId: tokens.webId,\n        isLoggedIn: \"true\",\n      },\n      { secure: true }\n    );\n    // Clear the code query param from the redirect URL before storing it, but\n    // preserve any state that my have been provided by the client and returned\n    // by the IdP.\n    url.searchParams.delete(\"code\");\n    await this.storageUtility.setForUser(\n      storedSessionId,\n      {\n        redirectUrl: url.toString(),\n      },\n      {\n        secure: false,\n      }\n    );\n\n    const sessionInfo = await this.sessionInfoManager.get(storedSessionId);\n    if (!sessionInfo) {\n      throw new Error(`Could not retrieve session: [${storedSessionId}].`);\n    }\n\n    return Object.assign(sessionInfo, {\n      fetch: authFetch,\n      expirationDate:\n        typeof tokens.expiresIn === \"number\"\n          ? tokenCreatedAt + tokens.expiresIn * 1000\n          : null,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}