{"ast":null,"code":"import _classCallCheck from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"E:/react-todo-app/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n// **N3Writer** writes N3 documents.\nimport namespaces from './IRIs';\nimport { default as N3DataFactory, Term } from './N3DataFactory';\nimport { isDefaultGraph } from './N3Util';\nvar DEFAULTGRAPH = N3DataFactory.defaultGraph();\nvar rdf = namespaces.rdf,\n  xsd = namespaces.xsd;\n\n// Characters in literals that require escaping\nvar escape = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n  escapeAll = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n  escapedCharacters = {\n    '\\\\': '\\\\\\\\',\n    '\"': '\\\\\"',\n    '\\t': '\\\\t',\n    '\\n': '\\\\n',\n    '\\r': '\\\\r',\n    '\\b': '\\\\b',\n    '\\f': '\\\\f'\n  };\n\n// ## Placeholder class to represent already pretty-printed terms\nvar SerializedTerm = /*#__PURE__*/function (_Term) {\n  _inherits(SerializedTerm, _Term);\n  var _super = _createSuper(SerializedTerm);\n  function SerializedTerm() {\n    _classCallCheck(this, SerializedTerm);\n    return _super.apply(this, arguments);\n  }\n  _createClass(SerializedTerm, [{\n    key: \"equals\",\n    value:\n    // Pretty-printed nodes are not equal to any other node\n    // (e.g., [] does not equal [])\n    function equals() {\n      return false;\n    }\n  }]);\n  return SerializedTerm;\n}(Term); // ## Constructor\nvar N3Writer = /*#__PURE__*/function () {\n  function N3Writer(outputStream, options) {\n    _classCallCheck(this, N3Writer);\n    // ### `_prefixRegex` matches a prefixed name or IRI that begins with one of the added prefixes\n    this._prefixRegex = /$0^/;\n\n    // Shift arguments if the first argument is not a stream\n    if (outputStream && typeof outputStream.write !== 'function') options = outputStream, outputStream = null;\n    options = options || {};\n    this._lists = options.lists;\n\n    // If no output stream given, send the output as string through the end callback\n    if (!outputStream) {\n      var output = '';\n      this._outputStream = {\n        write: function write(chunk, encoding, done) {\n          output += chunk;\n          done && done();\n        },\n        end: function end(done) {\n          done && done(null, output);\n        }\n      };\n      this._endStream = true;\n    } else {\n      this._outputStream = outputStream;\n      this._endStream = options.end === undefined ? true : !!options.end;\n    }\n\n    // Initialize writer, depending on the format\n    this._subject = null;\n    if (!/triple|quad/i.test(options.format)) {\n      this._lineMode = false;\n      this._graph = DEFAULTGRAPH;\n      this._prefixIRIs = Object.create(null);\n      options.prefixes && this.addPrefixes(options.prefixes);\n      if (options.baseIRI) {\n        this._baseMatcher = new RegExp(\"^\".concat(escapeRegex(options.baseIRI)).concat(options.baseIRI.endsWith('/') ? '' : '[#?]'));\n        this._baseLength = options.baseIRI.length;\n      }\n    } else {\n      this._lineMode = true;\n      this._writeQuad = this._writeQuadLine;\n    }\n  }\n\n  // ## Private methods\n\n  // ### Whether the current graph is the default graph\n  _createClass(N3Writer, [{\n    key: \"_inDefaultGraph\",\n    get: function get() {\n      return DEFAULTGRAPH.equals(this._graph);\n    }\n\n    // ### `_write` writes the argument to the output stream\n  }, {\n    key: \"_write\",\n    value: function _write(string, callback) {\n      this._outputStream.write(string, 'utf8', callback);\n    }\n\n    // ### `_writeQuad` writes the quad to the output stream\n  }, {\n    key: \"_writeQuad\",\n    value: function _writeQuad(subject, predicate, object, graph, done) {\n      try {\n        // Write the graph's label if it has changed\n        if (!graph.equals(this._graph)) {\n          // Close the previous graph and start the new one\n          this._write((this._subject === null ? '' : this._inDefaultGraph ? '.\\n' : '\\n}\\n') + (DEFAULTGRAPH.equals(graph) ? '' : \"\".concat(this._encodeIriOrBlank(graph), \" {\\n\")));\n          this._graph = graph;\n          this._subject = null;\n        }\n        // Don't repeat the subject if it's the same\n        if (subject.equals(this._subject)) {\n          // Don't repeat the predicate if it's the same\n          if (predicate.equals(this._predicate)) this._write(\", \".concat(this._encodeObject(object)), done);\n          // Same subject, different predicate\n          else this._write(\";\\n    \".concat(this._encodePredicate(this._predicate = predicate), \" \").concat(this._encodeObject(object)), done);\n        }\n        // Different subject; write the whole quad\n        else this._write(\"\".concat((this._subject === null ? '' : '.\\n') + this._encodeSubject(this._subject = subject), \" \").concat(this._encodePredicate(this._predicate = predicate), \" \").concat(this._encodeObject(object)), done);\n      } catch (error) {\n        done && done(error);\n      }\n    }\n\n    // ### `_writeQuadLine` writes the quad to the output stream as a single line\n  }, {\n    key: \"_writeQuadLine\",\n    value: function _writeQuadLine(subject, predicate, object, graph, done) {\n      // Write the quad without prefixes\n      delete this._prefixMatch;\n      this._write(this.quadToString(subject, predicate, object, graph), done);\n    }\n\n    // ### `quadToString` serializes a quad as a string\n  }, {\n    key: \"quadToString\",\n    value: function quadToString(subject, predicate, object, graph) {\n      return \"\".concat(this._encodeSubject(subject), \" \").concat(this._encodeIriOrBlank(predicate), \" \").concat(this._encodeObject(object)).concat(graph && graph.value ? \" \".concat(this._encodeIriOrBlank(graph), \" .\\n\") : ' .\\n');\n    }\n\n    // ### `quadsToString` serializes an array of quads as a string\n  }, {\n    key: \"quadsToString\",\n    value: function quadsToString(quads) {\n      var _this = this;\n      return quads.map(function (t) {\n        return _this.quadToString(t.subject, t.predicate, t.object, t.graph);\n      }).join('');\n    }\n\n    // ### `_encodeSubject` represents a subject\n  }, {\n    key: \"_encodeSubject\",\n    value: function _encodeSubject(entity) {\n      return entity.termType === 'Quad' ? this._encodeQuad(entity) : this._encodeIriOrBlank(entity);\n    }\n\n    // ### `_encodeIriOrBlank` represents an IRI or blank node\n  }, {\n    key: \"_encodeIriOrBlank\",\n    value: function _encodeIriOrBlank(entity) {\n      // A blank node or list is represented as-is\n      if (entity.termType !== 'NamedNode') {\n        // If it is a list head, pretty-print it\n        if (this._lists && entity.value in this._lists) entity = this.list(this._lists[entity.value]);\n        return 'id' in entity ? entity.id : \"_:\".concat(entity.value);\n      }\n      var iri = entity.value;\n      // Use relative IRIs if requested and possible\n      if (this._baseMatcher && this._baseMatcher.test(iri)) iri = iri.substr(this._baseLength);\n      // Escape special characters\n      if (escape.test(iri)) iri = iri.replace(escapeAll, characterReplacer);\n      // Try to represent the IRI as prefixed name\n      var prefixMatch = this._prefixRegex.exec(iri);\n      return !prefixMatch ? \"<\".concat(iri, \">\") : !prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2];\n    }\n\n    // ### `_encodeLiteral` represents a literal\n  }, {\n    key: \"_encodeLiteral\",\n    value: function _encodeLiteral(literal) {\n      // Escape special characters\n      var value = literal.value;\n      if (escape.test(value)) value = value.replace(escapeAll, characterReplacer);\n\n      // Write a language-tagged literal\n      if (literal.language) return \"\\\"\".concat(value, \"\\\"@\").concat(literal.language);\n\n      // Write dedicated literals per data type\n      if (this._lineMode) {\n        // Only abbreviate strings in N-Triples or N-Quads\n        if (literal.datatype.value === xsd.string) return \"\\\"\".concat(value, \"\\\"\");\n      } else {\n        // Use common datatype abbreviations in Turtle or TriG\n        switch (literal.datatype.value) {\n          case xsd.string:\n            return \"\\\"\".concat(value, \"\\\"\");\n          case xsd.boolean:\n            if (value === 'true' || value === 'false') return value;\n            break;\n          case xsd.integer:\n            if (/^[+-]?\\d+$/.test(value)) return value;\n            break;\n          case xsd.decimal:\n            if (/^[+-]?\\d*\\.\\d+$/.test(value)) return value;\n            break;\n          case xsd.double:\n            if (/^[+-]?(?:\\d+\\.\\d*|\\.?\\d+)[eE][+-]?\\d+$/.test(value)) return value;\n            break;\n        }\n      }\n\n      // Write a regular datatyped literal\n      return \"\\\"\".concat(value, \"\\\"^^\").concat(this._encodeIriOrBlank(literal.datatype));\n    }\n\n    // ### `_encodePredicate` represents a predicate\n  }, {\n    key: \"_encodePredicate\",\n    value: function _encodePredicate(predicate) {\n      return predicate.value === rdf.type ? 'a' : this._encodeIriOrBlank(predicate);\n    }\n\n    // ### `_encodeObject` represents an object\n  }, {\n    key: \"_encodeObject\",\n    value: function _encodeObject(object) {\n      switch (object.termType) {\n        case 'Quad':\n          return this._encodeQuad(object);\n        case 'Literal':\n          return this._encodeLiteral(object);\n        default:\n          return this._encodeIriOrBlank(object);\n      }\n    }\n\n    // ### `_encodeQuad` encodes an RDF* quad\n  }, {\n    key: \"_encodeQuad\",\n    value: function _encodeQuad(_ref) {\n      var subject = _ref.subject,\n        predicate = _ref.predicate,\n        object = _ref.object,\n        graph = _ref.graph;\n      return \"<<\".concat(this._encodeSubject(subject), \" \").concat(this._encodePredicate(predicate), \" \").concat(this._encodeObject(object)).concat(isDefaultGraph(graph) ? '' : \" \".concat(this._encodeIriOrBlank(graph)), \">>\");\n    }\n\n    // ### `_blockedWrite` replaces `_write` after the writer has been closed\n  }, {\n    key: \"_blockedWrite\",\n    value: function _blockedWrite() {\n      throw new Error('Cannot write because the writer has been closed.');\n    }\n\n    // ### `addQuad` adds the quad to the output stream\n  }, {\n    key: \"addQuad\",\n    value: function addQuad(subject, predicate, object, graph, done) {\n      // The quad was given as an object, so shift parameters\n      if (object === undefined) this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate);\n      // The optional `graph` parameter was not provided\n      else if (typeof graph === 'function') this._writeQuad(subject, predicate, object, DEFAULTGRAPH, graph);\n      // The `graph` parameter was provided\n      else this._writeQuad(subject, predicate, object, graph || DEFAULTGRAPH, done);\n    }\n\n    // ### `addQuads` adds the quads to the output stream\n  }, {\n    key: \"addQuads\",\n    value: function addQuads(quads) {\n      for (var i = 0; i < quads.length; i++) this.addQuad(quads[i]);\n    }\n\n    // ### `addPrefix` adds the prefix to the output stream\n  }, {\n    key: \"addPrefix\",\n    value: function addPrefix(prefix, iri, done) {\n      var prefixes = {};\n      prefixes[prefix] = iri;\n      this.addPrefixes(prefixes, done);\n    }\n\n    // ### `addPrefixes` adds the prefixes to the output stream\n  }, {\n    key: \"addPrefixes\",\n    value: function addPrefixes(prefixes, done) {\n      // Ignore prefixes if not supported by the serialization\n      if (!this._prefixIRIs) return done && done();\n\n      // Write all new prefixes\n      var hasPrefixes = false;\n      for (var prefix in prefixes) {\n        var iri = prefixes[prefix];\n        if (typeof iri !== 'string') iri = iri.value;\n        hasPrefixes = true;\n        // Finish a possible pending quad\n        if (this._subject !== null) {\n          this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n          this._subject = null, this._graph = '';\n        }\n        // Store and write the prefix\n        this._prefixIRIs[iri] = prefix += ':';\n        this._write(\"@prefix \".concat(prefix, \" <\").concat(iri, \">.\\n\"));\n      }\n      // Recreate the prefix matcher\n      if (hasPrefixes) {\n        var IRIlist = '',\n          prefixList = '';\n        for (var prefixIRI in this._prefixIRIs) {\n          IRIlist += IRIlist ? \"|\".concat(prefixIRI) : prefixIRI;\n          prefixList += (prefixList ? '|' : '') + this._prefixIRIs[prefixIRI];\n        }\n        IRIlist = escapeRegex(IRIlist, /[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n        this._prefixRegex = new RegExp(\"^(?:\".concat(prefixList, \")[^/]*$|\") + \"^(\".concat(IRIlist, \")([_a-zA-Z][\\\\-_a-zA-Z0-9]*)$\"));\n      }\n      // End a prefix block with a newline\n      this._write(hasPrefixes ? '\\n' : '', done);\n    }\n\n    // ### `blank` creates a blank node with the given content\n  }, {\n    key: \"blank\",\n    value: function blank(predicate, object) {\n      var children = predicate,\n        child,\n        length;\n      // Empty blank node\n      if (predicate === undefined) children = [];\n      // Blank node passed as blank(Term(\"predicate\"), Term(\"object\"))\n      else if (predicate.termType) children = [{\n        predicate: predicate,\n        object: object\n      }];\n      // Blank node passed as blank({ predicate: predicate, object: object })\n      else if (!('length' in predicate)) children = [predicate];\n      switch (length = children.length) {\n        // Generate an empty blank node\n        case 0:\n          return new SerializedTerm('[]');\n        // Generate a non-nested one-triple blank node\n        case 1:\n          child = children[0];\n          if (!(child.object instanceof SerializedTerm)) return new SerializedTerm(\"[ \".concat(this._encodePredicate(child.predicate), \" \").concat(this._encodeObject(child.object), \" ]\"));\n        // Generate a multi-triple or nested blank node\n        default:\n          var contents = '[';\n          // Write all triples in order\n          for (var i = 0; i < length; i++) {\n            child = children[i];\n            // Write only the object is the predicate is the same as the previous\n            if (child.predicate.equals(predicate)) contents += \", \".concat(this._encodeObject(child.object));\n            // Otherwise, write the predicate and the object\n            else {\n              contents += \"\".concat((i ? ';\\n  ' : '\\n  ') + this._encodePredicate(child.predicate), \" \").concat(this._encodeObject(child.object));\n              predicate = child.predicate;\n            }\n          }\n          return new SerializedTerm(\"\".concat(contents, \"\\n]\"));\n      }\n    }\n\n    // ### `list` creates a list node with the given content\n  }, {\n    key: \"list\",\n    value: function list(elements) {\n      var length = elements && elements.length || 0,\n        contents = new Array(length);\n      for (var i = 0; i < length; i++) contents[i] = this._encodeObject(elements[i]);\n      return new SerializedTerm(\"(\".concat(contents.join(' '), \")\"));\n    }\n\n    // ### `end` signals the end of the output stream\n  }, {\n    key: \"end\",\n    value: function end(done) {\n      // Finish a possible pending quad\n      if (this._subject !== null) {\n        this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n        this._subject = null;\n      }\n      // Disallow further writing\n      this._write = this._blockedWrite;\n\n      // Try to end the underlying stream, ensuring done is called exactly one time\n      var singleDone = done && function (error, result) {\n        singleDone = null, done(error, result);\n      };\n      if (this._endStream) {\n        try {\n          return this._outputStream.end(singleDone);\n        } catch (error) {/* error closing stream */}\n      }\n      singleDone && singleDone();\n    }\n  }]);\n  return N3Writer;\n}(); // Replaces a character by its escaped version\nexport { N3Writer as default };\nfunction characterReplacer(character) {\n  // Replace a single character by its escaped version\n  var result = escapedCharacters[character];\n  if (result === undefined) {\n    // Replace a single character with its 4-bit unicode escape sequence\n    if (character.length === 1) {\n      result = character.charCodeAt(0).toString(16);\n      result = \"\\\\u0000\".substr(0, 6 - result.length) + result;\n    }\n    // Replace a surrogate pair with its 8-bit unicode escape sequence\n    else {\n      result = ((character.charCodeAt(0) - 0xD800) * 0x400 + character.charCodeAt(1) + 0x2400).toString(16);\n      result = \"\\\\U00000000\".substr(0, 10 - result.length) + result;\n    }\n  }\n  return result;\n}\nfunction escapeRegex(regex) {\n  return regex.replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n}","map":{"version":3,"names":["namespaces","default","N3DataFactory","Term","isDefaultGraph","DEFAULTGRAPH","defaultGraph","rdf","xsd","escape","escapeAll","escapedCharacters","SerializedTerm","N3Writer","outputStream","options","_prefixRegex","write","_lists","lists","output","_outputStream","chunk","encoding","done","end","_endStream","undefined","_subject","test","format","_lineMode","_graph","_prefixIRIs","Object","create","prefixes","addPrefixes","baseIRI","_baseMatcher","RegExp","escapeRegex","endsWith","_baseLength","length","_writeQuad","_writeQuadLine","equals","string","callback","subject","predicate","object","graph","_write","_inDefaultGraph","_encodeIriOrBlank","_predicate","_encodeObject","_encodePredicate","_encodeSubject","error","_prefixMatch","quadToString","value","quads","map","t","join","entity","termType","_encodeQuad","list","id","iri","substr","replace","characterReplacer","prefixMatch","exec","literal","language","datatype","boolean","integer","decimal","double","type","_encodeLiteral","Error","i","addQuad","prefix","hasPrefixes","IRIlist","prefixList","prefixIRI","children","child","contents","elements","Array","_blockedWrite","singleDone","result","character","charCodeAt","toString","regex"],"sources":["E:/react-todo-app/node_modules/n3/src/N3Writer.js"],"sourcesContent":["// **N3Writer** writes N3 documents.\nimport namespaces from './IRIs';\nimport { default as N3DataFactory, Term } from './N3DataFactory';\nimport { isDefaultGraph } from './N3Util';\n\nconst DEFAULTGRAPH = N3DataFactory.defaultGraph();\n\nconst { rdf, xsd } = namespaces;\n\n// Characters in literals that require escaping\nconst escape    = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019\\ud800-\\udbff]/,\n    escapeAll = /[\"\\\\\\t\\n\\r\\b\\f\\u0000-\\u0019]|[\\ud800-\\udbff][\\udc00-\\udfff]/g,\n    escapedCharacters = {\n      '\\\\': '\\\\\\\\', '\"': '\\\\\"', '\\t': '\\\\t',\n      '\\n': '\\\\n', '\\r': '\\\\r', '\\b': '\\\\b', '\\f': '\\\\f',\n    };\n\n// ## Placeholder class to represent already pretty-printed terms\nclass SerializedTerm extends Term {\n  // Pretty-printed nodes are not equal to any other node\n  // (e.g., [] does not equal [])\n  equals() {\n    return false;\n  }\n}\n\n// ## Constructor\nexport default class N3Writer {\n  constructor(outputStream, options) {\n    // ### `_prefixRegex` matches a prefixed name or IRI that begins with one of the added prefixes\n    this._prefixRegex = /$0^/;\n\n    // Shift arguments if the first argument is not a stream\n    if (outputStream && typeof outputStream.write !== 'function')\n      options = outputStream, outputStream = null;\n    options = options || {};\n    this._lists = options.lists;\n\n    // If no output stream given, send the output as string through the end callback\n    if (!outputStream) {\n      let output = '';\n      this._outputStream = {\n        write(chunk, encoding, done) { output += chunk; done && done(); },\n        end: done => { done && done(null, output); },\n      };\n      this._endStream = true;\n    }\n    else {\n      this._outputStream = outputStream;\n      this._endStream = options.end === undefined ? true : !!options.end;\n    }\n\n    // Initialize writer, depending on the format\n    this._subject = null;\n    if (!(/triple|quad/i).test(options.format)) {\n      this._lineMode = false;\n      this._graph = DEFAULTGRAPH;\n      this._prefixIRIs = Object.create(null);\n      options.prefixes && this.addPrefixes(options.prefixes);\n      if (options.baseIRI) {\n        this._baseMatcher = new RegExp(`^${escapeRegex(options.baseIRI)\n            }${options.baseIRI.endsWith('/') ? '' : '[#?]'}`);\n        this._baseLength = options.baseIRI.length;\n      }\n    }\n    else {\n      this._lineMode = true;\n      this._writeQuad = this._writeQuadLine;\n    }\n  }\n\n  // ## Private methods\n\n  // ### Whether the current graph is the default graph\n  get _inDefaultGraph() {\n    return DEFAULTGRAPH.equals(this._graph);\n  }\n\n  // ### `_write` writes the argument to the output stream\n  _write(string, callback) {\n    this._outputStream.write(string, 'utf8', callback);\n  }\n\n  // ### `_writeQuad` writes the quad to the output stream\n  _writeQuad(subject, predicate, object, graph, done) {\n    try {\n      // Write the graph's label if it has changed\n      if (!graph.equals(this._graph)) {\n        // Close the previous graph and start the new one\n        this._write((this._subject === null ? '' : (this._inDefaultGraph ? '.\\n' : '\\n}\\n')) +\n                    (DEFAULTGRAPH.equals(graph) ? '' : `${this._encodeIriOrBlank(graph)} {\\n`));\n        this._graph = graph;\n        this._subject = null;\n      }\n      // Don't repeat the subject if it's the same\n      if (subject.equals(this._subject)) {\n        // Don't repeat the predicate if it's the same\n        if (predicate.equals(this._predicate))\n          this._write(`, ${this._encodeObject(object)}`, done);\n        // Same subject, different predicate\n        else\n          this._write(`;\\n    ${\n                      this._encodePredicate(this._predicate = predicate)} ${\n                      this._encodeObject(object)}`, done);\n      }\n      // Different subject; write the whole quad\n      else\n        this._write(`${(this._subject === null ? '' : '.\\n') +\n                    this._encodeSubject(this._subject = subject)} ${\n                    this._encodePredicate(this._predicate = predicate)} ${\n                    this._encodeObject(object)}`, done);\n    }\n    catch (error) { done && done(error); }\n  }\n\n  // ### `_writeQuadLine` writes the quad to the output stream as a single line\n  _writeQuadLine(subject, predicate, object, graph, done) {\n    // Write the quad without prefixes\n    delete this._prefixMatch;\n    this._write(this.quadToString(subject, predicate, object, graph), done);\n  }\n\n  // ### `quadToString` serializes a quad as a string\n  quadToString(subject, predicate, object, graph) {\n    return  `${this._encodeSubject(subject)} ${\n            this._encodeIriOrBlank(predicate)} ${\n            this._encodeObject(object)\n            }${graph && graph.value ? ` ${this._encodeIriOrBlank(graph)} .\\n` : ' .\\n'}`;\n  }\n\n  // ### `quadsToString` serializes an array of quads as a string\n  quadsToString(quads) {\n    return quads.map(t => {\n      return this.quadToString(t.subject, t.predicate, t.object, t.graph);\n    }).join('');\n  }\n\n  // ### `_encodeSubject` represents a subject\n  _encodeSubject(entity) {\n    return entity.termType === 'Quad' ?\n      this._encodeQuad(entity) : this._encodeIriOrBlank(entity);\n  }\n\n  // ### `_encodeIriOrBlank` represents an IRI or blank node\n  _encodeIriOrBlank(entity) {\n    // A blank node or list is represented as-is\n    if (entity.termType !== 'NamedNode') {\n      // If it is a list head, pretty-print it\n      if (this._lists && (entity.value in this._lists))\n        entity = this.list(this._lists[entity.value]);\n      return 'id' in entity ? entity.id : `_:${entity.value}`;\n    }\n    let iri = entity.value;\n    // Use relative IRIs if requested and possible\n    if (this._baseMatcher && this._baseMatcher.test(iri))\n      iri = iri.substr(this._baseLength);\n    // Escape special characters\n    if (escape.test(iri))\n      iri = iri.replace(escapeAll, characterReplacer);\n    // Try to represent the IRI as prefixed name\n    const prefixMatch = this._prefixRegex.exec(iri);\n    return !prefixMatch ? `<${iri}>` :\n           (!prefixMatch[1] ? iri : this._prefixIRIs[prefixMatch[1]] + prefixMatch[2]);\n  }\n\n  // ### `_encodeLiteral` represents a literal\n  _encodeLiteral(literal) {\n    // Escape special characters\n    let value = literal.value;\n    if (escape.test(value))\n      value = value.replace(escapeAll, characterReplacer);\n\n    // Write a language-tagged literal\n    if (literal.language)\n      return `\"${value}\"@${literal.language}`;\n\n    // Write dedicated literals per data type\n    if (this._lineMode) {\n      // Only abbreviate strings in N-Triples or N-Quads\n      if (literal.datatype.value === xsd.string)\n        return `\"${value}\"`;\n    }\n    else {\n      // Use common datatype abbreviations in Turtle or TriG\n      switch (literal.datatype.value) {\n      case xsd.string:\n        return `\"${value}\"`;\n      case xsd.boolean:\n        if (value === 'true' || value === 'false')\n          return value;\n        break;\n      case xsd.integer:\n        if (/^[+-]?\\d+$/.test(value))\n          return value;\n        break;\n      case xsd.decimal:\n        if (/^[+-]?\\d*\\.\\d+$/.test(value))\n          return value;\n        break;\n      case xsd.double:\n        if (/^[+-]?(?:\\d+\\.\\d*|\\.?\\d+)[eE][+-]?\\d+$/.test(value))\n          return value;\n        break;\n      }\n    }\n\n    // Write a regular datatyped literal\n    return `\"${value}\"^^${this._encodeIriOrBlank(literal.datatype)}`;\n  }\n\n  // ### `_encodePredicate` represents a predicate\n  _encodePredicate(predicate) {\n    return predicate.value === rdf.type ? 'a' : this._encodeIriOrBlank(predicate);\n  }\n\n  // ### `_encodeObject` represents an object\n  _encodeObject(object) {\n    switch (object.termType) {\n    case 'Quad':\n      return this._encodeQuad(object);\n    case 'Literal':\n      return this._encodeLiteral(object);\n    default:\n      return this._encodeIriOrBlank(object);\n    }\n  }\n\n  // ### `_encodeQuad` encodes an RDF* quad\n  _encodeQuad({ subject, predicate, object, graph }) {\n    return `<<${\n      this._encodeSubject(subject)} ${\n      this._encodePredicate(predicate)} ${\n      this._encodeObject(object)}${\n      isDefaultGraph(graph) ? '' : ` ${this._encodeIriOrBlank(graph)}`}>>`;\n  }\n\n  // ### `_blockedWrite` replaces `_write` after the writer has been closed\n  _blockedWrite() {\n    throw new Error('Cannot write because the writer has been closed.');\n  }\n\n  // ### `addQuad` adds the quad to the output stream\n  addQuad(subject, predicate, object, graph, done) {\n    // The quad was given as an object, so shift parameters\n    if (object === undefined)\n      this._writeQuad(subject.subject, subject.predicate, subject.object, subject.graph, predicate);\n    // The optional `graph` parameter was not provided\n    else if (typeof graph === 'function')\n      this._writeQuad(subject, predicate, object, DEFAULTGRAPH, graph);\n    // The `graph` parameter was provided\n    else\n      this._writeQuad(subject, predicate, object, graph || DEFAULTGRAPH, done);\n  }\n\n  // ### `addQuads` adds the quads to the output stream\n  addQuads(quads) {\n    for (let i = 0; i < quads.length; i++)\n      this.addQuad(quads[i]);\n  }\n\n  // ### `addPrefix` adds the prefix to the output stream\n  addPrefix(prefix, iri, done) {\n    const prefixes = {};\n    prefixes[prefix] = iri;\n    this.addPrefixes(prefixes, done);\n  }\n\n  // ### `addPrefixes` adds the prefixes to the output stream\n  addPrefixes(prefixes, done) {\n    // Ignore prefixes if not supported by the serialization\n    if (!this._prefixIRIs)\n      return done && done();\n\n    // Write all new prefixes\n    let hasPrefixes = false;\n    for (let prefix in prefixes) {\n      let iri = prefixes[prefix];\n      if (typeof iri !== 'string')\n        iri = iri.value;\n      hasPrefixes = true;\n      // Finish a possible pending quad\n      if (this._subject !== null) {\n        this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n        this._subject = null, this._graph = '';\n      }\n      // Store and write the prefix\n      this._prefixIRIs[iri] = (prefix += ':');\n      this._write(`@prefix ${prefix} <${iri}>.\\n`);\n    }\n    // Recreate the prefix matcher\n    if (hasPrefixes) {\n      let IRIlist = '', prefixList = '';\n      for (const prefixIRI in this._prefixIRIs) {\n        IRIlist += IRIlist ? `|${prefixIRI}` : prefixIRI;\n        prefixList += (prefixList ? '|' : '') + this._prefixIRIs[prefixIRI];\n      }\n      IRIlist = escapeRegex(IRIlist, /[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n      this._prefixRegex = new RegExp(`^(?:${prefixList})[^\\/]*$|` +\n                                     `^(${IRIlist})([_a-zA-Z][\\\\-_a-zA-Z0-9]*)$`);\n    }\n    // End a prefix block with a newline\n    this._write(hasPrefixes ? '\\n' : '', done);\n  }\n\n  // ### `blank` creates a blank node with the given content\n  blank(predicate, object) {\n    let children = predicate, child, length;\n    // Empty blank node\n    if (predicate === undefined)\n      children = [];\n    // Blank node passed as blank(Term(\"predicate\"), Term(\"object\"))\n    else if (predicate.termType)\n      children = [{ predicate: predicate, object: object }];\n    // Blank node passed as blank({ predicate: predicate, object: object })\n    else if (!('length' in predicate))\n      children = [predicate];\n\n    switch (length = children.length) {\n    // Generate an empty blank node\n    case 0:\n      return new SerializedTerm('[]');\n    // Generate a non-nested one-triple blank node\n    case 1:\n      child = children[0];\n      if (!(child.object instanceof SerializedTerm))\n        return new SerializedTerm(`[ ${this._encodePredicate(child.predicate)} ${\n                                  this._encodeObject(child.object)} ]`);\n    // Generate a multi-triple or nested blank node\n    default:\n      let contents = '[';\n      // Write all triples in order\n      for (let i = 0; i < length; i++) {\n        child = children[i];\n        // Write only the object is the predicate is the same as the previous\n        if (child.predicate.equals(predicate))\n          contents += `, ${this._encodeObject(child.object)}`;\n        // Otherwise, write the predicate and the object\n        else {\n          contents += `${(i ? ';\\n  ' : '\\n  ') +\n                      this._encodePredicate(child.predicate)} ${\n                      this._encodeObject(child.object)}`;\n          predicate = child.predicate;\n        }\n      }\n      return new SerializedTerm(`${contents}\\n]`);\n    }\n  }\n\n  // ### `list` creates a list node with the given content\n  list(elements) {\n    const length = elements && elements.length || 0, contents = new Array(length);\n    for (let i = 0; i < length; i++)\n      contents[i] = this._encodeObject(elements[i]);\n    return new SerializedTerm(`(${contents.join(' ')})`);\n  }\n\n  // ### `end` signals the end of the output stream\n  end(done) {\n    // Finish a possible pending quad\n    if (this._subject !== null) {\n      this._write(this._inDefaultGraph ? '.\\n' : '\\n}\\n');\n      this._subject = null;\n    }\n    // Disallow further writing\n    this._write = this._blockedWrite;\n\n    // Try to end the underlying stream, ensuring done is called exactly one time\n    let singleDone = done && ((error, result) => { singleDone = null, done(error, result); });\n    if (this._endStream) {\n      try { return this._outputStream.end(singleDone); }\n      catch (error) { /* error closing stream */ }\n    }\n    singleDone && singleDone();\n  }\n}\n\n// Replaces a character by its escaped version\nfunction characterReplacer(character) {\n  // Replace a single character by its escaped version\n  let result = escapedCharacters[character];\n  if (result === undefined) {\n    // Replace a single character with its 4-bit unicode escape sequence\n    if (character.length === 1) {\n      result = character.charCodeAt(0).toString(16);\n      result = '\\\\u0000'.substr(0, 6 - result.length) + result;\n    }\n    // Replace a surrogate pair with its 8-bit unicode escape sequence\n    else {\n      result = ((character.charCodeAt(0) - 0xD800) * 0x400 +\n                 character.charCodeAt(1) + 0x2400).toString(16);\n      result = '\\\\U00000000'.substr(0, 10 - result.length) + result;\n    }\n  }\n  return result;\n}\n\nfunction escapeRegex(regex) {\n  return regex.replace(/[\\]\\/\\(\\)\\*\\+\\?\\.\\\\\\$]/g, '\\\\$&');\n}\n"],"mappings":";;;;AAAA;AACA,OAAOA,UAAU,MAAM,QAAQ;AAC/B,SAASC,OAAO,IAAIC,aAAa,EAAEC,IAAI,QAAQ,iBAAiB;AAChE,SAASC,cAAc,QAAQ,UAAU;AAEzC,IAAMC,YAAY,GAAGH,aAAa,CAACI,YAAY,EAAE;AAEjD,IAAQC,GAAG,GAAUP,UAAU,CAAvBO,GAAG;EAAEC,GAAG,GAAKR,UAAU,CAAlBQ,GAAG;;AAEhB;AACA,IAAMC,MAAM,GAAM,2CAA2C;EACzDC,SAAS,GAAG,8DAA8D;EAC1EC,iBAAiB,GAAG;IAClB,IAAI,EAAE,MAAM;IAAE,GAAG,EAAE,KAAK;IAAE,IAAI,EAAE,KAAK;IACrC,IAAI,EAAE,KAAK;IAAE,IAAI,EAAE,KAAK;IAAE,IAAI,EAAE,KAAK;IAAE,IAAI,EAAE;EAC/C,CAAC;;AAEL;AAAA,IACMC,cAAc;EAAA;EAAA;EAAA;IAAA;IAAA;EAAA;EAAA;IAAA;IAAA;IAClB;IACA;IACA,kBAAS;MACP,OAAO,KAAK;IACd;EAAC;EAAA;AAAA,EAL0BT,IAAI,GAQjC;AAAA,IACqBU,QAAQ;EAC3B,kBAAYC,YAAY,EAAEC,OAAO,EAAE;IAAA;IACjC;IACA,IAAI,CAACC,YAAY,GAAG,KAAK;;IAEzB;IACA,IAAIF,YAAY,IAAI,OAAOA,YAAY,CAACG,KAAK,KAAK,UAAU,EAC1DF,OAAO,GAAGD,YAAY,EAAEA,YAAY,GAAG,IAAI;IAC7CC,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;IACvB,IAAI,CAACG,MAAM,GAAGH,OAAO,CAACI,KAAK;;IAE3B;IACA,IAAI,CAACL,YAAY,EAAE;MACjB,IAAIM,MAAM,GAAG,EAAE;MACf,IAAI,CAACC,aAAa,GAAG;QACnBJ,KAAK,iBAACK,KAAK,EAAEC,QAAQ,EAAEC,IAAI,EAAE;UAAEJ,MAAM,IAAIE,KAAK;UAAEE,IAAI,IAAIA,IAAI,EAAE;QAAE,CAAC;QACjEC,GAAG,EAAE,aAAAD,IAAI,EAAI;UAAEA,IAAI,IAAIA,IAAI,CAAC,IAAI,EAAEJ,MAAM,CAAC;QAAE;MAC7C,CAAC;MACD,IAAI,CAACM,UAAU,GAAG,IAAI;IACxB,CAAC,MACI;MACH,IAAI,CAACL,aAAa,GAAGP,YAAY;MACjC,IAAI,CAACY,UAAU,GAAGX,OAAO,CAACU,GAAG,KAAKE,SAAS,GAAG,IAAI,GAAG,CAAC,CAACZ,OAAO,CAACU,GAAG;IACpE;;IAEA;IACA,IAAI,CAACG,QAAQ,GAAG,IAAI;IACpB,IAAI,CAAE,cAAc,CAAEC,IAAI,CAACd,OAAO,CAACe,MAAM,CAAC,EAAE;MAC1C,IAAI,CAACC,SAAS,GAAG,KAAK;MACtB,IAAI,CAACC,MAAM,GAAG3B,YAAY;MAC1B,IAAI,CAAC4B,WAAW,GAAGC,MAAM,CAACC,MAAM,CAAC,IAAI,CAAC;MACtCpB,OAAO,CAACqB,QAAQ,IAAI,IAAI,CAACC,WAAW,CAACtB,OAAO,CAACqB,QAAQ,CAAC;MACtD,IAAIrB,OAAO,CAACuB,OAAO,EAAE;QACnB,IAAI,CAACC,YAAY,GAAG,IAAIC,MAAM,YAAKC,WAAW,CAAC1B,OAAO,CAACuB,OAAO,CAAC,SACxDvB,OAAO,CAACuB,OAAO,CAACI,QAAQ,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,MAAM,EAAG;QACrD,IAAI,CAACC,WAAW,GAAG5B,OAAO,CAACuB,OAAO,CAACM,MAAM;MAC3C;IACF,CAAC,MACI;MACH,IAAI,CAACb,SAAS,GAAG,IAAI;MACrB,IAAI,CAACc,UAAU,GAAG,IAAI,CAACC,cAAc;IACvC;EACF;;EAEA;;EAEA;EAAA;IAAA;IAAA,KACA,eAAsB;MACpB,OAAOzC,YAAY,CAAC0C,MAAM,CAAC,IAAI,CAACf,MAAM,CAAC;IACzC;;IAEA;EAAA;IAAA;IAAA,OACA,gBAAOgB,MAAM,EAAEC,QAAQ,EAAE;MACvB,IAAI,CAAC5B,aAAa,CAACJ,KAAK,CAAC+B,MAAM,EAAE,MAAM,EAAEC,QAAQ,CAAC;IACpD;;IAEA;EAAA;IAAA;IAAA,OACA,oBAAWC,OAAO,EAAEC,SAAS,EAAEC,MAAM,EAAEC,KAAK,EAAE7B,IAAI,EAAE;MAClD,IAAI;QACF;QACA,IAAI,CAAC6B,KAAK,CAACN,MAAM,CAAC,IAAI,CAACf,MAAM,CAAC,EAAE;UAC9B;UACA,IAAI,CAACsB,MAAM,CAAC,CAAC,IAAI,CAAC1B,QAAQ,KAAK,IAAI,GAAG,EAAE,GAAI,IAAI,CAAC2B,eAAe,GAAG,KAAK,GAAG,OAAQ,KACtElD,YAAY,CAAC0C,MAAM,CAACM,KAAK,CAAC,GAAG,EAAE,aAAM,IAAI,CAACG,iBAAiB,CAACH,KAAK,CAAC,SAAM,CAAC,CAAC;UACvF,IAAI,CAACrB,MAAM,GAAGqB,KAAK;UACnB,IAAI,CAACzB,QAAQ,GAAG,IAAI;QACtB;QACA;QACA,IAAIsB,OAAO,CAACH,MAAM,CAAC,IAAI,CAACnB,QAAQ,CAAC,EAAE;UACjC;UACA,IAAIuB,SAAS,CAACJ,MAAM,CAAC,IAAI,CAACU,UAAU,CAAC,EACnC,IAAI,CAACH,MAAM,aAAM,IAAI,CAACI,aAAa,CAACN,MAAM,CAAC,GAAI5B,IAAI,CAAC;UACtD;UAAA,KAEE,IAAI,CAAC8B,MAAM,kBACC,IAAI,CAACK,gBAAgB,CAAC,IAAI,CAACF,UAAU,GAAGN,SAAS,CAAC,cAClD,IAAI,CAACO,aAAa,CAACN,MAAM,CAAC,GAAI5B,IAAI,CAAC;QACnD;QACA;QAAA,KAEE,IAAI,CAAC8B,MAAM,WAAI,CAAC,IAAI,CAAC1B,QAAQ,KAAK,IAAI,GAAG,EAAE,GAAG,KAAK,IACvC,IAAI,CAACgC,cAAc,CAAC,IAAI,CAAChC,QAAQ,GAAGsB,OAAO,CAAC,cAC5C,IAAI,CAACS,gBAAgB,CAAC,IAAI,CAACF,UAAU,GAAGN,SAAS,CAAC,cAClD,IAAI,CAACO,aAAa,CAACN,MAAM,CAAC,GAAI5B,IAAI,CAAC;MACnD,CAAC,CACD,OAAOqC,KAAK,EAAE;QAAErC,IAAI,IAAIA,IAAI,CAACqC,KAAK,CAAC;MAAE;IACvC;;IAEA;EAAA;IAAA;IAAA,OACA,wBAAeX,OAAO,EAAEC,SAAS,EAAEC,MAAM,EAAEC,KAAK,EAAE7B,IAAI,EAAE;MACtD;MACA,OAAO,IAAI,CAACsC,YAAY;MACxB,IAAI,CAACR,MAAM,CAAC,IAAI,CAACS,YAAY,CAACb,OAAO,EAAEC,SAAS,EAAEC,MAAM,EAAEC,KAAK,CAAC,EAAE7B,IAAI,CAAC;IACzE;;IAEA;EAAA;IAAA;IAAA,OACA,sBAAa0B,OAAO,EAAEC,SAAS,EAAEC,MAAM,EAAEC,KAAK,EAAE;MAC9C,iBAAW,IAAI,CAACO,cAAc,CAACV,OAAO,CAAC,cAC/B,IAAI,CAACM,iBAAiB,CAACL,SAAS,CAAC,cACjC,IAAI,CAACO,aAAa,CAACN,MAAM,CAAC,SACvBC,KAAK,IAAIA,KAAK,CAACW,KAAK,cAAO,IAAI,CAACR,iBAAiB,CAACH,KAAK,CAAC,YAAS,MAAM;IACpF;;IAEA;EAAA;IAAA;IAAA,OACA,uBAAcY,KAAK,EAAE;MAAA;MACnB,OAAOA,KAAK,CAACC,GAAG,CAAC,UAAAC,CAAC,EAAI;QACpB,OAAO,KAAI,CAACJ,YAAY,CAACI,CAAC,CAACjB,OAAO,EAAEiB,CAAC,CAAChB,SAAS,EAAEgB,CAAC,CAACf,MAAM,EAAEe,CAAC,CAACd,KAAK,CAAC;MACrE,CAAC,CAAC,CAACe,IAAI,CAAC,EAAE,CAAC;IACb;;IAEA;EAAA;IAAA;IAAA,OACA,wBAAeC,MAAM,EAAE;MACrB,OAAOA,MAAM,CAACC,QAAQ,KAAK,MAAM,GAC/B,IAAI,CAACC,WAAW,CAACF,MAAM,CAAC,GAAG,IAAI,CAACb,iBAAiB,CAACa,MAAM,CAAC;IAC7D;;IAEA;EAAA;IAAA;IAAA,OACA,2BAAkBA,MAAM,EAAE;MACxB;MACA,IAAIA,MAAM,CAACC,QAAQ,KAAK,WAAW,EAAE;QACnC;QACA,IAAI,IAAI,CAACpD,MAAM,IAAKmD,MAAM,CAACL,KAAK,IAAI,IAAI,CAAC9C,MAAO,EAC9CmD,MAAM,GAAG,IAAI,CAACG,IAAI,CAAC,IAAI,CAACtD,MAAM,CAACmD,MAAM,CAACL,KAAK,CAAC,CAAC;QAC/C,OAAO,IAAI,IAAIK,MAAM,GAAGA,MAAM,CAACI,EAAE,eAAQJ,MAAM,CAACL,KAAK,CAAE;MACzD;MACA,IAAIU,GAAG,GAAGL,MAAM,CAACL,KAAK;MACtB;MACA,IAAI,IAAI,CAACzB,YAAY,IAAI,IAAI,CAACA,YAAY,CAACV,IAAI,CAAC6C,GAAG,CAAC,EAClDA,GAAG,GAAGA,GAAG,CAACC,MAAM,CAAC,IAAI,CAAChC,WAAW,CAAC;MACpC;MACA,IAAIlC,MAAM,CAACoB,IAAI,CAAC6C,GAAG,CAAC,EAClBA,GAAG,GAAGA,GAAG,CAACE,OAAO,CAAClE,SAAS,EAAEmE,iBAAiB,CAAC;MACjD;MACA,IAAMC,WAAW,GAAG,IAAI,CAAC9D,YAAY,CAAC+D,IAAI,CAACL,GAAG,CAAC;MAC/C,OAAO,CAACI,WAAW,cAAOJ,GAAG,SACrB,CAACI,WAAW,CAAC,CAAC,CAAC,GAAGJ,GAAG,GAAG,IAAI,CAACzC,WAAW,CAAC6C,WAAW,CAAC,CAAC,CAAC,CAAC,GAAGA,WAAW,CAAC,CAAC,CAAE;IACpF;;IAEA;EAAA;IAAA;IAAA,OACA,wBAAeE,OAAO,EAAE;MACtB;MACA,IAAIhB,KAAK,GAAGgB,OAAO,CAAChB,KAAK;MACzB,IAAIvD,MAAM,CAACoB,IAAI,CAACmC,KAAK,CAAC,EACpBA,KAAK,GAAGA,KAAK,CAACY,OAAO,CAAClE,SAAS,EAAEmE,iBAAiB,CAAC;;MAErD;MACA,IAAIG,OAAO,CAACC,QAAQ,EAClB,mBAAWjB,KAAK,gBAAKgB,OAAO,CAACC,QAAQ;;MAEvC;MACA,IAAI,IAAI,CAAClD,SAAS,EAAE;QAClB;QACA,IAAIiD,OAAO,CAACE,QAAQ,CAAClB,KAAK,KAAKxD,GAAG,CAACwC,MAAM,EACvC,mBAAWgB,KAAK;MACpB,CAAC,MACI;QACH;QACA,QAAQgB,OAAO,CAACE,QAAQ,CAAClB,KAAK;UAC9B,KAAKxD,GAAG,CAACwC,MAAM;YACb,mBAAWgB,KAAK;UAClB,KAAKxD,GAAG,CAAC2E,OAAO;YACd,IAAInB,KAAK,KAAK,MAAM,IAAIA,KAAK,KAAK,OAAO,EACvC,OAAOA,KAAK;YACd;UACF,KAAKxD,GAAG,CAAC4E,OAAO;YACd,IAAI,YAAY,CAACvD,IAAI,CAACmC,KAAK,CAAC,EAC1B,OAAOA,KAAK;YACd;UACF,KAAKxD,GAAG,CAAC6E,OAAO;YACd,IAAI,iBAAiB,CAACxD,IAAI,CAACmC,KAAK,CAAC,EAC/B,OAAOA,KAAK;YACd;UACF,KAAKxD,GAAG,CAAC8E,MAAM;YACb,IAAI,wCAAwC,CAACzD,IAAI,CAACmC,KAAK,CAAC,EACtD,OAAOA,KAAK;YACd;QAAM;MAEV;;MAEA;MACA,mBAAWA,KAAK,iBAAM,IAAI,CAACR,iBAAiB,CAACwB,OAAO,CAACE,QAAQ,CAAC;IAChE;;IAEA;EAAA;IAAA;IAAA,OACA,0BAAiB/B,SAAS,EAAE;MAC1B,OAAOA,SAAS,CAACa,KAAK,KAAKzD,GAAG,CAACgF,IAAI,GAAG,GAAG,GAAG,IAAI,CAAC/B,iBAAiB,CAACL,SAAS,CAAC;IAC/E;;IAEA;EAAA;IAAA;IAAA,OACA,uBAAcC,MAAM,EAAE;MACpB,QAAQA,MAAM,CAACkB,QAAQ;QACvB,KAAK,MAAM;UACT,OAAO,IAAI,CAACC,WAAW,CAACnB,MAAM,CAAC;QACjC,KAAK,SAAS;UACZ,OAAO,IAAI,CAACoC,cAAc,CAACpC,MAAM,CAAC;QACpC;UACE,OAAO,IAAI,CAACI,iBAAiB,CAACJ,MAAM,CAAC;MAAC;IAE1C;;IAEA;EAAA;IAAA;IAAA,OACA,2BAAmD;MAAA,IAArCF,OAAO,QAAPA,OAAO;QAAEC,SAAS,QAATA,SAAS;QAAEC,MAAM,QAANA,MAAM;QAAEC,KAAK,QAALA,KAAK;MAC7C,mBACE,IAAI,CAACO,cAAc,CAACV,OAAO,CAAC,cAC5B,IAAI,CAACS,gBAAgB,CAACR,SAAS,CAAC,cAChC,IAAI,CAACO,aAAa,CAACN,MAAM,CAAC,SAC1BhD,cAAc,CAACiD,KAAK,CAAC,GAAG,EAAE,cAAO,IAAI,CAACG,iBAAiB,CAACH,KAAK,CAAC,CAAE;IACpE;;IAEA;EAAA;IAAA;IAAA,OACA,yBAAgB;MACd,MAAM,IAAIoC,KAAK,CAAC,kDAAkD,CAAC;IACrE;;IAEA;EAAA;IAAA;IAAA,OACA,iBAAQvC,OAAO,EAAEC,SAAS,EAAEC,MAAM,EAAEC,KAAK,EAAE7B,IAAI,EAAE;MAC/C;MACA,IAAI4B,MAAM,KAAKzB,SAAS,EACtB,IAAI,CAACkB,UAAU,CAACK,OAAO,CAACA,OAAO,EAAEA,OAAO,CAACC,SAAS,EAAED,OAAO,CAACE,MAAM,EAAEF,OAAO,CAACG,KAAK,EAAEF,SAAS,CAAC;MAC/F;MAAA,KACK,IAAI,OAAOE,KAAK,KAAK,UAAU,EAClC,IAAI,CAACR,UAAU,CAACK,OAAO,EAAEC,SAAS,EAAEC,MAAM,EAAE/C,YAAY,EAAEgD,KAAK,CAAC;MAClE;MAAA,KAEE,IAAI,CAACR,UAAU,CAACK,OAAO,EAAEC,SAAS,EAAEC,MAAM,EAAEC,KAAK,IAAIhD,YAAY,EAAEmB,IAAI,CAAC;IAC5E;;IAEA;EAAA;IAAA;IAAA,OACA,kBAASyC,KAAK,EAAE;MACd,KAAK,IAAIyB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzB,KAAK,CAACrB,MAAM,EAAE8C,CAAC,EAAE,EACnC,IAAI,CAACC,OAAO,CAAC1B,KAAK,CAACyB,CAAC,CAAC,CAAC;IAC1B;;IAEA;EAAA;IAAA;IAAA,OACA,mBAAUE,MAAM,EAAElB,GAAG,EAAElD,IAAI,EAAE;MAC3B,IAAMY,QAAQ,GAAG,CAAC,CAAC;MACnBA,QAAQ,CAACwD,MAAM,CAAC,GAAGlB,GAAG;MACtB,IAAI,CAACrC,WAAW,CAACD,QAAQ,EAAEZ,IAAI,CAAC;IAClC;;IAEA;EAAA;IAAA;IAAA,OACA,qBAAYY,QAAQ,EAAEZ,IAAI,EAAE;MAC1B;MACA,IAAI,CAAC,IAAI,CAACS,WAAW,EACnB,OAAOT,IAAI,IAAIA,IAAI,EAAE;;MAEvB;MACA,IAAIqE,WAAW,GAAG,KAAK;MACvB,KAAK,IAAID,MAAM,IAAIxD,QAAQ,EAAE;QAC3B,IAAIsC,GAAG,GAAGtC,QAAQ,CAACwD,MAAM,CAAC;QAC1B,IAAI,OAAOlB,GAAG,KAAK,QAAQ,EACzBA,GAAG,GAAGA,GAAG,CAACV,KAAK;QACjB6B,WAAW,GAAG,IAAI;QAClB;QACA,IAAI,IAAI,CAACjE,QAAQ,KAAK,IAAI,EAAE;UAC1B,IAAI,CAAC0B,MAAM,CAAC,IAAI,CAACC,eAAe,GAAG,KAAK,GAAG,OAAO,CAAC;UACnD,IAAI,CAAC3B,QAAQ,GAAG,IAAI,EAAE,IAAI,CAACI,MAAM,GAAG,EAAE;QACxC;QACA;QACA,IAAI,CAACC,WAAW,CAACyC,GAAG,CAAC,GAAIkB,MAAM,IAAI,GAAI;QACvC,IAAI,CAACtC,MAAM,mBAAYsC,MAAM,eAAKlB,GAAG,UAAO;MAC9C;MACA;MACA,IAAImB,WAAW,EAAE;QACf,IAAIC,OAAO,GAAG,EAAE;UAAEC,UAAU,GAAG,EAAE;QACjC,KAAK,IAAMC,SAAS,IAAI,IAAI,CAAC/D,WAAW,EAAE;UACxC6D,OAAO,IAAIA,OAAO,cAAOE,SAAS,IAAKA,SAAS;UAChDD,UAAU,IAAI,CAACA,UAAU,GAAG,GAAG,GAAG,EAAE,IAAI,IAAI,CAAC9D,WAAW,CAAC+D,SAAS,CAAC;QACrE;QACAF,OAAO,GAAGrD,WAAW,CAACqD,OAAO,EAAE,yBAAyB,EAAE,MAAM,CAAC;QACjE,IAAI,CAAC9E,YAAY,GAAG,IAAIwB,MAAM,CAAC,cAAOuD,UAAU,4BACZD,OAAO,kCAA+B,CAAC;MAC7E;MACA;MACA,IAAI,CAACxC,MAAM,CAACuC,WAAW,GAAG,IAAI,GAAG,EAAE,EAAErE,IAAI,CAAC;IAC5C;;IAEA;EAAA;IAAA;IAAA,OACA,eAAM2B,SAAS,EAAEC,MAAM,EAAE;MACvB,IAAI6C,QAAQ,GAAG9C,SAAS;QAAE+C,KAAK;QAAEtD,MAAM;MACvC;MACA,IAAIO,SAAS,KAAKxB,SAAS,EACzBsE,QAAQ,GAAG,EAAE;MACf;MAAA,KACK,IAAI9C,SAAS,CAACmB,QAAQ,EACzB2B,QAAQ,GAAG,CAAC;QAAE9C,SAAS,EAAEA,SAAS;QAAEC,MAAM,EAAEA;MAAO,CAAC,CAAC;MACvD;MAAA,KACK,IAAI,EAAE,QAAQ,IAAID,SAAS,CAAC,EAC/B8C,QAAQ,GAAG,CAAC9C,SAAS,CAAC;MAExB,QAAQP,MAAM,GAAGqD,QAAQ,CAACrD,MAAM;QAChC;QACA,KAAK,CAAC;UACJ,OAAO,IAAIhC,cAAc,CAAC,IAAI,CAAC;QACjC;QACA,KAAK,CAAC;UACJsF,KAAK,GAAGD,QAAQ,CAAC,CAAC,CAAC;UACnB,IAAI,EAAEC,KAAK,CAAC9C,MAAM,YAAYxC,cAAc,CAAC,EAC3C,OAAO,IAAIA,cAAc,aAAM,IAAI,CAAC+C,gBAAgB,CAACuC,KAAK,CAAC/C,SAAS,CAAC,cAC3C,IAAI,CAACO,aAAa,CAACwC,KAAK,CAAC9C,MAAM,CAAC,QAAK;QACnE;QACA;UACE,IAAI+C,QAAQ,GAAG,GAAG;UAClB;UACA,KAAK,IAAIT,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9C,MAAM,EAAE8C,CAAC,EAAE,EAAE;YAC/BQ,KAAK,GAAGD,QAAQ,CAACP,CAAC,CAAC;YACnB;YACA,IAAIQ,KAAK,CAAC/C,SAAS,CAACJ,MAAM,CAACI,SAAS,CAAC,EACnCgD,QAAQ,gBAAS,IAAI,CAACzC,aAAa,CAACwC,KAAK,CAAC9C,MAAM,CAAC,CAAE;YACrD;YAAA,KACK;cACH+C,QAAQ,cAAO,CAACT,CAAC,GAAG,OAAO,GAAG,MAAM,IACxB,IAAI,CAAC/B,gBAAgB,CAACuC,KAAK,CAAC/C,SAAS,CAAC,cACtC,IAAI,CAACO,aAAa,CAACwC,KAAK,CAAC9C,MAAM,CAAC,CAAE;cAC9CD,SAAS,GAAG+C,KAAK,CAAC/C,SAAS;YAC7B;UACF;UACA,OAAO,IAAIvC,cAAc,WAAIuF,QAAQ,SAAM;MAAC;IAEhD;;IAEA;EAAA;IAAA;IAAA,OACA,cAAKC,QAAQ,EAAE;MACb,IAAMxD,MAAM,GAAGwD,QAAQ,IAAIA,QAAQ,CAACxD,MAAM,IAAI,CAAC;QAAEuD,QAAQ,GAAG,IAAIE,KAAK,CAACzD,MAAM,CAAC;MAC7E,KAAK,IAAI8C,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9C,MAAM,EAAE8C,CAAC,EAAE,EAC7BS,QAAQ,CAACT,CAAC,CAAC,GAAG,IAAI,CAAChC,aAAa,CAAC0C,QAAQ,CAACV,CAAC,CAAC,CAAC;MAC/C,OAAO,IAAI9E,cAAc,YAAKuF,QAAQ,CAAC/B,IAAI,CAAC,GAAG,CAAC,OAAI;IACtD;;IAEA;EAAA;IAAA;IAAA,OACA,aAAI5C,IAAI,EAAE;MACR;MACA,IAAI,IAAI,CAACI,QAAQ,KAAK,IAAI,EAAE;QAC1B,IAAI,CAAC0B,MAAM,CAAC,IAAI,CAACC,eAAe,GAAG,KAAK,GAAG,OAAO,CAAC;QACnD,IAAI,CAAC3B,QAAQ,GAAG,IAAI;MACtB;MACA;MACA,IAAI,CAAC0B,MAAM,GAAG,IAAI,CAACgD,aAAa;;MAEhC;MACA,IAAIC,UAAU,GAAG/E,IAAI,IAAK,UAACqC,KAAK,EAAE2C,MAAM,EAAK;QAAED,UAAU,GAAG,IAAI,EAAE/E,IAAI,CAACqC,KAAK,EAAE2C,MAAM,CAAC;MAAE,CAAE;MACzF,IAAI,IAAI,CAAC9E,UAAU,EAAE;QACnB,IAAI;UAAE,OAAO,IAAI,CAACL,aAAa,CAACI,GAAG,CAAC8E,UAAU,CAAC;QAAE,CAAC,CAClD,OAAO1C,KAAK,EAAE,CAAE;MAClB;MACA0C,UAAU,IAAIA,UAAU,EAAE;IAC5B;EAAC;EAAA;AAAA,KAGH;AAAA,SA7VqB1F,QAAQ;AA8V7B,SAASgE,iBAAiB,CAAC4B,SAAS,EAAE;EACpC;EACA,IAAID,MAAM,GAAG7F,iBAAiB,CAAC8F,SAAS,CAAC;EACzC,IAAID,MAAM,KAAK7E,SAAS,EAAE;IACxB;IACA,IAAI8E,SAAS,CAAC7D,MAAM,KAAK,CAAC,EAAE;MAC1B4D,MAAM,GAAGC,SAAS,CAACC,UAAU,CAAC,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC;MAC7CH,MAAM,GAAG,SAAS,CAAC7B,MAAM,CAAC,CAAC,EAAE,CAAC,GAAG6B,MAAM,CAAC5D,MAAM,CAAC,GAAG4D,MAAM;IAC1D;IACA;IAAA,KACK;MACHA,MAAM,GAAG,CAAC,CAACC,SAAS,CAACC,UAAU,CAAC,CAAC,CAAC,GAAG,MAAM,IAAI,KAAK,GACzCD,SAAS,CAACC,UAAU,CAAC,CAAC,CAAC,GAAG,MAAM,EAAEC,QAAQ,CAAC,EAAE,CAAC;MACzDH,MAAM,GAAG,aAAa,CAAC7B,MAAM,CAAC,CAAC,EAAE,EAAE,GAAG6B,MAAM,CAAC5D,MAAM,CAAC,GAAG4D,MAAM;IAC/D;EACF;EACA,OAAOA,MAAM;AACf;AAEA,SAAS/D,WAAW,CAACmE,KAAK,EAAE;EAC1B,OAAOA,KAAK,CAAChC,OAAO,CAAC,yBAAyB,EAAE,MAAM,CAAC;AACzD"},"metadata":{},"sourceType":"module","externalDependencies":[]}