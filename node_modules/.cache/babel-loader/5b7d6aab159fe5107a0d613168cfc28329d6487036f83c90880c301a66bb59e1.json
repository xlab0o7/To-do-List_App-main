{"ast":null,"code":"/**\n * A JavaScript implementation of the JSON-LD API.\n *\n * @author Dave Longley\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2011-2019 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nconst canonize = require('rdf-canonize');\nconst platform = require('./platform');\nconst util = require('./util');\nconst ContextResolver = require('./ContextResolver');\nconst IdentifierIssuer = util.IdentifierIssuer;\nconst JsonLdError = require('./JsonLdError');\nconst LRU = require('lru-cache');\nconst NQuads = require('./NQuads');\nconst {\n  expand: _expand\n} = require('./expand');\nconst {\n  flatten: _flatten\n} = require('./flatten');\nconst {\n  fromRDF: _fromRDF\n} = require('./fromRdf');\nconst {\n  toRDF: _toRDF\n} = require('./toRdf');\nconst {\n  frameMergedOrDefault: _frameMergedOrDefault,\n  cleanupNull: _cleanupNull\n} = require('./frame');\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString\n} = require('./types');\nconst {\n  isSubjectReference: _isSubjectReference\n} = require('./graphTypes');\nconst {\n  expandIri: _expandIri,\n  getInitialContext: _getInitialContext,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\nconst {\n  compact: _compact,\n  compactIri: _compactIri\n} = require('./compact');\nconst {\n  createNodeMap: _createNodeMap,\n  createMergedNodeMap: _createMergedNodeMap,\n  mergeNodeMaps: _mergeNodeMaps\n} = require('./nodeMap');\n\n/* eslint-disable indent */\n// attaches jsonld API to the given object\nconst wrapper = function (jsonld) {\n  /** Registered RDF dataset parsers hashed by content-type. */\n  const _rdfParsers = {};\n\n  // resolved context cache\n  // TODO: consider basing max on context size rather than number\n  const RESOLVED_CONTEXT_CACHE_MAX_SIZE = 100;\n  const _resolvedContextCache = new LRU({\n    max: RESOLVED_CONTEXT_CACHE_MAX_SIZE\n  });\n\n  /* Core API */\n\n  /**\n   * Performs JSON-LD compaction.\n   *\n   * @param input the JSON-LD input to compact.\n   * @param ctx the context to compact with.\n   * @param [options] options to use:\n   *          [base] the base IRI to use.\n   *          [compactArrays] true to compact arrays to single values when\n   *            appropriate, false not to (default: true).\n   *          [compactToRelative] true to compact IRIs to be relative to document\n   *            base, false to keep absolute (default: true)\n   *          [graph] true to always output a top-level graph (default: false).\n   *          [expandContext] a context to expand with.\n   *          [skipExpansion] true to assume the input is expanded and skip\n   *            expansion, false not to, defaults to false.\n   *          [documentLoader(url, options)] the document loader.\n   *          [expansionMap(info)] a function that can be used to custom map\n   *            unmappable values (or to throw an error when they are detected);\n   *            if this function returns `undefined` then the default behavior\n   *            will be used.\n   *          [framing] true if compaction is occuring during a framing operation.\n   *          [compactionMap(info)] a function that can be used to custom map\n   *            unmappable values (or to throw an error when they are detected);\n   *            if this function returns `undefined` then the default behavior\n   *            will be used.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the compacted output.\n   */\n  jsonld.compact = async function (input, ctx, options) {\n    if (arguments.length < 2) {\n      throw new TypeError('Could not compact, too few arguments.');\n    }\n    if (ctx === null) {\n      throw new JsonLdError('The compaction context must not be null.', 'jsonld.CompactError', {\n        code: 'invalid local context'\n      });\n    }\n\n    // nothing to compact\n    if (input === null) {\n      return null;\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      compactArrays: true,\n      compactToRelative: true,\n      graph: false,\n      skipExpansion: false,\n      link: false,\n      issuer: new IdentifierIssuer('_:b'),\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n    if (options.link) {\n      // force skip expansion when linking, \"link\" is not part of the public\n      // API, it should only be called from framing\n      options.skipExpansion = true;\n    }\n    if (!options.compactToRelative) {\n      delete options.base;\n    }\n\n    // expand input\n    let expanded;\n    if (options.skipExpansion) {\n      expanded = input;\n    } else {\n      expanded = await jsonld.expand(input, options);\n    }\n\n    // process context\n    const activeCtx = await jsonld.processContext(_getInitialContext(options), ctx, options);\n\n    // do compaction\n    let compacted = await _compact({\n      activeCtx,\n      element: expanded,\n      options,\n      compactionMap: options.compactionMap\n    });\n\n    // perform clean up\n    if (options.compactArrays && !options.graph && _isArray(compacted)) {\n      if (compacted.length === 1) {\n        // simplify to a single item\n        compacted = compacted[0];\n      } else if (compacted.length === 0) {\n        // simplify to an empty object\n        compacted = {};\n      }\n    } else if (options.graph && _isObject(compacted)) {\n      // always use array if graph option is on\n      compacted = [compacted];\n    }\n\n    // follow @context key\n    if (_isObject(ctx) && '@context' in ctx) {\n      ctx = ctx['@context'];\n    }\n\n    // build output context\n    ctx = util.clone(ctx);\n    if (!_isArray(ctx)) {\n      ctx = [ctx];\n    }\n    // remove empty contexts\n    const tmp = ctx;\n    ctx = [];\n    for (let i = 0; i < tmp.length; ++i) {\n      if (!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {\n        ctx.push(tmp[i]);\n      }\n    }\n\n    // remove array if only one context\n    const hasContext = ctx.length > 0;\n    if (ctx.length === 1) {\n      ctx = ctx[0];\n    }\n\n    // add context and/or @graph\n    if (_isArray(compacted)) {\n      // use '@graph' keyword\n      const graphAlias = _compactIri({\n        activeCtx,\n        iri: '@graph',\n        relativeTo: {\n          vocab: true\n        }\n      });\n      const graph = compacted;\n      compacted = {};\n      if (hasContext) {\n        compacted['@context'] = ctx;\n      }\n      compacted[graphAlias] = graph;\n    } else if (_isObject(compacted) && hasContext) {\n      // reorder keys so @context is first\n      const graph = compacted;\n      compacted = {\n        '@context': ctx\n      };\n      for (const key in graph) {\n        compacted[key] = graph[key];\n      }\n    }\n    return compacted;\n  };\n\n  /**\n   * Performs JSON-LD expansion.\n   *\n   * @param input the JSON-LD input to expand.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [keepFreeFloatingNodes] true to keep free-floating nodes,\n   *            false not to, defaults to false.\n   *          [documentLoader(url, options)] the document loader.\n   *          [expansionMap(info)] a function that can be used to custom map\n   *            unmappable values (or to throw an error when they are detected);\n   *            if this function returns `undefined` then the default behavior\n   *            will be used.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the expanded output.\n   */\n  jsonld.expand = async function (input, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not expand, too few arguments.');\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      keepFreeFloatingNodes: false,\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n    if (options.expansionMap === false) {\n      options.expansionMap = undefined;\n    }\n\n    // build set of objects that may have @contexts to resolve\n    const toResolve = {};\n\n    // build set of contexts to process prior to expansion\n    const contextsToProcess = [];\n\n    // if an `expandContext` has been given ensure it gets resolved\n    if ('expandContext' in options) {\n      const expandContext = util.clone(options.expandContext);\n      if (_isObject(expandContext) && '@context' in expandContext) {\n        toResolve.expandContext = expandContext;\n      } else {\n        toResolve.expandContext = {\n          '@context': expandContext\n        };\n      }\n      contextsToProcess.push(toResolve.expandContext);\n    }\n\n    // if input is a string, attempt to dereference remote document\n    let defaultBase;\n    if (!_isString(input)) {\n      // input is not a URL, do not need to retrieve it first\n      toResolve.input = util.clone(input);\n    } else {\n      // load remote doc\n      const remoteDoc = await jsonld.get(input, options);\n      defaultBase = remoteDoc.documentUrl;\n      toResolve.input = remoteDoc.document;\n      if (remoteDoc.contextUrl) {\n        // context included in HTTP link header and must be resolved\n        toResolve.remoteContext = {\n          '@context': remoteDoc.contextUrl\n        };\n        contextsToProcess.push(toResolve.remoteContext);\n      }\n    }\n\n    // set default base\n    if (!('base' in options)) {\n      options.base = defaultBase || '';\n    }\n\n    // process any additional contexts\n    let activeCtx = _getInitialContext(options);\n    for (const localCtx of contextsToProcess) {\n      activeCtx = await _processContext({\n        activeCtx,\n        localCtx,\n        options\n      });\n    }\n\n    // expand resolved input\n    let expanded = await _expand({\n      activeCtx,\n      element: toResolve.input,\n      options,\n      expansionMap: options.expansionMap\n    });\n\n    // optimize away @graph with no other properties\n    if (_isObject(expanded) && '@graph' in expanded && Object.keys(expanded).length === 1) {\n      expanded = expanded['@graph'];\n    } else if (expanded === null) {\n      expanded = [];\n    }\n\n    // normalize to an array\n    if (!_isArray(expanded)) {\n      expanded = [expanded];\n    }\n    return expanded;\n  };\n\n  /**\n   * Performs JSON-LD flattening.\n   *\n   * @param input the JSON-LD to flatten.\n   * @param ctx the context to use to compact the flattened output, or null.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the flattened output.\n   */\n  jsonld.flatten = async function (input, ctx, options) {\n    if (arguments.length < 1) {\n      return new TypeError('Could not flatten, too few arguments.');\n    }\n    if (typeof ctx === 'function') {\n      ctx = null;\n    } else {\n      ctx = ctx || null;\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n\n    // expand input\n    const expanded = await jsonld.expand(input, options);\n\n    // do flattening\n    const flattened = _flatten(expanded);\n    if (ctx === null) {\n      // no compaction required\n      return flattened;\n    }\n\n    // compact result (force @graph option to true, skip expansion)\n    options.graph = true;\n    options.skipExpansion = true;\n    const compacted = await jsonld.compact(flattened, ctx, options);\n    return compacted;\n  };\n\n  /**\n   * Performs JSON-LD framing.\n   *\n   * @param input the JSON-LD input to frame.\n   * @param frame the JSON-LD frame to use.\n   * @param [options] the framing options.\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [embed] default @embed flag: '@last', '@always', '@never', '@link'\n   *            (default: '@last').\n   *          [explicit] default @explicit flag (default: false).\n   *          [requireAll] default @requireAll flag (default: true).\n   *          [omitDefault] default @omitDefault flag (default: false).\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the framed output.\n   */\n  jsonld.frame = async function (input, frame, options) {\n    if (arguments.length < 2) {\n      throw new TypeError('Could not frame, too few arguments.');\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      embed: '@once',\n      explicit: false,\n      requireAll: false,\n      omitDefault: false,\n      bnodesToClear: [],\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n\n    // if frame is a string, attempt to dereference remote document\n    if (_isString(frame)) {\n      // load remote doc\n      const remoteDoc = await jsonld.get(frame, options);\n      frame = remoteDoc.document;\n      if (remoteDoc.contextUrl) {\n        // inject link header @context into frame\n        let ctx = frame['@context'];\n        if (!ctx) {\n          ctx = remoteDoc.contextUrl;\n        } else if (_isArray(ctx)) {\n          ctx.push(remoteDoc.contextUrl);\n        } else {\n          ctx = [ctx, remoteDoc.contextUrl];\n        }\n        frame['@context'] = ctx;\n      }\n    }\n    const frameContext = frame ? frame['@context'] || {} : {};\n\n    // process context\n    const activeCtx = await jsonld.processContext(_getInitialContext(options), frameContext, options);\n\n    // mode specific defaults\n    if (!options.hasOwnProperty('omitGraph')) {\n      options.omitGraph = _processingMode(activeCtx, 1.1);\n    }\n    if (!options.hasOwnProperty('pruneBlankNodeIdentifiers')) {\n      options.pruneBlankNodeIdentifiers = _processingMode(activeCtx, 1.1);\n    }\n\n    // expand input\n    const expanded = await jsonld.expand(input, options);\n\n    // expand frame\n    const opts = {\n      ...options\n    };\n    opts.isFrame = true;\n    opts.keepFreeFloatingNodes = true;\n    const expandedFrame = await jsonld.expand(frame, opts);\n\n    // if the unexpanded frame includes a key expanding to @graph, frame the\n    // default graph, otherwise, the merged graph\n    const frameKeys = Object.keys(frame).map(key => _expandIri(activeCtx, key, {\n      vocab: true\n    }));\n    opts.merged = !frameKeys.includes('@graph');\n    opts.is11 = _processingMode(activeCtx, 1.1);\n\n    // do framing\n    const framed = _frameMergedOrDefault(expanded, expandedFrame, opts);\n    opts.graph = !options.omitGraph;\n    opts.skipExpansion = true;\n    opts.link = {};\n    opts.framing = true;\n    let compacted = await jsonld.compact(framed, frameContext, opts);\n\n    // replace @null with null, compacting arrays\n    opts.link = {};\n    compacted = _cleanupNull(compacted, opts);\n    return compacted;\n  };\n\n  /**\n   * **Experimental**\n   *\n   * Links a JSON-LD document's nodes in memory.\n   *\n   * @param input the JSON-LD document to link.\n   * @param [ctx] the JSON-LD context to apply.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the linked output.\n   */\n  jsonld.link = async function (input, ctx, options) {\n    // API matches running frame with a wildcard frame and embed: '@link'\n    // get arguments\n    const frame = {};\n    if (ctx) {\n      frame['@context'] = ctx;\n    }\n    frame['@embed'] = '@link';\n    return jsonld.frame(input, frame, options);\n  };\n\n  /**\n   * Performs RDF dataset normalization on the given input. The input is JSON-LD\n   * unless the 'inputFormat' option is used. The output is an RDF dataset\n   * unless the 'format' option is used.\n   *\n   * @param input the input to normalize as JSON-LD or as a format specified by\n   *          the 'inputFormat' option.\n   * @param [options] the options to use:\n   *          [algorithm] the normalization algorithm to use, `URDNA2015` or\n   *            `URGNA2012` (default: `URDNA2015`).\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [skipExpansion] true to assume the input is expanded and skip\n   *            expansion, false not to, defaults to false.\n   *          [inputFormat] the format if input is not JSON-LD:\n   *            'application/n-quads' for N-Quads.\n   *          [format] the format if output is a string:\n   *            'application/n-quads' for N-Quads.\n   *          [documentLoader(url, options)] the document loader.\n   *          [useNative] true to use a native canonize algorithm\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the normalized output.\n   */\n  jsonld.normalize = jsonld.canonize = async function (input, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not canonize, too few arguments.');\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      algorithm: 'URDNA2015',\n      skipExpansion: false,\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n    if ('inputFormat' in options) {\n      if (options.inputFormat !== 'application/n-quads' && options.inputFormat !== 'application/nquads') {\n        throw new JsonLdError('Unknown canonicalization input format.', 'jsonld.CanonizeError');\n      }\n      // TODO: `await` for async parsers\n      const parsedInput = NQuads.parse(input);\n\n      // do canonicalization\n      return canonize.canonize(parsedInput, options);\n    }\n\n    // convert to RDF dataset then do normalization\n    const opts = {\n      ...options\n    };\n    delete opts.format;\n    opts.produceGeneralizedRdf = false;\n    const dataset = await jsonld.toRDF(input, opts);\n\n    // do canonicalization\n    return canonize.canonize(dataset, options);\n  };\n\n  /**\n   * Converts an RDF dataset to JSON-LD.\n   *\n   * @param dataset a serialized string of RDF in a format specified by the\n   *          format option or an RDF dataset to convert.\n   * @param [options] the options to use:\n   *          [format] the format if dataset param must first be parsed:\n   *            'application/n-quads' for N-Quads (default).\n   *          [rdfParser] a custom RDF-parser to use to parse the dataset.\n   *          [useRdfType] true to use rdf:type, false to use @type\n   *            (default: false).\n   *          [useNativeTypes] true to convert XSD types into native types\n   *            (boolean, integer, double), false not to (default: false).\n   *\n   * @return a Promise that resolves to the JSON-LD document.\n   */\n  jsonld.fromRDF = async function (dataset, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not convert from RDF, too few arguments.');\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      format: _isString(dataset) ? 'application/n-quads' : undefined\n    });\n    const {\n      format\n    } = options;\n    let {\n      rdfParser\n    } = options;\n\n    // handle special format\n    if (format) {\n      // check supported formats\n      rdfParser = rdfParser || _rdfParsers[format];\n      if (!rdfParser) {\n        throw new JsonLdError('Unknown input format.', 'jsonld.UnknownFormat', {\n          format\n        });\n      }\n    } else {\n      // no-op parser, assume dataset already parsed\n      rdfParser = () => dataset;\n    }\n\n    // rdfParser must be synchronous or return a promise, no callback support\n    const parsedDataset = await rdfParser(dataset);\n    return _fromRDF(parsedDataset, options);\n  };\n\n  /**\n   * Outputs the RDF dataset found in the given JSON-LD object.\n   *\n   * @param input the JSON-LD input.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [skipExpansion] true to assume the input is expanded and skip\n   *            expansion, false not to, defaults to false.\n   *          [format] the format to use to output a string:\n   *            'application/n-quads' for N-Quads.\n   *          [produceGeneralizedRdf] true to output generalized RDF, false\n   *            to produce only standard RDF (default: false).\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the RDF dataset.\n   */\n  jsonld.toRDF = async function (input, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not convert to RDF, too few arguments.');\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      skipExpansion: false,\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n\n    // TODO: support toRDF custom map?\n    let expanded;\n    if (options.skipExpansion) {\n      expanded = input;\n    } else {\n      // expand input\n      expanded = await jsonld.expand(input, options);\n    }\n\n    // output RDF dataset\n    const dataset = _toRDF(expanded, options);\n    if (options.format) {\n      if (options.format === 'application/n-quads' || options.format === 'application/nquads') {\n        return NQuads.serialize(dataset);\n      }\n      throw new JsonLdError('Unknown output format.', 'jsonld.UnknownFormat', {\n        format: options.format\n      });\n    }\n    return dataset;\n  };\n\n  /**\n   * **Experimental**\n   *\n   * Recursively flattens the nodes in the given JSON-LD input into a merged\n   * map of node ID => node. All graphs will be merged into the default graph.\n   *\n   * @param input the JSON-LD input.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the merged node map.\n   */\n  jsonld.createNodeMap = async function (input, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not create node map, too few arguments.');\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      base: _isString(input) ? input : '',\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n\n    // expand input\n    const expanded = await jsonld.expand(input, options);\n    return _createMergedNodeMap(expanded, options);\n  };\n\n  /**\n   * **Experimental**\n   *\n   * Merges two or more JSON-LD documents into a single flattened document.\n   *\n   * @param docs the JSON-LD documents to merge together.\n   * @param ctx the context to use to compact the merged result, or null.\n   * @param [options] the options to use:\n   *          [base] the base IRI to use.\n   *          [expandContext] a context to expand with.\n   *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n   *          [mergeNodes] true to merge properties for nodes with the same ID,\n   *            false to ignore new properties for nodes with the same ID once\n   *            the ID has been defined; note that this may not prevent merging\n   *            new properties where a node is in the `object` position\n   *            (default: true).\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the merged output.\n   */\n  jsonld.merge = async function (docs, ctx, options) {\n    if (arguments.length < 1) {\n      throw new TypeError('Could not merge, too few arguments.');\n    }\n    if (!_isArray(docs)) {\n      throw new TypeError('Could not merge, \"docs\" must be an array.');\n    }\n    if (typeof ctx === 'function') {\n      ctx = null;\n    } else {\n      ctx = ctx || null;\n    }\n\n    // set default options\n    options = _setDefaults(options, {\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n\n    // expand all documents\n    const expanded = await Promise.all(docs.map(doc => {\n      const opts = {\n        ...options\n      };\n      return jsonld.expand(doc, opts);\n    }));\n    let mergeNodes = true;\n    if ('mergeNodes' in options) {\n      mergeNodes = options.mergeNodes;\n    }\n    const issuer = options.issuer || new IdentifierIssuer('_:b');\n    const graphs = {\n      '@default': {}\n    };\n    for (let i = 0; i < expanded.length; ++i) {\n      // uniquely relabel blank nodes\n      const doc = util.relabelBlankNodes(expanded[i], {\n        issuer: new IdentifierIssuer('_:b' + i + '-')\n      });\n\n      // add nodes to the shared node map graphs if merging nodes, to a\n      // separate graph set if not\n      const _graphs = mergeNodes || i === 0 ? graphs : {\n        '@default': {}\n      };\n      _createNodeMap(doc, _graphs, '@default', issuer);\n      if (_graphs !== graphs) {\n        // merge document graphs but don't merge existing nodes\n        for (const graphName in _graphs) {\n          const _nodeMap = _graphs[graphName];\n          if (!(graphName in graphs)) {\n            graphs[graphName] = _nodeMap;\n            continue;\n          }\n          const nodeMap = graphs[graphName];\n          for (const key in _nodeMap) {\n            if (!(key in nodeMap)) {\n              nodeMap[key] = _nodeMap[key];\n            }\n          }\n        }\n      }\n    }\n\n    // add all non-default graphs to default graph\n    const defaultGraph = _mergeNodeMaps(graphs);\n\n    // produce flattened output\n    const flattened = [];\n    const keys = Object.keys(defaultGraph).sort();\n    for (let ki = 0; ki < keys.length; ++ki) {\n      const node = defaultGraph[keys[ki]];\n      // only add full subjects to top-level\n      if (!_isSubjectReference(node)) {\n        flattened.push(node);\n      }\n    }\n    if (ctx === null) {\n      return flattened;\n    }\n\n    // compact result (force @graph option to true, skip expansion)\n    options.graph = true;\n    options.skipExpansion = true;\n    const compacted = await jsonld.compact(flattened, ctx, options);\n    return compacted;\n  };\n\n  /**\n   * The default document loader for external documents.\n   *\n   * @param url the URL to load.\n   *\n   * @return a promise that resolves to the remote document.\n   */\n  Object.defineProperty(jsonld, 'documentLoader', {\n    get: () => jsonld._documentLoader,\n    set: v => jsonld._documentLoader = v\n  });\n  // default document loader not implemented\n  jsonld.documentLoader = async url => {\n    throw new JsonLdError('Could not retrieve a JSON-LD document from the URL. URL ' + 'dereferencing not implemented.', 'jsonld.LoadDocumentError', {\n      code: 'loading document failed',\n      url\n    });\n  };\n\n  /**\n   * Gets a remote JSON-LD document using the default document loader or\n   * one given in the passed options.\n   *\n   * @param url the URL to fetch.\n   * @param [options] the options to use:\n   *          [documentLoader] the document loader to use.\n   *\n   * @return a Promise that resolves to the retrieved remote document.\n   */\n  jsonld.get = async function (url, options) {\n    let load;\n    if (typeof options.documentLoader === 'function') {\n      load = options.documentLoader;\n    } else {\n      load = jsonld.documentLoader;\n    }\n    const remoteDoc = await load(url);\n    try {\n      if (!remoteDoc.document) {\n        throw new JsonLdError('No remote document found at the given URL.', 'jsonld.NullRemoteDocument');\n      }\n      if (_isString(remoteDoc.document)) {\n        remoteDoc.document = JSON.parse(remoteDoc.document);\n      }\n    } catch (e) {\n      throw new JsonLdError('Could not retrieve a JSON-LD document from the URL.', 'jsonld.LoadDocumentError', {\n        code: 'loading document failed',\n        cause: e,\n        remoteDoc\n      });\n    }\n    return remoteDoc;\n  };\n\n  /**\n   * Processes a local context, resolving any URLs as necessary, and returns a\n   * new active context.\n   *\n   * @param activeCtx the current active context.\n   * @param localCtx the local context to process.\n   * @param [options] the options to use:\n   *          [documentLoader(url, options)] the document loader.\n   *          [contextResolver] internal use only.\n   *\n   * @return a Promise that resolves to the new active context.\n   */\n  jsonld.processContext = async function (activeCtx, localCtx, options) {\n    // set default options\n    options = _setDefaults(options, {\n      base: '',\n      contextResolver: new ContextResolver({\n        sharedCache: _resolvedContextCache\n      })\n    });\n\n    // return initial context early for null context\n    if (localCtx === null) {\n      return _getInitialContext(options);\n    }\n\n    // get URLs in localCtx\n    localCtx = util.clone(localCtx);\n    if (!(_isObject(localCtx) && '@context' in localCtx)) {\n      localCtx = {\n        '@context': localCtx\n      };\n    }\n    return _processContext({\n      activeCtx,\n      localCtx,\n      options\n    });\n  };\n\n  // backwards compatibility\n  jsonld.getContextValue = require('./context').getContextValue;\n\n  /**\n   * Document loaders.\n   */\n  jsonld.documentLoaders = {};\n\n  /**\n   * Assigns the default document loader for external document URLs to a built-in\n   * default. Supported types currently include: 'xhr' and 'node'.\n   *\n   * @param type the type to set.\n   * @param [params] the parameters required to use the document loader.\n   */\n  jsonld.useDocumentLoader = function (type) {\n    if (!(type in jsonld.documentLoaders)) {\n      throw new JsonLdError('Unknown document loader type: \"' + type + '\"', 'jsonld.UnknownDocumentLoader', {\n        type\n      });\n    }\n\n    // set document loader\n    jsonld.documentLoader = jsonld.documentLoaders[type].apply(jsonld, Array.prototype.slice.call(arguments, 1));\n  };\n\n  /**\n   * Registers an RDF dataset parser by content-type, for use with\n   * jsonld.fromRDF. An RDF dataset parser will always be given one parameter,\n   * a string of input. An RDF dataset parser can be synchronous or\n   * asynchronous (by returning a promise).\n   *\n   * @param contentType the content-type for the parser.\n   * @param parser(input) the parser function (takes a string as a parameter\n   *          and either returns an RDF dataset or a Promise that resolves to one.\n   */\n  jsonld.registerRDFParser = function (contentType, parser) {\n    _rdfParsers[contentType] = parser;\n  };\n\n  /**\n   * Unregisters an RDF dataset parser by content-type.\n   *\n   * @param contentType the content-type for the parser.\n   */\n  jsonld.unregisterRDFParser = function (contentType) {\n    delete _rdfParsers[contentType];\n  };\n\n  // register the N-Quads RDF parser\n  jsonld.registerRDFParser('application/n-quads', NQuads.parse);\n  jsonld.registerRDFParser('application/nquads', NQuads.parse);\n\n  /* URL API */\n  jsonld.url = require('./url');\n\n  /* Utility API */\n  jsonld.util = util;\n  // backwards compatibility\n  Object.assign(jsonld, util);\n\n  // reexpose API as jsonld.promises for backwards compatability\n  jsonld.promises = jsonld;\n\n  // backwards compatibility\n  jsonld.RequestQueue = require('./RequestQueue');\n\n  /* WebIDL API */\n  jsonld.JsonLdProcessor = require('./JsonLdProcessor')(jsonld);\n  platform.setupGlobals(jsonld);\n  platform.setupDocumentLoaders(jsonld);\n  function _setDefaults(options, _ref) {\n    let {\n      documentLoader = jsonld.documentLoader,\n      ...defaults\n    } = _ref;\n    return Object.assign({}, {\n      documentLoader\n    }, defaults, options);\n  }\n\n  // end of jsonld API `wrapper` factory\n  return jsonld;\n};\n\n// external APIs:\n\n// used to generate a new jsonld API instance\nconst factory = function () {\n  return wrapper(function () {\n    return factory();\n  });\n};\n\n// wrap the main jsonld API instance\nwrapper(factory);\n// export API\nmodule.exports = factory;","map":{"version":3,"names":["canonize","require","platform","util","ContextResolver","IdentifierIssuer","JsonLdError","LRU","NQuads","expand","_expand","flatten","_flatten","fromRDF","_fromRDF","toRDF","_toRDF","frameMergedOrDefault","_frameMergedOrDefault","cleanupNull","_cleanupNull","isArray","_isArray","isObject","_isObject","isString","_isString","isSubjectReference","_isSubjectReference","expandIri","_expandIri","getInitialContext","_getInitialContext","process","_processContext","processingMode","_processingMode","compact","_compact","compactIri","_compactIri","createNodeMap","_createNodeMap","createMergedNodeMap","_createMergedNodeMap","mergeNodeMaps","_mergeNodeMaps","wrapper","jsonld","_rdfParsers","RESOLVED_CONTEXT_CACHE_MAX_SIZE","_resolvedContextCache","max","input","ctx","options","arguments","length","TypeError","code","_setDefaults","base","compactArrays","compactToRelative","graph","skipExpansion","link","issuer","contextResolver","sharedCache","expanded","activeCtx","processContext","compacted","element","compactionMap","clone","tmp","i","Object","keys","push","hasContext","graphAlias","iri","relativeTo","vocab","key","keepFreeFloatingNodes","expansionMap","undefined","toResolve","contextsToProcess","expandContext","defaultBase","remoteDoc","get","documentUrl","document","contextUrl","remoteContext","localCtx","flattened","frame","embed","explicit","requireAll","omitDefault","bnodesToClear","frameContext","hasOwnProperty","omitGraph","pruneBlankNodeIdentifiers","opts","isFrame","expandedFrame","frameKeys","map","merged","includes","is11","framed","framing","normalize","algorithm","inputFormat","parsedInput","parse","format","produceGeneralizedRdf","dataset","rdfParser","parsedDataset","serialize","merge","docs","Promise","all","doc","mergeNodes","graphs","relabelBlankNodes","_graphs","graphName","_nodeMap","nodeMap","defaultGraph","sort","ki","node","defineProperty","_documentLoader","set","v","documentLoader","url","load","JSON","e","cause","getContextValue","documentLoaders","useDocumentLoader","type","apply","Array","prototype","slice","call","registerRDFParser","contentType","parser","unregisterRDFParser","assign","promises","RequestQueue","JsonLdProcessor","setupGlobals","setupDocumentLoaders","defaults","factory","module","exports"],"sources":["E:/react-todo-app/node_modules/jsonld/lib/jsonld.js"],"sourcesContent":["/**\n * A JavaScript implementation of the JSON-LD API.\n *\n * @author Dave Longley\n *\n * @license BSD 3-Clause License\n * Copyright (c) 2011-2019 Digital Bazaar, Inc.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice,\n * this list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer in the\n * documentation and/or other materials provided with the distribution.\n *\n * Neither the name of the Digital Bazaar, Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED\n * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\nconst canonize = require('rdf-canonize');\nconst platform = require('./platform');\nconst util = require('./util');\nconst ContextResolver = require('./ContextResolver');\nconst IdentifierIssuer = util.IdentifierIssuer;\nconst JsonLdError = require('./JsonLdError');\nconst LRU = require('lru-cache');\nconst NQuads = require('./NQuads');\n\nconst {expand: _expand} = require('./expand');\nconst {flatten: _flatten} = require('./flatten');\nconst {fromRDF: _fromRDF} = require('./fromRdf');\nconst {toRDF: _toRDF} = require('./toRdf');\n\nconst {\n  frameMergedOrDefault: _frameMergedOrDefault,\n  cleanupNull: _cleanupNull\n} = require('./frame');\n\nconst {\n  isArray: _isArray,\n  isObject: _isObject,\n  isString: _isString\n} = require('./types');\n\nconst {\n  isSubjectReference: _isSubjectReference,\n} = require('./graphTypes');\n\nconst {\n  expandIri: _expandIri,\n  getInitialContext: _getInitialContext,\n  process: _processContext,\n  processingMode: _processingMode\n} = require('./context');\n\nconst {\n  compact: _compact,\n  compactIri: _compactIri\n} = require('./compact');\n\nconst {\n  createNodeMap: _createNodeMap,\n  createMergedNodeMap: _createMergedNodeMap,\n  mergeNodeMaps: _mergeNodeMaps\n} = require('./nodeMap');\n\n/* eslint-disable indent */\n// attaches jsonld API to the given object\nconst wrapper = function(jsonld) {\n\n/** Registered RDF dataset parsers hashed by content-type. */\nconst _rdfParsers = {};\n\n// resolved context cache\n// TODO: consider basing max on context size rather than number\nconst RESOLVED_CONTEXT_CACHE_MAX_SIZE = 100;\nconst _resolvedContextCache = new LRU({max: RESOLVED_CONTEXT_CACHE_MAX_SIZE});\n\n/* Core API */\n\n/**\n * Performs JSON-LD compaction.\n *\n * @param input the JSON-LD input to compact.\n * @param ctx the context to compact with.\n * @param [options] options to use:\n *          [base] the base IRI to use.\n *          [compactArrays] true to compact arrays to single values when\n *            appropriate, false not to (default: true).\n *          [compactToRelative] true to compact IRIs to be relative to document\n *            base, false to keep absolute (default: true)\n *          [graph] true to always output a top-level graph (default: false).\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false.\n *          [documentLoader(url, options)] the document loader.\n *          [expansionMap(info)] a function that can be used to custom map\n *            unmappable values (or to throw an error when they are detected);\n *            if this function returns `undefined` then the default behavior\n *            will be used.\n *          [framing] true if compaction is occuring during a framing operation.\n *          [compactionMap(info)] a function that can be used to custom map\n *            unmappable values (or to throw an error when they are detected);\n *            if this function returns `undefined` then the default behavior\n *            will be used.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the compacted output.\n */\njsonld.compact = async function(input, ctx, options) {\n  if(arguments.length < 2) {\n    throw new TypeError('Could not compact, too few arguments.');\n  }\n\n  if(ctx === null) {\n    throw new JsonLdError(\n      'The compaction context must not be null.',\n      'jsonld.CompactError', {code: 'invalid local context'});\n  }\n\n  // nothing to compact\n  if(input === null) {\n    return null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    compactArrays: true,\n    compactToRelative: true,\n    graph: false,\n    skipExpansion: false,\n    link: false,\n    issuer: new IdentifierIssuer('_:b'),\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n  if(options.link) {\n    // force skip expansion when linking, \"link\" is not part of the public\n    // API, it should only be called from framing\n    options.skipExpansion = true;\n  }\n  if(!options.compactToRelative) {\n    delete options.base;\n  }\n\n  // expand input\n  let expanded;\n  if(options.skipExpansion) {\n    expanded = input;\n  } else {\n    expanded = await jsonld.expand(input, options);\n  }\n\n  // process context\n  const activeCtx = await jsonld.processContext(\n    _getInitialContext(options), ctx, options);\n\n  // do compaction\n  let compacted = await _compact({\n    activeCtx,\n    element: expanded,\n    options,\n    compactionMap: options.compactionMap\n  });\n\n  // perform clean up\n  if(options.compactArrays && !options.graph && _isArray(compacted)) {\n    if(compacted.length === 1) {\n      // simplify to a single item\n      compacted = compacted[0];\n    } else if(compacted.length === 0) {\n      // simplify to an empty object\n      compacted = {};\n    }\n  } else if(options.graph && _isObject(compacted)) {\n    // always use array if graph option is on\n    compacted = [compacted];\n  }\n\n  // follow @context key\n  if(_isObject(ctx) && '@context' in ctx) {\n    ctx = ctx['@context'];\n  }\n\n  // build output context\n  ctx = util.clone(ctx);\n  if(!_isArray(ctx)) {\n    ctx = [ctx];\n  }\n  // remove empty contexts\n  const tmp = ctx;\n  ctx = [];\n  for(let i = 0; i < tmp.length; ++i) {\n    if(!_isObject(tmp[i]) || Object.keys(tmp[i]).length > 0) {\n      ctx.push(tmp[i]);\n    }\n  }\n\n  // remove array if only one context\n  const hasContext = (ctx.length > 0);\n  if(ctx.length === 1) {\n    ctx = ctx[0];\n  }\n\n  // add context and/or @graph\n  if(_isArray(compacted)) {\n    // use '@graph' keyword\n    const graphAlias = _compactIri({\n      activeCtx, iri: '@graph', relativeTo: {vocab: true}\n    });\n    const graph = compacted;\n    compacted = {};\n    if(hasContext) {\n      compacted['@context'] = ctx;\n    }\n    compacted[graphAlias] = graph;\n  } else if(_isObject(compacted) && hasContext) {\n    // reorder keys so @context is first\n    const graph = compacted;\n    compacted = {'@context': ctx};\n    for(const key in graph) {\n      compacted[key] = graph[key];\n    }\n  }\n\n  return compacted;\n};\n\n/**\n * Performs JSON-LD expansion.\n *\n * @param input the JSON-LD input to expand.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [keepFreeFloatingNodes] true to keep free-floating nodes,\n *            false not to, defaults to false.\n *          [documentLoader(url, options)] the document loader.\n *          [expansionMap(info)] a function that can be used to custom map\n *            unmappable values (or to throw an error when they are detected);\n *            if this function returns `undefined` then the default behavior\n *            will be used.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the expanded output.\n */\njsonld.expand = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not expand, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    keepFreeFloatingNodes: false,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n  if(options.expansionMap === false) {\n    options.expansionMap = undefined;\n  }\n\n  // build set of objects that may have @contexts to resolve\n  const toResolve = {};\n\n  // build set of contexts to process prior to expansion\n  const contextsToProcess = [];\n\n  // if an `expandContext` has been given ensure it gets resolved\n  if('expandContext' in options) {\n    const expandContext = util.clone(options.expandContext);\n    if(_isObject(expandContext) && '@context' in expandContext) {\n      toResolve.expandContext = expandContext;\n    } else {\n      toResolve.expandContext = {'@context': expandContext};\n    }\n    contextsToProcess.push(toResolve.expandContext);\n  }\n\n  // if input is a string, attempt to dereference remote document\n  let defaultBase;\n  if(!_isString(input)) {\n    // input is not a URL, do not need to retrieve it first\n    toResolve.input = util.clone(input);\n  } else {\n    // load remote doc\n    const remoteDoc = await jsonld.get(input, options);\n    defaultBase = remoteDoc.documentUrl;\n    toResolve.input = remoteDoc.document;\n    if(remoteDoc.contextUrl) {\n      // context included in HTTP link header and must be resolved\n      toResolve.remoteContext = {'@context': remoteDoc.contextUrl};\n      contextsToProcess.push(toResolve.remoteContext);\n    }\n  }\n\n  // set default base\n  if(!('base' in options)) {\n    options.base = defaultBase || '';\n  }\n\n  // process any additional contexts\n  let activeCtx = _getInitialContext(options);\n  for(const localCtx of contextsToProcess) {\n    activeCtx = await _processContext({activeCtx, localCtx, options});\n  }\n\n  // expand resolved input\n  let expanded = await _expand({\n    activeCtx,\n    element: toResolve.input,\n    options,\n    expansionMap: options.expansionMap\n  });\n\n  // optimize away @graph with no other properties\n  if(_isObject(expanded) && ('@graph' in expanded) &&\n    Object.keys(expanded).length === 1) {\n    expanded = expanded['@graph'];\n  } else if(expanded === null) {\n    expanded = [];\n  }\n\n  // normalize to an array\n  if(!_isArray(expanded)) {\n    expanded = [expanded];\n  }\n\n  return expanded;\n};\n\n/**\n * Performs JSON-LD flattening.\n *\n * @param input the JSON-LD to flatten.\n * @param ctx the context to use to compact the flattened output, or null.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the flattened output.\n */\njsonld.flatten = async function(input, ctx, options) {\n  if(arguments.length < 1) {\n    return new TypeError('Could not flatten, too few arguments.');\n  }\n\n  if(typeof ctx === 'function') {\n    ctx = null;\n  } else {\n    ctx = ctx || null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  // do flattening\n  const flattened = _flatten(expanded);\n\n  if(ctx === null) {\n    // no compaction required\n    return flattened;\n  }\n\n  // compact result (force @graph option to true, skip expansion)\n  options.graph = true;\n  options.skipExpansion = true;\n  const compacted = await jsonld.compact(flattened, ctx, options);\n\n  return compacted;\n};\n\n/**\n * Performs JSON-LD framing.\n *\n * @param input the JSON-LD input to frame.\n * @param frame the JSON-LD frame to use.\n * @param [options] the framing options.\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [embed] default @embed flag: '@last', '@always', '@never', '@link'\n *            (default: '@last').\n *          [explicit] default @explicit flag (default: false).\n *          [requireAll] default @requireAll flag (default: true).\n *          [omitDefault] default @omitDefault flag (default: false).\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the framed output.\n */\njsonld.frame = async function(input, frame, options) {\n  if(arguments.length < 2) {\n    throw new TypeError('Could not frame, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    embed: '@once',\n    explicit: false,\n    requireAll: false,\n    omitDefault: false,\n    bnodesToClear: [],\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // if frame is a string, attempt to dereference remote document\n  if(_isString(frame)) {\n    // load remote doc\n    const remoteDoc = await jsonld.get(frame, options);\n    frame = remoteDoc.document;\n\n    if(remoteDoc.contextUrl) {\n      // inject link header @context into frame\n      let ctx = frame['@context'];\n      if(!ctx) {\n        ctx = remoteDoc.contextUrl;\n      } else if(_isArray(ctx)) {\n        ctx.push(remoteDoc.contextUrl);\n      } else {\n        ctx = [ctx, remoteDoc.contextUrl];\n      }\n      frame['@context'] = ctx;\n    }\n  }\n\n  const frameContext = frame ? frame['@context'] || {} : {};\n\n  // process context\n  const activeCtx = await jsonld.processContext(\n    _getInitialContext(options), frameContext, options);\n\n  // mode specific defaults\n  if(!options.hasOwnProperty('omitGraph')) {\n    options.omitGraph = _processingMode(activeCtx, 1.1);\n  }\n  if(!options.hasOwnProperty('pruneBlankNodeIdentifiers')) {\n    options.pruneBlankNodeIdentifiers = _processingMode(activeCtx, 1.1);\n  }\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  // expand frame\n  const opts = {...options};\n  opts.isFrame = true;\n  opts.keepFreeFloatingNodes = true;\n  const expandedFrame = await jsonld.expand(frame, opts);\n\n  // if the unexpanded frame includes a key expanding to @graph, frame the\n  // default graph, otherwise, the merged graph\n  const frameKeys = Object.keys(frame)\n    .map(key => _expandIri(activeCtx, key, {vocab: true}));\n  opts.merged = !frameKeys.includes('@graph');\n  opts.is11 = _processingMode(activeCtx, 1.1);\n\n  // do framing\n  const framed = _frameMergedOrDefault(expanded, expandedFrame, opts);\n\n  opts.graph = !options.omitGraph;\n  opts.skipExpansion = true;\n  opts.link = {};\n  opts.framing = true;\n  let compacted = await jsonld.compact(framed, frameContext, opts);\n\n  // replace @null with null, compacting arrays\n  opts.link = {};\n  compacted = _cleanupNull(compacted, opts);\n\n  return compacted;\n};\n\n/**\n * **Experimental**\n *\n * Links a JSON-LD document's nodes in memory.\n *\n * @param input the JSON-LD document to link.\n * @param [ctx] the JSON-LD context to apply.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the linked output.\n */\njsonld.link = async function(input, ctx, options) {\n  // API matches running frame with a wildcard frame and embed: '@link'\n  // get arguments\n  const frame = {};\n  if(ctx) {\n    frame['@context'] = ctx;\n  }\n  frame['@embed'] = '@link';\n  return jsonld.frame(input, frame, options);\n};\n\n/**\n * Performs RDF dataset normalization on the given input. The input is JSON-LD\n * unless the 'inputFormat' option is used. The output is an RDF dataset\n * unless the 'format' option is used.\n *\n * @param input the input to normalize as JSON-LD or as a format specified by\n *          the 'inputFormat' option.\n * @param [options] the options to use:\n *          [algorithm] the normalization algorithm to use, `URDNA2015` or\n *            `URGNA2012` (default: `URDNA2015`).\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false.\n *          [inputFormat] the format if input is not JSON-LD:\n *            'application/n-quads' for N-Quads.\n *          [format] the format if output is a string:\n *            'application/n-quads' for N-Quads.\n *          [documentLoader(url, options)] the document loader.\n *          [useNative] true to use a native canonize algorithm\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the normalized output.\n */\njsonld.normalize = jsonld.canonize = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not canonize, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    algorithm: 'URDNA2015',\n    skipExpansion: false,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n  if('inputFormat' in options) {\n    if(options.inputFormat !== 'application/n-quads' &&\n      options.inputFormat !== 'application/nquads') {\n      throw new JsonLdError(\n        'Unknown canonicalization input format.',\n        'jsonld.CanonizeError');\n    }\n    // TODO: `await` for async parsers\n    const parsedInput = NQuads.parse(input);\n\n    // do canonicalization\n    return canonize.canonize(parsedInput, options);\n  }\n\n  // convert to RDF dataset then do normalization\n  const opts = {...options};\n  delete opts.format;\n  opts.produceGeneralizedRdf = false;\n  const dataset = await jsonld.toRDF(input, opts);\n\n  // do canonicalization\n  return canonize.canonize(dataset, options);\n};\n\n/**\n * Converts an RDF dataset to JSON-LD.\n *\n * @param dataset a serialized string of RDF in a format specified by the\n *          format option or an RDF dataset to convert.\n * @param [options] the options to use:\n *          [format] the format if dataset param must first be parsed:\n *            'application/n-quads' for N-Quads (default).\n *          [rdfParser] a custom RDF-parser to use to parse the dataset.\n *          [useRdfType] true to use rdf:type, false to use @type\n *            (default: false).\n *          [useNativeTypes] true to convert XSD types into native types\n *            (boolean, integer, double), false not to (default: false).\n *\n * @return a Promise that resolves to the JSON-LD document.\n */\njsonld.fromRDF = async function(dataset, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not convert from RDF, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    format: _isString(dataset) ? 'application/n-quads' : undefined\n  });\n\n  const {format} = options;\n  let {rdfParser} = options;\n\n  // handle special format\n  if(format) {\n    // check supported formats\n    rdfParser = rdfParser || _rdfParsers[format];\n    if(!rdfParser) {\n      throw new JsonLdError(\n        'Unknown input format.',\n        'jsonld.UnknownFormat', {format});\n    }\n  } else {\n    // no-op parser, assume dataset already parsed\n    rdfParser = () => dataset;\n  }\n\n  // rdfParser must be synchronous or return a promise, no callback support\n  const parsedDataset = await rdfParser(dataset);\n  return _fromRDF(parsedDataset, options);\n};\n\n/**\n * Outputs the RDF dataset found in the given JSON-LD object.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [skipExpansion] true to assume the input is expanded and skip\n *            expansion, false not to, defaults to false.\n *          [format] the format to use to output a string:\n *            'application/n-quads' for N-Quads.\n *          [produceGeneralizedRdf] true to output generalized RDF, false\n *            to produce only standard RDF (default: false).\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the RDF dataset.\n */\njsonld.toRDF = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not convert to RDF, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    skipExpansion: false,\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // TODO: support toRDF custom map?\n  let expanded;\n  if(options.skipExpansion) {\n    expanded = input;\n  } else {\n    // expand input\n    expanded = await jsonld.expand(input, options);\n  }\n\n  // output RDF dataset\n  const dataset = _toRDF(expanded, options);\n  if(options.format) {\n    if(options.format === 'application/n-quads' ||\n      options.format === 'application/nquads') {\n      return NQuads.serialize(dataset);\n    }\n    throw new JsonLdError(\n      'Unknown output format.',\n      'jsonld.UnknownFormat', {format: options.format});\n  }\n\n  return dataset;\n};\n\n/**\n * **Experimental**\n *\n * Recursively flattens the nodes in the given JSON-LD input into a merged\n * map of node ID => node. All graphs will be merged into the default graph.\n *\n * @param input the JSON-LD input.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the merged node map.\n */\njsonld.createNodeMap = async function(input, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not create node map, too few arguments.');\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    base: _isString(input) ? input : '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand input\n  const expanded = await jsonld.expand(input, options);\n\n  return _createMergedNodeMap(expanded, options);\n};\n\n/**\n * **Experimental**\n *\n * Merges two or more JSON-LD documents into a single flattened document.\n *\n * @param docs the JSON-LD documents to merge together.\n * @param ctx the context to use to compact the merged result, or null.\n * @param [options] the options to use:\n *          [base] the base IRI to use.\n *          [expandContext] a context to expand with.\n *          [issuer] a jsonld.IdentifierIssuer to use to label blank nodes.\n *          [mergeNodes] true to merge properties for nodes with the same ID,\n *            false to ignore new properties for nodes with the same ID once\n *            the ID has been defined; note that this may not prevent merging\n *            new properties where a node is in the `object` position\n *            (default: true).\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the merged output.\n */\njsonld.merge = async function(docs, ctx, options) {\n  if(arguments.length < 1) {\n    throw new TypeError('Could not merge, too few arguments.');\n  }\n  if(!_isArray(docs)) {\n    throw new TypeError('Could not merge, \"docs\" must be an array.');\n  }\n\n  if(typeof ctx === 'function') {\n    ctx = null;\n  } else {\n    ctx = ctx || null;\n  }\n\n  // set default options\n  options = _setDefaults(options, {\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // expand all documents\n  const expanded = await Promise.all(docs.map(doc => {\n    const opts = {...options};\n    return jsonld.expand(doc, opts);\n  }));\n\n  let mergeNodes = true;\n  if('mergeNodes' in options) {\n    mergeNodes = options.mergeNodes;\n  }\n\n  const issuer = options.issuer || new IdentifierIssuer('_:b');\n  const graphs = {'@default': {}};\n\n  for(let i = 0; i < expanded.length; ++i) {\n    // uniquely relabel blank nodes\n    const doc = util.relabelBlankNodes(expanded[i], {\n      issuer: new IdentifierIssuer('_:b' + i + '-')\n    });\n\n    // add nodes to the shared node map graphs if merging nodes, to a\n    // separate graph set if not\n    const _graphs = (mergeNodes || i === 0) ? graphs : {'@default': {}};\n    _createNodeMap(doc, _graphs, '@default', issuer);\n\n    if(_graphs !== graphs) {\n      // merge document graphs but don't merge existing nodes\n      for(const graphName in _graphs) {\n        const _nodeMap = _graphs[graphName];\n        if(!(graphName in graphs)) {\n          graphs[graphName] = _nodeMap;\n          continue;\n        }\n        const nodeMap = graphs[graphName];\n        for(const key in _nodeMap) {\n          if(!(key in nodeMap)) {\n            nodeMap[key] = _nodeMap[key];\n          }\n        }\n      }\n    }\n  }\n\n  // add all non-default graphs to default graph\n  const defaultGraph = _mergeNodeMaps(graphs);\n\n  // produce flattened output\n  const flattened = [];\n  const keys = Object.keys(defaultGraph).sort();\n  for(let ki = 0; ki < keys.length; ++ki) {\n    const node = defaultGraph[keys[ki]];\n    // only add full subjects to top-level\n    if(!_isSubjectReference(node)) {\n      flattened.push(node);\n    }\n  }\n\n  if(ctx === null) {\n    return flattened;\n  }\n\n  // compact result (force @graph option to true, skip expansion)\n  options.graph = true;\n  options.skipExpansion = true;\n  const compacted = await jsonld.compact(flattened, ctx, options);\n\n  return compacted;\n};\n\n/**\n * The default document loader for external documents.\n *\n * @param url the URL to load.\n *\n * @return a promise that resolves to the remote document.\n */\nObject.defineProperty(jsonld, 'documentLoader', {\n  get: () => jsonld._documentLoader,\n  set: v => jsonld._documentLoader = v\n});\n// default document loader not implemented\njsonld.documentLoader = async url => {\n  throw new JsonLdError(\n    'Could not retrieve a JSON-LD document from the URL. URL ' +\n    'dereferencing not implemented.', 'jsonld.LoadDocumentError',\n    {code: 'loading document failed', url});\n};\n\n/**\n * Gets a remote JSON-LD document using the default document loader or\n * one given in the passed options.\n *\n * @param url the URL to fetch.\n * @param [options] the options to use:\n *          [documentLoader] the document loader to use.\n *\n * @return a Promise that resolves to the retrieved remote document.\n */\njsonld.get = async function(url, options) {\n  let load;\n  if(typeof options.documentLoader === 'function') {\n    load = options.documentLoader;\n  } else {\n    load = jsonld.documentLoader;\n  }\n\n  const remoteDoc = await load(url);\n\n  try {\n    if(!remoteDoc.document) {\n      throw new JsonLdError(\n        'No remote document found at the given URL.',\n        'jsonld.NullRemoteDocument');\n    }\n    if(_isString(remoteDoc.document)) {\n      remoteDoc.document = JSON.parse(remoteDoc.document);\n    }\n  } catch(e) {\n    throw new JsonLdError(\n      'Could not retrieve a JSON-LD document from the URL.',\n      'jsonld.LoadDocumentError', {\n        code: 'loading document failed',\n        cause: e,\n        remoteDoc\n      });\n  }\n\n  return remoteDoc;\n};\n\n/**\n * Processes a local context, resolving any URLs as necessary, and returns a\n * new active context.\n *\n * @param activeCtx the current active context.\n * @param localCtx the local context to process.\n * @param [options] the options to use:\n *          [documentLoader(url, options)] the document loader.\n *          [contextResolver] internal use only.\n *\n * @return a Promise that resolves to the new active context.\n */\njsonld.processContext = async function(\n  activeCtx, localCtx, options) {\n  // set default options\n  options = _setDefaults(options, {\n    base: '',\n    contextResolver: new ContextResolver(\n      {sharedCache: _resolvedContextCache})\n  });\n\n  // return initial context early for null context\n  if(localCtx === null) {\n    return _getInitialContext(options);\n  }\n\n  // get URLs in localCtx\n  localCtx = util.clone(localCtx);\n  if(!(_isObject(localCtx) && '@context' in localCtx)) {\n    localCtx = {'@context': localCtx};\n  }\n\n  return _processContext({activeCtx, localCtx, options});\n};\n\n// backwards compatibility\njsonld.getContextValue = require('./context').getContextValue;\n\n/**\n * Document loaders.\n */\njsonld.documentLoaders = {};\n\n/**\n * Assigns the default document loader for external document URLs to a built-in\n * default. Supported types currently include: 'xhr' and 'node'.\n *\n * @param type the type to set.\n * @param [params] the parameters required to use the document loader.\n */\njsonld.useDocumentLoader = function(type) {\n  if(!(type in jsonld.documentLoaders)) {\n    throw new JsonLdError(\n      'Unknown document loader type: \"' + type + '\"',\n      'jsonld.UnknownDocumentLoader',\n      {type});\n  }\n\n  // set document loader\n  jsonld.documentLoader = jsonld.documentLoaders[type].apply(\n    jsonld, Array.prototype.slice.call(arguments, 1));\n};\n\n/**\n * Registers an RDF dataset parser by content-type, for use with\n * jsonld.fromRDF. An RDF dataset parser will always be given one parameter,\n * a string of input. An RDF dataset parser can be synchronous or\n * asynchronous (by returning a promise).\n *\n * @param contentType the content-type for the parser.\n * @param parser(input) the parser function (takes a string as a parameter\n *          and either returns an RDF dataset or a Promise that resolves to one.\n */\njsonld.registerRDFParser = function(contentType, parser) {\n  _rdfParsers[contentType] = parser;\n};\n\n/**\n * Unregisters an RDF dataset parser by content-type.\n *\n * @param contentType the content-type for the parser.\n */\njsonld.unregisterRDFParser = function(contentType) {\n  delete _rdfParsers[contentType];\n};\n\n// register the N-Quads RDF parser\njsonld.registerRDFParser('application/n-quads', NQuads.parse);\njsonld.registerRDFParser('application/nquads', NQuads.parse);\n\n/* URL API */\njsonld.url = require('./url');\n\n/* Utility API */\njsonld.util = util;\n// backwards compatibility\nObject.assign(jsonld, util);\n\n// reexpose API as jsonld.promises for backwards compatability\njsonld.promises = jsonld;\n\n// backwards compatibility\njsonld.RequestQueue = require('./RequestQueue');\n\n/* WebIDL API */\njsonld.JsonLdProcessor = require('./JsonLdProcessor')(jsonld);\n\nplatform.setupGlobals(jsonld);\nplatform.setupDocumentLoaders(jsonld);\n\nfunction _setDefaults(options, {\n  documentLoader = jsonld.documentLoader,\n  ...defaults\n}) {\n  return Object.assign({}, {documentLoader}, defaults, options);\n}\n\n// end of jsonld API `wrapper` factory\nreturn jsonld;\n};\n\n// external APIs:\n\n// used to generate a new jsonld API instance\nconst factory = function() {\n  return wrapper(function() {\n    return factory();\n  });\n};\n\n// wrap the main jsonld API instance\nwrapper(factory);\n// export API\nmodule.exports = factory;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}